<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/ICSS_EMAC_LLD_developers_guide by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 08:45:32 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>ICSS EMAC LLD developers guide - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"ICSS_EMAC_LLD_developers_guide","wgTitle":"ICSS EMAC LLD developers guide","wgCurRevisionId":235576,"wgRevisionId":235576,"wgArticleId":39918,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages with broken file links"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"ICSS_EMAC_LLD_developers_guide","wgRelevantArticleId":39918,"wgRequestId":"cd3bb1386b688a22ee7c5290","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":["sysop"],"wgRestrictionMove":["sysop"]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-ICSS_EMAC_LLD_developers_guide rootpage-ICSS_EMAC_LLD_developers_guide skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">ICSS EMAC LLD developers guide</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><p><b><big><big><span style="color:red"> Starting in v4.3, Processor SDK documentation is no longer hosted on processors wiki.</span></big></big></b> <br /><br />
Please bookmark the new links:
</p>
<ul><li>Linux, RT-Linux: <a rel="nofollow" class="external free" href="http://software-dl.ti.com/processor-sdk-linux/esd/docs/latest/linux/index.html">http://software-dl.ti.com/processor-sdk-linux/esd/docs/latest/linux/index.html</a></li>
<li>RTOS: <a rel="nofollow" class="external free" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index.html">http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index.html</a></li>
<li>Android: <a rel="nofollow" class="external free" href="http://software-dl.ti.com/processor-sdk-android/esd/docs/latest/android/index.html">http://software-dl.ti.com/processor-sdk-android/esd/docs/latest/android/index.html</a></li></ul>
<p><br />
</p><p><br /><br />
</p>
<hr />
<div class="center"><div class="floatnone"><a href="File_Ti_hz_2c_pos_rgb_jpg.html" class="image"><img alt="Ti hz 2c pos rgb jpg.jpg" src="https://processors.wiki.ti.com/images/b/b5/Ti_hz_2c_pos_rgb_jpg.jpg" width="500" height="115" /></a></div></div>
<hr />
<p><br />
</p><p><font size="5"><b>ICSS_EMAC_LLD Developers guide</b></font>
</p><p><font size="2">Last updated: <b>09/09/2018</b></font>
</p>
<div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Terms_and_Glossary"><span class="tocnumber">1</span> <span class="toctext">Terms and Glossary</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Document_Revision_Table"><span class="tocnumber">2</span> <span class="toctext">Document Revision Table</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Introduction"><span class="tocnumber">3</span> <span class="toctext">Introduction</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Assumption"><span class="tocnumber">3.1</span> <span class="toctext">Assumption</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Scope_of_the_Document"><span class="tocnumber">3.2</span> <span class="toctext">Scope of the Document</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Software_Architecture"><span class="tocnumber">4</span> <span class="toctext">Software Architecture</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="#File_Organization"><span class="tocnumber">4.1</span> <span class="toctext">File Organization</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#EMAC_and_Switch"><span class="tocnumber">4.2</span> <span class="toctext">EMAC and Switch</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Ports_in_Driver_context"><span class="tocnumber">4.3</span> <span class="toctext">Ports in Driver context</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Driver_Architecture_and_Memory_Map"><span class="tocnumber">4.4</span> <span class="toctext">Driver Architecture and Memory Map</span></a>
<ul>
<li class="toclevel-3 tocsection-11"><a href="#DDR"><span class="tocnumber">4.4.1</span> <span class="toctext">DDR</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#L3_OCMC_RAM"><span class="tocnumber">4.4.2</span> <span class="toctext">L3 OCMC RAM</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#Shared_Data_RAM"><span class="tocnumber">4.4.3</span> <span class="toctext">Shared Data RAM</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#PRU0_Data_RAM"><span class="tocnumber">4.4.4</span> <span class="toctext">PRU0 Data RAM</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#PRU1_Data_RAM"><span class="tocnumber">4.4.5</span> <span class="toctext">PRU1 Data RAM</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#Quality_of_Service_and_Queues"><span class="tocnumber">4.5</span> <span class="toctext">Quality of Service and Queues</span></a>
<ul>
<li class="toclevel-3 tocsection-17"><a href="#How_QoS_Works"><span class="tocnumber">4.5.1</span> <span class="toctext">How QoS Works</span></a>
<ul>
<li class="toclevel-4 tocsection-18"><a href="#Switch_QoS"><span class="tocnumber">4.5.1.1</span> <span class="toctext">Switch QoS</span></a></li>
<li class="toclevel-4 tocsection-19"><a href="#EMAC_QoS"><span class="tocnumber">4.5.1.2</span> <span class="toctext">EMAC QoS</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-20"><a href="#Data_Path"><span class="tocnumber">4.6</span> <span class="toctext">Data Path</span></a>
<ul>
<li class="toclevel-3 tocsection-21"><a href="#Rx_Data_Path"><span class="tocnumber">4.6.1</span> <span class="toctext">Rx Data Path</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#Tx_Data_Path"><span class="tocnumber">4.6.2</span> <span class="toctext">Tx Data Path</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#Usage"><span class="tocnumber">4.6.3</span> <span class="toctext">Usage</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="#Forwarding_Rules"><span class="tocnumber">4.6.4</span> <span class="toctext">Forwarding Rules</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-25"><a href="#Interrupts_and_Tasks"><span class="tocnumber">4.7</span> <span class="toctext">Interrupts and Tasks</span></a>
<ul>
<li class="toclevel-3 tocsection-26"><a href="#Interrupts"><span class="tocnumber">4.7.1</span> <span class="toctext">Interrupts</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#Interrupt_Pacing"><span class="tocnumber">4.7.2</span> <span class="toctext">Interrupt Pacing</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#Tasks"><span class="tocnumber">4.7.3</span> <span class="toctext">Tasks</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-29"><a href="#Learning.2FFDB"><span class="tocnumber">4.8</span> <span class="toctext">Learning/FDB</span></a>
<ul>
<li class="toclevel-3 tocsection-30"><a href="#Design"><span class="tocnumber">4.8.1</span> <span class="toctext">Design</span></a></li>
<li class="toclevel-3 tocsection-31"><a href="#API_Guide_.26_Data_Structures"><span class="tocnumber">4.8.2</span> <span class="toctext">API Guide &amp; Data Structures</span></a></li>
<li class="toclevel-3 tocsection-32"><a href="#Usage_2"><span class="tocnumber">4.8.3</span> <span class="toctext">Usage</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-33"><a href="#Storm_Control"><span class="tocnumber">4.9</span> <span class="toctext">Storm Control</span></a>
<ul>
<li class="toclevel-3 tocsection-34"><a href="#Design_2"><span class="tocnumber">4.9.1</span> <span class="toctext">Design</span></a></li>
<li class="toclevel-3 tocsection-35"><a href="#API_Guide_.26_Data_Structures_2"><span class="tocnumber">4.9.2</span> <span class="toctext">API Guide &amp; Data Structures</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="#Usage_3"><span class="tocnumber">4.9.3</span> <span class="toctext">Usage</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-37"><a href="#Statistics"><span class="tocnumber">4.10</span> <span class="toctext">Statistics</span></a>
<ul>
<li class="toclevel-3 tocsection-38"><a href="#Design_3"><span class="tocnumber">4.10.1</span> <span class="toctext">Design</span></a></li>
<li class="toclevel-3 tocsection-39"><a href="#API_Guide_.26_Data_Structures_3"><span class="tocnumber">4.10.2</span> <span class="toctext">API Guide &amp; Data Structures</span></a></li>
<li class="toclevel-3 tocsection-40"><a href="#Usage_4"><span class="tocnumber">4.10.3</span> <span class="toctext">Usage</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-41"><a href="#Memory_Map"><span class="tocnumber">5</span> <span class="toctext">Memory Map</span></a></li>
<li class="toclevel-1 tocsection-42"><a href="#OS_and_TCP.2FIP"><span class="tocnumber">6</span> <span class="toctext">OS and TCP/IP</span></a>
<ul>
<li class="toclevel-2 tocsection-43"><a href="#RTOS"><span class="tocnumber">6.1</span> <span class="toctext">RTOS</span></a></li>
<li class="toclevel-2 tocsection-44"><a href="#TCP.2FIP"><span class="tocnumber">6.2</span> <span class="toctext">TCP/IP</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-45"><a href="#PRUSS_.26_EMAC_Handle"><span class="tocnumber">7</span> <span class="toctext">PRUSS &amp; EMAC Handle</span></a></li>
<li class="toclevel-1 tocsection-46"><a href="#IOCTL"><span class="tocnumber">8</span> <span class="toctext">IOCTL</span></a>
<ul>
<li class="toclevel-2 tocsection-47"><a href="#Design_4"><span class="tocnumber">8.1</span> <span class="toctext">Design</span></a></li>
<li class="toclevel-2 tocsection-48"><a href="#API_Guide_.26_Data_Structures_4"><span class="tocnumber">8.2</span> <span class="toctext">API Guide &amp; Data Structures</span></a></li>
<li class="toclevel-2 tocsection-49"><a href="#Usage_5"><span class="tocnumber">8.3</span> <span class="toctext">Usage</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-50"><a href="#Time_Triggered_Send"><span class="tocnumber">9</span> <span class="toctext">Time Triggered Send</span></a>
<ul>
<li class="toclevel-2 tocsection-51"><a href="#TTS_Design_Overview"><span class="tocnumber">9.1</span> <span class="toctext">TTS Design Overview</span></a></li>
<li class="toclevel-2 tocsection-52"><a href="#TTS_API_Details_and_Data_Structures"><span class="tocnumber">9.2</span> <span class="toctext">TTS API Details and Data Structures</span></a></li>
<li class="toclevel-2 tocsection-53"><a href="#TTS_Cyclic_Frame_Notification"><span class="tocnumber">9.3</span> <span class="toctext">TTS Cyclic Frame Notification</span></a>
<ul>
<li class="toclevel-3 tocsection-54"><a href="#Polling_Mode"><span class="tocnumber">9.3.1</span> <span class="toctext">Polling Mode</span></a></li>
<li class="toclevel-3 tocsection-55"><a href="#Interrupt_Mode"><span class="tocnumber">9.3.2</span> <span class="toctext">Interrupt Mode</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-56"><a href="#ICSS_EMAC_LLD_Dependencies"><span class="tocnumber">10</span> <span class="toctext">ICSS EMAC LLD Dependencies</span></a>
<ul>
<li class="toclevel-2 tocsection-57"><a href="#Interrupt_Configuration"><span class="tocnumber">10.1</span> <span class="toctext">Interrupt Configuration</span></a>
<ul>
<li class="toclevel-3 tocsection-58"><a href="#Rx_Interrupt"><span class="tocnumber">10.1.1</span> <span class="toctext">Rx Interrupt</span></a></li>
<li class="toclevel-3 tocsection-59"><a href="#Link_Interrupt"><span class="tocnumber">10.1.2</span> <span class="toctext">Link Interrupt</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-60"><a href="#Learning_module_Increment_counter_implementation"><span class="tocnumber">10.2</span> <span class="toctext">Learning module Increment counter implementation</span></a></li>
<li class="toclevel-2 tocsection-61"><a href="#MDIO_Configurations"><span class="tocnumber">10.3</span> <span class="toctext">MDIO Configurations</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-62"><a href="#EMAC_Configuration_and_How_To"><span class="tocnumber">11</span> <span class="toctext">EMAC Configuration and How To</span></a>
<ul>
<li class="toclevel-2 tocsection-63"><a href="#Network_related"><span class="tocnumber">11.1</span> <span class="toctext">Network related</span></a>
<ul>
<li class="toclevel-3 tocsection-64"><a href="#How_to_configure_IP_address_and_other_IPv4_parameters"><span class="tocnumber">11.1.1</span> <span class="toctext">How to configure IP address and other IPv4 parameters</span></a></li>
<li class="toclevel-3 tocsection-65"><a href="#How_to_configure_MAC_address"><span class="tocnumber">11.1.2</span> <span class="toctext">How to configure MAC address</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Terms_and_Glossary">Terms and Glossary</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=1" title="Edit section: Terms and Glossary">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<table class="wikitable" style="margin: auto; text-align: center; background-color: white;">
<caption><b>Glossary</b>
</caption>
<tbody><tr>
<th>Abbreviation
</th>
<th>Meaning
</th>
<th>Abbreviation
</th>
<th>Meaning
</th></tr>
<tr>
<td>ICSS
</td>
<td style="text-align: left;">Industrial Communicatin Sub-System
</td>
<td>SDK
</td>
<td style="text-align: left;">Industrial Software Development Kit
</td></tr>
<tr>
<td>PRU
</td>
<td style="text-align: left;">Programmable Real Time Unit
</td>
<td>INTC
</td>
<td style="text-align: left;">Interrupt Controller
</td></tr>
<tr>
<td>LLD
</td>
<td style="text-align: left;">Low Level Driver
</td>
<td>SoC
</td>
<td style="text-align: left;">System On Chip. Platforms like AM335x/AM437x etc
</td></tr>
<tr>
<td>EMAC
</td>
<td style="text-align: left;">Ethernet MAC
</td>
<td>RTOS
</td>
<td style="text-align: left;">Real Time Operating System
</td></tr>
<tr>
<td>TRM
</td>
<td style="text-align: left;">Technical Reference Manual for an SoC. Such as <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/spruh73l/spruh73l.pdf">this</a>.
</td>
<td>DLR
</td>
<td style="text-align: left;">Device Level Ring - a redundancy protocol for EtherNet/IP.
</td></tr>
<tr>
<td>Rx/Tx
</td>
<td style="text-align: left;">Packet Receive/Packet Transmit
</td>
<td>Host/CPU/Cortex
</td>
<td style="text-align: left;">Used interchangeably and refers to the Application Processor
</td></tr></tbody></table>
<p><br />
</p>
<ul><li><b>Bold</b> typeface refers to name of function/API/variable/structure.</li>
<li>Code snippets are shown as below</li></ul>
<pre>Sample code snippet
</pre>
<h2><span class="mw-headline" id="Document_Revision_Table">Document Revision Table</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=2" title="Edit section: Document Revision Table">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<table class="wikitable" style="margin: auto; background-color: white;">
<caption>Document Revision
</caption>
<tbody><tr>
<th>Date
</th>
<th>Revision
</th>
<th>Comments
</th></tr>
<tr>
<td>02-Oct-2015
</td>
<td>v.1.0
</td>
<td>Initial Release
</td></tr>
<tr>
<td>04-Oct-2015
</td>
<td>v.1.1
</td>
<td>Fixed links and images
</td></tr>
<tr>
<td>04-July-2016
</td>
<td>v.1.2
</td>
<td>Added Time Triggered Send details
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Introduction">Introduction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=3" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a rel="nofollow" class="external text" href="http://www.ti.com/tool/sysbiossdk-ind-sitara">Industrial SDK</a> release from Texas Instruments enables the use of the PRU-ICSS for ethernet packet processing. This is used to implement several Industrial Ethernet based protocols including Profinet, EtherNet/IP, EtherCAT etc.,  The SDK contains one example for each protocol. These are available under <i>SDK/public/examples</i>. For more information on protocols, examples, folder structure and information on how to use the SDK, please refer to the <a rel="nofollow" class="external text" href="AM335x_SYSBIOS_Industrial_SDK_Getting_Started_Guide.html">Getting Started Guide</a>.
</p><p>In addition to these, the SDK comes with an Ethernet MAC example. This example uses two PRU's to implement two independent MAC's with two different MAC addresses and two different IP addresses. To provide an analogy, this is somewhat similar to a two port Ethernet PCIe NIC card on a PC, only here, the Ethernet interface is available along with the Host processor on a single SoC.
</p><p>Since all the Industrial protocols and Ethernet MAC share the same basic software architecture a discussion of Ethernet MAC goes a long way in understanding the implementation of other protocols. This is a recommended reading for anyone trying to develop or use other Ethernet based protocols provided in the SDK.
</p>
<h3><span class="mw-headline" id="Assumption">Assumption</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=4" title="Edit section: Assumption">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The guide is geared towards helping developers with starting to build applications using the Ethernet MAC and as such does not contain extensive architectural and design  information. Readers are expected to be well versed with PRU-ICSS hardware architecture and peripherals. A description of the PRU-ICSS can be found <a rel="nofollow" class="external text" href="PRU-ICSS.html">here</a>. 
</p><p>This guide also assumes general familiarity with the SDK structure and Industrial EVM's. If you are not familiar with this then please go through the Getting Started Guide mentioned previously.
</p><p>Current SDK release <a rel="nofollow" class="external text" href="http://downloads.ti.com/sitara_indus/esd/SYSBIOSSDK-IND-SITARA/latest/index_FDS.html">2.1.0.1</a> covers both AM335x and AM437x platforms, please refer to the TRM's for details on the SoC. The TRM's can be found here. <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/spruh73l/spruh73l.pdf">AM335x</a>/<a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/spruhl7d/spruhl7d.pdf">AM437x</a>.
</p>
<h3><span class="mw-headline" id="Scope_of_the_Document">Scope of the Document</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=5" title="Edit section: Scope of the Document">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This document:
</p>
<ul><li>Enables a developer to build simple applications using the Ethernet Driver and the sample Ethernet MAC application</li>
<li>Explains the components, software organization and architecture of the Ethernet driver briefly. This is only to enable developers to use and debug the modules. A detailed discussion of the architecture is beyond the scope of this document.</li>
<li>Explains usage and simple tasks through use cases and examples</li>
<li>Helps port another TCP/IP Stack or RTOS for the Ethernet MAC example</li></ul>
<p>The document follows a hands on approach and different aspects are explained through examples and code snippets, these in turn are derived from questions on the forum and field.
</p><p>To prevent the guide from becoming too big and to limit it's scope a separate <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_debug_guide.html">debugging guide</a> has been written which covers various other aspects such as Q&amp;A's and Debug examples with screenshots. The two documents must be used in conjunction to utilize them fully.
</p>
<div style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><b>NOTE</b><br /><br />The code snippets in this guide are only informative, they may or may not compile if taken as it is. Developers are requested to consult the API guide and other relevant user guides for exact coding details.</div>
<h2><span class="mw-headline" id="Software_Architecture">Software Architecture</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=6" title="Edit section: Software Architecture">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The ICSS EMAC consists of driver + firmware implementation. Firmware refers to the code running on the two PRU's which are part of ICSS while driver refers to that portion of code running on host which is directly associated with the firmware. The two PRU's are responsible for reception of packets while Host runs higher level tasks.
</p><p>Logically the software on host can be partitioned into
</p>
<ul><li>Ethernet Driver - Copying packet data and providing to upper layers. Managing PRU/ICSS.</li>
<li>TCP/IP and other network stack. NDK in this case.</li>
<li>RTOS code. SYS/BIOS in this case.</li>
<li>Peripheral initialization and management.</li></ul>
<p>Out of these the first three are relevant to this discussion. Only the driver is discussed in depth while NDK and SYS/BIOS are mentioned in passing whenever relevant.
</p>
<h3><span class="mw-headline" id="File_Organization">File Organization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=7" title="Edit section: File Organization">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>SDK Folder structure is covered in the SDK User Guide <a rel="nofollow" class="external text" href="SYSBIOS_Industrial_SDK_02.01.00-2.html#SDK_Directory_Structure">here</a>. This guide only covers the contents of the folder referred to as <i>os_drivers</i> in the user guide.
</p><p>The contents of the folder <i>os_drivers</i> are discussed briefly:
</p>
<ul><li><i><b>lld</b></i> - Refers to Link Layer Driver. This contains the core of the driver which implements the following:
<ul><li>Rx - Copying the packet received from the firmware and providing it to the TCP/IP stack</li>
<li>Tx - Providing packet from TCP/IP stack to the firmware</li>
<li>Learning/Forwarding Data Base - refer <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#Learning.2FFDB">here</a></li>
<li>Storm Prevention implementation - refer <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#Storm_Control">here</a></li>
<li>Host Statistics implementation - refer <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#Statistics">here</a></li></ul></li>
<li><i><b>pruss</b></i> - Refers to the software which manages the PRU. It performs the following tasks
<ul><li>Initializing the PRU memory</li>
<li>Populating memory offsets, MAC addresses in PRU memory</li>
<li>Managing PRU Interrupt Controller</li></ul></li>
<li><i><b>ICSS</b></i> - Contains software related to the NDK (TCP/IP) Interface.
<ul><li>TCP/IP stack related initialization</li>
<li>Configuring IP address</li>
<li>ARM interrupt management</li></ul></li></ul>
<h3><span class="mw-headline" id="EMAC_and_Switch">EMAC and Switch</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=8" title="Edit section: EMAC and Switch">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>It is important to differentiate between the two different types of implementations in SDK context because this keeps coming up while discussing SDK and it's components. An EMAC example implements two independent Ethernet MAC's using PRU 0/1, they have two different MAC, IP addresses and two different instances of the TCP/IP stack while a Switch presents a single IP and MAC address for any external entity. Another important difference which is obvious from the name is that an EMAC does not forward a packet from one port to another like a Switch.
</p><p>SDK only provides a separate EMAC example, right now there is no example in the SDK for a standalone Switch on the lines of EMAC. The example that comes close to it is the EtherNetIP adapter which is a standalone Ethernet Switch running a EtherNet/IP protocol stack. Instructions on how to remove the EtherNet/IP part of it are given <a href="SYSBIOS_ISDK_Steps_for_creating_stand_alone_switch_example.html" title="SYSBIOS ISDK Steps for creating stand alone switch example">here</a>. 
</p><p>There are some important differences between an EMAC and Switch
</p><p><br />
</p>
<table class="wikitable" style="margin: auto; background-color: white;">
<caption>Differences between EMAC and Switch
</caption>
<tbody><tr>
<th>EMAC
</th>
<th>Ethernet Switch
<p>(Profinet and EtherNet/IP)
</p>
</th></tr>
<tr>
<td>Two interface MAC addresses
</td>
<td>Single interface MAC address
</td></tr>
<tr>
<td>PRU0 transmits on Port0 and PRU1 on Port1
</td>
<td>PRU0 transmits on Port1 and PRU1 on Port0
</td></tr>
<tr>
<td>Two TCP/IP instances and two IP addresses
</td>
<td>One TCP/IP instance and one IP address
</td></tr>
<tr>
<td>Two Rx interrupts, semaphores and tasks for two ports
</td>
<td>Single Rx interrupt, semaphore and task
</td></tr>
<tr>
<td>Two ICSS EMAC Handles
</td>
<td>Single ICSS EMAC Handle
</td></tr>
<tr>
<td>No collision handling (independent MAC's)
</td>
<td>Collision buffer with Collision Handling
<p>Collision refers to Queue Contention
</p>
</td></tr>
<tr>
<td>No forwarding of packets
</td>
<td>Packets forwarded depending on forwarding rules
</td></tr></tbody></table>
<p><br />
</p>
<h3><span class="mw-headline" id="Ports_in_Driver_context">Ports in Driver context</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=9" title="Edit section: Ports in Driver context">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Before beginning it’s important to explain the conventions used in this document, although there are two physical ports for every ICSS for the sake of convenience the Host is considered as a third port. In fact for some protocols this is the logical partitioning used. 
The convention used here is two physical ports and one host port.
</p><p>The ports are referred to as
</p>
<ul><li>Host Port       - <i>ICSS_EMAC_PORT_0</i></li>
<li>Physical Port 0 - <i>ICSS_EMAC_PORT_1</i></li>
<li>Physical Port 1 - <i>ICSS_EMAC_PORT_2</i></li></ul>
<p>This convention is followed throughout the document as well as inside the driver and firmware.
</p>
<h3><span class="mw-headline" id="Driver_Architecture_and_Memory_Map">Driver Architecture and Memory Map</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=10" title="Edit section: Driver Architecture and Memory Map">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A detailed discussion of the architecture is beyond the scope of this document. A brief summary is provided below to explain where the data is copied to, how and why.  
</p><p>While discussing the ICSS Switch we are mainly concerned with 4 types of memories.
</p>
<h4><span class="mw-headline" id="DDR">DDR</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=11" title="Edit section: DDR">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This is the memory from where ARM core operates. It's not on the SoC and hence has a lower performance. This is cached.
</p><p>This contains
</p>
<ul><li>TCP/IP Buffers.</li>
<li>Learning/FDB tables.</li>
<li>Host Statistics.</li>
<li>Control structures and variables.</li></ul>
<h4><span class="mw-headline" id="L3_OCMC_RAM">L3 OCMC RAM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=12" title="Edit section: L3 OCMC RAM">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This is where the actual packet buffers or queues are located. There are 15 queues (Switch) or 12 queues (EMAC) in total. 4 queues for each port (including host) and 1 additional queue for each port to handle collision. This is covered later in QoS section. Developer needs to know that firmware copies the packet data here after receiving them and this is where the driver writes the packet data meant for transmission using the firmware. So this acts as a place holder for packet data before it received or transmitted. This memory resides inside the SoC (but outside ICSS) and is faster than DDR. It's buffered but non-cached. Size varies from SoC to SoC, please refer to the TRM for more details. The L3 OCMC RAM contains:
</p>
<ul><li>Host receive queues</li>
<li>Port transmit queues</li>
<li>Collision queues (not in EMAC mode)</li></ul>
<div style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><b>NOTE</b><br /><br />This memory map is applicable only for EMAC application. Other applications might have their own map.</div>
<h4><span class="mw-headline" id="Shared_Data_RAM">Shared Data RAM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=13" title="Edit section: Shared Data RAM">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This is specific to the PRU subsystem although access is possible from Host albeit slowly. Data common to both PRU's such as Host queue descriptors are stored here. A lot of the memory is available for protocol or application specific usage, for more details refer to the memory map. Size varies from SoC to SoC, please refer to the TRM for more details. The Shared Data RAM contains
</p>
<ul><li>Host queue descriptors</li>
<li>Buffer descriptors for all 12 queues</li>
<li>Host Rx Context for 4 Host receive queues</li></ul>
<div style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><b>NOTE</b><br /><br />This memory map is applicable only for EMAC application. Other applications might have their own map.</div>
<h4><span class="mw-headline" id="PRU0_Data_RAM">PRU0 Data RAM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=14" title="Edit section: PRU0 Data RAM">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This is similar to Shared Data RAM though meant for use only by PRU0. Access from PRU1 is also possible, so the separation is only logical, not in hardware. Size varies from SoC to SoC, please refer to the TRM for more details. The PRU0 Data RAM contains:
</p>
<ul><li>Port 0 Time Triggered Send variables</li>
<li>Port 0 Queue descriptors for 4 Tx queues</li>
<li>Port 0 Tx Context for 4 Port Tx queues</li>
<li>Port 0 Statistics</li>
<li>Port 0 MAC ID</li>
<li>Port 0 Port, Speed and Duplex information</li></ul>
<div style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><b>NOTE</b><br /><br />This memory map is applicable only for EMAC application. Other applications might have their own map.</div>
<h4><span class="mw-headline" id="PRU1_Data_RAM">PRU1 Data RAM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=15" title="Edit section: PRU1 Data RAM">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Similar to PRU0 Data RAM but for PRU1.
</p>
<h3><span class="mw-headline" id="Quality_of_Service_and_Queues">Quality of Service and Queues</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=16" title="Edit section: Quality of Service and Queues">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Quality of Service is very important for an Ethernet Switch/EMAC as it allows high priority packets to be processed separately from regular packets. This provides reliability for real time traffic. In EMAC this is done using queues which are mapped to 8 VLAN based priority levels. Each queue is a block of memory on L3 used to store the packet data. Queue sizes may vary and are build time configurable from <i>icss_emacSwitch.h</i>, for example host queue sizes used for default EMAC application are given below, the sizes are denoted by blocks. Each block is 32 bytes in size. The sizes are limited by L3 size which are dictated by SoC. For in depth information on how to re-build the icss-emac LLD PDK component in case your use case requires re-sizing the Queue sizes, refer to  <a rel="nofollow" class="external autonumber" href="https://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_overview.html#rebuild-pdk">[1]</a>.
</p>
<pre>#define HOST_QUEUE_1_SIZE		194	
#define HOST_QUEUE_2_SIZE		194	
#define HOST_QUEUE_3_SIZE		194	
#define HOST_QUEUE_4_SIZE		194
</pre>
<p>The transmit queues sizes are denoted separately
</p>
<pre>#define QUEUE_1_SIZE		97 	
#define QUEUE_2_SIZE		97	
#define QUEUE_3_SIZE		97	
#define QUEUE_4_SIZE		97	
</pre>
<p>So in total there are 15 queues (12 queues in EMAC), 4 receive queues for Host and 4 transmit queues for each of the two physical ports. In addition to these there is 1 collision queue each for Host and 2 ports which can hold one packet irrespective of packet size. 
</p>
<div style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><b>NOTE</b><br /><br />There are no collision queues in EMAC.</div>
<p>The figure below is illustrative to remember this
</p>
<div class="center"><div class="floatnone"><a href="File_Switch_Queues.html" class="image" title="Switch Rx/Tx Queues"><img alt="Switch Rx/Tx Queues" src="https://processors.wiki.ti.com/images/d/df/Switch_Queues.png" width="600" height="363" /></a></div></div>
<h4><span class="mw-headline" id="How_QoS_Works">How QoS Works</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=17" title="Edit section: How QoS Works">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<h5><span class="mw-headline" id="Switch_QoS">Switch QoS</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=18" title="Edit section: Switch QoS">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>When a packet is received in firmware, the 3 bit PCP field of the VLAN tag is read and the packet is copied to the appropriate queue based on fixed mapping which maps 2 levels(out of 8) of QoS to one queue. So 7 &amp; 6 map to Queue 4, 5 &amp; 4 to Queue 3 and so on. On the driver this queue number then translates to the priority value and is used to decide how to process the packet. If a packet is missing VLAN tag then the lowest priority queue Queue 4 is chosen.
</p>
<h5><span class="mw-headline" id="EMAC_QoS">EMAC QoS</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=19" title="Edit section: EMAC QoS">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>PCP to queue mapping is different for EMAC. In EMAC, the 4 Host receive queues are split into two groups. Queue 1 and Queue 2 are used for storing packets received at PRU0/Port1 and Queue 3 and Queue 4 are used for storing packets received at PRU1/Port2. So, the low priority queues are Queue 2 and Queue 4 for Port 1 and Port 2 respectively. Queue 1 and Queue 3 are high priority queues for Port 1 and Port 2 respectively.
</p>
<ul><li>All the non-VLAN tagged frames are stored in the lowest priority queue (Queue 2 for Port 1 and Queue 4 for Port 2).</li>
<li>VLAN tagged frames with “Priority Code Point (PCP)” value of 4, 5, 6 and 7 are stored in highest priority queue (Queue 1 for Port 1 and Queue 3 for Port 2).</li>
<li>VLAN tagged frames with “Priority Code Point (PCP)” value of 0, 1, 2, and 3 are stored in low priority queue (Queue 2 for Port 1 and Queue 4 for Port 2).</li></ul>
<p>More on this in the next section where driver side Rx processing is discussed in detail.
</p>
<div style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><b>NOTE</b><br /><br />
<ul><li>When a queue overflows, packets are <b>not</b> automatically copied to the next free queue. So overflow can occur.</li>
<li>Contention/Collision queue can only handle a single packet irrespective of size, anything above is dropped.</li>
<li>On Tx side, there is no special handling with regards to QoS. Data is copied to one of the four queues based on the <b>queuePriority</b> field <b>ICSS_EmacTxArgument</b> structure passed to the <b>ICSS_EmacTxPacket</b> API.</li>
<li>At the moment driver/firmware doesn't support DSCP.</li></ul>
</div>
<p><br />
</p>
<h3><span class="mw-headline" id="Data_Path">Data Path</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=20" title="Edit section: Data Path">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Data path refers to the control flow which is executed on the driver and firmware to send or receive a packet. A basic understanding of it goes a long way in explaining the software architecture and if a developer is only trying to use the Rx and Tx capabilities of EMAC or Switch a knowledge of this is sufficient to build an application.
</p>
<h4><span class="mw-headline" id="Rx_Data_Path">Rx Data Path</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=21" title="Edit section: Rx Data Path">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="center"><div class="floatnone"><a href="File_Rx_Data_path.html" class="image" title="Rx Data Path"><img alt="Rx Data Path" src="https://processors.wiki.ti.com/images/c/c5/Rx_Data_path.png" width="500" height="325" /></a></div></div>
<p>Packets are received in the ICSS from where they are copied by the PRU's to L3 memory. The PRU's then assert an interrupt to tell the Host about the presence of a packet. PRU avoids corruption and does not write over the memory till the packet is copied by the Host.
</p><p>The flowchart shown above shows the sequence in very broad strokes. A detailed description is given below.
</p>
<ol><li>PRU Posts an Rx interrupt to the ARM interrupt controller. For EMAC each PRU has a separate Rx interrupt, the configuration for which is done in the application (details in Interrupts).</li>
<li>The interrupt triggers the ISR <b>ICSS_EmacRxInterruptHandler</b> which in turn posts a semaphore rxSemaphoreHandle to signal <b>RxTask</b> to empty the Rx queues.</li>
<li>The <b>RxTask</b> function goes through all the queues, extracts the port/queue number and provides it to an API which copies data from L3 to DDR. The code excerpt is shown below with explanations.</li></ol>
<pre>/*Read till all queues are empty*/
while(allQueuesEempty&#160;!= 1 &amp;&amp; numPacketsInLoop &lt;= ((((ICSSEMAC_Object*)icssEmacHandle-&gt;object)-&gt;emacInitcfg)-&gt;pacingThreshold))
{
     /*This API reads the queues and gets the queue and port number for each packet*/
     pLength = ICSS_EmacRxPktInfo(icssEmacHandle, &amp;port_number, &amp;queue_number);
     if(pLength &gt; 0)
     {
          if(queue_number &gt;= ((ICSSEMAC_Object*)(icssEmacHandle-&gt;object))-&gt;emacInitcfg-&gt;ethPrioQueue)
          {
               /*Based on queue priority settings decide if the packet is to be sent to the TCP/IP stack*/
               /*This API is hooked to NDK*/
               icssEmacHwIntRx(&amp;queue_number,icssEmacHandle);
          }
          else
          {
               /*Protocol specific callback*/
               if(((((ICSSEMAC_Object*)icssEmacHandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;callBack&#160;!= NULL)
               {
                    ((((ICSSEMAC_Object*)icssEmacHandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;callBack(&amp;queue_number,
                    ((((ICSSEMAC_Object*)icssEmacHandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;userArg);
               }
               else
               {
                    /* just dump the packet here so we do no stall the queues*/
                    ICSS_EmacRxPktGet(icssEmacHandle,(uint32_t)dest_address, queue_number, &amp;port_number, &amp;more);   
               }
          }
          ...
          ...
}
</pre>
<p>In the code snippet above, function <b>ICSS_EmacRxPktInfo</b> goes through each queue one at a time, extracts the port &amp; queue number information for every packet and provides it to functions below. Based on the priority of the packet which is decided by the queue number (refer to <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_2_1_Driver_Guide.html#How_QoS_works">discussion</a> on QoS and queues) driver decides to either forward it to NDK, done by <b>icssEmacHwIntRx</b> or give it to the callback function.
</p><p>The threshold for this decision is decided by the user settable parameter shown in the code above.
</p>
<pre>((ICSSEMAC_Object*)(icssEmacHandle-&gt;object))-&gt;emacInitcfg-&gt;ethPrioQueue)
</pre>
<p>Anything lower than this configured value goes to the callback function. If a callback is not registered then the queue is just emptied to prevent queues from overflowing. This is done by the function <b>ICSS_EmacRxPktGet</b> which takes a single packet and copies it into <b>dest_address</b> provided as a parameter. This is not a dummy API but a basic Rx API which performs the task of copying data from L3 to DDR, even the NDK API <b>icssEmacHwIntRx</b> internally calls <b>ICSS_EmacRxPktGet</b> to fetch the packet data.
</p><p>If a developer is building a custom API to process packets then he/she needs to call the API <b>ICSS_EmacRxPktGet</b> in their respective function, this is explained with an example below.
</p><p><i><b> Doing customized packet processing: </b></i>
</p><p>This example is taken from EtherNet/IP adapter application where some DLR packets are processed different from other packets using a callback. For this example the value of <b>ethPrioQueue</b> is set to 4 or <i>ICSS_EMAC_QUEUEPRIO4</i> and in this case these DLR frames have a the highest priority so they go to the callback function, developers need to set an appropriate value for <b>ethPrioQueue</b> based on their requirements. The callback is configured in <b>main</b> like this (taken from <i>icss_eip_driver.c</i>)
</p>
<pre>/*Packet processing callback*/
((((ICSSEMAC_Object*)icssEmacHandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;callBack = (ICSS_EmacCallBack)processProtocolFrames;
((((ICSSEMAC_Object*)icssEmacHandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;userArg = icssEmacHandle;
</pre>
<p>Where <b>icssEmacHandle</b> is the main driver handle and <b>processProtocolFrames</b> is the callback function whose outline is given below
</p>
<pre>void processProtocolFrames(uint32_t* queue_number, void* userArg) {
...
...
uint8_t *dstMacId = tempFrame;
ICSSEMAC_Handle eipIcssEmacHandle = (ICSSEMAC_Handle)userArg;
/*Fetch the packet*/
size = ICSS_EmacRxPktGet(eipIcssEmacHandle,(uint32_t)tempFrame, *queue_number, &amp;port, &amp;more); 
...
/*Compare Destination MAC ID and determine if this is a DLR packet*/
if(COMPARE_MAC(dstMacId, dlrMAC)) {
  processDLRFrame(eipIcssEmacHandle, tempFrame, port-1, size);
...
...
}

</pre>
<p>As can be seen <b>processProtocolFrames</b> function calls <b>ICSS_EmacRxPktGet</b> internally and passes the data to <b>processDLRFrame</b> for further processing.
</p>
<h4><span class="mw-headline" id="Tx_Data_Path">Tx Data Path</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=22" title="Edit section: Tx Data Path">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div class="center"><div class="floatnone"><a href="File_Tx_data_path.html" class="image" title="Tx Data Pah"><img alt="Tx Data Pah" src="https://processors.wiki.ti.com/images/e/e4/Tx_data_path.png" width="500" height="330" /></a></div></div>
<p>The Transmit path on host is simpler than the Rx path. As far as the developer is concerned the main API call is <b>ICSS_EmacTxPacket</b>. This API implements the Learning/FDB functionality.  <b>ICSS_EmacTxPacket</b> in turn calls another API <b>ICSS_EmacTxPacketEnqueue</b> which performs the actual task of copying data from DDR to L3 and signals the PRU to transmit the data. <b>ICSS_EmacTxPacket</b> when called with the parameter <i>ICSS_EMAC_PORT_0</i> in <b>portNumber</b> field enables learning/FDB and calls the <b>ICSS_EmacTxPacketEnqueue</b> with the correct port number and when called with parameter <i>ICSS_EMAC_PORT_1</i> or <i>ICSS_EMAC_PORT_1</i> the API directly calls the underlying API. To avoid confusion developers must always call the API <b>ICSS_EmacTxPacket</b> (NOT <strike><b>ICSS_EmacTxPacketEnqueue</b></strike>) with <b>portNumber</b> as
</p>
<ul><li><i>ICSS_EMAC_PORT_0</i>&#160;: If they do not know the port number on which to transmit.</li>
<li><i>ICSS_EMAC_PORT_1</i> or <i>ICSS_EMAC_PORT_2</i>&#160;: If they know the port number</li></ul>
<div style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><b>NOTE</b><br /><br /> Firmware automatically appends CRC to the packet on Transmit path.</div>
<h4><span class="mw-headline" id="Usage">Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=23" title="Edit section: Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>For simple and/or non time critical applications, it makes more sense to use the NDK socket API's to perform Receive and Transmit operations. An example using NDK sockets which performs both Rx and Tx is given below. For in depth information on how to use sockets please consult <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/spru523i/spru523i.pdf">NDK User's guide</a> and <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/spru524i/spru524i.pdf">NDK API Reference guide</a>.
</p>
<pre>/*Transmit to System with IP Address*/
#define DST_IP "192.168.1.64"
#define DST_PORT 7
/*Open file session*/
fdOpenSession( (HANDLE)Task_self() );		
SOCKET s = INVALID_SOCKET;
struct sockaddr_in sin1;
struct timeval timeout; 
/*Create UDP socket*/
s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
/*Prepare address for connect*/
IPN IPAddr;
IPAddr = inet_addr(DST_IP);
bzero( &amp;sin1, sizeof(struct sockaddr_in) );
sin1.sin_family = AF_INET;
sin1.sin_addr.s_addr = IPAddr;
sin1.sin_port = htons(DST_PORT); 
 /*Configure our Tx and Rx timeout*/
timeout.tv_sec = 0;
timeout.tv_usec = 1;
setsockopt( s, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, sizeof( timeout ) );
setsockopt( s, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, sizeof( timeout ) );
/*Transmit packet*/
sendto( s, pBuf, testsize, 0, (PSA)&amp;sin1, sizeof(sin1) );
/*Receive packet*/
recv(s, pBuf, MAX_UDP_SIZE, 0);

</pre>
<p>For time critical applications with low latency requirements directly calling the API's is recommended. For Transmit this can be done by populating the packet directly(or through a stack) in a memory buffer and calling <b>ICSS_EmacTxPacket</b> with the buffer in a task in <b>main()</b>. Shown below is an example of a periodic transmit being done in main function.
</p>
<pre>/**A dummy packet*/
uint8_t dummyPkt[ETHERNET_FRAME_SIZE_60] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
0x45,0x00,0x00,0x2E,0x00,0x00,0x40,0x00,0x40,0x00,0x3A,0xD1};
Void taskSendPacket(UArg a0, UArg a1) {
  /*wait for system to initialize*/
  /*Send packet in a loop every 500ms*/
  Task_sleep(5000);
  while(1) {
    /*Send packet on PORT 1*. Size is known previously/     
    ICSS_EmacTxPacket(emachandle,dummyPkt, ICSS_EMAC_PORT_1, 1, ETHERNET_FRAME_SIZE_60);
    Task_sleep(500);
  }
}
</pre>
<p>For receive the application/stack can receive the packet data directly in <b>(uint32_t)dest_address</b> from <b>ICSS_EmacRxPktGet</b> inside <b>RxTask</b>. Modify the <b>ethPrioQueue</b> value as per requirement. (Explained above)
</p>
<h4><span class="mw-headline" id="Forwarding_Rules">Forwarding Rules</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=24" title="Edit section: Forwarding Rules">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Forwarding Rules specify how packets are forwarded between ports and from the port to the Host. There are three basic types of forwarding scenarios. The image below shows all modes when receiving on first port. <b>HW Port</b> represents the physical port. These modes are not exclusive to each other and multiple modes are also allowed.
</p><p>Please note that EMAC can only forward to the Host, other modes only apply to switch.
</p>
<div class="center"><div class="floatnone"><a href="File_Forwarding-Rules.html" class="image" title="Forwarding Rules"><img alt="Forwarding Rules" src="https://processors.wiki.ti.com/images/5/56/Forwarding-Rules.png" width="300" height="270" /></a></div></div>
<ul><li><b>Cut Through</b> - In this mode the firmware copies the data from Rx FIFO to Tx FIFO through the registers. No data is copied to the queues, this is the fastest mode of transmit from one port to another. Advantage is low latency, disadvantage is that CRC is not checked before transmit since it lies at the end of the packet.</li>
<li><b>Store &amp; Forward</b> - In this mode the firmware copies the received data to the transmit queues on opposite port, no data is sent to the Host (Rx interrupt on Host is not asserted). CRC is checked before transmit. Many protocols like PTP use this mode.</li>
<li><b>Forward to Host</b> - Data is received in the Host receive queues and an Rx interrupt is asserted to copy the data. This is the only mode available for an EMAC.</li></ul>
<p><br />
</p>
<table class="wikitable" style="margin: auto; background-color: white;">
<caption><b>Forwarding Rules</b>
</caption>
<tbody><tr>
<th>Packet Type
</th>
<th>Forwarding Mode
</th></tr>
<tr>
<td>Broadcast
</td>
<td>Cut through &amp; Forward to Host
</td></tr>
<tr>
<td>Multicast
</td>
<td>Cut through &amp; Forward to Host
<p>Multicast frames like PTP/DLR are handled based on protocol
</p>
</td></tr>
<tr>
<td>Unicast (not to Host)
</td>
<td>Cut through
</td></tr>
<tr>
<td>Unicast (to Host)
</td>
<td>Forward to Host
</td></tr></tbody></table>
<p><br />
</p>
<h3><span class="mw-headline" id="Interrupts_and_Tasks">Interrupts and Tasks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=25" title="Edit section: Interrupts and Tasks">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This section deals with Interrupts and Tasks required to implement an EMAC LLD application. Since they are tied to the RTOS used, they are exported via the driver handle to the application as well as through the OSAL layer. Developers must take care to maintain correct priorities and order so as not to alter the behavior of the driver. All the interrupts and tasks enabled in an application can be checked using the SYSBIOS ROV. For more details on this tool refer to the <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_debug_guide.html#SYS.2FBIOS">SYSBIOS</a> section of EMAC LLD Debug Guide.
</p>
<h4><span class="mw-headline" id="Interrupts">Interrupts</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=26" title="Edit section: Interrupts">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>There are six interrupts (eight if time triggered send is enabled) in an EMAC LLD coming from PRU. Other implementations like EtherNet/IP, PTP, Profinet etc may use their own interrupts. Please note that there are individual interrupts for each port because this is a dual MAC implementation, for an Ethernet switch like EtherNet/IP there are only two interrupts (no time triggered send in Switch mode).
</p><p>The eight interrupts are:
</p>
<ol><li>Rx interrupt x 2&#160;: One for each port, both mapping to same ISR. These are used by PRU to tell ARM about the presence of a packet. For Port 0 this is interrupt number (ARM) 20 on AM335x and for Port 1 it is 21. In the mapping these are indicated by <b>PRU_ARM_EVENT0</b> and <b>PRU_ARM_EVENT1</b> respectively. For ethernet switch it's just <b>PRU_ARM_EVENT0</b>.</li>
<li>Link interrupt x 2: One for each port, both mapping to same ISR. These are used to indicate PHY state change to Host. For Port 0 interrupt number (ARM) is 26 and for Port 1 27. In mapping these are indicated by <b>MII_LINK0_EVENT</b> and <b>MII_LINK1_EVENT</b> which map to <b>CHANNEL7</b> and <b>CHANNEL8</b> respectively. For ethernet switch both link events map to a single channel <b>CHANNEL7</b>.</li>
<li>Tx Completion Interrupt x 2: One for each port, mapping to different ISRs. These are used by PRU to tell ARM about the completion of transmission of a packet. For Port 0 this is interrupt number (ARM) 22 on AM335x and for Port 1 it is 23. In the mapping these are indicated by <b>PRU_ARM_EVENT2</b> and <b>PRU_ARM_EVENT3</b> respectively.</li>
<li>TTS Insert Cyclic Frame Interrupt x 2: One for each port, mapping to different ISRs. These are used by PRU to tell ARM that its time to insert cyclic frame. For Port 0 this is interrupt number (ARM) 22 on AM335x and for Port 1 it is 23. In the mapping these are indicated by <b>PRU_ARM_EVENT4</b> and <b>PRU_ARM_EVENT5</b> respectively. These are only applicable when TTS is enabled and initialized by the application.</li></ol>
<div style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><b>NOTE</b><br /><br /> Tx Completion Interrupts and TTS Cyclic Frame Interrupts are different PRU events, i.e., total 4 PRU events. But these map to the same interrupt and ISR per port i.e., Tx Completion Interrupt and TTS Cyclic Frame Interrupt share one ARM interrupt number and ISR for Port 1 and share one ARM interrupt number and ISR for Port 2.</div>
<p>There are two types of interrupts:
</p>
<ul><li><i><b>ICSS Interrupts</b></i>&#160;: These are interrupts that are routed through the ICSS Interrupt controller to the Host (Refer to section 4.4.2 of <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/spruh73l/spruh73l.pdf">AM335x TRM</a>). It consists of interrupts asserted by the PRU as well as interrupts asserted by the peripherals (MDIO, ECAP etc) attached to the ICSS Interrupt controller.</li></ul>
<p>The Host Interrupt controller has 8 usable interrupts mapped to the ICSS interrupt controller. This mapping is programmable and varies from example to example. Every example has a <i>x_pruss_intc_mapping.h</i> file in the <i>sdk/examples</i> folder where x stands for the example name. For EMAC this file is called <i>tiemac_pruss_intc_mapping.h</i>.
</p><p><i><b>Mapping Explanation</b></i>
</p><p>The interrupt mapping consists of 3 parts:
</p>
<ol><li>8 PRU user interrupts (can be set in the firmware by writing to R31) - represented by <i>PRU_ARM_EVENT0</i> to <i>PRU_ARM_EVENT7</i>. These are part of the 64 system interrupts (out of which 32 are usable). This includes the two link interrupts for two ports <i>MII_LINK0_EVENT</i> and <i>MII_LINK1_EVENT</i>.</li>
<li>10 ICSS Host channels <i>CHANNEL0</i> to <i>CHANNEL9</i> out of which the first two <i>CHANNEL0</i> and <i>CHANNEL1</i> are used internally.</li>
<li>8 ARM PRU interrupts represented by <i>PRU_EVTOUT0</i> to <i>PRU_EVTOUT7</i>. These can also be seen in the ARM INTC in SoC TRM. Provided below is a screenshot from AM335x TRM showing the 8 interrupts mapped to the PRU.</li></ol>
<p><br />
</p>
<div class="center"><div class="floatnone"><a href="File_AM335x-PRUINT.html" class="image" title="AM335x PRUINT"><img alt="AM335x PRUINT" src="https://processors.wiki.ti.com/images/6/6d/AM335x-PRUINT.png" width="500" height="201" /></a></div></div>
<p><br />
The complete mapping follows the pattern 
</p>
<pre>PRU user interrupts --&gt; Host Channels --&gt; ARM PRU Interrupts

</pre>
<p>To take an example of Rx interrupt for Port 0 (EMAC only). For switch this is the Rx interrupt for both ports.
</p><p>The following line maps PRU user interrupt 0 to Host channel 2.
</p>
<pre>{PRU_ARM_EVENT0,CHANNEL2, SYS_EVT_POLARITY_HIGH ,SYS_EVT_TYPE_PULSE}
</pre>
<p>Host channel <i>CHANNEL2</i> in turn maps to the first ARM interrupt <i>PRU_ICSS_EVTOUT_0</i> through this line.
</p>
<pre>{CHANNEL2, PRU_EVTOUT0}
</pre>
<p>As seen from the screenshot the interrupt number for <i>PRU_ICSS_EVTOUT_0</i> on AM335x is <i>20</i>, so the interrupt number that must be configured for this in application should be 20 if the platform is AM335x. This is done in the following line (defined in <i>main.c</i>)
</p>
<pre>switchEmacCfg-&gt;rxIntNum = 20; 
</pre>
<p>This mapping alone determines which ARM interrupt number will be associated with a particular PRU user interrupt. For example the line above where PRU user interrupt 0 maps to Host channel 2 can be modified to
</p>
<pre>{PRU_ARM_EVENT0,CHANNEL2, SYS_EVT_POLARITY_HIGH ,SYS_EVT_TYPE_PULSE} ---&gt; {PRU_ARM_EVENT0,CHANNEL4, SYS_EVT_POLARITY_HIGH ,SYS_EVT_TYPE_PULSE}
</pre>
<p>and the Channel to ARM interrupt map can be configured as, and the interrupt number on ARM would still remain the same i.e. 20
</p>
<pre>{CHANNEL2, PRU_EVTOUT0} ---&gt;  {CHANNEL4, PRU_EVTOUT0}
</pre>
<p>A question arises in this case as to the usefulness of <i>CHANNELx</i>. The answer is that channels allow us to map multiple PRU User interrupts and system interrupts to a single channel and in turn to a single ARM interrupt. For example take a look at the link interrupt mapping
</p>
<pre>{MII_LINK0_EVENT, CHANNEL7, SYS_EVT_POLARITY_HIGH ,SYS_EVT_TYPE_PULSE},	\
{MII_LINK1_EVENT, CHANNEL7, SYS_EVT_POLARITY_HIGH ,SYS_EVT_TYPE_PULSE},	\
</pre>
<p>and 
</p>
<pre>{CHANNEL7, PRU_EVTOUT6}
</pre>
<p>This configuration maps both Port 0 and Port 1 interrupts to a single channel and in turn to a single ARM interrupt <i>PRU_ICSS_EVTOUT6</i>, which is interrupt number 26 (shown by the line below in <i>main.c</i>)
</p>
<pre>switchEmacCfg-&gt;linkIntNum=26;
</pre>
<p>The link interrupt binds to a single ISR <b>ICSS_EmacLinkISR</b> on Host. Inside the ISR an ICSS register <b>HW_ICSS_INTC_SECR1</b>is checked to find out which link event <i>MII_LINK0_EVENT</i> or <i>MII_LINK1_EVENT</i> asserted the interrupt. The advantage of such an approach is that both interrupts are serviced even if they are raised at the same time.
</p><p>These interrupt numbers can change from SoC to SoC so please consult TRM before making any modifications to the interrupt map. This is also one of the reasons for exporting these configurations to application so that a single driver can handle multiple SoC's others being ease of use, porting other operating systems etc.
</p><p><br />
</p>
<table class="wikitable" style="margin: auto; text-align: center; background-color: white;">
<caption>PRU Interrupt Mapping in EMAC
</caption>
<tbody><tr>
<th>PRU Interrupt Number
</th>
<th>Channel Number
</th>
<th>Host Interrupt Number
</th>
<th>ISR
</th></tr>
<tr>
<td>PRU_ARM_EVENT0
<p>Port 0 RX Interrupt
</p>
</td>
<td>CHANNEL2
</td>
<td>20
</td>
<td><i>ICSS_EmacRxInterruptHandler</i>
</td></tr>
<tr>
<td>PRU_ARM_EVENT1
<p>Port 1 RX Interrupt
</p>
</td>
<td>CHANNEL3
</td>
<td>21
</td>
<td><i>ICSS_EmacRxInterruptHandler</i>
</td></tr>
<tr>
<td>PRU_ARM_EVENT2
<p>Port 0 TX Completion Interrupt
</p>
</td>
<td>CHANNEL4
</td>
<td>22
</td>
<td><i>ICSS_EmacTxInterruptHandlerPort1</i>
</td></tr>
<tr>
<td>PRU_ARM_EVENT3
<p>Port 1 TX Completion Interrupt
</p>
</td>
<td>CHANNEL5
</td>
<td>23
</td>
<td><i>ICSS_EmacTxInterruptHandlerPort2</i>
</td></tr>
<tr>
<td>PRU_ARM_EVENT4
<p>Port 0 TTS Insert Cyclic Frame Interrupt
</p>
</td>
<td>CHANNEL4
</td>
<td>22
</td>
<td><i>ICSS_EmacTxInterruptHandlerPort1</i>
</td></tr>
<tr>
<td>PRU_ARM_EVENT5
<p>Port 1 TTS Insert Cyclic Frame Interrupt
</p>
</td>
<td>CHANNEL5
</td>
<td>23
</td>
<td><i>ICSS_EmacTxInterruptHandlerPort2</i>
</td></tr>
<tr>
<td>MII_LINK0_EVENT
<p>Port 0 Link Interrupt
</p>
</td>
<td>CHANNEL7
</td>
<td>26
</td>
<td><i>ICSS_EmacLinkISR</i>
</td></tr>
<tr>
<td>MII_LINK1_EVENT
<p>Port 1 Link Interrupt
</p>
</td>
<td>CHANNEL8
</td>
<td>27
</td>
<td><i>ICSS_EmacLinkISR</i>
</td></tr></tbody></table>
<p><br />
</p>
<ul><li><i><b>Host Interrupts</b></i>&#160;: Host interrupts are interrupts that are not coming via ICSS Interrupt controller. These include peripherals, EDMA, timers etc. A full list is present inside the Interrupt section of any TRM. On AM335x a total of 128 interrupts are available through this (including 8 PRU ICSS interrupts). Discussion of Host interrupts is beyond the scope of this guide as we only deal with the EMAC LLD driver here.</li></ul>
<p>Some examples of Host interrupts used in the driver are DMTimer interrupts and EDMA interrupts which are available through the OSAL layer <i>osdrv_edma.c</i> and <i>osdrv_osal.c</i>
</p>
<h4><span class="mw-headline" id="Interrupt_Pacing">Interrupt Pacing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=27" title="Edit section: Interrupt Pacing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>When packets are sent to the Host at a very high rate (this happens more often with small frames) it's possible that ARM is interrupted frequently by the PRU's, this results in packets getting dropped as the host is unable to empty the queues in time because of context switching. Interrupt pacing is a scheme used to cope with this situation. In this scheme interrupts are disabled when the first Rx interrupt is received (The PRU still keeps receiving the frames and putting them on the queues), after a certain number of packets have been processed on the Host, the interrupts are enabled once more. Since interrupts on PRU have not been disabled any pending packets will assert the interrupt again, this ensures that no packets are missed. The advantage of pacing is that a greater throughput is achieved while disadvantage is that if any critical packets need to be serviced immediately, it's possible that some delay may occur. Pacing is enabled in the driver using the variable <b>intrPacingMode</b>. There are two pacing modes in driver.
</p>
<ul><li><b>INTR_PACING_MODE1</b>&#160;: This is entirely ARM based, i.e. interrupts are disabled only on the Host. This does not require any firmware support. This is the scheme supported with Ethernet MAC and Ethernet IP Adapter.</li>
<li><b>INTR_PACING_MODE1</b>&#160;: In this scheme interrupts are disabled on the PRU. This requires firmware support. Only supported in Profinet right now.</li></ul>
<h4><span class="mw-headline" id="Tasks">Tasks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=28" title="Edit section: Tasks">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Tasks are the Linux equivalent of processes in SysBIOS. A simple example to create a task from EMAC application is given below
</p>
<pre> Task_Params_init(&amp;taskParams);
 taskParams.priority = 15;
 taskParams.instance-&gt;name = "SwitchTask";
 Task_create(taskPruss, &amp;taskParams, &amp;eb);
</pre>
<p>Here <b>taskPruss</b> is given the job of initializing the PRU's and loading the firmware onto them. The task itself is a simple function with two arguments
</p>
<pre>/*
 *	---task to initialize PRU---
 */
Void taskPruss(UArg a0, UArg a1)
{
  ...
  ...
  ...
}
</pre>
<p>They can be used for simple tasks like sending or receiving a packet. To get an idea <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#Usage">refer</a> to the example usage for sending a packet through a call to transmit API <b>ICSS_EmacTxPacket</b> in a loop. If calling the task in an endless while loop developers must add a small delay inside the loop using <i>Task_sleep(time in milliseconds)</i> to let other tasks get some time as well, failure to do so is a common mistake that developers make.
</p>
<h3><span id="Learning/FDB"></span><span class="mw-headline" id="Learning.2FFDB">Learning/FDB</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=29" title="Edit section: Learning/FDB">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Learning/FDB where FDB stands for Forwarding Data Base is a module that learns source MAC addresses of packets addressed to the Host and thus maintains a list of which devices reside on which port. While transmitting a packet when provided with the destination MAC address the module returns the port number on which the device resides. This avoids duplication of traffic on both ports. This module is applicable only in Switch mode, in EMAC mode this module is disabled since there is only one port.
</p>
<h4><span class="mw-headline" id="Design">Design</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=30" title="Edit section: Design">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Learning table is currently implemented as a Hash table. There is one table for each physical port. Each table has 256 buckets where a bucket has a size of 4. The bucket size and number of buckets are in turn dictated by the choice of Hashing algorithm. A detailed discussion on this topic is beyond the scope of this document, suffice to say that theoretically a hash table is capable of learning 256 * 4 = 1024 entries. The actual capacity may be lower owing to collisions. 
</p><p>A single bucket has
</p>
<ul><li>Four entries - For storing four MAC Id's</li>
<li>Four ageing counters - One associated with each entry</li>
<li>Number of Entries - A value which tells how many entries are there in the bucket.</li></ul>
<p>A single table has
</p>
<ul><li>256 buckets</li>
<li>Total number of entries - Sum of entries in all the buckets</li>
<li>Port State - A table has three states
<ul><li>Learning - This is the default state. All actions are permitted</li>
<li>Not Learning - No new addresses are learnt. Deletions possible.</li>
<li>Locked - No additions/deletions allowed</li></ul></li></ul>
<p>Collisions are handled using ageing counters, one ageing counter is associated with each of the 4 entries inside a bucket. It tells the module which entries are old and which ones are new.
</p>
<h4><span id="API_Guide_&amp;_Data_Structures"></span><span class="mw-headline" id="API_Guide_.26_Data_Structures">API Guide &amp; Data Structures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=31" title="Edit section: API Guide &amp; Data Structures">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>A learning table has the following structure
</p>
<pre>typedef struct HashTable_t{
       
 uint32_t totalNumEntries;	      /**Total number of entries in the hash table*/
 portState state;		      /**State of the hash table, see enum portState above*/
 HashBucket_t  entries[NUMBUCKETS];  /**Number of bucket entries*/
       
} HashTable_t;
</pre>
<p>The individual bucket which makes up the learning table has the following structure
</p>
<pre>typedef struct {
 
 MAC mac[MAX_NUM_ENTRIES];            /**Four MAC Id per bucket*/
 uint8_t timerCount[MAX_NUM_ENTRIES]; /**Timer count used for ageing and conflict resolution*/
 uint8_t numEntries;                  /**Number of MAC entries in the bucket, 4 means it is full*/
  
} HashBucket_t;
</pre>
<p>The default values are 
</p>
<ul><li>NUMBUCKETS      256</li>
<li>MAX_NUM_ENTRIES 4</li></ul>
<p>The algorithm assumes these values and they cannot be changed at present.
</p><p>API descriptions are only for information, developers are requested to use corresponding <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#IOCTL">IOCTL</a> calls. The IOCTL command for Learning/FDB modules is <i><b>ICSS_EMAC_IOCTL_LEARNING_CTRL</b></i>
</p><p><i><b>Adding A MAC address</b></i>&#160;: The corresponding API for this is 
</p>
<pre>void updateHashTable(uint8_t* macId, uint8_t portNum, HashTable_t *tablePtr,ICSSEMAC_CallBackConfig* exceptionCallBack)
</pre>
<p>The API is integrated inside <b>ICSS_EmacRxPktGet</b> so developer need not call it separately, if at all it is required please use the IOCTL call for this. IOCTL Param value is <i>ICSS_EMAC_LEARN_CTRL_UPDATE_TABLE</i>
</p><p><i><b>Looking up an Entry</b></i>&#160;: The corresponding API for this is 
</p>
<pre>uint8_t findMAC(const uint8_t * macId, HashTable_t *tablePtr)
</pre>
<p>Integrated with driver inside <b>ICSS_EmacTxPacket</b>, use IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_FIND_MAC</i>
</p><p><i><b>Removing a MAC address</b></i>&#160;: The corresponding API for this is 
</p>
<pre>uint8_t removeMAC(uint8_t * macId, HashTable_t *tablePtr)
</pre>
<p>Entries are removed automatically upon ageing, if forced removal is required use IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_REMOVE_MAC</i>
</p><p><i><b>Ageing an Entry</b></i>&#160;: The driver already implements this inside the periodic task which is called every 100 NDK Ticks <i><b>_HwPktPoll()</b></i> but users can call it as well. IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_INC_COUNTER</i>
</p><p>The corresponding API for this is 
</p>
<pre>void incrementCounter(HashTable_t *tablePtr)
</pre>
<p><i><b>Removing an Aged Entry</b></i>&#160;: The corresponding API for this is 
</p>
<pre>void ageingRoutine(uint8_t portNum, HashTable_t *tablePtr)
</pre>
<p>Integrated with driver. IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_AGEING</i>
</p><p><i><b>Changing Port State</b></i>&#160;: Change the port state to appropriate value. This is useful in the implementation of requirements specified by IEEE 802.1D.
</p><p>The corresponding API for this is
</p>
<pre>void changePortState(portState state, HashTable_t *tablePtr)
</pre>
<p>As part of changing port state the module implements locking of a port (where addition/deletion of entries is not possible), ageing (age the entries to simulate passage of time). Not integrated with driver, application must do it. IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_SET_PORTSTATE</i>
</p><p><i><b>Flushing/Clearing the entire Table</b></i>&#160;: The corresponding API for this is 
</p>
<pre>void purgeTable(uint8_t portNum, HashTable_t *tablePtr)
</pre>
<p>Not integrated with driver, call separately using IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_CLR_TABLE</i>
</p>
<h4><span class="mw-headline" id="Usage_2">Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=32" title="Edit section: Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The module is integrated with the driver so a developer need not bother about calling the API's separately in the application unless there is a specific need to 
</p>
<ul><li>Add a MAC ID</li>
<li>Remove a MAC ID</li>
<li>Lock the Port or change it's state</li></ul>
<p>The ageing module is called inside <b>_HwPktPoll</b> (which is a periodic NDK task, more info in the porting guide) via an IOCTL call, to age faster please call the routine separately in another task. Changing the time period of <b>_HwPktPoll</b> is not recommended as many other tasks are performed in this.
</p>
<h3><span class="mw-headline" id="Storm_Control">Storm Control</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=33" title="Edit section: Storm Control">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Strom control or Storm prevention is a feature that limits the number of broadcast and multicast packets going to the host and/or cutting through to the other port. Since broadcast and multicast packets are sent over all the ports of a switch they have the potential to create a storm which drowns all other traffic on the network, in this regard this is a very important feature for the switch.
</p>
<h4><span class="mw-headline" id="Design_2">Design</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=34" title="Edit section: Design">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Storm prevention is implemented on the two PRU's as a credit based scheme. When the feature is enabled, every time a multicast or broadcast packet is received a counter referred to as storm prevention credits is decremented and the packet is sent to the host as well as cut through. If the counter value is 0 then the packet is dropped. The counter is stored on respective PRU DMEM's and is reset after a fixed period by the Host. The combination of this period and credit value decides the rate of acceptance/rejection.
</p><p>The mechanism is shown below in the diagram
</p><p><a href="File_Storm_Prevention_architecture_Industrial.html" class="image"><img alt="Storm Prevention architecture Industrial.jpeg" src="https://processors.wiki.ti.com/images/6/66/Storm_Prevention_architecture_Industrial.jpeg" width="300" height="311" /></a>
</p><p>The Storm prevention implementation is similar in both PRU's but implemented separately, so it's possible to turn it off selectively for each port. As of now the multicast and broadcast storm prevention functionalities are clubbed together but it is proposed to have them separate in the future.
</p>
<h4><span id="API_Guide_&amp;_Data_Structures_2"></span><span class="mw-headline" id="API_Guide_.26_Data_Structures_2">API Guide &amp; Data Structures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=35" title="Edit section: API Guide &amp; Data Structures">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The main parent structure for Storm Prevention is 
</p>
<pre>typedef struct {
         
 uint8_t suppressionEnabled;   /** enable/disable storm prevention*/
 uint16_t credits;             /** Number of packets allowed in a time interval*/
  
} stormPrevention_t;
</pre>
<p>There is an instance of this structure for each port
</p><p>API descriptions are only for information, developers are requested to use corresponding <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#IOCTL">IOCTL</a> calls. The IOCTL command for Learning/FDB modules is <i><b>ICSS_EMAC_IOCTL_STORM_PREV_CTRL</b></i>
</p><p><i><b>Enabling Storm Prevention </b></i>&#160;: The corresponding API for this is
</p>
<pre>void ICSS_EmacEnableStormPrevention(uint8_t portnum, ICSSEMAC_Handle icssEmacHandle)
</pre>
<p>Corresponding IOCTL Param value is <i>ICSS_EMAC_STORM_PREV_CTRL_ENABLE</i>
</p><p><i><b>Disabling Storm Prevention</b></i>&#160;: Similar to enablement, variable set to False.
The corresponding API for this is
</p>
<pre>void ICSS_EmacDisableStormPrevention(uint8_t portnum, ICSSEMAC_Handle icssEmacHandle)
</pre>
<p>IOCTL Param value is <i>ICSS_EMAC_STORM_PREV_CTRL_DISABLE</i>
</p><p><i><b>Resetting the counters</b></i>&#160;: This is called inside <b>_HwPktPoll</b> which is the NDK tick function. The time period of this tick function (default 100ms) in combination with <b>credits</b> value decides the rate at which Storm Prevention works. This is called by default inside the driver.
</p><p>The corresponding API for this is
</p>
<pre>void ICSS_EmacResetStormPreventionCounter(ICSSEMAC_Handle icssEmacHandle)
</pre>
<p>IOCTL Param value is <i>ICSS_EMAC_STORM_PREV_CTRL_RESET</i>
</p><p><i><b>Changing the rate</b></i>&#160;: To change how many packets are accepted or rejected change the value in the structure. At every iteration these values are written to the data RAM by the <b>ICSS_EmacResetStormPreventionCounter</b> API. The scheme through which this occurs is explained in the design description above
</p><p>The corresponding API for this is
</p>
<pre>void setCreditValue(uint16_t creditValue, stormPrevention_t* stormPrevPtr)
</pre>
<p>IOCTL Param value is <i>ICSS_EMAC_STORM_PREV_CTRL_SET_CREDITS</i>
</p>
<h4><span class="mw-headline" id="Usage_3">Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=36" title="Edit section: Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Most often Storm Prevention is the main reason for users not being able to receive a packet, esp if the rate is configured incorrectly. So first verify if it is enabled for that port. This can be done by 
</p>
<ul><li>Checking structure variable&#160;: See the value of <b>suppressionEnabled</b> variable in the structure.</li>
<li>Checking memory&#160;: See the memory offset STORM_PREVENTION_OFFSET in the corresponding data RAM. The first bit of the byte location tells you whether the logic is enabled on the port.</li>
<li>Disabling Storm Prevention&#160;: This is the easiest and preferable for someone not using an emulator. Use the corresponding IOCTL call.</li></ul>
<p>To quickly verify if the logic is indeed dropping packets, try sending some broadcast packets at line rate to the device and check the value of PRU statistics variable <b>stormPrevCounter</b>. See statistics section on how to read this variable.
</p>
<h3><span class="mw-headline" id="Statistics">Statistics</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=37" title="Edit section: Statistics">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Statistics on ICSS Switch provide a great deal of information on what's going on with the switch. They are enabled by default and provide provide port specific statistics. They are also a great debugging tool and should be the first thing a developer should look at if they suspect any issue with Rx or Tx.
</p>
<h4><span class="mw-headline" id="Design_3">Design</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=38" title="Edit section: Design">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The Statistics are divided into
</p>
<ul><li><i><b>Statistics on PRU</b></i>&#160;: Since the LLD functionality is implemented on the PRU's the majority of statistics are implemented on them. The count for each port is stored on the respective Data RAM's starting at the offset STATISTICS_OFFSET. The map is shown below</li>
<li><i><b>Statistics on Host</b></i>&#160;: The packets coming to the Host are counted once again, this is useful for debugging purposes and to measure throughput (from the PRU to Host) if required. Some statistics like "Unknown protocol type" are only implemented on the Host.</li></ul>
<p>Functionally the statistics are classified into 
</p>
<ul><li><i><b>Rx/Tx related statistics</b></i>&#160;: This includes count of broadcast, multicast and unicast packets and their derivatives. Only valid packets are part of this which means that an Rx packet which has been dropped because of storm prevention will not be counted.</li>
<li><i><b>Error Counters</b></i>&#160;: This includes statistics such as Dropped frames, Rx/Tx errors etc.</li>
<li><i><b>Other statistics</b></i>&#160;: Includes statistics related to 802.1 CSMA/CD, number of link breaks etc.</li></ul>
<p>A description of PRU statistics along with corresponding memory map is given below. 
</p>

 align="center" 
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;"><caption><i><b>PRU Statistics Description &amp; Memory Map</b></i>
</caption>
<tbody><tr>
<th>Name of Variable
</th>
<th>Description
</th>
<th>Name of Offset
<p>Refer to <i>icss_emacSwitch.h</i>
</p>
</th>
<th>Offset in PRU DRAM 0/1
</th></tr>
<tr>
<td><b>txBcast</b>
</td>
<td>Number of broadcast packets sent
</td>
<td><i>TX_BC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F00</i>
</td></tr>
<tr>
<td><b>txMcast</b>
</td>
<td>Number of multicast packets sent
</td>
<td><i>TX_MC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F04</i>
</td></tr>
<tr>
<td><b>txUcast</b>
</td>
<td>Number of unicast packets sent
</td>
<td><i>TX_UC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F08</i>
</td></tr>
<tr>
<td><b>txOctets</b>
</td>
<td>Total number of octets sent, includes all packets
</td>
<td><i>TX_BYTE_CNT_OFFSET</i>
</td>
<td><i>0x1F0C</i>
</td></tr>
<tr>
<td><b>rxBcast</b>
</td>
<td>Number of broadcast packets received
</td>
<td><i>RX_BC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F10</i>
</td></tr>
<tr>
<td><b>rxMcast</b>
</td>
<td>Number of multicast packets received
</td>
<td><i>RX_MC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F14</i>
</td></tr>
<tr>
<td><b>rxUcast</b>
</td>
<td>Number of unicast packets received
</td>
<td><i>RX_UC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F18</i>
</td></tr>
<tr>
<td><b>rxOctets</b>
</td>
<td>Total number of octets received, includes all packets
</td>
<td><i>RX_BYTE_CNT_OFFSET</i>
</td>
<td><i>0x1F1C</i>
</td></tr>
<tr>
<td><b>lateColl</b>
</td>
<td>Number of packets that suffered collisions late into Tx
</td>
<td><i>LATE_COLLISION_OFFSET</i>
</td>
<td><i>0x1F20</i>
</td></tr>
<tr>
<td><b>singleColl</b>
</td>
<td>Number of packets that suffered collision only once
</td>
<td><i>SINGLE_COLLISION_OFFSET</i>
</td>
<td><i>0x1F24</i>
</td></tr>
<tr>
<td><b>multiColl</b>
</td>
<td>Number of packets that suffered collisions more than once
</td>
<td><i>MULTIPLE_COLLISION_OFFSET</i>
</td>
<td><i>0x1F28</i>
</td></tr>
<tr>
<td><b>excessColl</b>
</td>
<td>Number of packets that suffered collisions more than 15 times
</td>
<td><i>EXCESS_COLLISION_OFFSET</i>
</td>
<td><i>0x1F2C</i>
</td></tr>
<tr>
<td><b>txOverFlow</b>
</td>
<td>Number of times Tx queue overflowed
<p>(This is not supported right now)
</p>
</td>
<td><i>TX_OVERFLOW_OFFSET</i>
</td>
<td><i>0x1F30</i>
</td></tr>
<tr>
<td><b>rxMisAlignmentFrames</b>
</td>
<td>Number of frames with uneven number of bytes in an octet
<p>(This is not tested)
</p>
</td>
<td><i>RX_MISALIGNMENT_COUNT_OFFSET</i>
</td>
<td><i>0x1F34</i>
</td></tr>
<tr>
<td><b>stormPrevCounter</b>
</td>
<td>Number of packets dropped due to storm prevention
</td>
<td><i>STORM_PREVENTION_COUNTER</i>
</td>
<td><i>0x1F38</i>
</td></tr>
<tr>
<td><b>macRxError</b>
</td>
<td>Number of packets with Rx MAC Error
</td>
<td><i>RX_ERROR_OFFSET</i>
</td>
<td><i>0x1F3C</i>
</td></tr>
<tr>
<td><b>SFDError</b>
</td>
<td>Number of packets with incorrect SFD
</td>
<td><i>SFD_ERROR_OFFSET</i>
</td>
<td><i>0x1F40</i>
</td></tr>
<tr>
<td><b>defTx</b>
</td>
<td>Number of packets deferred at least once due to CS high signal
</td>
<td><i>TX_DEFERRED_OFFSET</i>
</td>
<td><i>0x1F44</i>
</td></tr>
<tr>
<td><b>macTxError</b>
</td>
<td>Number of packets facing Tx MAC Error
</td>
<td><i>TX_ERROR_OFFSET</i>
</td>
<td><i>0x1F48</i>
</td></tr>
<tr>
<td><b>rxOverSizedFrames</b>
</td>
<td>Number of packets &gt;1518 bytes
</td>
<td><i>RX_OVERSIZED_FRAME_OFFSET</i>
</td>
<td><i>0x1F4C</i>
</td></tr>
<tr>
<td><b>rxUnderSizedFrames</b>
</td>
<td>Number of packets &lt; 60 bytes
</td>
<td><i>RX_UNDERSIZED_FRAME_OFFSET</i>
</td>
<td><i>0x1F50</i>
</td></tr>
<tr>
<td><b>rxCRCFrames</b>
</td>
<td>Frames with CRC/FCS Error
</td>
<td><i>RX_CRC_COUNT_OFFSET</i>
</td>
<td><i>0x1F54</i>
</td></tr>
<tr>
<td><b>droppedPackets</b>
</td>
<td>Number of Received packets that were not transmitted because of link loss
</td>
<td><i>RX_DROPPED_FRAMES_OFFSET</i>
</td>
<td><i>0x1F5C</i>
</td></tr>
<tr>
<td><b>tx64byte</b>
</td>
<td>Transmitted frames with size &lt;= 64 bytes
</td>
<td><i>TX_64_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F60</i>
</td></tr>
<tr>
<td><b>tx65_127byte</b>
</td>
<td>Transmitted frames with size &gt;= 65 bytes and &lt;= 127 bytes
</td>
<td><i>TX_65_127_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F64</i>
</td></tr>
<tr>
<td><b>tx128_255byte</b>
</td>
<td>Transmitted frames with size &gt;= 128 bytes and &lt;= 255 bytes
</td>
<td><i>TX_128_255_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F6C</i>
</td></tr>
<tr>
<td><b>tx256_511byte</b>
</td>
<td>Transmitted frames with size &gt;= 256 bytes and &lt;= 511 bytes
</td>
<td><i>TX_256_511_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F70</i>
</td></tr>
<tr>
<td><b>tx512_1023byte</b>
</td>
<td>Transmitted frames with size &gt;= 512 bytes and &lt;= 1023 bytes
</td>
<td><i>TX_512_1023_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F74</i>
</td></tr>
<tr>
<td><b>rx64byte</b>
</td>
<td>Received frames with size &lt;= 64 bytes
</td>
<td><i>RX_64_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F78</i>
</td></tr>
<tr>
<td><b>rx65_127byte</b>
</td>
<td>Received frames with size &gt;= 65 bytes and &lt;= 127 bytes
</td>
<td><i>RX_65_127_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F7C</i>
</td></tr>
<tr>
<td><b>rx128_255byte</b>
</td>
<td>Received frames with size &gt;= 128 bytes and &lt;= 255 bytes
</td>
<td><i>RX_128_255_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F80</i>
</td></tr>
<tr>
<td><b>rx256_511byte</b>
</td>
<td>Received frames with size &gt;= 256 bytes and &lt;= 511 bytes
</td>
<td><i>RX_256_511_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F84</i>
</td></tr>
<tr>
<td><b>rx512_1023byte</b>
</td>
<td>Received frames with size &gt;= 512 bytes and &lt;= 1023 bytes
</td>
<td><i>RX_512_1023_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F88</i>
</td></tr></tbody></table>
<h4><span id="API_Guide_&amp;_Data_Structures_3"></span><span class="mw-headline" id="API_Guide_.26_Data_Structures_3">API Guide &amp; Data Structures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=39" title="Edit section: API Guide &amp; Data Structures">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>As discussed above there are two data structures for Statistics.
</p>
<ol><li>PRU based</li>
<li>On Host</li></ol>
<p>Shown below are the members of Host Statistics. The members of PRU statistics are listed in the memory map.
</p>
<pre>typedef struct {
 
 volatile uint32_t txUcast;			/**Number of unicast packets sent*/
 volatile uint32_t txBcast;			/**Number of broadcast packets sent*/
 volatile uint32_t txMcast;			/**Number of multicast packets sent*/
 volatile uint32_t txOctets;			/**Number of bytes sent*/
 volatile uint32_t rxUcast;			/**Number of unicast packets rcvd*/
 volatile uint32_t rxBcast;			/**Number of broadcast packets rcvd*/
 volatile uint32_t rxMcast;			/**Number of multicast packets rcvd*/
 volatile uint32_t rxOctets;			/**Number of Rx packets*/
 volatile uint32_t rxUnknownProtocol;	        /**Number of packets with unknown protocol*/
 volatile uint32_t linkBreak;			/**Number of link breaks*/
 
}hostStatistics_t;
</pre>
<p>As one can see most of the members are identical to that of PRU statistics (they are a subset) and if all packets are sent to the Host then these member values for PRU and Host statistics should match.
</p><p>API descriptions are only for information, developers are requested to use corresponding <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#IOCTL">IOCTL</a> calls. The IOCTL command for Statistics module is <i><b>ICSS_EMAC_IOCTL_STATS_CTRL</b></i>
</p><p><i><b>Reading PRU Statistics </b></i>&#160;: To fetch PRU statistics an M2M copy is done from the PRU Data RAM to the PRU statistics structure on DDR. To get the values correctly the memory layout on both sides should be identical. <span style="color: red">Developers should not modify the member order in <b>pruStatistics_t. Doing so can give incorrect results</b></span>
</p><p>Host statistics are updated on the fly in the structure as packets are received (<b>ICSS_EmacUpdateRxStats</b> ) or transmitted (<b>ICSS_EmacUpdateTxStats</b> ) so there is no separate API to collate them.
</p><p>The corresponding API for this is
</p>
<pre>void ICSS_EmacReadStats(uint8_t portNum, ICSSEMAC_Handle icssEmacHandle)
</pre>
<p>IOCTL Param value is <i>ICSS_EMAC_IOCTL_STAT_CTRL_GET</i>
</p><p><i><b>Clearing PRU and Host Statistics </b></i>&#160;: To clear the values do memory write to the structure memory, PRU data RAM and initialize to 0. 
</p><p>The corresponding API for this is
</p>
<pre>void PurgeStats(uint8_t portNum, ICSSEMAC_Handle icssEmacHandle)
</pre>
<p>IOCTL Param value is <i>ICSS_EMAC_IOCTL_STAT_CTRL_CLEAR</i>
</p>
<h4><span class="mw-headline" id="Usage_4">Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=40" title="Edit section: Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Statistics are a great tool to debug issues on the switch. To get them in the application use the IOCTL calls to get and clear statistics
</p><p>While IOCTL calls provide access to statistics in the application. If someone is using CCS then another quick way to see if there is any activity on the Ports is to directly go to the PRU data RAM offset <i>STATISTICS_OFFSET</i> and see the values directly in memory Refer Debug guide on how to see data RAM values directly in CCS.
</p>
<h2><span class="mw-headline" id="Memory_Map">Memory Map</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=41" title="Edit section: Memory Map">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The memory map here refers to the Shared Data RAM memory map in ICSS. L3 map is not of much use to the developer while DDR map is dynamic and is part of the application. The goal of providing this is to help the developer in debugging. Based on the memory map one can directly look at the memory in a CCS + Emulator environment and verify if driver/firmware is working correctly.
</p><p>The memory map can be found in <i>icss_emacSwitch.h</i> under <i>os_drivers/lld/emac</i> and is common to firmware and driver builds
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">
  
<caption><i><b>ICSS Shared Memory Map</b></i>
</caption>
<tbody><tr>
<th>Shared Memory Offset
</th>
<th>Value
</th>
<th>PRU0 Data RAM
</th>
<th>Value
</th>
<th>PRU1 Data RAM
</th>
<th>Value
</th></tr>
<tr>
<td>0x0000 - 0x1C10
</td>
<td>Buffer Descriptor Offsets
<p>For Host Queues
</p>
</td>
<td>0x0000 - 0x0400
</td>
<td>Reserved for Future Use
</td>
<td>0x0000 - 0x0400
</td>
<td>Reserved for Future Use
</td></tr>
<tr>
<td>0x1C10-0x2010
</td>
<td>Multicast Filtering Table
<p>(Disabled for EMAC)
</p>
</td>
<td>0x0400-0x1EC0
</td>
<td>Available for Protocol/Application
</td>
<td>0x0400-0x1EC0
</td>
<td>Available for Protocol/Application
</td></tr>
<tr>
<td>0x2010-0x2400
</td>
<td>Reserved for Future Use
</td>
<td>0x1EC0-0x1F00
</td>
<td>Port Queue Offsets
</td>
<td>0x1EC0-0x1F00
</td>
<td>Port Queue Offsets
</td></tr>
<tr>
<td>0x2400-0x3000
</td>
<td>Available for Protocol/Application
</td>
<td>0x1F00-0x1F8C
</td>
<td>Port0 Statistics
<p>(Map provided <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#Design_3">above</a>)
</p>
</td>
<td>0x1F00-0x1F8C
</td>
<td>Port1 Statistics
<p>(Map provided <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#Design_3">above</a>)
</p>
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>0x1F8C
</td>
<td>Port0 Storm Prevention
<p>Control Variable
</p>
</td>
<td>0x1F8C
</td>
<td>Port1 Storm Prevention
<p>Control Variable
</p>
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>0x1F90
</td>
<td>Port0 Link Speed
<p>0x64 - 100Mbps
</p><p>0xA - 10Mbps
</p>
</td>
<td>0x1F90
</td>
<td>Port1 Link Speed
<p>Same as Port0
</p><p>Any other value is illegal
</p>
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>0x1F94
</td>
<td>Port0 Link Status
<p>0x1 - Link Up
</p><p>0x0 - Link Down
</p>
</td>
<td>0x1F94
</td>
<td>Port1 Link Status
<p>Same as Port0
</p>
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>0x1F9A
</td>
<td>Port0 Control
<p>0x1 - Rx Disabled
</p><p>0x0 - Rx Enabled
</p>
</td>
<td>0x1F9A
</td>
<td>Port1 Control
<p>Same as Port0
</p>
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>0x1FA0
</td>
<td>Port0 MAC ID
<p>6 bytes
</p>
</td>
<td>0x1FA0
</td>
<td>Port1 MAC ID
<p>6 bytes
</p>
</td></tr></tbody></table>
<h2><span id="OS_and_TCP/IP"></span><span class="mw-headline" id="OS_and_TCP.2FIP">OS and TCP/IP</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=42" title="Edit section: OS and TCP/IP">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="RTOS">RTOS</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=43" title="Edit section: RTOS">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The SDK uses <a rel="nofollow" class="external text" href="Category_SYSBIOS.html">SYS/BIOS</a> as it's RTOS. Configuration for the RTOS is done through RTSC tool chain integrated with CCS. SYS/BIOS is provided free of cost and is a very capable RTOS for typical use cases with minimal latency. 
</p><p>The driver is written in a manner such that there is very little dependency on the Operating System. All dependence on SYS/BIOS is abstracted to OSAL (Operating System Abstraction Layer) and developers are integrate their own operating systems.
</p><p>OSAL consists of
</p>
<ol><li>Interrupt management</li>
<li>Task and Semaphore management, Mailbox</li>
<li>Management of peripherals like DMTimer, BIOS Timers</li></ol>
<p>The <i>osdrv</i> layer deals with RTOS and other OS related tasks in general, within this layer the relevant files which deal with OSAL layer are <i><b>osdrv_osal.c</b></i> and <i><b>osdrv_osal.h</b></i>. Developers are requested to port the API's within these two files to their own Operating System. This is described in detail in the section <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#Porting_ICSS_EMAC_LLD">Porting Guide</a>
</p>
<h3><span id="TCP/IP"></span><span class="mw-headline" id="TCP.2FIP">TCP/IP</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=44" title="Edit section: TCP/IP">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The Industrial SDK uses <a rel="nofollow" class="external text" href="http://www.ti.com/tool/NDKTCPIP">NDK</a> as it's TCP/IP stack. API reference guide <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/spru524i/spru524i.pdf">here</a>. Like SYS/BIOS the module is imported externally through RTSC (refer Debug Guide) and managed through the application configuration file (<i><b>am335x_app.cfg</b></i> and <i><b>am437x_app.cfg</b></i>) 
</p><p>NDK recommends it's own abstraction layer which is called NIMU (Network Interface Management Unit). This layer is implemented in the driver. Relevant source files are
</p>
<ul><li><i>icss_ethdriver.c</i></li>
<li><i>icss_nimu_eth.c</i></li>
<li><i>icss_switch_emac.c</i></li></ul>
<p>Understanding the NIMU layer helps in porting another TCP/IP stack to the example. The NIMU layer is explained in this <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/sprufp2a/sprufp2a.pdf">guide</a>
</p><p><a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#Porting_ICSS_EMAC_LLD">Porting guide</a> covers all aspects of using a custom TCP/IP stack to the EMAC LLD example.
</p>
<h2><span id="PRUSS_&amp;_EMAC_Handle"></span><span class="mw-headline" id="PRUSS_.26_EMAC_Handle">PRUSS &amp; EMAC Handle</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=45" title="Edit section: PRUSS &amp; EMAC Handle">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The ICSS EMAC Handle is a main driver handle which provides access to all members, variables, registers and addresses in the SoC. 
</p><p>It is the application's task to allocate memory for the handle and pass it to the driver initialization API. The handle is also required as a parameter for most of the external API's and all IOCTL calls in the driver so it's important to understand it's members.
</p><p>The members of the EMAC Handle are discussed in detail <a rel="nofollow" class="external text" href="http://processors.wiki.ti.com/index.php?title=SYSBIOS_Industrial_SDK_Migration_guide_from_1.1_to_2.1#ICSS_EMAC_LLD">here</a>
</p><p>The sample code for Handle allocation and initialization (from the example application) is shown below
</p>
<pre>/*Declare the EMAC Handle*/
ICSSEMAC_Handle emachandle; 
/*Declare the PRUSS Handle*/
PRUICSS_Handle handle; 
/*Allocate memory for EMAC and PRUSS Handle*/
handle = (PRUICSS_Handle)malloc(sizeof(PRUICSS_Config));
handle-&gt;object = (PRUICSS_V1_Object*)malloc(sizeof(PRUICSS_V1_Object));
handle-&gt;hwAttrs = (PRUICSS_HwAttrs*)malloc(sizeof(PRUICSS_HwAttrs));
emachandle = (ICSSEMAC_Handle)malloc(sizeof(ICSSEMAC_Config));
/*Initialize the EMAC*/
ICSSEmacDRVInit(emachandle, 0);
/*Initialize PRUSS*/
PRUSSDRVInit(handle); /* ICSS_M instance 0 */
/*Assign PRU handle to EMAC handle making it the parent structure*/
((ICSSEMAC_Object*)emachandle-&gt;object)-&gt;pruIcssHandle = handle;
((ICSSEMAC_Object*)emachandle-&gt;object)-&gt;emacInitcfg = switchEmacCfg;
</pre>
<h2><span class="mw-headline" id="IOCTL">IOCTL</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=46" title="Edit section: IOCTL">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>IOCTL implementation for the switch drivers is identical to the Unix/Linux based IOCTL calls. They provide the application a convenient method to access driver/kernel space parameters or modify them. 
</p><p>Developers are expected to familiarize themselves with the full list of IOCTL calls so that they can utilize all the features provided. This is even more important when working in an Application/OS kind of environment where access to an emulator is not available.
</p>
<h3><span class="mw-headline" id="Design_4">Design</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=47" title="Edit section: Design">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The primary IOCTL call is through the API <b>ICSS_EmacIoctl</b> which is implemented in the file icss_emacFwInit.c
An IOCTL call uses two parameters to find out which driver API to call
</p>
<ol><li><b>ioctlCommand</b>&#160;: Is used to locate the module (Statistics/ Port control etc) which should be called.</li>
<li><b>ioctlParams</b>&#160;: Is used to give module specific instructions</li></ol>
<p><i><b>ioctlParams</b></i> consists of
</p>
<ul><li><b>command</b>&#160;: Indicates which specific API to execute</li>
<li><b>ioctlVal</b>&#160;: Sometimes the API may require specific input, this is used to provide that.</li></ul>
<p>For <u>example</u> to disable receive functionality on a port the following code is used. This code is part of Link interrupt functionality where receive is disabled when PHY detects a link down.
</p>
<pre>ioctlvalue = ICSS_EMAC_IOCTL_PORT_CTRL_DISABLE;
ioctlParams.ioctlVal = &amp;ioctlvalue;
ICSS_EmacIoctl(icssEmacHandle, ICSS_EMAC_IOCTL_PORT_CTRL, ICSS_EMAC_PORT_1, (void*)&amp;ioctlParams); 
</pre>
<p>Here <i>ICSS_EMAC_IOCTL_PORT_CTRL</i> refers to the <i><b>ioctlCommand</b></i> while <i>ICSS_EMAC_IOCTL_PORT_CTRL_DISABLE</i> is the <i><b>command</b></i> part of  <b>ioctlParams</b> which tells which action to perform, in this case disabling the port. Port selected is <i>ICSS_EMAC_PORT_1</i> which refers to Port 1.
</p><p>A complete list of commands and actions is given below.
</p>
<h3><span id="API_Guide_&amp;_Data_Structures_4"></span><span class="mw-headline" id="API_Guide_.26_Data_Structures_4">API Guide &amp; Data Structures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=48" title="Edit section: API Guide &amp; Data Structures">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>IOCTL Command structure
</p>
<pre> typedef struct ICSSEMAC_IoctlCmd {
   uint8_t command;
   uint8_t* ioctlVal;
 }ICSSEMAC_IoctlCmd;
</pre>
<p>There is only one API for IOCTL. It's defined below
</p>
<pre>uint8_t ICSS_EmacIoctl(ICSSEMAC_Handle icssEmacHandle, uint32_t ioctlCommand, uint8_t portNo, void *ioctlParams)
</pre>
<p>The possible values for <i><b>ioctlCommand</b></i> are 
</p>
<ul><li><i>ICSS_EMAC_IOCTL_PORT_CTRL</i>&#160;: Select Port Control Operations. Enable/Disable Rx for the specified port.</li>
<li><i>ICSS_EMAC_IOCTL_LEARNING_CTRL</i>&#160;: Select Learning/FDB module.</li>
<li><i>ICSS_EMAC_IOCTL_STORM_PREV_CTRL</i>&#160;: Select Storm Prevention module.</li>
<li><i>ICSS_EMAC_IOCTL_STATS_CTRL</i>&#160;: Select Statistics module.</li>
<li><i>ICSS_EMAC_IOCTL_TTS_CTRL</i>&#160;: Select Time Triggered Send Configuration module. Enable/Disable TTS for the specified port.</li>
<li><i>ICSS_EMAC_IOCTL_TTS_STATUS_CTRL</i>&#160;: Select Time Triggered Send Query module. Get TTS status and other details for the specified port from PRU firmware.</li></ul>
<p>Possible values for <i><b>ioctlParams</b></i> are
</p>
<ul><li><b>ICSS_EMAC_IOCTL_LEARNING_CTRL</b>&#160;: Refer to Learning/FDB API's
<ul><li><i>ICSS_EMAC_LEARN_CTRL_UPDATE_TABLE</i>&#160;: Add an entry to the Hash table.</li>
<li><i>ICSS_EMAC_LEARN_CTRL_CLR_TABLE</i>&#160;: Clear the Learning Table for the specified port.</li>
<li><i>ICSS_EMAC_LEARN_CTRL_AGEING</i>&#160;: Age out old entries from the table.</li>
<li><i>ICSS_EMAC_LEARN_CTRL_FIND_MAC</i>&#160;: Find the port number given a MAC ID.</li>
<li><i>ICSS_EMAC_LEARN_CTRL_REMOVE_MAC</i>&#160;: Remove a MAC ID from the Learning Table</li>
<li><i>ICSS_EMAC_LEARN_CTRL_INC_COUNTER</i>&#160;: Age the entries with time by calling this periodically</li>
<li><i>ICSS_EMAC_LEARN_CTRL_INIT_TABLE</i>&#160;: Initialize the learning table</li>
<li><i>ICSS_EMAC_LEARN_CTRL_SET_PORTSTATE</i>&#160;: Set the Port state to value defined by the enum type <b>portState</b></li></ul></li></ul>
<ul><li><b>ICSS_EMAC_IOCTL_STATS_CTRL</b>&#160;: Refer to Statistics API's
<ul><li><i>ICSS_EMAC_IOCTL_STAT_CTRL_GET</i>&#160;: Get the statistics</li>
<li><i>ICSS_EMAC_IOCTL_STAT_CTRL_CLEAR</i>&#160;: Clear all stat counters</li></ul></li></ul>
<ul><li><b>ICSS_EMAC_IOCTL_STORM_PREV_CTRL</b>&#160;: Refer to Storm prevention API's
<ul><li><i>ICSS_EMAC_STORM_PREV_CTRL_ENABLE</i>&#160;: Enable Storm Prevention</li>
<li><i>ICSS_EMAC_STORM_PREV_CTRL_DISABLE</i>&#160;: Disable Storm Prevention</li>
<li><i>ICSS_EMAC_STORM_PREV_CTRL_SET_CREDITS</i>&#160;: Set how many BC/MC packets are allowed in a period of 100 NDK Ticks (Time period of <b>_HwPktPoll()</b>)</li>
<li><i>ICSS_EMAC_STORM_PREV_CTRL_INIT</i>&#160;: Initialize Storm Prevention</li>
<li><i>ICSS_EMAC_STORM_PREV_CTRL_RESET</i>&#160;: Renew the storm prevention counters, this allows more packets to come through once existing credits have expired. This must be called periodically in <b>_HwPktPoll()</b></li></ul></li></ul>
<ul><li><b>ICSS_EMAC_IOCTL_PORT_CTRL</b>&#160;: For Rx Enable/Disable operations. There are no sub-commands here. Whether to enable or disable is decided by the value of <i><b>ioctlVal</b></i></li></ul>
<h3><span class="mw-headline" id="Usage_5">Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=49" title="Edit section: Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Using IOCTL to debug the issues is encouraged. This is easier than trying to connect an emulator and reading the values at run time. There are numerous instances of it's usage. A quick search for the API <b>ICSS_EmacIoctl</b> throughout the code reveals numerous examples. One of them pertaining to Storm Control module is shown below.
</p><p>In this example the storm prevention counters are reset in PRU Data RAM using IOCTL. The <b>if/else</b> refers to Switch or EMAC mode, rest of the code is self-explanatory
</p>
<pre> ioctlParams.command = ICSS_EMAC_STORM_PREV_CTRL_RESET;
 /*Reset the credit values used for Storm prevention*/
 if(ICSS_EMAC_MODE_SWITCH == ((ICSSEMAC_Object*)(pi-&gt;nimuDrvHandle)-&gt;object)-&gt;emacInitcfg-&gt;portMask)
 {
   strmPreventionEnable1 = (stormPrevention_t*)(((ICSSEMAC_Object*)(pi-&gt;nimuDrvHandle)-&gt;object)-&gt;stormPrevPtr);
   strmPreventionEnable2 = (stormPrevention_t*)(((ICSSEMAC_Object*)(pi-&gt;nimuDrvHandle)-&gt;object)-&gt;stormPrevPtr +1);
   if(strmPreventionEnable1-&gt;suppressionEnabled ||	strmPreventionEnable2-&gt;suppressionEnabled)
   	ICSS_EmacIoctl(pi-&gt;nimuDrvHandle, ICSS_EMAC_IOCTL_STORM_PREV_CTRL, NULL, (void*)&amp;ioctlParams);
 }
 else
 {
   strmPreventionEnable1 = (stormPrevention_t*)(((ICSSEMAC_Object*)(pi-&gt;nimuDrvHandle)-&gt;object)-&gt;stormPrevPtr);
   if(strmPreventionEnable1-&gt;suppressionEnabled)
   	ICSS_EmacIoctl(pi-&gt;nimuDrvHandle, ICSS_EMAC_IOCTL_STORM_PREV_CTRL, NULL, (void*)&amp;ioctlParams);
 }
</pre>
<h2><span class="mw-headline" id="Time_Triggered_Send">Time Triggered Send</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=50" title="Edit section: Time Triggered Send">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The EMAC Time Triggered Send (TTS) is used to expand classical Ethernet to meet deterministic, time-critical or safety-relevant conditions. TTS reduces the transmission jitter from 10us range to 40ns. TTS can be dynamically enabled and disabled by the Host. We have two well defined TTS APIs which control all TTS related EMAC aspects. Developers are advised to access these APIs using the EMAC IOCTL implementation as explained in the <a href="ICSS_EMAC_LLD_developers_guide.html#IOCTL" title="ICSS EMAC LLD developers guide">IOCTL</a> section previously.
</p>
<h3><span class="mw-headline" id="TTS_Design_Overview">TTS Design Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=51" title="Edit section: TTS Design Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>TTS is designed to facilitate transmission of packets at pre-defined cyclic instants/triggers. The <a href="ICSS_EMAC_LLD_developers_guide.html#TTS_API_Details_and_Data_Structures" title="ICSS EMAC LLD developers guide">TTS API Details and Data Structures</a> are explained below but in a broad sense we can say that while initializing TTS, the application must provide the first cyclic trigger and the cycle period. The PRU firmware then sets cyclic triggers repeatedly and shall send the packets cyclically provided that they are queued before the trigger. The following timing diagram explains the use of TTS.
</p>
<div class="center"><div class="floatnone"><a href="File_TTS_Overview.html" class="image" title="Time Triggered Send Overview"><img alt="Time Triggered Send Overview" src="https://processors.wiki.ti.com/images/f/f5/TTS_Overview.png" width="501" height="173" /></a></div></div>
<p>Each cycle shall have a configuration time (as shown in the figure above) before each trigger. This configuration time is used to setup the start trigger and end trigger of current cycle in the PRU firmware. If the application does not set a suitable (long enough) configuration time, the PRU and perhaps even the EMAC Driver TTS API may not get enough time to setup and initialize TTS. This might result in improper functionality. The configuration time shall also be provided during initialization and shall be application specific. For example, if a response packet is to be received for the cyclic packet sent at trigger T1 and based on that response packet the next cyclic packet shall be generated, then the developer can increase/decrease configuration time accordingly to ensure that the next cyclic packet is ready before trigger T2 which shall in-turn be based on when the response packet is received.
</p><p>Queue 0 (high priority queue) is reserved as the real-time queue. All packets in queue 0 are cyclic packets. On the other hand, packets from other queues are acyclic packets. Cyclic packets are sent at triggered instances, whereas acyclic packets are sent based on time availability, as shown in the figure below.
</p>
<div class="center"><div class="floatnone"><a href="File_TTS_Time_Availability_Check.html" class="image" title="TTS Time Availability Check"><img alt="TTS Time Availability Check" src="https://processors.wiki.ti.com/images/4/41/TTS_Time_Availability_Check.png" width="501" height="501" /></a></div></div>
<p>The time availability check for cyclic packets means to basically check whether the acyclic packet can be transmitted such that its transmission does not overlap the next cyclic trigger, considering the size of the acyclic packet. Such a situation is represented as “Undesired Behaviour” in the above figure and PRU firmware ensures that this never happens. Only one cyclic packet will be sent out in each cycle irrespective of the number of cyclic packets available in Queue 0. There is no restriction on the number of acyclic packets sent out in each cycle but it is contingent on time availability. Cyclic packets must be queued in Queue 0 before the trigger instant else two erroneous situations are possible:
</p>
<ol><li>If the firmware finds a packet in any other low priority queue, it will send the acyclic packet. Once an acyclic packet has been transmitted in a given cycle, no cyclic packet will be transmitted in that cycle. So, if the cyclic packet is not queued on time, it will miss the cycle and will be transmitted in the next cycle.</li>
<li>If all the queues are empty and a cyclic packet is inserted late, it will result in increased jitter.</li></ol>
<p>The above two situations are demonstrated in the figure below.
</p>
<div class="center"><div class="floatnone"><a href="File_TTS_Erroneous_Conditions.html" class="image" title="TTS Error Conditions"><img alt="TTS Error Conditions" src="https://processors.wiki.ti.com/images/9/9d/TTS_Erroneous_Conditions.png" width="443" height="407" /></a></div></div>
<p>In the above figure, the PRU firmware ensures that the first two situations never occur but the application needs to take care of the third situation, i.e., by queueing the cyclic packet on time.
</p><p>The PRU firmware makes the following assumptions regarding TTS:
</p>
<ol><li>The cycle period is long enough to be able to transmit any cyclic packet in queue 0. Failure to ensure this will cause the cyclic packet with size greater than the allowed size (as per the period), and any cyclic packets following it, to remain in the queue.</li>
<li>The configuration time provided (using ICSS EMAC IOCTL) is sufficient for the PRU to configure the next cycle. PRU should typically need a maximum of 10us to configure the next cycle.</li>
<li>If the host keeps queuing packets irrespective of the fact whether the packet has been transmitted by the firmware (in accordance with the preset triggered intervals), the packets might get dropped at the driver level if the queue is full. It is assumed that this is taken care of at the host level.</li></ol>
<h3><span class="mw-headline" id="TTS_API_Details_and_Data_Structures">TTS API Details and Data Structures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=52" title="Edit section: TTS API Details and Data Structures">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>TTS has the following APIs, which are accessed using EMAC IOCTL implementation as explained in the IOCTL section previously.
</p>
<pre>int8_t ICSS_EmacTTS(const ICSS_EmacTTSConfig* ttsConfig)
</pre>
<p>This API is used to enable/disable time triggered send for Queue 0 frames.
</p>
<pre>int8_t ICSS_EmacTTSGetStatus(ICSS_EmacTTSQuery* ttsQuery)
</pre>
<p>This API is used to query time triggered send details, status and TTS parameter values from PRU firmware.
</p><p>The TTS parameter structure is explained below:
</p>
<pre>typedef struct ICSS_EmacTTSConfig_s {
  ICSSEMAC_Handle icssEmacHandle;
  uint8_t portNumber;
  uint64_t cycleStartTime;
  uint32_t cyclePeriod;
  uint32_t configTime;
  uint8_t statusTTS;
  uint8_t cycTxSOFStatus;
} ICSS_EmacTTSConfig;
</pre>
<ul><li><i>icssEmacHandle</i>: EMAC handle for concerned EMAC instance and port.</li>
<li><i>portNumber</i>: Port number for which TTS needs to be enabled/disabled.</li>
<li><i>cycleStartTime</i>: A future IEP counter value at which the first cyclic packet will be transmitted.</li>
<li><i>cyclePeriod</i>: TTS cycle period.</li>
<li><i>configTime</i>: Configuration time for PRU to setup upcoming TTS cycle.</li>
<li><i>statusTTS</i>: Enable/Disable TTS. Enable = 1, Disable = 0.</li>
<li><i>cycTxSOFStatus</i>: Enable/Disable storing transmit start-of-frame timestamp for cyclic packets in memory. Enable = 1, Disable = 0.</li></ul>
<p>The TTS query structure is as explained below:
</p>
<pre>typedef struct ICSS_EmacTTSQuery_s {
  ICSSEMAC_Handle icssEmacHandle;
  uint8_t portNumber;
  uint8_t statusTTS;
  uint8_t missedCycle;
  uint8_t insertCycFrameNotification;
  uint8_t cycTxSOFStatus;
  uint32_t missedCycleCounter;
  uint64_t cycTxSOF;
} ICSS_EmacTTSQuery;
</pre>
<ul><li><i>icssEmacHandle</i>: EMAC handle for concerned EMAC instance and port.</li>
<li><i>portNumber</i>: Port number for which TTS query needs to be performed.</li>
<li><i>statusTTS</i>: Whether TTS is enabled/disabled for given port. Enabled = 1, Disabled = 0.</li>
<li><i>missedCycle</i>: Whether any cyclic packet missed a cycle. Missed = 1, Did not miss = 0.</li>
<li><i>insertCycFrameNotification</i>: Notification to state that it’s time to insert cyclic packet. If it’s time = 1, else = 0.</li>
<li><i>cycTxSOFStatus</i>: Whether storing transmit start-of-frame timestamp for cyclic packets in memory is enabled/disabled. Enabled = 1, Disabled = 0.</li>
<li><i>missedCycleCounter</i>: Number of cycles missed by cyclic packets.</li></ul>
<p>The application shall update the elements of the ICSS_EmacTTSConfig structure and pass its pointer to EMAC IOCTL with appropriate command to enable/disable TTS. On the other hand, the application shall only update the icssEmacHandle and portNumber elements of the ICSS_EmacTTSQuery structure and pass its pointer to EMAC IOCTL with appropriate command to retrieve the details from PRU firmware. The driver TTS API (ICSS_EmacTTSGetStatus) shall then update the elements of the structure with appropriate values.
</p><p>TTS can be enabled/disabled using EMAC IOCTL as follows:
</p><p>For Enable:
</p>
<pre>ICSSEMAC_IoctlCmd ioctlParams;
ICSS_EmacTTSConfig ttsConfig;
uint32_t iepRegsBase;
int8_t ret;

ioctlParams.command = 0;
ioctlParams.ioctlVal = (void *)(&amp;ttsConfig);

ttsConfig.icssEmacHandle = icssEmacHandle;
ttsConfig.cycTxSOFStatus = ICSS_EMAC_TTS_CYC_TXSOF_ENABLE;
ttsConfig.portNumber = portNumber;
ttsConfig.configTime = ICSS_EMAC_TTS_CONFIG_TIME;
ttsConfig.cyclePeriod = cyclePeriod;
ttsConfig.statusTTS = ICSS_EMAC_TTS_ENABLE;

iepRegsBase = (((ICSS_EmacHwAttrs*)icssEmacHandle-&gt;hwAttrs)-&gt;emacBaseAddrCfg)-&gt;prussIepRegs;

/*	Reading IEP Counter Value.	*/
iepCounterVal = (*((uint64_t*)(iepRegsBase + CSL_ICSSIEP_COUNT_REG0)));

/*	Calculating cycle start value by adding 100us to counter value.	*/
ttsConfig.cycleStartTime = (uint64_t)(iepCounterVal + 100000);

/*	Enabling time triggered send.	*/
ret = ICSS_EmacIoctl(icssEmacHandle, ICSS_EMAC_IOCTL_TTS_CTRL, portNumber, &amp;ioctlParams);
assert(ret == 0);
</pre>
<p>For Disable:
</p>
<pre>ICSSEMAC_IoctlCmd ioctlParams2;
ICSS_EmacTTSConfig ttsConfig;
int8_t ret;

/*	Setting tts status to disable (Port 1)	*/
ttsConfig.icssEmacHandle = icssEmacHandle;
ttsConfig.statusTTS = ICSS_EMAC_TTS_DISABLE;
ttsConfig.cyclePeriod = 0;
ttsConfig.configTime = 0;
ttsConfig.cycleStartTime = 0;
ttsConfig.cycTxSOFStatus = ICSS_EMAC_TTS_CYC_TXSOF_DISABLE;
ttsConfig.portNumber = portNumber;

ioctlParams2.command = 0;
ioctlParams2.ioctlVal = (void *)(&amp;ttsConfig);

/*	Disabling time triggered send on PORT 1 (PRU0).	*/
ret = ICSS_EmacIoctl(icssEmacHandle, ICSS_EMAC_IOCTL_TTS_CTRL, portNumber, &amp;ioctlParams2);
assert(ret == 0);
</pre>
<h3><span class="mw-headline" id="TTS_Cyclic_Frame_Notification">TTS Cyclic Frame Notification</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=53" title="Edit section: TTS Cyclic Frame Notification">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The PRU firmware has been designed to notify the Host when it’s time to insert the cyclic packet. This helps the Host to queue the cyclic packet well before trigger time and avoid any unnecessary jitter or any other erroneous situations as  mentioned previously. The firmware does this in two ways:
</p>
<h4><span class="mw-headline" id="Polling_Mode">Polling Mode</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=54" title="Edit section: Polling Mode">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul><li>In this mode the firmware sets a status bit when it’s time to insert the cyclic frame and this bit cleared when the time to insert the cyclic frame is over or the firmware has found a cyclic frame in Queue 0.</li>
<li>This status bit can be queried using the EMAC IOCTL and is reflected in insertCycFrameNotification element of the ICSS_EmacTTSQuery structure.</li>
<li>If it’s time, insertCycFrameNotification = 1, else insertCycFrameNotification = 0.</li>
<li>The application must then continuously poll for this status by repeating EMAC IOCLT calls and querying TTS status.</li>
<li>Once insertCycFrameNotification = 1, the application must queue the cyclic frame in Queue 0.</li></ul>
<h4><span class="mw-headline" id="Interrupt_Mode">Interrupt Mode</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=55" title="Edit section: Interrupt Mode">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul><li>In this mode, in addition to setting the status bit as in polling mode, the firmware has the capability to give an interrupt to the Host when it’s time to insert a cyclic frame.</li>
<li>The interrupt feature should be first enabled as follows during EMAC Driver Initilization.</li></ul>
<pre>ICSS_EmacInitConfig* switchEmacCfg;
switchEmacCfg = (ICSS_EmacInitConfig*)malloc(sizeof(ICSS_EmacInitConfig));
switchEmacCfg-&gt;ICSS_EmacTTSEnableCycPktInterrupt = ICSS_EMAC_TTS_CYC_INTERRUPT_ENABLE;
</pre>
<ul><li>Also, proper interrupt mapping should be done as explained earlier in this guide.</li>
<li>Interrupt callback functions should also be registered for all concerned EMAC handles using the following API:</li></ul>
<pre>ICSS_EmacRegisterHwIntTTSCyc(emachandle, (ICSS_EmacCallBack)ttsCycPort1Callback);
</pre>
<ul><li>Interrupts should also be enabled. Please refer to example ICSS EMAC applications from Processor SDK RTOS for further details.</li>
<li>Once the PRU firmware throws an interrupt, the registered callback function is called and this is where the application shall queue the cyclic packet to Queue 0.</li></ul>
<h2><span class="mw-headline" id="ICSS_EMAC_LLD_Dependencies">ICSS EMAC LLD Dependencies</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=56" title="Edit section: ICSS EMAC LLD Dependencies">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>ICSS EMAC LLD is dependent on the Application/Transport layer for its proper functioning. These dependencies have been consolidated and exported to the application layer (example) to make it easy for developer to integrate the LLD with their own RTOS and TCP/IP stack.
</p>
<h3><span class="mw-headline" id="Interrupt_Configuration">Interrupt Configuration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=57" title="Edit section: Interrupt Configuration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>ICSS EMAC LLD expects the Interrupt configuration to come from Application/Transport layer. The interrupt configuration is explained in detail in the interrupts <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#Interrupts">section</a>. Please refer to it for more details.
</p><p>The LLD makes use of two interrupts for copying packets from the queues to the TCP/IP stack.
</p>
<h4><span class="mw-headline" id="Rx_Interrupt">Rx Interrupt</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=58" title="Edit section: Rx Interrupt">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The ICSS EMAC LLD depends on the Rx interrupt for receiving packets.The application should do the interrupt creation and should use the API <b>ICSS_EmacRxInterruptHandler</b> as the ISR.This will enable the ICSS EMAC LLD to receive packets. The user should make sure the arm interrupt (Rx) is mapped to correct PRUSS Event. The PRUSS Event that is used for Rx will be determined by the firmware which will be used along with the ICSS EMAC LLD
</p>
<h4><span class="mw-headline" id="Link_Interrupt">Link Interrupt</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=59" title="Edit section: Link Interrupt">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Link Interrupt informs the ICSS EMAC LLD of any Link state change. This is where the LLD informs the firmware about the Link status and the Phy configuration.The LLD expects single interrupt for both Ports. In case the Interrupt mechanism is not available, the application should call <b>ICSS_EmacLinkISR</b> whenever there is a link change.
</p>
<h3><span class="mw-headline" id="Learning_module_Increment_counter_implementation">Learning module Increment counter implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=60" title="Edit section: Learning module Increment counter implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This is required for Switch implementation only. The application needs to call the IOCTL periodically, this is already done by the NDK. Refer to the API <a rel="nofollow" class="external text" href="ICSS_EMAC_LLD_developers_guide.html#API_Guide_.26_Data_Structures">section</a> of Learning for more details.
</p>
<h3><span class="mw-headline" id="MDIO_Configurations">MDIO Configurations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=61" title="Edit section: MDIO Configurations">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>ICSS EMAC LLD does not do any of the MDIO configurations. It expects the application to do following MDIO operations 
</p>
<ul><li>MDIO Initialization -</li>
<li>MDIO Link Interrupt enable if MDIO Link interrupt is used</li></ul>
<p>NOTE: Please refer to ti/drv/icss_emac/test/src/test_mdio.c for details of how to initialize the MDIO sub-system and how to enable MDIO link interrupts. 
This file contains a set of MDIO test APIs which are used by the icss emac loopback unit tests.
</p><p><br />
</p>
<h2><span class="mw-headline" id="EMAC_Configuration_and_How_To">EMAC Configuration and How To</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=62" title="Edit section: EMAC Configuration and How To">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Network_related">Network related</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=63" title="Edit section: Network related">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span class="mw-headline" id="How_to_configure_IP_address_and_other_IPv4_parameters">How to configure IP address and other IPv4 parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=64" title="Edit section: How to configure IP address and other IPv4 parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>IP address, network mask and other params can be set through the NDK configuration file. See <a rel="nofollow" class="external text" href="SYSBIOS_Industrial_SDK_02.01.00-2.html#Ethernet_MAC">here</a>
</p>
<h4><span class="mw-headline" id="How_to_configure_MAC_address">How to configure MAC address</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;section=65" title="Edit section: How to configure MAC address">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>MAC address is variable <b>macId</b> in the configuration <b>ICSSEMAC_InitConfig</b>. It can be set as per the application requirements. The following excerpt from <b>ethernet_mac</b> example shows how to do this
</p>
<pre>/*Get MAC address from eFUSE*/
SOCCtrlGetPortMacAddr(1,lclMac);
/*Assign MAC ID for that particular port*/
switchEmacCfg-&gt;macId = lclMac;
</pre>
<!-- 
NewPP limit report
Cached time: 20201130202650
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.196 seconds
Real time usage: 0.204 seconds
Preprocessor visited node count: 338/1000000
Preprocessor generated node count: 495/1000000
Post‐expand include size: 2781/2097152 bytes
Template argument size: 1447/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    4.410      1 -total
 42.38%    1.869      8 Template:SpNote
 29.10%    1.283      2 Template:Prettytable
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:39918-0!canonical and timestamp 20201130202650 and revision id 235576
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>ICSS EMAC LLD developers guide</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>ICSS EMAC LLD developers guide</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>ICSS EMAC LLD developers guide</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>ICSS EMAC LLD developers guide</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>ICSS EMAC LLD developers guide</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>ICSS EMAC LLD developers guide</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>ICSS EMAC LLD developers guide</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>ICSS EMAC LLD developers guide</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>ICSS EMAC LLD developers guide</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;oldid=235576">https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;oldid=235576</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="https://processors.wiki.ti.com/index.php?title=Category:Pages_with_broken_file_links&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages with broken file links (page does not exist)">Pages with broken file links</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=ICSS+EMAC+LLD+developers+guide" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="ICSS_EMAC_LLD_developers_guide.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Talk:ICSS_EMAC_LLD_developers_guide&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="ICSS_EMAC_LLD_developers_guide.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/ICSS_EMAC_LLD_developers_guide.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/ICSS_EMAC_LLD_developers_guide.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;oldid=235576" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=ICSS_EMAC_LLD_developers_guide&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 9 September 2018, at 04:03.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.196","walltime":"0.204","ppvisitednodes":{"value":338,"limit":1000000},"ppgeneratednodes":{"value":495,"limit":1000000},"postexpandincludesize":{"value":2781,"limit":2097152},"templateargumentsize":{"value":1447,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    4.410      1 -total"," 42.38%    1.869      8 Template:SpNote"," 29.10%    1.283      2 Template:Prettytable"]},"cachereport":{"timestamp":"20201130202650","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":231});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/ICSS_EMAC_LLD_developers_guide by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 08:45:47 GMT -->
</html>
