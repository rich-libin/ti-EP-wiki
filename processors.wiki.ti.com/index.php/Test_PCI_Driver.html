<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/Test_PCI_Driver by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 04:36:46 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>Test PCI Driver - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Test_PCI_Driver","wgTitle":"Test PCI Driver","wgCurRevisionId":100059,"wgRevisionId":100059,"wgArticleId":1041,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["DSPLink"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Test_PCI_Driver","wgRelevantArticleId":1041,"wgRequestId":"cc51fdf2a4ad6aa7e7c4f5ef","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Test_PCI_Driver rootpage-Test_PCI_Driver skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">Test PCI Driver</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Overview"><span class="tocnumber">2</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Details"><span class="tocnumber">3</span> <span class="toctext">Details</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Usage"><span class="tocnumber">4</span> <span class="toctext">Usage</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Introduction">Introduction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Test_PCI_Driver&amp;action=edit&amp;section=1" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This document describes the PCI test driver, which can be used to test the PCI hardware before running DSPLink.
</p>
<h2><span class="mw-headline" id="Overview">Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Test_PCI_Driver&amp;action=edit&amp;section=2" title="Edit section: Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This PCI driver tests all hardware related aspect needed by DSPLink for providing support on the desired platform. DSPLink requires
memory to be shared between HOST and device, power management, interrupts between HOST and device and EDMA features of DSP device. This test driver tests each of these components. 
</p>
<h2><span class="mw-headline" id="Details">Details</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Test_PCI_Driver&amp;action=edit&amp;section=3" title="Edit section: Details">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This test driver is written from the DSP and HAL logic of DSPLink source. APIs provided by this test driver are somewhat similar to
APIs provided by DSPLink DSP and HAL code. <br />
It gives out error message incase of failure otherwise it prints successful message.
</p>
<pre>#include &lt;linux/module.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/pci.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/ioport.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;asm/uaccess.h&gt;

/** ============================================================================
 *  @macro  Data types
 *
 *  @desc   Basic data types
 *  ============================================================================
 */
typedef signed char         Int8&#160;;      /*  8 bit value */
typedef signed short int    Int16&#160;;     /* 16 bit value */
typedef signed long  int    Int32&#160;;     /* 32 bit value */

typedef unsigned char       Uint8&#160;;     /*  8 bit value */
typedef unsigned short int  Uint16&#160;;    /* 16 bit value */
typedef unsigned long  int  Uint32&#160;;    /* 32 bit value */

typedef float               Real32&#160;;    /* 32 bit value */
typedef double              Real64&#160;;    /* 64 bit value */

typedef short int           Bool&#160;;      /* 16 bit value */

typedef char                Char8&#160;;     /*  8 bit value */
typedef short               Char16&#160;;    /* 16 bit value */

typedef unsigned char       Uchar8&#160;;    /*  8 bit value */
typedef unsigned short      Uchar16&#160;;   /* 16 bit value */

#define Void                void
typedef void *              Pvoid&#160;;

typedef Char8 *             Pstr&#160;;
typedef Uchar8 *            Pustr&#160;;

/** ============================================================================
 *  @const  PCI_TI_VENDOR
 *
 *  @desc   TI Vendor ID.
 *  ============================================================================
 */
#define PCI_TI_VENDOR   0x104c

/** ============================================================================
 *  @const  PCI_TI_DEVICE
 *
 *  @desc   PCI Device ID.
 *  ============================================================================
 */
#define PCI_TI_DEVICE   0xB001

/** ============================================================================
 *  @const   DM64LCPCI_DEVREG_BASE
 *
 *  @desc    Base address of Device config registers.
 *  ============================================================================
 */
#define DM64LCPCI_DEVREG_BASE      0x01C40000

/** ============================================================================
 *  @const   DM64LCPCI_PLLREG_BASE
 *
 *  @desc    Base address of PLL0 registers.
 *  ============================================================================
 */
#define DM64LCPCI_PLL0REG_BASE      0x01C40800

/** ============================================================================
 *  @const   DM64LCPCI_PLLREG_BASE
 *
 *  @desc    Base address of PLL1 registers.
 *  ============================================================================
 */
#define DM64LCPCI_PLL1REG_BASE      0x01C40C00

/** ============================================================================
 *  @const   DM64LCPCI_EDMAREG_BASE
 *
 *  @desc    Base address of EDMA registers.
 *  ============================================================================
 */
#define DM64LCPCI_EDMAREG_BASE      0x01C00000

/** ============================================================================
 *  @const   DM64LCPCI_DDRREG_BASE
 *
 *  @desc    Base address of DDR PHY registers.
 *  ============================================================================
 */
#define DM64LCPCI_DDRREG_BASE       0x20000000

/** ============================================================================
 *  @const   DM64LCPCI_PSCREG_BASE
 *
 *  @desc    Base address of PSC registers.
 *  ============================================================================
 */
#define DM64LCPCI_PSCREG_BASE       0x01C41000

/** ============================================================================
 *  @const   DM64LCPCI_PCIREG_BASE
 *
 *  @desc    Base address of PCI backend registers.
 *  ============================================================================
 */
#define DM64LCPCI_PCIREG_BASE       0x01C1A000

/** ============================================================================
 *  @const   DM64LCPCI_SOFTINT0_MASK
 *
 *  @desc    Mask for generating soft int0 (DSP-&gt;GPP)
 *  ============================================================================
 */
#define DM64LCPCI_SOFTINT0_MASK       0x01000000

/** ============================================================================
 *  @const   DM64LCPCI_SOFTINT1_MASK
 *
 *  @desc    Mask for generating soft int1 (GPP-&gt;DSP)
 *  ============================================================================
 */
#define DM64LCPCI_SOFTINT1_MASK       0x02000000

/** ============================================================================
 *  @const   DM64LCPCI_LRESET_MASK
 *
 *  @desc    Mask for reseting/releasing GEM.
 *  ============================================================================
 */
#define DM64LCPCI_LRESET_MASK         0x00000100

/** ============================================================================
 *  @const   DM64LCPCI_INTSTATUS_MASK
 *
 *  @desc    Bitmask for Interrupt status (DSP-&gt;GPP)
 *  ============================================================================
 */
#define DM64LCPCI_INTSTATUS_MASK      0x00080000

/** ============================================================================
 *  @const   DM64LCPCI_PCIADLEN
 *
 *  @desc    Length each segment of addressable PCI Space..
 *  ============================================================================
 */
#define DM64LCPCI_PCIADLEN            0x00800000

/** ============================================================================
 *  @const   DM64LCPCI_PCIADWRBITMASK
 *
 *  @desc    Mask indicating writeable bits in PCI Address Window registers.
 *  ============================================================================
 */
#define DM64LCPCI_PCIADWRBITMASK      0xFF800000

/** ============================================================================
 *  @const   DM64LCPCI_PAGEWRBITMASK
 *
 *  @desc    Mask indicating writeable bits in PCI Base Address Mask Register5.
 *  ============================================================================
 */
#define DM64LCPCI_PAGEWRBITMASK       0xFF800000

/** ============================================================================
 *  @name   DM64LCPCI_pllRegs
 *
 *  @desc   Register Overlay Structure for Device config registers.
 *  ============================================================================
 */
typedef struct DM64LCPCI_devRegs_tag {
    volatile Uint32 PINMUX0      &#160;;
    volatile Uint32 PINMUX1      &#160;;
    volatile Uint32 DSPBOOTADDR  &#160;;
    volatile Uint32 BOOTCMPLT    &#160;;
    volatile Uint32 RSVD0        &#160;;
    volatile Uint32 BOOTCFG      &#160;;
    volatile Uint32 VDD1P0V_ADJ  &#160;;
    volatile Uint32 VDD1P2V_ADJ  &#160;;
    volatile Uint32 DDR_SLEW     &#160;;
    volatile Uint32 PERIPHEN     &#160;;
    volatile Uint32 DEVICE_ID    &#160;;
    volatile Uint32 DAC_DEMEN    &#160;;
    volatile Uint32 UHPICTL      &#160;;
    volatile Uint32 RSVD1 [2]    &#160;;
    volatile Uint32 MSTPRI0      &#160;;
    volatile Uint32 MSTPRI1      &#160;;
    volatile Uint32 VPSS_CLK_CTRL&#160;;
    volatile Uint32 VDD3P3V_PWRDN&#160;;
    volatile Uint32 DFT_ENABLE   &#160;;
    volatile Uint32 SEC_SCAN_REG &#160;;
    volatile Uint32 SEC_TEST_REG &#160;;
    volatile Uint32 SEC_TAP_CTL  &#160;;
    volatile Uint32 PUBLIC_KEY0  &#160;;
    volatile Uint32 PUBLIC_KEY1  &#160;;
    volatile Uint32 PUBLIC_KEY2  &#160;;
    volatile Uint32 PUBLIC_KEY3  &#160;;
    volatile Uint32 VLYNQ_DELAY  &#160;;
    volatile Uint32 SEC_PSEUDO0  &#160;;
    volatile Uint32 SEC_PSEUDO1  &#160;;
    volatile Uint32 RSVD2 [3]    &#160;;
    volatile Uint32 TIMERCTL     &#160;;
    volatile Uint32 TPTCCCFG     &#160;;
    volatile Uint32 RSVD3        &#160;;
} DM64LCPCI_devRegs&#160;;

/** ============================================================================
 *  @name   DM64LCPCI_pllRegs
 *
 *  @desc   Register Overlay Structure for PLL.
 *  ============================================================================
 */
typedef struct DM64LCPCI_pllRegs_tag {
    volatile Uint32 PID        &#160;;
    volatile Uint8  RSVD0 [220]&#160;;
    volatile Uint32 FUSERR     &#160;;
    volatile Uint32 RSTYPE     &#160;;
    volatile Uint32 RSTDEF     &#160;;
    volatile Uint8  RSVD1 [20] &#160;;
    volatile Uint32 PLLCTL     &#160;;
    volatile Uint32 OCSEL      &#160;;
    volatile Uint32 SECCTL     &#160;;
    volatile Uint8  RSVD2 [4]  &#160;;
    volatile Uint32 PLLM       &#160;;
    volatile Uint32 PREDIV     &#160;;
    volatile Uint32 PLLDIV1    &#160;;
    volatile Uint32 PLLDIV2    &#160;;
    volatile Uint32 PLLDIV3    &#160;;
    volatile Uint32 OSCDIV1    &#160;;
    volatile Uint32 POSTDIV    &#160;;
    volatile Uint32 BPDIV      &#160;;
    volatile Uint32 WAKEUP     &#160;;
    volatile Uint8  RSVD3 [4]  &#160;;
    volatile Uint32 PLLCMD     &#160;;
    volatile Uint32 PLLSTAT    &#160;;
    volatile Uint32 ALNCTL     &#160;;
    volatile Uint32 DCHANGE    &#160;;
    volatile Uint32 CKEN       &#160;;
    volatile Uint32 CKSTAT     &#160;;
    volatile Uint32 SYSTAT     &#160;;
    volatile Uint8  RSVD4 [12] &#160;;
    volatile Uint32 PLLDIV4    &#160;;
    volatile Uint32 PLLDIV5    &#160;;
    volatile Uint32 PLLDIV6    &#160;;
    volatile Uint32 PLLDIV7    &#160;;
    volatile Uint32 PLLDIV8    &#160;;
} DM64LCPCI_pllRegs&#160;;

/** ============================================================================
 *  @name   DM64LCPCI_ddrRegs
 *
 *  @desc   Register Overlay Structure for DDR.
 *  ============================================================================
 */
typedef struct  {
    volatile Uint32 ERCSR      &#160;;
    volatile Uint32 SDRSTAT    &#160;;
    volatile Uint32 SDBCR      &#160;;
    volatile Uint32 SDRCR      &#160;;
    volatile Uint32 SDTIMR     &#160;;
    volatile Uint32 SDTIMR2    &#160;;
    volatile Uint8  RSVD0 [8]  &#160;;
    volatile Uint32 VBPR       &#160;;
    volatile Uint8  RSVD1 [4]  &#160;;
    volatile Uint32 VBCFG1     &#160;;
    volatile Uint32 VBCFG2     &#160;;
    volatile Uint8  RSVD2 [16] &#160;;
    volatile Uint32 PERFC1R    &#160;;
    volatile Uint32 PERFC2R    &#160;;
    volatile Uint32 PCCR       &#160;;
    volatile Uint32 PCMRSR     &#160;;
    volatile Uint8  RSVD3 [48] &#160;;
    volatile Uint32 ASYNCCS2CR &#160;;
    volatile Uint32 ASYNCCS3CR &#160;;
    volatile Uint32 ASYNCCS4CR &#160;;
    volatile Uint32 ASYNCCS5CR &#160;;
    volatile Uint8  RSVD4 [16] &#160;;
    volatile Uint32 AWCCR      &#160;;
    volatile Uint8  RSVD5 [28] &#160;;
    volatile Uint32 IRR        &#160;;
    volatile Uint32 IMR        &#160;;
    volatile Uint32 IMSR       &#160;;
    volatile Uint32 IMCR       &#160;;
    volatile Uint8  RSVD6 [16] &#160;;
    volatile Uint32 DDRPHYREV  &#160;;
    volatile Uint32 DDRPHYCR   &#160;;
    volatile Uint32 DDRPHYSR   &#160;;
    volatile Uint8  RSVD7 [4]  &#160;;
    volatile Uint32 VTPCTRL    &#160;;
    volatile Uint32 VTPSTAT    &#160;;
} DM64LCPCI_ddrRegs&#160;;

/** ============================================================================
 *  @name   DM64LCPCI_pscRegs
 *
 *  @desc   Register Overlay Structure for PSC.
 *  ============================================================================
 */
typedef struct DM64LCPCI_pscRegs_tag {
    volatile Uint32 PID         &#160;;
    volatile Uint8  RSVD0 [12]  &#160;;
    volatile Uint32 GBLCTL      &#160;;
    volatile Uint8  RSVD1 [4]   &#160;;
    volatile Uint32 INTEVAL     &#160;;
    volatile Uint8  RSVD2 [36]  &#160;;
    volatile Uint32 ERRPR0      &#160;;
    volatile Uint32 ERRPR1      &#160;;
    volatile Uint8  RSVD3 [8]   &#160;;
    volatile Uint32 ERRCR0      &#160;;
    volatile Uint32 ERRCR1      &#160;;
    volatile Uint8  RSVD4 [8]   &#160;;
    volatile Uint32 PERRPR      &#160;;
    volatile Uint8  RSVD5 [4]   &#160;;
    volatile Uint32 PERRCR      &#160;;
    volatile Uint8  RSVD6 [4]   &#160;;
    volatile Uint32 EPCPR       &#160;;
    volatile Uint8  RSVD7 [4]   &#160;;
    volatile Uint32 EPCR        &#160;;
    volatile Uint8  RSVD8 [132] &#160;;
    volatile Uint32 RAILSTAT    &#160;;
    volatile Uint32 RAILCTL     &#160;;
    volatile Uint32 RAILSEL     &#160;;
    volatile Uint8  RSVD9 [20]  &#160;;
    volatile Uint32 PTCMD       &#160;;
    volatile Uint8  RSVD10 [4]  &#160;;
    volatile Uint32 PTSTAT      &#160;;
    volatile Uint8  RSVD11 [212]&#160;;
    volatile Uint32 PDSTAT [41] &#160;;
    volatile Uint8  RSVD12 [92] &#160;;
    volatile Uint32 PDCTL [41]  &#160;;
    volatile Uint8  RSVD13 [348]&#160;;
    volatile Uint32 MRSTOUT [2] &#160;;
    volatile Uint8  RSVD14 [8]  &#160;;
    volatile Uint32 MCKOUT [2]  &#160;;
    volatile Uint8  RSVD15 [232]&#160;;
    volatile Uint32 MDCFG [41]  &#160;;
    volatile Uint8  RSVD16 [348]&#160;;
    volatile Uint32 MDSTAT [41] &#160;;
    volatile Uint8  RSVD17 [348]&#160;;
    volatile Uint32 MDCTL [41]  &#160;;
} DM64LCPCI_pscRegs&#160;;

/** ============================================================================
 *  @name   DM64LCPCI_paramEntry
 *
 *  @desc   Register Overlay Structure for PARAMENTRY.
 *  ============================================================================
 */
typedef struct DM64LCPCI_paramEntry_tags {
    volatile Uint32 OPTION          &#160;;
    volatile Uint32 SRC          &#160;;
    volatile Uint32 A_B_CNT      &#160;;
    volatile Uint32 DST          &#160;;
    volatile Uint32 SRC_DST_BIDX &#160;;
    volatile Uint32 LINK_BCNTRLD &#160;;
    volatile Uint32 SRC_DST_CIDX &#160;;
    volatile Uint32 CCNT         &#160;;
} DM64LCPCI_paramEntry&#160;;

/** ============================================================================
 *  @name   DM64LCPCI_edmaRegs
 *
 *  @desc   Register Overlay Structure for EDMA.
 *  ============================================================================
 */
typedef struct DM64LCPCI_edmaRegs_tag {
    volatile Uint32      REV               &#160;;
    volatile Uint32      CCCFG             &#160;;
    volatile Uint8       RSVD0 [248]       &#160;;
    volatile Uint32      DCHMAP [64]       &#160;;
    volatile Uint32      QCHMAP [8]        &#160;;
    volatile Uint8       RSVD1 [32]        &#160;;
    volatile Uint32      DMAQNUM [8]       &#160;;
    volatile Uint32      QDMAQNUM          &#160;;
    volatile Uint8       RSVD2 [28]        &#160;;
    volatile Uint32      QUETCMAP          &#160;;
    volatile Uint32      QUEPRI            &#160;;
    volatile Uint8       RSVD3 [120]       &#160;;
    volatile Uint32      EMR               &#160;;
    volatile Uint32      EMRH              &#160;;
    volatile Uint32      EMCR              &#160;;
    volatile Uint32      EMCRH             &#160;;
    volatile Uint32      QEMR              &#160;;
    volatile Uint32      QEMCR             &#160;;
    volatile Uint32      CCERR             &#160;;
    volatile Uint32      CCERRCLR          &#160;;
    volatile Uint32      EEVAL             &#160;;
    volatile Uint8       RSVD4  [28]       &#160;;
    volatile Uint8       RSVD5 [64]        &#160;;
    volatile Uint32      QRAE [8]          &#160;;
    volatile Uint8       RSVD6[96]         &#160;;
    volatile Uint8       RSVD7 [512]       &#160;;
    volatile Uint32      QSTAT [8]         &#160;;
    volatile Uint32      QWMTHRA           &#160;;
    volatile Uint32      QWMTHRB           &#160;;
    volatile Uint8       RSVD8 [24]        &#160;;
    volatile Uint32      CCSTAT            &#160;;
    volatile Uint8       RSVD9 [188]       &#160;;
    volatile Uint32      AETCTL            &#160;;
    volatile Uint32      AETSTAT           &#160;;
    volatile Uint32      AETCMD            &#160;;
    volatile Uint8       RSVD10 [244]      &#160;;
    volatile Uint32      MPFAR             &#160;;
    volatile Uint32      MPFSR             &#160;;
    volatile Uint32      MPFCR             &#160;;
    volatile Uint32      MPPAG             &#160;;
    volatile Uint32      MPPA [8]          &#160;;
    volatile Uint8       RSVD11 [2000]     &#160;;
    volatile Uint32      ER                &#160;;
    volatile Uint32      ERH               &#160;;
    volatile Uint32      ECR               &#160;;
    volatile Uint32      ECRH              &#160;;
    volatile Uint32      ESR               &#160;;
    volatile Uint32      ESRH              &#160;;
    volatile Uint32      CER               &#160;;
    volatile Uint32      CERH              &#160;;
    volatile Uint32      EER               &#160;;
    volatile Uint32      EERH              &#160;;
    volatile Uint32      EECR              &#160;;
    volatile Uint32      EECRH             &#160;;
    volatile Uint32      EESR              &#160;;
    volatile Uint32      EESRH             &#160;;
    volatile Uint32      SER               &#160;;
    volatile Uint32      SERH              &#160;;
    volatile Uint32      SECR              &#160;;
    volatile Uint32      SECRH             &#160;;
    volatile Uint8       RSVD12 [8]        &#160;;
    volatile Uint32      IER               &#160;;
    volatile Uint32      IERH              &#160;;
    volatile Uint32      IECR              &#160;;
    volatile Uint32      IECRH             &#160;;
    volatile Uint32      IESR              &#160;;
    volatile Uint32      IESRH             &#160;;
    volatile Uint32      IPR               &#160;;
    volatile Uint32      IPRH              &#160;;
    volatile Uint32      ICR               &#160;;
    volatile Uint32      ICRH              &#160;;
    volatile Uint32      IEVAL             &#160;;
    volatile Uint8       RSVD13 [4]        &#160;;
    volatile Uint32      QER               &#160;;
    volatile Uint32      QEER              &#160;;
    volatile Uint32      QEECR             &#160;;
    volatile Uint32      QEESR             &#160;;
    volatile Uint32      QSER              &#160;;
    volatile Uint32      QSECR             &#160;;
    volatile Uint8       RSVD14 [3944]     &#160;;
    volatile Uint8       RSVD15 [4096]     &#160;;
    volatile Uint8       RSVD16 [4096]     &#160;;
    DM64LCPCI_paramEntry PARAMENTRY[512]   &#160;;
} DM64LCPCI_edmaRegs&#160;;

/** ============================================================================
 *  @name   DM64LCPCI_pciRegs
 *
 *  @desc   PCI Back end register overlay structure.
 *  ============================================================================
 */
typedef struct DM64LCPCI_pciRegs_tag {
    volatile Uint32 PCIREVID      &#160;;
    volatile Uint8  RSVD0 [12]    &#160;;
    volatile Uint32 PCISTATSET    &#160;;
    volatile Uint32 PCISTATCLR    &#160;;
    volatile Uint8  RSVD1 [8]     &#160;;
    volatile Uint32 PCIHINTSET    &#160;;
    volatile Uint32 PCIHINTCLR    &#160;;
    volatile Uint8  RSVD2 [8]     &#160;;
    volatile Uint32 PCIBINTSET    &#160;;
    volatile Uint32 PCIBINTCLR    &#160;;
    volatile Uint32 PCIBCLKMGT    &#160;;
    volatile Uint8  RSVD3 [196]   &#160;;
    volatile Uint32 PCIVENDEVMIR  &#160;;
    volatile Uint32 PCICSRMIR     &#160;;
    volatile Uint32 PCICLREVMIR   &#160;;
    volatile Uint32 PCICLINEMIR   &#160;;
    volatile Uint32 PCIBAR0MSK    &#160;;
    volatile Uint32 PCIBAR1MSK    &#160;;
    volatile Uint32 PCIBAR2MSK    &#160;;
    volatile Uint32 PCIBAR3MSK    &#160;;
    volatile Uint32 PCIBAR4MSK    &#160;;
    volatile Uint32 PCIBAR5MSK    &#160;;
    volatile Uint8  RSVD4[4]      &#160;;
    volatile Uint32 PCISUBIDMIR   &#160;;
    volatile Uint8  RSVD5 [4]     &#160;;
    volatile Uint32 PCICPBPTRMIR  &#160;;
    volatile Uint8  RSVD6 [4]     &#160;;
    volatile Uint32 PCILGINTMIR   &#160;;
    volatile Uint8  RSVD7 [64]    &#160;;
    volatile Uint32 PCISLVCNTL    &#160;;
    volatile Uint8  RSVD8 [60]    &#160;;
    volatile Uint32 PCIBAR0TRL    &#160;;
    volatile Uint32 PCIBAR1TRL    &#160;;
    volatile Uint32 PCIBAR2TRL    &#160;;
    volatile Uint32 PCIBAR3TRL    &#160;;
    volatile Uint32 PCIBAR4TRL    &#160;;
    volatile Uint32 PCIBAR5TRL    &#160;;
    volatile Uint8  RSVD9 [8]     &#160;;
    volatile Uint32 PCIBARMIR [6] &#160;;
    volatile Uint8  RSVD10 [264]  &#160;;
    volatile Uint32 PCIMCFGDAT    &#160;;
    volatile Uint32 PCIMCFGADR    &#160;;
    volatile Uint32 PCIMCFGCMD    &#160;;
    volatile Uint8  RSVD11 [4]    &#160;;
    volatile Uint32 PCIMSTCFG     &#160;;
    volatile Uint32 PCIADDSUB [32]&#160;;
    volatile Uint32 PCIVENDEVPRG  &#160;;
    volatile Uint32 PCICMDSTATPRG &#160;;
    volatile Uint32 PCICLREVPRG   &#160;;
    volatile Uint32 PCISUBIDPRG   &#160;;
    volatile Uint32 PCIMAXLGPRG   &#160;;
    volatile Uint32 PCILRSTREG    &#160;;
    volatile Uint32 PCICFGDONE    &#160;;
    volatile Uint32 PCIBAR0MPRG   &#160;;
    volatile Uint32 PCIBAR1MPRG   &#160;;
    volatile Uint32 PCIBAR2MPRG   &#160;;
    volatile Uint32 PCIBAR3MPRG   &#160;;
    volatile Uint32 PCIBAR4MPRG   &#160;;
    volatile Uint32 PCIBAR5MPRG   &#160;;
    volatile Uint32 PCIBAR0PRG    &#160;;
    volatile Uint32 PCIBAR1PRG    &#160;;
    volatile Uint32 PCIBAR2PRG    &#160;;
    volatile Uint32 PCIBAR3PRG    &#160;;
    volatile Uint32 PCIBAR4PRG    &#160;;
    volatile Uint32 PCIBAR5PRG    &#160;;
    volatile Uint32 PCIBAR0TRLPRG &#160;;
    volatile Uint32 PCIBAR1TRLPRG &#160;;
    volatile Uint32 PCIBAR2TRLPRG &#160;;
    volatile Uint32 PCIBAR3TRLPRG &#160;;
    volatile Uint32 PCIBAR4TRLPRG &#160;;
    volatile Uint32 PCIBAR5TRLPRG &#160;;
    volatile Uint32 PCIBASENPRG   &#160;;
} DM64LCPCI_pciRegs&#160;;


struct pci_dev * GEM = NULL&#160;;

Uint32   regBase = 0&#160;;
Uint32   memBase = 0&#160;;
Uint32   ddrRegBase = 0&#160;;

Uint32 * regVirt = NULL&#160;;
Uint32 * memVirt = NULL&#160;;
Uint32 * ddrRegVirt = NULL&#160;;

Uint32   memLen  = 0&#160;;
Uint32   regLen  = 0&#160;;
Uint32   ddrRegLen  = 0&#160;;

Int32    irqNo&#160;;


/* ============================================================================
 *  @func   PCI_FindPciDevices
 *
 *  @desc   This function locates DM642 PCI cards on system.
 *
 *  @modif  None.
 *  ============================================================================
 */
Void
PCI_FindPciDevices (Void)
{
    struct pci_dev * dev = NULL&#160;;

    while ((dev = pci_find_device (PCI_TI_VENDOR, PCI_TI_DEVICE, dev))&#160;!= NULL)
    {
        irqNo = dev-&gt;irq&#160;;
        GEM = dev&#160;;
        break&#160;;
    }
}

/* ============================================================================
 *  @func   PCI_readBAR
 *
 *  @desc   This function reads config.
 *
 *  @modif  None.
 *  ============================================================================
 */
Void PCI_readBAR (Void)
{
    Uint32  barStart [3] &#160;;
    Uint32  barLen   [3] &#160;;
    Uint32  barFlags [3] &#160;;

    barStart [0] = pci_resource_start (GEM, 0);
    barLen   [0] = pci_resource_len   (GEM, 0);
    barFlags [0] = pci_resource_flags (GEM, 0);
    barStart [1] = pci_resource_start (GEM, 1);
    barLen   [1] = pci_resource_len   (GEM, 1);
    barFlags [1] = pci_resource_flags (GEM, 1);
    barStart [2] = pci_resource_start (GEM, 2);
    barLen   [2] = pci_resource_len   (GEM, 2);
    barFlags [2] = pci_resource_flags (GEM, 2);

    /* ---------------------------------------------------------------------
     * Map the L2RAM memory region
     * ---------------------------------------------------------------------
     */
    if (barFlags [0] &amp; IORESOURCE_MEM) {
        memBase = barStart [0]&#160;;
        /* Map the memory region. */
        request_mem_region (memBase,
                            barLen [0],
                            "DSPLINK");
    }
    else {
        /* Map the memory region. */
        request_region (memBase,
                        barLen [0],
                        "DSPLINK");
    }

    if (memBase &gt; 0) {
        memVirt = ioremap (barStart [0],
                           barLen [0])&#160;;
    }

    /* ---------------------------------------------------------------------
     * Map the DDR REG memory region
     * ---------------------------------------------------------------------
     */
    if (barFlags [1] &amp; IORESOURCE_MEM) {
        ddrRegBase = barStart [1]&#160;;
        /* Map the memory region. */
        request_mem_region (ddrRegBase,
                            barLen [1],
                            "DSPLINK");
    }
    else {
        /* Map the memory region. */
        request_region (ddrRegBase,
                        barLen [1],
                        "DSPLINK");
    }

    if (ddrRegBase &gt; 0) {
        ddrRegVirt = ioremap (barStart [1],
                              barLen [1])&#160;;
    }

    /* ---------------------------------------------------------------------
     * Map the REG memory region
     * ---------------------------------------------------------------------
     */
    if (barFlags [2] &amp; IORESOURCE_MEM) {
        regBase = barStart [2]&#160;;
        /* Map the memory region. */
        request_mem_region (regBase,
                            barLen [2],
                            "DSPLINK");
    }
    else {
        /* Map the memory region. */
        request_region (regBase,
                        barLen [2],
                        "DSPLINK");
    }

    if (regBase &gt; 0) {
        regVirt = ioremap (barStart [2],
                           barLen [2])&#160;;
    }

    memLen    = barLen [0]&#160;;
    ddrRegLen = barLen [1]&#160;;
    regLen    = barLen [2]&#160;;
}

/* =============================================================================
 *  @func   PCI_setMaster
 *
 *  @desc   This function makes the given device to be master.
 *
 *  @modif  None.
 *  ============================================================================
 */
Void
PCI_setMaster (void)
{
    Int32   retVal&#160;;
    Uint16  cmdVal&#160;;
    struct pci_dev * dev&#160;;

    dev = GEM&#160;;

    /* set the DMA mask */
    if (pci_set_dma_mask (dev, 0xfffffff0ULL)) {
    }

    /*
     * set the desired PCI dev to be master, this internally sets the latency
     * timer.
     */
    pci_set_master (dev)&#160;;
    pci_write_config_byte(dev, PCI_LATENCY_TIMER, 0x80);

    /* Add support memory write invalidate */
    retVal = pci_set_mwi (dev)&#160;;

    pci_read_config_word (dev, PCI_COMMAND, (u16 *) &amp;cmdVal)&#160;;
    /* and set the master bit in command register. */
    cmdVal |=   PCI_COMMAND_MEMORY
              | PCI_COMMAND_MASTER
              | PCI_COMMAND_SERR &#160;;
    /* and clear the interrupt disable bit in command register. */
    cmdVal &amp;=   ~PCI_COMMAND_INTX_DISABLE;
    pci_write_config_word (dev, PCI_COMMAND, cmdVal)&#160;;
}



/* =============================================================================
 *  @func   HAL_CheckPciInterrupt
 *
 *  @desc   This function check whether interrupt is generated by DM642 or not.
 *
 *  @modif  None.
 *  ============================================================================
 */
Bool
HAL_CheckPciInterrupt (void)
{
    volatile DM64LCPCI_pciRegs * pciRegs = (DM64LCPCI_pciRegs *) ((Uint32) regVirt + (DM64LCPCI_PCIREG_BASE - 0x01C00000))&#160;;
    Bool                 status = 0&#160;;

    if (   (pciRegs-&gt;PCICSRMIR &amp; DM64LCPCI_INTSTATUS_MASK)
        == (DM64LCPCI_INTSTATUS_MASK)) {
        status = 1&#160;;
    }

    return status&#160;;
}


/** ============================================================================
 *  @func   HAL_PciClearDspInterrupt
 *
 *  @desc   Clear pending interrupt from DSP to Host.
 *
 *  @modif  None.
 *  ============================================================================
 */
Void
HAL_PciClearDspInterrupt (Void)
{
    volatile DM64LCPCI_pciRegs * pciRegs = (DM64LCPCI_pciRegs *) ((Uint32) regVirt + (DM64LCPCI_PCIREG_BASE - 0x01C00000))&#160;;

    pciRegs-&gt;PCISTATCLR |= DM64LCPCI_SOFTINT0_MASK&#160;;
}


/** ============================================================================
 *  @func   HAL_PciEnableDspInterrupt
 *
 *  @desc   Allow the DSP to generate interrupts to the Host.
 *
 *  @modif  None.
 *  ============================================================================
 */
Void
HAL_PciEnableDspInterrupt (Void)
{
    volatile DM64LCPCI_pciRegs * pciRegs = (DM64LCPCI_pciRegs *) ((Uint32) regVirt + (DM64LCPCI_PCIREG_BASE - 0x01C00000))&#160;;

    pciRegs-&gt;PCIHINTSET |= DM64LCPCI_SOFTINT0_MASK&#160;;
}


/** ============================================================================
 *  @func   HAL_PciDisableDspInterrupt
 *
 *  @desc   Disallow the DSP to generate interrupts to the Host.
 *
 *  @modif  None.
 *  ============================================================================
 */
Void
HAL_PciDisableDspInterrupt (Void)
{
    volatile DM64LCPCI_pciRegs * pciRegs = (DM64LCPCI_pciRegs *) ((Uint32) regVirt + (DM64LCPCI_PCIREG_BASE - 0x01C00000))&#160;;

    pciRegs-&gt;PCIHINTCLR |= DM64LCPCI_SOFTINT0_MASK&#160;;
}


/*  ----------------------------------------------------------------------------
 *  @func   HAL_changeState
 *
 *  @desc   Change power module state to ( ENABLE, DISABLE, SYNCRESET, RESET ).
 *
 *  @modif  None
 *  ----------------------------------------------------------------------------
 */
Void
HAL_changeState (Uint32 lpscNum, Uint16 state)
{
    volatile DM64LCPCI_pscRegs * pscRegs = (DM64LCPCI_pscRegs *) ((Uint32) regVirt + (DM64LCPCI_PSCREG_BASE - 0x01C00000))&#160;;

    if ((pscRegs-&gt;MDSTAT [lpscNum] &amp; 0x001F) == state) {
        return&#160;;
    }
    /*  ------------------------------------------------------------------------
     *  Step 1 - Wait for PTSTAT.GOSTAT to clear
     *  ------------------------------------------------------------------------
     */
    while (pscRegs-&gt;PTSTAT &amp; 0x1)&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 2 - Set MDCTLx.NEXT to new state
     *  ------------------------------------------------------------------------
     */
    pscRegs-&gt;MDCTL [lpscNum] &amp;= 0xFFE0&#160;;
    pscRegs-&gt;MDCTL [lpscNum] |= state &#160;;

    /*  ------------------------------------------------------------------------
     *  Step 3 - Start power transition ( set PTCMD.GO to 1 )
     *  ------------------------------------------------------------------------
     */
    pscRegs-&gt;PTCMD = 0x0001&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 4 - Wait for PTSTAT.GOSTAT to clear
     *  ------------------------------------------------------------------------
     */
    while (pscRegs-&gt;PTSTAT &amp; 0x1)&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 5 - Verify state changed
     *  ------------------------------------------------------------------------
     */
    while ((pscRegs-&gt;MDSTAT [lpscNum] &amp; 0x001F)&#160;!= state)&#160;;
}


/*  ----------------------------------------------------------------------------
 *  @func   HAL_cfgPLL1
 *
 *  @desc   Configures the PLL1.
 *
 *  @modif  None
 *  ----------------------------------------------------------------------------
 */
Void
HAL_cfgPLL1 (Uint32       pllm,
             Uint32       div1,
             Uint32       div2)
{
    volatile DM64LCPCI_pllRegs * pllRegs = (DM64LCPCI_pllRegs *) ((Uint32) regVirt + (DM64LCPCI_PLL1REG_BASE - 0x01C00000))&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 1 - Set PLL to BYPASS mode and select clock source.
     *  ------------------------------------------------------------------------
     */
    pllRegs-&gt;PLLCTL &amp;= 0xFFFFFEFF&#160;;
    pllRegs-&gt;PLLCTL |= 0x0&#160;;
    pllRegs-&gt;PLLCTL &amp;= 0xFFFFFFDF&#160;;
    pllRegs-&gt;PLLCTL &amp;= 0xFFFFFFFE&#160;;

    udelay (10000)&#160;;

    pllRegs-&gt;PLLCTL &amp;= 0xFFFFFFF7&#160;;
    pllRegs-&gt;PLLCTL |= 0x00000010&#160;;
    pllRegs-&gt;PLLCTL &amp;= 0xFFFFFFFD&#160;;
    pllRegs-&gt;PLLCTL &amp;= 0xFFFFFFEF&#160;;
    pllRegs-&gt;PLLCTL &amp;= 0xFFFFFEFF&#160;;
    pllRegs-&gt;PLLCTL |= 0x0&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 2 - Load PLL multiplier.
     *  ------------------------------------------------------------------------
     */
    pllRegs-&gt;PLLM = pllm&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 3 - Load PLL2 divider - DDR2 and VPBE are programmable.
     *  ------------------------------------------------------------------------
     */
    pllRegs-&gt;PLLDIV1  =  div2&#160;;
    pllRegs-&gt;PLLDIV2  =  div1&#160;;
    pllRegs-&gt;PLLDIV1 &amp;= 0xFFFF7FFF&#160;;
    pllRegs-&gt;PLLDIV2 &amp;= 0xFFFF7FFF&#160;;
    pllRegs-&gt;PLLDIV1 |= 0x00008000&#160;;
    pllRegs-&gt;PLLDIV2 |= 0x00008000&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 4 - Set phase alignment and Wait for operation to finish.
     *  ------------------------------------------------------------------------
     */
    pllRegs-&gt;PLLCMD |= 0x00000001&#160;;
    while ((pllRegs-&gt;PLLSTAT &amp; 0x1) == 0x1)&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 5 - Wait for PLL to re-lock ( 2000 cycles ).
     *  ------------------------------------------------------------------------
     */
    udelay (10000)&#160;;
    pllRegs-&gt;PLLCTL |= 0x00000008&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 6 - Switch out of BYPASS mode.
     *  ------------------------------------------------------------------------
     */
    udelay (10000)&#160;;
    pllRegs-&gt;PLLCTL |= 0x00000001&#160;;
}


/*  ----------------------------------------------------------------------------
 *  @func   HAL_cfgDDR2
 *
 *  @desc   Configures the DDR2 module.
 *
 *  @modif  None
 *  ----------------------------------------------------------------------------
 */
Void
HAL_cfgDDR2 (Uint32  freq)
{
    volatile DM64LCPCI_ddrRegs * ddrRegs = (DM64LCPCI_ddrRegs *) ((Uint32) ddrRegVirt)&#160;;
    Uint32 *             vtpiocr = NULL&#160;;
    Uint32 *             vtpr    = NULL&#160;;
    Uint32 *             dftEnb  = NULL&#160;;

    vtpiocr  = (Uint32 *) ((Uint32) ddrRegVirt  + 0xF0)&#160;;
    vtpr     = (Uint32 *) ((Uint32) regVirt + 0x42038)&#160;;
    dftEnb   = (Uint32 *) ((Uint32) regVirt + 0x4004C)&#160;;

    /* Enable the DDR2 PSC Module */
    HAL_changeState (13, 0x3)&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 1. Enable DDR2 PHY.
     *  ------------------------------------------------------------------------
     */
    ddrRegs-&gt;DDRPHYCR =  0x50006405&#160;;
    ddrRegs-&gt;SDBCR    =  0x00138822&#160;;
    ddrRegs-&gt;SDTIMR   =  0x16492148&#160;;
    ddrRegs-&gt;SDTIMR2  =  0x000CC702&#160;;
    ddrRegs-&gt;SDBCR    =  0x00130822&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 3. Refresh Control [ 7.8 usec * freq in MHz ].
     *  ------------------------------------------------------------------------
     */
    ddrRegs-&gt;SDRCR = 0x4EF&#160;;

    /* Reset the DDR2 PSC Module */
    HAL_changeState (13, 0x1)&#160;;
    HAL_changeState (13, 0x3)&#160;;

    /*  ------------------------------------------------------------------------
     *  Step 4. Enable VTP calibration
     *  ------------------------------------------------------------------------
     */
    *vtpiocr  = 0x201F&#160;;
    *vtpiocr  = 0xA01F&#160;;

    /* wait for 33 VTP clock cycles */
    udelay (10000);
    *dftEnb   = 1&#160;;
    *vtpiocr  = 0xA000 | (*vtpr | 0x3FF)&#160;;

    /* Wait for few more clock cycles */
    udelay (10000);
    *vtpiocr &amp;= 0xFFFFDFFF&#160;;
    *dftEnb   = 0&#160;;
}

/* ============================================================================
 *  @func   HAL_readDMA
 *
 *  @desc   DMAs contents from DSP memory to GPP Memory. Here read means DSP
 *          write.
 *
 *  @modif  None.
 *  ============================================================================
 */
Void
HAL_readDMA (Uint32       srcAddr,
             Uint32       dstAddr,
             Uint32       size)
{
    volatile DM64LCPCI_edmaRegs * edmaRegs = (DM64LCPCI_edmaRegs *) ((Uint32) regVirt + (DM64LCPCI_EDMAREG_BASE - 0x01C00000))&#160;;
    volatile DM64LCPCI_pciRegs *  pciRegs  = (DM64LCPCI_pciRegs *) ((Uint32) regVirt + (DM64LCPCI_PCIREG_BASE - 0x01C00000))&#160;;
    Uint32                        i        = 0&#160;;
    Uint32                        pageBase&#160;;
    Uint32                        numUSec&#160;;
    Uint32                        tSize  &#160;;
    Uint32                        tmp&#160;;

    if (size &lt;= DM64LCPCI_PCIADLEN) {
        pageBase = dstAddr &amp; DM64LCPCI_PCIADWRBITMASK&#160;;
        pciRegs-&gt;PCIADDSUB [0] = pageBase&#160;;
    }
    else {
        for (tmp = size, i = 0&#160;; tmp &gt; 0&#160;; tmp -= DM64LCPCI_PCIADLEN, i++) {
            pageBase =   (dstAddr + (DM64LCPCI_PCIADLEN * i))
                       &amp; DM64LCPCI_PCIADWRBITMASK&#160;;
            pciRegs-&gt;PCIADDSUB [i] = pageBase&#160;;
        }
    }

    do {
        /* Set the interrupt enable for 1st Channel. */
        edmaRegs-&gt;IESR |= 0x1&#160;;

        /* Clear any pending interrupt. */
        edmaRegs-&gt;ICR |= 0x1&#160;;

        /* Populate the Param entry. */
        edmaRegs-&gt;PARAMENTRY [0].OPTION       = 0x00100004&#160;;
        edmaRegs-&gt;PARAMENTRY [0].SRC          = srcAddr&#160;;
        /* Calculate the DSP PCI address for the PC address */
        tmp = 0x30000000 + (dstAddr &amp; ~DM64LCPCI_PCIADWRBITMASK)&#160;;
        edmaRegs-&gt;PARAMENTRY [0].DST          = tmp&#160;;

        /* Calculate the A &amp; B count */
        if (size &gt; 0x7000)  {
            tmp   = size / 0x7000&#160;;
            tSize = tmp * 0x7000&#160;;
            size -= (tmp * 0x7000)&#160;;
            tmp &lt;&lt;= 16&#160;;
            tmp  |= 0x7000&#160;;
        }
        else {
            tmp = 0x10000 | size&#160;;
            tSize = size&#160;;
            size = 0&#160;;
        }

        edmaRegs-&gt;PARAMENTRY [0].A_B_CNT      = tmp&#160;;
        edmaRegs-&gt;PARAMENTRY [0].LINK_BCNTRLD = 0xFFFF&#160;;
        edmaRegs-&gt;PARAMENTRY [0].SRC_DST_CIDX = 0&#160;;
        /* C Count is set to 1 since mostly size will not be more than 1GB */
        edmaRegs-&gt;PARAMENTRY [0].CCNT         = 0x1&#160;;
        /* no offset difference required */
        edmaRegs-&gt;PARAMENTRY [0].SRC_DST_BIDX = 0x70007000&#160;;

        /* Set the interrupt enable for 1st Channel. */
        edmaRegs-&gt;EESR |= 0x1&#160;;

        /* Clear any pending interrupt. */
        edmaRegs-&gt;ESR |= 0x1&#160;;

        /* wait for current DMA to finish. */
        numUSec = tSize / 132&#160;;
        do {
            udelay (numUSec)&#160;;
            /* now check in steps of 10 usec. */
            numUSec = 10&#160;;
        } while ((edmaRegs-&gt;IPR &amp; 0x1) == 0)&#160;;

        if (size&#160;!= 0) {
            srcAddr += tSize&#160;;
            dstAddr += tSize&#160;;
        }
    } while (size&#160;!= 0)&#160;;

    /* Clear any pending interrupt. */
    edmaRegs-&gt;ICR |= 0x1&#160;;
}


/* ============================================================================
 *  @func   HAL_writeDMA
 *
 *  @desc   DMAs contents from GPP memory to DSP Memory. Here write means DSP
 *          read.
 *
 *  @modif  None.
 *  ============================================================================
 */
Void
HAL_writeDMA (Uint32       srcAddr,
              Uint32       dstAddr,
              Uint32       size)
{
    volatile DM64LCPCI_edmaRegs * edmaRegs = (DM64LCPCI_edmaRegs *) ((Uint32) regVirt + (DM64LCPCI_EDMAREG_BASE - 0x01C00000))&#160;;
    volatile DM64LCPCI_pciRegs *  pciRegs  = (DM64LCPCI_pciRegs *) ((Uint32) regVirt + (DM64LCPCI_PCIREG_BASE - 0x01C00000))&#160;;
    Uint32                        i        = 0&#160;;
    Uint32                        pageBase&#160;;
    Uint32                        numUSec&#160;;
    Uint32                        tmp&#160;;
    Uint32                        tSize&#160;;

    if (size &lt;= DM64LCPCI_PCIADLEN) {
        pageBase = srcAddr &amp; DM64LCPCI_PCIADWRBITMASK&#160;;
        pciRegs-&gt;PCIADDSUB [0] = pageBase&#160;;
    }
    else {
        for (tmp = size, i = 0&#160;; tmp &gt; 0&#160;; tmp -= DM64LCPCI_PCIADLEN, i++) {
            pageBase =   (srcAddr + (DM64LCPCI_PCIADLEN * i))
                       &amp; DM64LCPCI_PCIADWRBITMASK&#160;;
            pciRegs-&gt;PCIADDSUB [i] = pageBase&#160;;
        }
    }

    do {
        /* Set the interrupt enable for 1st Channel. */
        edmaRegs-&gt;IESR  |= 0x1&#160;;

        /* Clear any pending interrupt. */
        edmaRegs-&gt;ICR |= 0x1&#160;;

        /* Populate the Param entry. */
        edmaRegs-&gt;PARAMENTRY [0].OPTION       = 0x00100004&#160;;

        /* Calculate the DSP PCI address for the PC address */
        tmp = 0x30000000 + (srcAddr &amp; ~DM64LCPCI_PCIADWRBITMASK)&#160;;
        edmaRegs-&gt;PARAMENTRY [0].SRC          = tmp&#160;;
        edmaRegs-&gt;PARAMENTRY [0].DST          = dstAddr&#160;;

        /* Calculate the A &amp; B count */
        if (size &gt; 0x7000)  {
            tmp   = size / 0x7000&#160;;
            tSize = tmp * 0x7000&#160;;
            size -= (tmp * 0x7000)&#160;;
            tmp &lt;&lt;= 16&#160;;
            tmp  |= 0x7000&#160;;
        }
        else {
            tmp = 0x10000 | size&#160;;
            tSize = size&#160;;
            size = 0&#160;;
        }

        edmaRegs-&gt;PARAMENTRY [0].A_B_CNT      = tmp&#160;;
        edmaRegs-&gt;PARAMENTRY [0].LINK_BCNTRLD = 0xFFFF&#160;;
        edmaRegs-&gt;PARAMENTRY [0].SRC_DST_CIDX = 0&#160;;
        /* no offset difference required */
        edmaRegs-&gt;PARAMENTRY [0].SRC_DST_BIDX = 0x70007000&#160;;
        /* C Count is set to 1 since mostly size will not be more than 1GB */
        edmaRegs-&gt;PARAMENTRY [0].CCNT         = 0x1&#160;;

        /* Set the interrupt enable for 1st Channel. */
        edmaRegs-&gt;EESR |= 0x1&#160;;

        /* Clear any pending interrupt. */
        edmaRegs-&gt;ESR |= 0x1&#160;;

        /* wait for current DMA to finish. */
        numUSec = tSize / 132&#160;;
        do {
            udelay (numUSec)&#160;;
            /* now check in steps of 10 usec. */
            numUSec = 10&#160;;
        } while ((edmaRegs-&gt;IPR &amp; 0x1) == 0)&#160;;

        if (size&#160;!= 0) {
            srcAddr += tSize&#160;;
            dstAddr += tSize&#160;;
        }
    } while (size&#160;!= 0)&#160;;

    /* Clear any pending interrupt. */
    edmaRegs-&gt;ICR |= 0x1&#160;;
}


#define ADDR32(x)                 *((Uint32 *) ((Uint32)memVirt + x))
/** ============================================================================
 *  @const   LPSC_EDMA_TPCC
 *
 *  @desc    Module number for EDMA TPCC.
 *  ============================================================================
 */
#define LPSC_EDMA_TPCC              2

/** ============================================================================
 *  @const   LPSC_EDMA_TPTC0
 *
 *  @desc    Module number for EDMA TPTC0.
 *  ============================================================================
 */
#define LPSC_EDMA_TPTC0             3

/** ============================================================================
 *  @const   LPSC_EDMA_TPTC1
 *
 *  @desc    Module number for EDMA TPTC1.
 *  ============================================================================
 */
#define LPSC_EDMA_TPTC1             4

static irqreturn_t ISR_handler (int irq, void * arg, struct pt_regs * flags)
{
    Uint32 status = HAL_CheckPciInterrupt () &#160;;
    if (status == 1) {
        HAL_PciClearDspInterrupt ()&#160;;
        printk ("Interrupt&#160;%d received from DSP\n", irq)&#160;;
        return IRQ_HANDLED;
    }
        return IRQ_NONE;
}

Uint32 dummy&#160;;

int init_module(void)
{
    Uint32 i;
    Uint32 j;
    Uint8 * wData&#160;;
    Uint8 * rData&#160;;

    wData = (Uint8 *) kmalloc (0x8000, GFP_DMA)&#160;;
    rData = (Uint8 *) kmalloc (0x8000, GFP_DMA)&#160;;

    printk ("&lt;1&gt;Finding the device....\n")&#160;;
    PCI_FindPciDevices ()&#160;;

    if (GEM&#160;!= NULL) {
        printk ("&lt;1&gt;Reading the BAR areas....\n")&#160;;
        PCI_readBAR ()&#160;;

        printk ("&lt;1&gt;Enabling the device....\n")&#160;;
        pci_enable_device (GEM)&#160;;

        pci_set_drvdata (GEM, memVirt)&#160;;

        PCI_setMaster ()&#160;;

        printk ("&lt;1&gt;Registering the irq\n")&#160;;
        request_irq (irqNo, ISR_handler, SA_SHIRQ, "PCIDRV", &amp;dummy)&#160;;
        HAL_PciEnableDspInterrupt ()&#160;;

        printk ("&lt;1&gt;Powering EDMA engine....\n")&#160;;
        HAL_changeState (LPSC_EDMA_TPCC, 0x3)&#160;;
        HAL_changeState (LPSC_EDMA_TPTC0, 0x3)&#160;;
        HAL_changeState (LPSC_EDMA_TPTC1, 0x3)&#160;;

        printk ("&lt;1&gt;PConfiguring the PLL1....\n")&#160;;
        HAL_cfgPLL1 (23, 11, 1)&#160;;

        printk ("&lt;1&gt;Configuring the DDR2....\n")&#160;;
        HAL_cfgDDR2 (162)&#160;;

        printk ("&lt;1&gt;Running memory test....\n")&#160;;
        {
            volatile Uint32 * ptr = (Uint32 *) memVirt&#160;;
            int               i&#160;;

            for (j = 0&#160;; j &lt; 1000&#160;; j++) {
                printk ("&lt;1&gt;Initializing memory....%d\n", j)&#160;;
                /* Initialize the buffer */
                for (i = 0&#160;; i &lt; 0x8000; i++) {
                    ptr [i] = i&#160;;
                }

                printk ("&lt;1&gt;Reading back memory....%d\n", j)&#160;;
                /* read the buffer back */
                for (i = 0&#160;; i &lt; 0x8000; i++) {
                    if (ptr [i]&#160;!= i) {
                        printk ("&lt;1&gt; Memory test failed at 0x%08x\n", 0x10800000+(i*4))&#160;;
                    }
                }
            }
        }
        
        /* If you see failure prints before this, means test failed */ 
        printk ("&lt;1&gt;Memory test passed....\n")&#160;;

        printk ("&lt;1&gt;Running DMA test....\n")&#160;;
        if (wData &amp;&amp; rData) {
            printk ("&lt;1&gt;Initializing memory....\n")&#160;;
            for (i = 0&#160;; i &lt; 0x8000; i++) {
                wData [i] = 0xAB&#160;;
                rData [i] = 0x00&#160;;
            }

            printk ("&lt;1&gt;Write DMA to DSP....\n")&#160;;
            HAL_writeDMA ((Uint32) virt_to_bus (wData), 0x80100000, 0x8000)&#160;;
            printk ("&lt;1&gt;Read DMA to DSP....\n")&#160;;
            HAL_readDMA  (0x80100000, (Uint32) virt_to_bus (rData), 0x8000)&#160;;
            if ((rData [0] == wData [0]) &amp;&amp; (wData [0x4000] == rData [0x4000])) {
                printk ("API DMA passed\n")&#160;;
            }
            else {
                printk ("API DMA failed&#160;%x\n", rData [0])&#160;;
            }
        }
        printk ("&lt;1&gt;Generating the irq\n")&#160;;
        {
            volatile DM64LCPCI_pciRegs * pciRegs =
                (DM64LCPCI_pciRegs *) (   (Uint32) regVirt
                                        + (DM64LCPCI_PCIREG_BASE - 0x01C00000))&#160;;
            pciRegs-&gt;PCISTATSET |= DM64LCPCI_SOFTINT0_MASK&#160;;
        }
    }
    else {
        printk ("&lt;1&gt;No PCI device found!!!\n")&#160;;
    }

    kfree (rData)&#160;;
    kfree (wData)&#160;;

    return 0&#160;;
}

void cleanup_module(void)
{
    if (GEM&#160;!= NULL) {
        HAL_PciDisableDspInterrupt ()&#160;;

        iounmap(memVirt)&#160;;
        if (pci_resource_flags (GEM, 0) &amp; IORESOURCE_MEM) {
            /* Map the memory region. */
            release_mem_region (memBase,
                                memLen);
        }
        else {
            /* Map the memory region. */
            release_region (memBase,
                            memLen);
        }

        /* ---------------------------------------------------------------------
         * Unmap baseRegs region &amp; release the reg region.
         * ---------------------------------------------------------------------
         */
        iounmap(ddrRegVirt)&#160;;
        if (pci_resource_flags (GEM, 1) &amp; IORESOURCE_MEM) {
            /* Map the memory region. */
            release_mem_region (ddrRegBase,
                                ddrRegLen);
        }
        else {
            /* Map the memory region. */
            release_region (ddrRegBase,
                            ddrRegLen);
        }

        /* ---------------------------------------------------------------------
         * Unmap baseRegs region &amp; release the reg region.
         * ---------------------------------------------------------------------
         */
        iounmap(regVirt)&#160;;
        if (pci_resource_flags (GEM, 2) &amp; IORESOURCE_MEM) {
            /* Map the memory region. */
            release_mem_region (regBase,
                                regLen);
        }
        else {
            /* Map the memory region. */
            release_region (regBase,
                            regLen);
        }

        free_irq (irqNo, &amp;dummy)&#160;;
    }
}
</pre>
<pre>KDIR=/usr/src/kernels/linux-2.6.21.7
PWD=$(shell pwd)

obj-m = pcidrv.o

all:
	$(MAKE) -C $(KDIR) M=$(PWD) 
clean:
	rm -fr *.o *.mod.c *.ko
</pre>
<h2><span class="mw-headline" id="Usage">Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Test_PCI_Driver&amp;action=edit&amp;section=4" title="Edit section: Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li>Copy the c code into a file called pcidrv.c</li>
<li>Copy it to the Linux workstation</li>
<li>Copy the gmake syntax to a file called Makefile</li>
<li>Copy it also to the same directory where c code was copied.</li>
<li>Then issue the following command.
<ul><li>$make</li></ul></li>
<li>Output of this command is pcidrv.ko file
<ul><li>Run it as follows: $insmod pcidrv.ko</li>
<li>Type the following command to see the output: $dmesg</li></ul></li></ul>

<!-- 
NewPP limit report
Cached time: 20201130083656
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.021 seconds
Real time usage: 0.021 seconds
Preprocessor visited node count: 32/1000000
Preprocessor generated node count: 60/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 46835/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:1041-0!canonical and timestamp 20201130083656 and revision id 100059
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Test PCI Driver</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Test PCI Driver</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>Test PCI Driver</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>Test PCI Driver</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>Test PCI Driver</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Test PCI Driver</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Test PCI Driver</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>Test PCI Driver</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>Test PCI Driver</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=Test_PCI_Driver&amp;oldid=100059">https://processors.wiki.ti.com/index.php?title=Test_PCI_Driver&amp;oldid=100059</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="Category_DSPLink.html" title="Category:DSPLink">DSPLink</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=Test+PCI+Driver" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="Test_PCI_Driver.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Talk:Test_PCI_Driver&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="Test_PCI_Driver.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Test_PCI_Driver&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Test_PCI_Driver&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/Test_PCI_Driver.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/Test_PCI_Driver.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=Test_PCI_Driver&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=Test_PCI_Driver&amp;oldid=100059" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=Test_PCI_Driver&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 8 March 2012, at 14:22.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.021","walltime":"0.021","ppvisitednodes":{"value":32,"limit":1000000},"ppgeneratednodes":{"value":60,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":46835,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20201130083656","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":232});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/Test_PCI_Driver by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 04:36:47 GMT -->
</html>
