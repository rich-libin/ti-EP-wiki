<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/StarterWare_USB by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 07:25:35 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>StarterWare USB - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"StarterWare_USB","wgTitle":"StarterWare USB","wgCurRevisionId":128280,"wgRevisionId":128280,"wgArticleId":13624,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["StarterWare"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"StarterWare_USB","wgRelevantArticleId":13624,"wgRequestId":"27e882257a1cd37b4c6d0e6d","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-StarterWare_USB rootpage-StarterWare_USB skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">StarterWare USB</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Comparison_to_StellarisWare_USB"><span class="tocnumber">2</span> <span class="toctext">Comparison to StellarisWare USB</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Core_Design"><span class="tocnumber">3</span> <span class="toctext">Core Design</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Mentor_Controller_Device_Abstraction_Layer_.28MUSB_DAL.29"><span class="tocnumber">3.1</span> <span class="toctext">Mentor Controller Device Abstraction Layer (MUSB DAL)</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Device_Core_Layer"><span class="tocnumber">3.2</span> <span class="toctext">Device Core Layer</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#USB_Configuration_Layer"><span class="tocnumber">3.3</span> <span class="toctext">USB Configuration Layer</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#System_Configuration_Layer"><span class="tocnumber">3.4</span> <span class="toctext">System Configuration Layer</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="#CDC_Device_Class"><span class="tocnumber">4</span> <span class="toctext">CDC Device Class</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Example_Application"><span class="tocnumber">4.1</span> <span class="toctext">Example Application</span></a>
<ul>
<li class="toclevel-3 tocsection-10"><a href="#Running_the_Application"><span class="tocnumber">4.1.1</span> <span class="toctext">Running the Application</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#CDC_Device_Enumeration"><span class="tocnumber">4.1.2</span> <span class="toctext">CDC Device Enumeration</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#CONNECT_.2F_DISCONNECT"><span class="tocnumber">4.1.3</span> <span class="toctext">CONNECT / DISCONNECT</span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#USB_Tick_module"><span class="tocnumber">4.1.4</span> <span class="toctext">USB Tick module</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#CDC_Application_Data_Flow"><span class="tocnumber">4.1.5</span> <span class="toctext">CDC Application Data Flow</span></a>
<ul>
<li class="toclevel-4 tocsection-15"><a href="#Data_out_Flow_.28From_Host_to_Device.29"><span class="tocnumber">4.1.5.1</span> <span class="toctext">Data out Flow (From Host to Device)</span></a>
<ul>
<li class="toclevel-5 tocsection-16"><a href="#Count_Register"><span class="tocnumber">4.1.5.1.1</span> <span class="toctext">Count Register</span></a></li>
</ul>
</li>
<li class="toclevel-4 tocsection-17"><a href="#Data_in_Flow_.28From_Device_to_Host.29"><span class="tocnumber">4.1.5.2</span> <span class="toctext">Data in Flow (From Device to Host)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-18"><a href="#How_To_Write_a_New_CDC_Device_Application"><span class="tocnumber">4.2</span> <span class="toctext">How To Write a New CDC Device Application</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Power_Configuration"><span class="tocnumber">4.3</span> <span class="toctext">Power Configuration</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-20"><a href="#Bulk_Device_Class"><span class="tocnumber">5</span> <span class="toctext">Bulk Device Class</span></a>
<ul>
<li class="toclevel-2 tocsection-21"><a href="#Bulk_Device_Enumeration"><span class="tocnumber">5.1</span> <span class="toctext">Bulk Device Enumeration</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#How_to_Write_a_New_Bulk_Application"><span class="tocnumber">5.2</span> <span class="toctext">How to Write a New Bulk Application</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Windows_Drivers_for_Generic_Bulk_Devices"><span class="tocnumber">5.3</span> <span class="toctext">Windows Drivers for Generic Bulk Devices</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#Running_the_Example_Application"><span class="tocnumber">5.4</span> <span class="toctext">Running the Example Application</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-25"><a href="#HID_Device_Class"><span class="tocnumber">6</span> <span class="toctext">HID Device Class</span></a>
<ul>
<li class="toclevel-2 tocsection-26"><a href="#HID_Device_Enumeration"><span class="tocnumber">6.1</span> <span class="toctext">HID Device Enumeration</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="#Example_Application_2"><span class="tocnumber">6.2</span> <span class="toctext">Example Application</span></a>
<ul>
<li class="toclevel-3 tocsection-28"><a href="#Running_the_Application_2"><span class="tocnumber">6.2.1</span> <span class="toctext">Running the Application</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="#In_Data_Flow_.28Device_to_Host.29"><span class="tocnumber">6.2.2</span> <span class="toctext">In Data Flow (Device to Host)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-30"><a href="#How_to_write_a_new_HID_Application"><span class="tocnumber">6.3</span> <span class="toctext">How to write a new HID Application</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-31"><a href="#Mass_Storage_Device_Class"><span class="tocnumber">7</span> <span class="toctext">Mass Storage Device Class</span></a>
<ul>
<li class="toclevel-2 tocsection-32"><a href="#Initialization_and_Data_Flow"><span class="tocnumber">7.1</span> <span class="toctext">Initialization and Data Flow</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Block_Media_Access"><span class="tocnumber">7.2</span> <span class="toctext">Block Media Access</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#RAM_Disk_Support"><span class="tocnumber">7.3</span> <span class="toctext">RAM Disk Support</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#DMA_Support"><span class="tocnumber">7.4</span> <span class="toctext">DMA Support</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="#Example_Application_3"><span class="tocnumber">7.5</span> <span class="toctext">Example Application</span></a>
<ul>
<li class="toclevel-3 tocsection-37"><a href="#Running_the_Application_3"><span class="tocnumber">7.5.1</span> <span class="toctext">Running the Application</span></a></li>
<li class="toclevel-3 tocsection-38"><a href="#How_to_Integrate_Alternate_Block_Media"><span class="tocnumber">7.5.2</span> <span class="toctext">How to Integrate Alternate Block Media</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-39"><a href="#Composite_Device_Class"><span class="tocnumber">8</span> <span class="toctext">Composite Device Class</span></a>
<ul>
<li class="toclevel-2 tocsection-40"><a href="#Composite_CDC_Serial_and_HID-Mouse_device_Example_Application"><span class="tocnumber">8.1</span> <span class="toctext">Composite CDC Serial and HID-Mouse device Example Application</span></a>
<ul>
<li class="toclevel-3 tocsection-41"><a href="#Device_Enumeration"><span class="tocnumber">8.1.1</span> <span class="toctext">Device Enumeration</span></a></li>
<li class="toclevel-3 tocsection-42"><a href="#Running_the_Application_4"><span class="tocnumber">8.1.2</span> <span class="toctext">Running the Application</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-43"><a href="#Composite_Dual_CDC_Serial_Port_device_Example_Application"><span class="tocnumber">8.2</span> <span class="toctext">Composite Dual CDC Serial Port device Example Application</span></a>
<ul>
<li class="toclevel-3 tocsection-44"><a href="#Device_Enumeration_2"><span class="tocnumber">8.2.1</span> <span class="toctext">Device Enumeration</span></a></li>
<li class="toclevel-3 tocsection-45"><a href="#Running_the_Application_5"><span class="tocnumber">8.2.2</span> <span class="toctext">Running the Application</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-46"><a href="#USB_Host_Class"><span class="tocnumber">9</span> <span class="toctext">USB Host Class</span></a>
<ul>
<li class="toclevel-2 tocsection-47"><a href="#Host_Class_Enumeration"><span class="tocnumber">9.1</span> <span class="toctext">Host Class Enumeration</span></a></li>
<li class="toclevel-2 tocsection-48"><a href="#USB_Pipes"><span class="tocnumber">9.2</span> <span class="toctext">USB Pipes</span></a></li>
<li class="toclevel-2 tocsection-49"><a href="#Control_Transactions"><span class="tocnumber">9.3</span> <span class="toctext">Control Transactions</span></a></li>
<li class="toclevel-2 tocsection-50"><a href="#Interrupt_Handling"><span class="tocnumber">9.4</span> <span class="toctext">Interrupt Handling</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-51"><a href="#HID_Host_Class"><span class="tocnumber">10</span> <span class="toctext">HID Host Class</span></a>
<ul>
<li class="toclevel-2 tocsection-52"><a href="#Device_Interface"><span class="tocnumber">10.1</span> <span class="toctext">Device Interface</span></a></li>
<li class="toclevel-2 tocsection-53"><a href="#Example_Application_.28Mouse.29"><span class="tocnumber">10.2</span> <span class="toctext">Example Application (Mouse)</span></a>
<ul>
<li class="toclevel-3 tocsection-54"><a href="#Running_the_Application_6"><span class="tocnumber">10.2.1</span> <span class="toctext">Running the Application</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-55"><a href="#Writing_a_New_HID_Host_Application"><span class="tocnumber">10.3</span> <span class="toctext">Writing a New HID Host Application</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-56"><a href="#Mass_Storage_Host_Class"><span class="tocnumber">11</span> <span class="toctext">Mass Storage Host Class</span></a>
<ul>
<li class="toclevel-2 tocsection-57"><a href="#Device_Interface_2"><span class="tocnumber">11.1</span> <span class="toctext">Device Interface</span></a></li>
<li class="toclevel-2 tocsection-58"><a href="#Host_SCSI_Layer"><span class="tocnumber">11.2</span> <span class="toctext">Host SCSI Layer</span></a></li>
<li class="toclevel-2 tocsection-59"><a href="#Example_Application_4"><span class="tocnumber">11.3</span> <span class="toctext">Example Application</span></a>
<ul>
<li class="toclevel-3 tocsection-60"><a href="#Running_the_Application_7"><span class="tocnumber">11.3.1</span> <span class="toctext">Running the Application</span></a></li>
<li class="toclevel-3 tocsection-61"><a href="#Integrating_a_Different_File_System"><span class="tocnumber">11.3.2</span> <span class="toctext">Integrating a Different File System</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-62"><a href="#Multi-instance_Support_Information"><span class="tocnumber">12</span> <span class="toctext">Multi-instance Support Information</span></a>
<ul>
<li class="toclevel-2 tocsection-63"><a href="#MSC_Device_.2B_MSC_Host_Example_Application"><span class="tocnumber">12.1</span> <span class="toctext">MSC Device + MSC Host Example Application</span></a>
<ul>
<li class="toclevel-3 tocsection-64"><a href="#Running_the_Application_8"><span class="tocnumber">12.1.1</span> <span class="toctext">Running the Application</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-65"><a href="#MSC_Host_.2B_MSC_Mouse_Example_Application"><span class="tocnumber">12.2</span> <span class="toctext">MSC Host + MSC Mouse Example Application</span></a>
<ul>
<li class="toclevel-3 tocsection-66"><a href="#Running_the_Application_9"><span class="tocnumber">12.2.1</span> <span class="toctext">Running the Application</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-67"><a href="#Performance"><span class="tocnumber">13</span> <span class="toctext">Performance</span></a>
<ul>
<li class="toclevel-2 tocsection-68"><a href="#Steps_to_capture_performance"><span class="tocnumber">13.1</span> <span class="toctext">Steps to capture performance</span></a></li>
<li class="toclevel-2 tocsection-69"><a href="#Performance_Figures_Table"><span class="tocnumber">13.2</span> <span class="toctext">Performance Figures Table</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-70"><a href="#Connector_Information"><span class="tocnumber">14</span> <span class="toctext">Connector Information</span></a></li>
<li class="toclevel-1 tocsection-71"><a href="#_Limitations"><span class="tocnumber">15</span> <span class="toctext">&#160;Limitations</span></a></li>
</ul>
</div>

<h1><span class="mw-headline" id="Introduction">Introduction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=1" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The StarterWare USB stack is an OS-independent USB solution that is migrated from the StellarisWare. For more information on the original StellarisWare USB library, please refer to the <a rel="nofollow" class="external text" href="http://focus.ti.com/docs/toolsw/folders/print/sw-usbl.html#Technical%20Documents">StellarisWare user guide</a>. 
</p><p>The API reference guide for StarterWare USB is available as part of release package. Look for the <tt>[Device]_StarterWare_x_xx_xx_xx.chm</tt> file in <tt>docs</tt> for the for detailed API documentation. 
</p><p>The StarterWare USB stack currently supports the following features: 
</p>
<table style="width: 1200px; height: 140px" cellspacing="1" cellpadding="1" width="1200" align="center" border="1">

<tbody><tr>
<td rowspan="2"><b>Release</b>
</td>
<td valign="middle" align="center" colspan="5"><b>Device Mode</b>
</td>
<td valign="middle" align="center" colspan="3"><b>Host Mode</b>
</td>
<td valign="middle" align="center" colspan="2"><b>Host + Device Mode</b>
</td>
<td valign="middle" align="center" colspan="2"><b>Host + Host Mode</b>
</td></tr>
<tr>
<td><a href="#CDC_Device_Class"><b>CDC Serial (PIO Mode)</b></a>
</td>
<td><a href="#Bulk_Device_Class"><b>Custom Bulk (PIO Mode)</b></a>
</td>
<td><a href="#HID_Device_Class"><b>HID Mouse (PIO Mode)</b></a>
</td>
<td><a href="#Mass_Storage_Device_Class"><b>MSC (PIO Mode)</b></a>
</td>
<td><a href="#Mass_Storage_Device_Class"><b>MSC (DMA Mode)</b></a>
</td>
<td><a href="#HID_Host_Class"><b>HID Mouse (PIO Mode)</b></a>
</td>
<td><a href="#Mass_storage_Host_Class"><b>MSC (PIO Mode)</b></a>
</td>
<td><a href="#Mass_storage_Host_Class"><b>MSC (DMA Mode)</b></a>
</td>
<td><a href="#Mass_storage_Host_Device_Class"><b>MSC (PIO Mode)</b></a>
</td>
<td><a href="#Mass_storage_Host_Device_Class"><b>MSC (DMA Mode)</b></a>
</td>
<td><a href="#Host_Host_Class"><b>MSC (PIO Mode)/Mouse (PIO Mode)</b></a>
</td>
<td><a href="#Host_Host_Class"><b>MSC (DMA Mode)/Mouse (PIO Mode)</b></a>
</td></tr>
<tr>
<td>1.00.01.01
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td></tr>
<tr>
<td>1.10.01.01
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td></tr>
<tr>
<td>1.20.01.01
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td></tr>
<tr>
<td>2.00.00.05(AM335x EVM)
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td></tr>
<tr>
<td>2.00.00.05(AM335x Beaglebone)
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td></tr>
<tr>
<td>2.00.00.06(AM335x EVM)
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>YES
</td>
<td>NO
</td>
<td>NO
</td></tr>
<tr>
<td>2.00.00.06(AM335x Beaglebone)
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td>
<td>NO
</td></tr>
<tr>
<td>2.00.00.07(AM335x EVM)
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td></tr>
<tr>
<td>2.00.00.07(AM335x Beaglebone)
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>NO
</td></tr>
<tr>
<td>2.00.00.07(AM335x EVMSK)
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>YES
</td>
<td>NO
</td>
<td>NO
</td></tr></tbody></table>
<h1><span class="mw-headline" id="Comparison_to_StellarisWare_USB">Comparison to StellarisWare USB</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=2" title="Edit section: Comparison to StellarisWare USB">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The following table compares the StarterWare and StellarisWare USB stacks. 
</p>
<table style="width: 773px; height: 203px" rules="all" align="center" border="1">

<tbody><tr>
<td><b>Feature</b>
</td>
<td><b>AM1808/OMAPL138/C6748</b>
</td>
<td><b>AM335x</b>
</td>
<td><b>Stellaris USB Subsystem</b>
</td></tr>
<tr>
<td><b>Core IP</b>
</td>
<td>MUSB
</td>
<td>MUSB
</td>
<td>MUSB
</td></tr>
<tr>
<td><b>Number Of Endpoints</b>
</td>
<td>4 + 1
</td>
<td>15 + 1
</td>
<td>15 + 1
</td></tr>
<tr>
<td><b>DMA</b>
</td>
<td>CPPI DMA 4.1
</td>
<td>CPPI DMA 4.1
</td>
<td>Micro DMA
</td></tr>
<tr>
<td><b>Mapped to Wrapper Registers</b>
</td>
<td>Yes, Only the Interrupt registers
</td>
<td>Yes, Only the Interrupt registers
</td>
<td>No
</td></tr>
<tr>
<td><b>Endpoint 0 FIFO size</b>
</td>
<td>64 Bytes
</td>
<td>64 Bytes
</td>
<td>64 Bytes
</td></tr>
<tr>
<td><b>Other Endpoint FIFO</b>
</td>
<td>8 to 8192 bytes configurable (Verified for 64/512 only)
</td>
<td>8 to 8192 bytes configurable (Verified for 64/512 only)
</td>
<td>8 to 8192 bytes configurable
</td></tr>
<tr>
<td><b>Speed</b>
</td>
<td>High Speed/Full Speed (Refer to Class Description for details)
</td>
<td>High Speed/Full Speed (Refer to Class Description for details)
</td>
<td>High Speed Not Supported
</td></tr></tbody></table>
<h1><span class="mw-headline" id="Core_Design">Core Design</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=3" title="Edit section: Core Design">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The following diagram shows the architecture of the StarterWare USB stack.
</p><p><a href="File_USB_Design.html" class="image"><img alt="USB Design.JPG" src="https://processors.wiki.ti.com/images/9/9b/USB_Design.JPG" width="804" height="723" /></a> 
</p>
<h2><span id="Mentor_Controller_Device_Abstraction_Layer_(MUSB_DAL)"></span><span class="mw-headline" id="Mentor_Controller_Device_Abstraction_Layer_.28MUSB_DAL.29">Mentor Controller Device Abstraction Layer (MUSB DAL)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=4" title="Edit section: Mentor Controller Device Abstraction Layer (MUSB DAL)">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The USBOTG Subsystem is based on Mentor Graphics USB Controller. IP core supports 4Tx/4Rx endpoints and an integrated CPPI41 DMA engine. The Device Abstraction Layer (DAL) is the only module in StarterWare USB which directly communicates with the Mentor controller. The MUSB DAL layers abstracts all the functionalities or services used by the layer above to configure and control the USB OTG Controller. The DAL APIs are used by the other components of device or host stack. 
</p><p>The MUSB DAL is implemented in single file (<tt>usb.c</tt>), and important APIs are summarized below. 
</p>
<ul><li><tt>USBDevConnect</tt> - Connects the USB controller to the bus in device mode. This API is used by the USB Core module during initialization.</li>
<li><tt>USBDevDisconnect</tt> - Removes the USB controller from the bus in device mode. This API is used by the USB core while unplugging or resetting the device.</li>
<li><tt>USBReset</tt> - Resets the USB controller. This API is used by the core during enumeration or whenever the reset is necessary.</li>
<li><tt>USBEndpointDataPut</tt> - Puts data into the given endpoint's FIFO. This API is used by the individual device stack.</li>
<li><tt>USBEndpointDataSend</tt> - Starts the transfer of data from an endpoint's FIFO. This API is used by the individual device stack in order to send the data.</li>
<li><tt>USBEndpointDataGet</tt> - Retrieves data from the given endpoint's FIFO. This API is used by the individual device stack.</li></ul>
<h2><span class="mw-headline" id="Device_Core_Layer">Device Core Layer</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=5" title="Edit section: Device Core Layer">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The Device Core Layer is responsible for device enumeration and handling all of the control transfers. The interrupt service routine (ISR) is a part of the core, so interrupt handling is also done by the core. The typical tasks handled by the device core layer are as follows:
</p>
<ul><li>Initialize the device controller driver</li>
<li>Enable clocking to the USB controller</li>
<li>Switch on the USB PHY</li>
<li>USB enumeration handling</li>
<li>Interrupt handling</li>
<li>Standard request handling</li>
<li>Terminate the device controller driver</li></ul>
<p>The standard requests that are handled by the device core are as follows:
</p>
<ul><li><tt>USBDGetStatus</tt></li>
<li><tt>USBDClearFeature</tt></li>
<li><tt>USBDSetFeature</tt></li>
<li><tt>USBDSetAddress</tt></li>
<li><tt>USBDGetDescriptor</tt></li>
<li><tt>USBDSetDescriptor</tt></li>
<li><tt>USBDGetConfiguration</tt></li>
<li><tt>USBDSetConfiguration</tt></li>
<li><tt>USBDGetInterface</tt></li>
<li><tt>USBDSetInterface</tt></li>
<li><tt>USBDSyncFrame</tt></li></ul>
<p>In <tt>USBDeviceIntHandlerInternal</tt>, the device core layer handles the following interrupts, invoking their corresponding callbacks:
</p>
<ul><li><tt>Reset</tt></li>
<li><tt>Suspend</tt></li>
<li><tt>Resume</tt></li>
<li><tt>Disconnect</tt></li>
<li><tt>Start of Frame</tt> (SOF)</li>
<li><tt>Endpoint Interrupt</tt></li></ul>
<p>The initialization API is called by the class driver in order to start enumeration. Once enumeration is started, all of the standard request routines are called from the ISR in response to the appropriate interrupt event. For any class-specific request, the application or class driver must register the callback handler with the core so that the ISR can branch there when necessary. 
</p><p>The device core layer is implemented by a single source file, <tt>usbdenum.c</tt>. The major APIs provided by this layer are summarized below:
</p>
<ul><li><tt>USBDCDInit</tt> - Initializes the USB library device control driver for a given hardware controller. This API is used by the individual class stack.</li>
<li><tt>USBDCDTerm</tt> - Frees the USB library device control driver for a given hardware controller.</li>
<li><tt>USBDCDSendDataEP0</tt> - Requests transfer of data to the host on endpoint zero.</li>
<li><tt>USBDCDStallEP0</tt> - Generates a stall condition on endpoint zero.</li>
<li><tt>USBDeviceEnumHandler</tt> - Interrupt handler for endpoint zero.</li>
<li><tt>USBDeviceIntHandlerInternal</tt> - Internal USB device interrupt handler.</li></ul>
<h2><span class="mw-headline" id="USB_Configuration_Layer">USB Configuration Layer</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=6" title="Edit section: USB Configuration Layer">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This layer contains all of the parameters required to configure the USB device. These parameters include VID, PID, Descriptors, event handlers, buffers, and more. These parameters are specified by the application writer. Once all the information is fed in to this layer, the configuration layer can give a device instance structure to the other layers within the USB stack. This device instance contains all of the information regarding the device, and the required information is extracted when necessary. 
</p><p>This layer is considered to be part of application, and most of the data is specified by the application programmer. This layer is implemented by the source file <tt>usb_serial_structs.c</tt>.  The following parameters are configurable by the application programmer: 
</p>
<ul><li>Global instance for the USB device structure</li>
<li>Rx and Tx Buffers</li>
<li>Vendor ID</li>
<li>Product ID</li>
<li>Power configuration parameters</li>
<li>Control event call backs</li>
<li>Application event call backs</li>
<li>String descriptors</li>
<li>Language descriptor</li></ul>
<h2><span class="mw-headline" id="System_Configuration_Layer">System Configuration Layer</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=7" title="Edit section: System Configuration Layer">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This layer provides APIs which can be used to configure platform-related parameters such as the clock speed, timers, pinmux, and more. These parameters are specified by the application developers as well as the underlying peripheral driver (i.e. DAL). Sometimes the entire system behavior depends on these parameters (ex. clock speed), so it is very important to select appropriate values for these parameters.
</p>
<h1><span class="mw-headline" id="CDC_Device_Class">CDC Device Class</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=8" title="Edit section: CDC Device Class">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p><a href="File_Sitaraware_USB.html" class="image"><img alt="Sitaraware USB.JPG" src="https://processors.wiki.ti.com/images/0/08/Sitaraware_USB.JPG" width="804" height="725" /></a> 
</p><p>The USB Communication Device Class (CDC) class driver supports the CDC Abstract Control Model variant and allows a client application to be seen as a virtual serial port to the USB host system. The driver provides two channels: one transmit and one receive. The channels may be used in conjunction with USB buffers to provide a simple read/write interface for data transfer to and from the host. Additional APIs and events are used to support serial link-specific operations such as notification of UART errors, sending break conditions, and setting communication line parameters. The data transmission capabilities of this device class driver are very similar to the generic bulk class, but (because this is a standard device class) the host operating system should be able to access the device without the need for any host-side drivers. On Windows, a simple INF file is all that is required to make the USB device appear as a COM port that can be accessed by any serial terminal application. This device class uses three endpoints in addition to endpoint zero. Two bulk endpoints carry data to and from the host and an interrupt IN endpoint is used to signal any serial errors such as break, framing error, or parity error detected by the device. Endpoint zero carries standard USB requests and also CDC-specific requests which translate to events passed to the application via the control channel callback . This layer is implemented in the source file <tt>usbdcdc.c</tt>. 
</p><p><br />
</p>
<h2><span class="mw-headline" id="Example_Application">Example Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=9" title="Edit section: Example Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Running_the_Application">Running the Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=10" title="Edit section: Running the Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li><b>Since this is a USB device mode application, the target (EVM) must be connected to host (Windows PC) by a USB cable.</b></li>
<li>Connect your host PC's serial port to the UART connector on the EVM using a null modem cable.</li>
<li>The CDC device requires an INF file at the host side in order to enable as virtual COM port. Please use the INF provided in the <tt>tools/usb_inf</tt> folder.
<ul><li>The INF file is required only with a windows based host.</li>
<li>To use different VID and PID, the INF file must be updated with the new VID and PID.</li></ul></li>
<li>Once the device is connected to the host, the host will ask for INF file. The user must browse to the INF file to proceed.</li></ul>
<p><a href="File_Cdc11.html" class="image"><img alt="Cdc11.JPG" src="https://processors.wiki.ti.com/images/b/be/Cdc11.JPG" width="499" height="393" /></a> 
</p>
<ul><li>Once the proper INF file is pointed out by the user, then virtual COM port will appear in the device manager</li></ul>
<p><a href="File_Cdc12.html" class="image"><img alt="Cdc12.JPG" src="https://processors.wiki.ti.com/images/2/25/Cdc12.JPG" width="639" height="448" /></a> 
</p>
<ul><li>Open a serial terminal application (ex. Teraterm, Hyperterminal) and choose the virtual COM port.</li></ul>
<p><a href="File_Cdc13.html" class="image"><img alt="Cdc13.JPG" src="https://processors.wiki.ti.com/images/f/f2/Cdc13.JPG" width="859" height="581" /></a> 
</p>
<ul><li>Set the parameters as shown.</li></ul>
<p><a href="File_Cdc14.html" class="image"><img alt="Cdc14.JPG" src="https://processors.wiki.ti.com/images/d/db/Cdc14.JPG" width="860" height="578" /></a> 
</p>
<ul><li>Open another terminal window and choose COM1 (or whichever serial port you previously connected to the EVM's UART connector).</li>
<li>Type in either terminal window on the host PC.  The text should appear on the other terminal screen.</li></ul>
<p><b>Note:</b> The CDC class is configured and tested for Hi-Speed PIO mode only
</p><p>Modules used by this application:
</p>
<ul><li>USB</li>
<li>Interrupt</li></ul>
<h3><span class="mw-headline" id="CDC_Device_Enumeration">CDC Device Enumeration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=11" title="Edit section: CDC Device Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The Application main must perform the following steps:
</p>
<ul><li>Configure the system interrupts</li>
<li>Register the interrupt handler (i.e. ISR)</li>
<li>Initialize the buffers</li>
<li>Call <tt>USBDCDCInit()</tt> with the device instance structure as a parameter</li></ul>
<p>With this call, control is given to the CDC device class layer. The device class layer must perform the following steps:
</p>
<ul><li>Assign endpoints to the device instance structure</li>
<li>Apply the configuration descriptor to the device instance structure</li>
<li>Call <tt>USBDCDInit()</tt> and pass the device instance structure to the core</li></ul>
<p>With this call, control is passed to the core layer. The core layer must perform the following steps in order to complete enumeration:
</p>
<ul><li>Enable the PSC clock</li>
<li>Reset the USB module</li>
<li>Switch on the USB PHY</li>
<li>Initialize the USB tick module</li>
<li>Clear all pending interrupts</li>
<li>Enable the required interrupts</li>
<li>Set the configuration parameters</li>
<li>Disconnect the device</li>
<li>Reconnect the device</li></ul>
<p>Now the device will start receiving interrupts from the host. The interrupt handler in the core layer will identify all of the Ep0 interrupts and call the appropriate handler. If all the standard requests are serviced by the device, then enumeration is complete and the device is ready for communication. Now control return to the application and wait for data interrupts. 
</p><p><a href="File_Control1.html" class="image"><img alt="Control1.JPG" src="https://processors.wiki.ti.com/images/b/bc/Control1.JPG" width="581" height="422" /></a> 
</p>
<h3><span id="CONNECT_/_DISCONNECT"></span><span class="mw-headline" id="CONNECT_.2F_DISCONNECT">CONNECT / DISCONNECT</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=12" title="Edit section: CONNECT / DISCONNECT">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If required, the MUSB can allow software to control its connection to the USB bus. When the Soft Connect/Disconnect option is selected with the MUSB operating in peripheral mode, the UTMI+-compliant PHY (used alongside the MUSB) can be switched between normal mode and non-driving mode by setting or clearing bit 6 of the Power register.  (This bit is identified as the Soft Conn bit.) When this Soft Conn bit is set to 1, the PHY is placed in its normal mode and the D+/D- lines of the USB bus are enabled. At the same time, the MUSB is placed in "Powered" state, where it will not respond to any USB signaling except a USB reset. When this feature is enabled and the Soft Conn bit is zero, the PHY is put into non-driving mode, D+ and D- are tri-stated, and the MUSB appears to other devices on the USB bus as if it has been disconnected. 
</p><p>After a hardware reset (NRST = 0), Soft Conn is cleared to 0. The MUSB will therefore appear disconnected until the software sets Soft Conn to 1. The application software can then choose when to set the PHY into its normal mode. Systems with a lengthy initialization procedure may use this to ensure that initialization is complete and the system is ready to perform enumeration before connecting to the USB. Once the Soft Conn bit has been set to 1, the software can also simulate a disconnect by clearing this bit to 0. 
</p>
<h3><span class="mw-headline" id="USB_Tick_module">USB Tick module</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=13" title="Edit section: USB Tick module">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The USB tick module contains the functions related to USB stack tick timer handling. It has functions to initialize the variables used in processing timer ticks, function handles registering OTG, Host, or Device SOF timer handler functions. This module is implemented in the source file <tt>usbtick.c</tt>.
</p>
<h3><span class="mw-headline" id="CDC_Application_Data_Flow">CDC Application Data Flow</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=14" title="Edit section: CDC Application Data Flow">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><a href="File_Cdc_data_flow.html" class="image"><img alt="Cdc data flow.JPG" src="https://processors.wiki.ti.com/images/8/86/Cdc_data_flow.JPG" width="778" height="684" /></a> 
</p>
<h4><span id="Data_out_Flow_(From_Host_to_Device)"></span><span class="mw-headline" id="Data_out_Flow_.28From_Host_to_Device.29">Data out Flow (From Host to Device)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=15" title="Edit section: Data out Flow (From Host to Device)">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>When data arrives from the host, the device will receive an interrupt from the host. The interrupt handler must perform the following steps on reception:
</p>
<ul><li>Read the interrupt status register</li>
<li>Identify the interrupt</li>
<li>Call the appropriate handler (i.e. Read Data handler)</li>
<li>Read handler checks whether the RX Packet Ready bit is set</li>
<li>Check the number of byte available in the buffer</li>
<li>Read the data to buffer</li>
<li>Clear the RX Packet Ready bit</li>
<li>Give the read data to the application</li></ul>
<p><a href="File_RX_mode1.html" class="image"><img alt="RX mode1.jpg" src="https://processors.wiki.ti.com/images/9/99/RX_mode1.jpg" width="354" height="725" /></a> 
</p>
<h5><span class="mw-headline" id="Count_Register">Count Register</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=16" title="Edit section: Count Register">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>RxCount is a 13-bit read-only register that holds the number of received data bytes in the packet currently in line to be read from the Rx FIFO. If the packet was transmitted as multiple bulk packets, the number given will be for the combined packet. The value returned changes as the FIFO is unloaded and is only valid while RxPktRdy is set.
</p>
<h4><span id="Data_in_Flow_(From_Device_to_Host)"></span><span class="mw-headline" id="Data_in_Flow_.28From_Device_to_Host.29">Data in Flow (From Device to Host)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=17" title="Edit section: Data in Flow (From Device to Host)">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>When the device side application needs to send data to the host, the device must follow the below steps. 
</p>
<ul><li>Application calls the write data API and passes the data buffer to the CDC layer</li>
<li>Write data API checks the amount of data to be sent</li>
<li>Copy data the TX buffer</li>
<li>Set the TX Packet Ready bit</li>
<li>After the transmit operation completes, the host sends a TX completion interrupt</li>
<li>TX Packet Ready bit will be cleared automatically</li>
<li>After receiving the TX Complete Interrupt, the ISR sends an event to the application indicating the completion of data transfer</li></ul>
<p><a href="File_TX_mode.html" class="image"><img alt="TX mode.JPG" src="https://processors.wiki.ti.com/images/e/e5/TX_mode.JPG" width="427" height="725" /></a> 
</p>
<h2><span class="mw-headline" id="How_To_Write_a_New_CDC_Device_Application">How To Write a New CDC Device Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=18" title="Edit section: How To Write a New CDC Device Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A new application must take the following steps to add CDC transmit and receive capability. 
</p>
<ul><li>Define the 6-entry string descriptor table, which is used to describe various features of your new device (i.e. application) to the host system.</li>
<li>Define a <tt>tCDCSerInstance</tt> structure, which the USB CDC serial device class driver uses to store its internal state information. This should never be accessed directly by the application.<br /><pre>tCDCSerInstance g_sSerialInstance;</pre></li>
<li>Define a <tt>tUSBDCDCDevice</tt> structure and initialize all fields as required by your application.</li>
<li>Add a receive event handler function to your application. This function must handle all messages that require a particular response. For the CDC device class, <tt>USB_EVENT_RX_AVAILABLE</tt> and <tt>USB_EVENT_DATA_REMAINING</tt> <b>must</b> be handled by the receive event handler.</li>
<li>Add a transmit event handler function to your application. This function must handle all messages that require a particular response. For the CDC device class, there are no events sent to the transmit callback that <b>must</b> be handled, but applications typically handle <tt>SB_EVENT_TX_COMPLETE</tt> since this is an interlock message indicating that the previous packet sent has been acknowledged by the host and a new packet can now be sent.</li>
<li>Add a control event handler function to your application and ensure that it handles <tt>USBD_CDC_EVENT_GET_LINE_CODING</tt>, returning a valid line coding configuration even if the device is not actually driving a UART. Handle any other control events as required by your application.</li>
<li>From your main initialization function call the CDC device class driver initialization function to configure the USB controller and place the device on the bus.<br /><pre>pDevice = USBDCDCInit(0, &amp;g_sCDCDevice);</pre></li>
<li>Assuming <tt>pDevice</tt> returned is not NULL, the device is now ready to communicate with a USB host.</li>
<li>Once the host connects, your control event handler will be receive a <tt>USB_EVENT_CONNECTED</tt> event, and the first packet of data may be sent to the host as soon as <tt>USB_EVENT_TX_COMPLETE</tt> is received via the transmit event handler.</li></ul>
<p>For connector information please check the connector information <a href="#Connector_Information">table</a> 
</p>
<h2><span class="mw-headline" id="Power_Configuration">Power Configuration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=19" title="Edit section: Power Configuration">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The power configuration for the CDC class device is held in two of the <tt>tUSBDCDCDevice</tt> members variables, <tt>usMaxPowermA</tt> and <tt>ucPwrAttributes</tt>. The <tt>usMaxPowermA</tt> variable holds the maximum power consumption for the device and is expressed in milliamps. The power configuration is held in the <tt>ucPwrAttributes</tt> member variable and indicates whether the device is self- or bus-powered. Valid values are <tt>USB_CONF_ATTR_SELF_PWR</tt> or <tt>USB_CONF_ATTR_BUS_PWR</tt>.
</p>
<h1><span class="mw-headline" id="Bulk_Device_Class">Bulk Device Class</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=20" title="Edit section: Bulk Device Class">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p><a href="File_Bulk.html" class="image"><img alt="Bulk.JPG" src="https://processors.wiki.ti.com/images/3/3c/Bulk.JPG" width="804" height="723" /></a>  
</p><p>The generic bulk device class driver offers a very simple method for an application to set up USB communication with a paired application running on the USB host system. The class driver offers a single bulk receive channel and a single bulk transmit channel and, when coupled with USB buffers on each channel, provides a straightforward read/write interface to the application. The device supports a single interface containing bulk IN and bulk OUT endpoints. The configuration and interface descriptors published by the device contain vendor-specific class identifiers, so an application on the host will have to communicate with the device using either a custom driver or a subsystem such as WinUSB or libusb-win32 on Windows to allow the device to be accessed. An example of this is provided in the usb_dev_bulk application. This class driver is particularly useful for applications that need to pass high volumes of data via USB and where host-side application code is being developed in partnership with the device. 
</p>
<h2><span class="mw-headline" id="Bulk_Device_Enumeration">Bulk Device Enumeration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=21" title="Edit section: Bulk Device Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>An application using the USB bulk device class must perform the following initialization steps:
</p>
<ul><li>Configure the system interrupts</li>
<li>Register the interrupt handler (i.e. ISR)</li>
<li>Initialize the buffers</li>
<li>Call the <tt>USBDBulkInit()</tt> API with the device instance structure as a parameter</li></ul>
<p>This function call gives contol to the bulk device class layer. The device class layer then performs the following steps:
</p>
<ul><li>Assign the endpoints to the device instance structure</li>
<li>Assign the configuration descriptor to the device instance structure.</li>
<li>Call the <tt>USBDCDInit()</tt> API and pass the device instance structure to the core</li></ul>
<p>This function call gives contol to the core layer. The core layer then performs the following steps in order to complete the bulk device enumeration:
</p>
<ul><li>Enable the PSC clock</li>
<li>Reset the USB module</li>
<li>Switch on the USB PHY</li>
<li>Initialize the USB tick module</li>
<li>Clear all pending interrupts</li>
<li>Enable the required interrupts</li>
<li>Set the configuration parameters</li>
<li>Disconnect the device</li>
<li>Reconnect the device</li></ul>
<p>Now the device will start receiving interrupts from the host. The interrupt handler in the core layer will identify all the Ep0 interrupts and call the appropriate handler. Once all the standard requests are serviced by the device, enumeration is complete and the device is ready for communication. Now control will return to the application to wait for data interrupts.
</p><p><a href="File_Bulk_enum.html" class="image"><img alt="Bulk enum.JPG" src="https://processors.wiki.ti.com/images/0/05/Bulk_enum.JPG" width="636" height="499" /></a>
</p>
<h2><span class="mw-headline" id="How_to_Write_a_New_Bulk_Application">How to Write a New Bulk Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=22" title="Edit section: How to Write a New Bulk Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To add USB bulk data transmit and receive capability to an application, take the following steps:
</p>
<ul><li>Add the following header files to the source file(s) that will support USB:<br /><pre>#include "usb.h"</pre><pre>#include "usblib.h"</pre><pre>#include "usbdevice.h"</pre><pre>#include "usbdbulk.h"</pre></li>
<li>Define the 5-entry string table that is used to describe various features of your new device to the host system.</li>
<li>Define an area of RAM of for the private data for the bulk device class driver. This structure should never be accessed by the application.</li>
<li>Define a <tt>tUSBDBulkDevice</tt> structure and initialize all fields as required for your application. The following example illustrates a simple case where no USB buffers are in use. For an example using USB buffers, see the source file <tt>usb_bulk_structs.c</tt> in the usb_dev_bulk example application.</li>
<li>Add a receive event handler function (ex. <tt>YourUSBReceiveEventCallback()</tt> in the previous example) to your application, taking care to handle all messages that require a particular response. For the generic bulk device class, only the <tt>USB_EVENT_RX_AVAILABLE</tt> <b>must</b> be handled by the receive event handler. In response to <tt>SB_EVENT_RX_AVAILABLE</tt>, your handler should check the amount of data received by calling the <tt>USBDBulkRxPacketAvailable()</tt> API then read it by calling <tt>USBDBulkPacketRead()</tt>. This causes the newly received data to be acknowledged to the host and instructs the host that it may now transmit another packet. If you are unable to read the data immediately, return 0 from the callback handler and it will be called again a few milliseconds later. Although no other events must be handled, <tt>USB_EVENT_CONNECTED</tt> and <tt>USB_EVENT_DISCONNECTED</tt> are typically required since these indicate when a host connects or disconnects and allow the application to flush any buffers or reset state as required. Attempts to send data when the host is disconnected will fail.</li>
<li>Add a transmit event handler function (ex. <tt>YourUSBTransmitEventCallback()</tt> in the previous example) to your application, taking care to handle all messages that require a particular response. For the generic bulk device class, there are no events sent to the transmit callback that <b>must</b> be handled, but applications typically want to note <tt>USB_EVENT_TX_COMPLETE</tt> since this is an interlock message indicating that the previous packet sent has been acknowledged by the host and a new packet can now be sent</li>
<li>From your main initialization function call the generic bulk device class driver initialization function to configure the USB controller and place the device on the bus.<br /><pre>pDevice = USBDBulkInit(0, &amp;g_sBulkDevice);</pre></li>
<li>Assuming <tt>pDevice</tt> returned is not NULL, your device is now ready to communicate with a USB host. Once the host connects, your receive event handler receives <tt>USB_EVENT_CONNECTED</tt>, and the first packet of data may be sent to the host using the <tt>USBDBulkPacketWrite()</tt> API as soon as <tt>USB_EVENT_TX_COMPLETE</tt> is received.<br /></li></ul>
<h2><span class="mw-headline" id="Windows_Drivers_for_Generic_Bulk_Devices">Windows Drivers for Generic Bulk Devices</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=23" title="Edit section: Windows Drivers for Generic Bulk Devices">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Since generic bulk devices appear to a host operating system as vendor-specific devices, no device drivers on the host system will be able to communicate with them without device-specific drivers. This require writing a Windows kernel driver for the device or, if that task is too daunting, steering Windows to use one of several generic kernel drivers that can manage the device with assistance from a Windows application. The second option does not require the developer to write any Windows driver code, but the developer instead needs to to write an application or DLL that interfaces with the device via user-mode APIs offered by generic USB drivers. 
</p><p>The developer is also responsible for producing a suitable INF file to allow Windows to associate the device (identified via its VID/PID combination) with a particular driver. A least two suitable USB subsystems are available for Windows:
</p>
<ol><li><b>WinUSB</b> - from Microsoft</li>
<li><b>libusb-win32</b> - an opensource project available from SourceForge</li></ol>
<p>WinUSB supports only WindowsXP and Vista systems. Further information can be obtained from the <a rel="nofollow" class="external text" href="http://msdn.microsoft.com/en-us/library/aa476426.aspx">MSDN website</a>. 
</p><p>To develop applications using WinUSB, the Windows Driver Development Kit (DDK) must be installed on your host PC. These applications can be found in the package PDL-LM3S-win, which is available for downloaded from the <a rel="nofollow" class="external text" href="http://www.luminarymicro.com/products/software_updates.html">Stellaris website</a>. 
</p><p>libusb-win32 supports all versions of Windows from Windows98SE onward and can be downloaded from the <a rel="nofollow" class="external text" href="http://libusb-win32.sourceforge.net/">SourceForge website</a>.
</p>
<h2><span class="mw-headline" id="Running_the_Example_Application">Running the Example Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=24" title="Edit section: Running the Example Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li>Download and install Windows host driver and application (SW-USB-WIN and SW-USB-WINDRIVERS) from the <a rel="nofollow" class="external text" href="http://www.luminarymicro.com/products/software_updates.html">StellarisWare download page</a>.
<ul><li>The INF file is located at <tt>windows_drivers/usb_dev_bulk.inf</tt>.</li>
<li>The host application is located at <tt>usb_examples/usb_bulk_example.exe</tt>.</li>
<li>The host application should only be run <b>after</b> the target application is already running (see below).</li></ul></li>
<li>Build and download the usb_dev_bulk application to the target board .</li>
<li>Connect the target board to PC via a USB cable.</li>
<li>When Windows detects your target device, browse to the INF file downloaded above.</li>
<li>Open the host application on the host PC. (Note: the host application will fail if you run it before the target application is running and connected to the PC.)</li>
<li>Type any text in the host application window to send it to the target device.</li>
<li>Follow the instructions from the host application to stop execution.</li></ul>
<p><b>Note:</b> The bulk class is configured and tested for Full-Speed PIO mode only
</p><p>For connector information please check the connector information <a href="#Connector_Information">table</a>
</p><p>Modules used by this application: 
</p>
<ul><li>USB</li>
<li>Interrupt</li>
<li>Timer (for 100 ms delay during USB enumeration; graphics too?)</li>
<li>UART (non-interrupt; for debug output)</li>
<li>LCDC (raster mode; display # bytes transferred )</li></ul>
<h1><span class="mw-headline" id="HID_Device_Class">HID Device Class</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=25" title="Edit section: HID Device Class">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p><span style="color: red"><b>Please note that in the current EVM only uses touchscreen hardware as the pointer device. The below text uses </b>HIDMouse<b> as a generic term to refer to this.</b></span> 
</p><p>The USB Human Interface Class device class supports a wide variety of input/output devices, not all of which actually pertain to "Human Interfaces." While the most commonly supported devices are keyboards, mice, and joysticks, the specification can cover practically any device offering user controls or data gathering functionality. Communication between the HID device and host is conducted according to a collection of "report" structures.  The device populates HID report descriptors, which the host can query. Reports are defined both for communication of device input to the host and for output or feature selection from the host. 
</p><p>In addition to the flexibility offered by the basic architecture, HID devices also benefit from excellent operating system support for the class.  This means that device-specific drivers are generally not necessary.  For standard devices such as keyboards and joysticks, the device can connect to and operate with the host system without any new host software having to be written. Even in the case of a nonstandard or vendor-specific HID device, the operating system support makes writing the host-side software very straightforward compared to developing the device using a vendor-specific class.
</p><p>Despite these advantages, there is one downside to using HID. The interface is limited in the amount of data that can be transferred, so HID is not suitable for devices that need to use a significant percentage of the USB bus bandwidth. Devices are limited to a maximum of 64KB per second for each report descriptor they support. Multiple reports can be used if necessary, but high bandwidth devices are better implemented using a class that supports bulk rather than interrupt endpoints, such as CDC or the generic bulk device class.
</p><p>The HID device class uses one or two endpoints in addition to endpoint zero. One interrupt IN endpoint carries HID input reports from the device to the host. Output and Feature reports from the host to the device are typically carried via endpoint zero but devices with high host-to-device data rates can select to offer an independent interrupt OUT endpoint to carry these. Endpoint zero carries standard USB requests and also HID-specific descriptor requests. This layer is implemented in the source files <tt>Usbdhid.c</tt> and <tt>Usbdhidmouse.c</tt>.
</p><p><a href="File_Hid_Mouse.html" class="image"><img alt="Hid Mouse.JPG" src="https://processors.wiki.ti.com/images/d/d2/Hid_Mouse.JPG" width="804" height="723" /></a> 
</p>
<h2><span class="mw-headline" id="HID_Device_Enumeration">HID Device Enumeration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=26" title="Edit section: HID Device Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The Application must perform the following steps to enumerate the USB in HID device mode:
</p>
<ul><li>Configure the system interrupts</li>
<li>Register the Interrupt handlers</li>
<li>Initialize the buffers</li>
<li>Call the <tt>USBDHIDMouseInit()</tt> API with the device instance structure as a parameter</li></ul>
<p>With this call, control passes to the HID mouse layer, which performs the following additional steps:
</p>
<ul><li>Initialize the various fields in the instance structure</li>
<li>Initialize the HID device class instance structure based on input from the caller</li>
<li>Initialize the lower layer HID driver by calling the <tt>USBDHIDInit()</tt> API</li></ul>
<p>With this call, control passes to the HID device class layer, which performs the following additional steps: 
</p>
<ul><li>Assign the endpoints to the device instance structure</li>
<li>Assign the configuration descriptor to the device instance structure</li>
<li>Call the <tt>USBDCDInit()</tt> API and pass the device instance structure to the core</li></ul>
<p>With this call, control passes to the core layer, which performs the following additional steps to complete enumeration:
</p>
<ul><li>Enable the PSC clock</li>
<li>Reset the USB module</li>
<li>Switch on the USB PHY</li>
<li>Initialize the USB tick module</li>
<li>Clear all the pending interrupts</li>
<li>Enable the required interrupts</li>
<li>Set the configuration parameters</li>
<li>Disconnect the device</li>
<li>Reconnect the device</li></ul>
<p>Now the device starts receiving interrupts from the host. The interrupt handler in the core layer identifies all the Ep0 interrupts and calls the appropriate handler. If all the standard requests are serviced by the device, then enumeration is complete and the device is ready for communication. Now the control returns to the application, where it waits for touch screen inputs.
</p><p><a href="File_HID_Mouse_Flow.html" class="image"><img alt="HID Mouse Flow.JPG" src="https://processors.wiki.ti.com/images/f/fd/HID_Mouse_Flow.JPG" width="761" height="483" /></a> 
</p>
<h2><span class="mw-headline" id="Example_Application_2">Example Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=27" title="Edit section: Example Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="File_Mouse_app_flow.html" class="image"><img alt="Mouse app flow.JPG" src="https://processors.wiki.ti.com/images/4/4d/Mouse_app_flow.JPG" width="678" height="593" /></a> 
</p><p>The above figure shows how the HID device (mouse) application works. The application continuously polls for a touch screen event. Once an event is detected, the application reads the x and y values.  The touch handler checks whether this is a button press or not (i.e. if the x and y coordinates belongs to the button area). If this is not a button press event, then read the x and y values are re-read multiple times. This helps to avoid the "bouncing" effects and confirm the touch event. Afterward, the current and previous x and y values are used to calculate how much we moved from the previous x/y location.  The new location values are sent to the host through HID report.
</p>
<h3><span class="mw-headline" id="Running_the_Application_2">Running the Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=28" title="Edit section: Running the Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>Connect the target board to the host PC via a USB cable</li>
<li>Load and run the target application</li>
<li>Once the device is connected to the host, it enumerates as HID mouse</li>
<li>User can check the device manager of the host to confirm the completion of the enumeration</li>
<li>Touch screen is initialized and buttons are displayed</li>
<li>User can use the touch screen to move the cursor on the host PC and press the mouse button to trigger mouse clicks</li></ul>
<p>For connector information please check the connector information <a href="#Connector_Information">table</a>
</p><p>Modules used by this application: 
</p>
<ul><li>USB HID</li>
<li>LCD raster</li>
<li>Graphics library</li>
<li>Touch screen (I2C)</li>
<li>Interrupt</li></ul>
<h3><span id="In_Data_Flow_(Device_to_Host)"></span><span class="mw-headline" id="In_Data_Flow_.28Device_to_Host.29">In Data Flow (Device to Host)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=29" title="Edit section: In Data Flow (Device to Host)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><a href="File_HID_Report_flow.html" class="image"><img alt="HID Report flow.JPG" src="https://processors.wiki.ti.com/images/1/15/HID_Report_flow.JPG" width="878" height="592" /></a> 
</p>
<h2><span class="mw-headline" id="How_to_write_a_new_HID_Application">How to write a new HID Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=30" title="Edit section: How to write a new HID Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To add USB HID mouse support to an application using the USB stack, use the following procedure: 
</p>
<ul><li>Add the following header files to the source file(s) that will support USB:<br /><pre>#include "src/usb.h"</pre><pre>#include "usblib/usblib.h"</pre><pre>#include "usblib/device/usbdhidmouse.h"</pre></li>
<li>Define the string table that is used to describe various features of your new device to the host system. This table must include a minimum of 6 entries: string descriptor 0 defines the language(s) available, and 5 strings for each supported language.</li>
<li>Define an area of RAM for the HID mouse class driver private data. This structure should never be accessed by the application.<br /><pre>static tHIDMouseInstance g_sMouseInstance;</pre></li>
<li>Define a <tt>tUSBDHIDMouseDevice</tt> structure and initialize all fields as required by your application.</li>
<li>Add a mouse event handler function to your application. A minimal implementation can ignore all events, but <tt>USB_EVENT_TX_COMPLETE</tt> is typically used to ensure that mouse messages are not sent when a previous report is still in transit to the host. Attempts to send a new mouse report when the previous report has not yet been acknowledged will result in return code <tt>MOUSE_ERR_TX_ERROR</tt> from <tt>USBDHIDMouseStateChange()</tt>.</li>
<li>From your main initialization function call the HID mouse device initialization API to configure the USB controller and place the device on the bus.<br /><pre>pDevice = USBDHIDMouseInit(0, &amp;g_sMouseDevice);</pre></li>
<li>Assuming <tt>pDevice</tt> is not returned as NULL, your mouse device is now ready to communicate with a USB host</li>
<li>Once the host connects, your mouse event handler receives an <tt>USB_EVENT_CONNECTED</tt> event.  Afterward, calls can be made to <tt>USBDHIDMouseStateChange()</tt> to inform the host of mouse position and button state changes.</li></ul>
<h1><span class="mw-headline" id="Mass_Storage_Device_Class">Mass Storage Device Class</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=31" title="Edit section: Mass Storage Device Class">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The USB mass storage device class allows an application to act as a physical storage device for use by another USB application or host PC. Because the type of storage can vary per application, the mass storage class abstracts the storage with a set of block-based APIs that are provided by the application to the USB library. These APIs allow the USB mass storage class to call an external set of functions that actually perform the operations on the physical storage media. The storage APIs are given to the USB librarys mass storage device class initialization function and are called by the USB library whenever it needs to access the physical media. 
</p><p><a href="File_Msc.html" class="image"><img alt="Msc.JPG" src="https://processors.wiki.ti.com/images/0/0a/Msc.JPG" width="804" height="723" /></a>  
</p>
<h2><span class="mw-headline" id="Initialization_and_Data_Flow">Initialization and Data Flow</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=32" title="Edit section: Initialization and Data Flow">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The USB librarys mass storage class provides a simple interface to initialize the mass storage class and pass it the needed functions to access a device without having any knowledge of the physical media. The <tt>USBDMSCInit()</tt> API is the only initialization required by the mass storage class, and it uses the structure <tt>tUSBDMSCDevice</tt> to hold all customizable values for the mass storage class. 
</p><p>The USB librarys mass storage class provides the ability to customize how the device is reported to the USB host controller in the <tt>tUSBDMSCDevice</tt> structure. The members of this structure contain all of the customizable parameters.
</p><p>The below diagram shows how data and commands flow to and from the MSC device. The diagram does not show using DMA to automate any data transfers.
</p><p><a href="File_Msc_flow.html" class="image"><img alt="Msc flow.JPG" src="https://processors.wiki.ti.com/images/2/2a/Msc_flow.JPG" width="764" height="593" /></a> 
</p>
<h2><span class="mw-headline" id="Block_Media_Access">Block Media Access</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=33" title="Edit section: Block Media Access">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The media access functions are passed in to the USB mass storage device class in the <tt>sMedia-&gt;Functions</tt> member variable. This structure holds the access functions used by this instance of the mass storage class device. All of the functions in this structure are required to be populated with valid functions. These functions are called by the USB mass storage device class whenever it needs to read or write the physical media, and they always use a fixed block size of 512 bytes. 
</p><p>In some cases, the application may need to be informed when the state of the mass storage device has changed. The <tt>pfnEventCallback</tt> member of the <tt>MSCDevice</tt> structure provides event notification to applications for the following events:
</p>
<ul><li><tt>USBD_MSC_EVENT_IDLE</tt></li>
<li><tt>USBD_MSC_EVENT_READING</tt></li>
<li><tt>USBD_MSC_WRITING</tt></li></ul>
<p>When a function of type <tt>tUSBCallback</tt> is called, only the first two parameters (<tt>pvCBData</tt> and <tt>ulEvent</tt>) are valid. The <tt>pvCBData</tt> parameter is the value that was returned when the application called <tt>USBDMSCInit()</tt> and can be used with other APIs. These events are not used in the example application provided with StarterWare. Application writers can make use of these events as required.
</p>
<h2><span class="mw-headline" id="RAM_Disk_Support">RAM Disk Support</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=34" title="Edit section: RAM Disk Support">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The MSC is provided with a RAM disk implementation as its block media. The current size supported by the RAM disk is 16 MB. Developers can change it by modifying the <tt>RAMDISK_SIZE</tt> macro in the <tt>ramdisk.c</tt> source file, depending on their board's RAM capacity.
</p>
<h2><span class="mw-headline" id="DMA_Support">DMA Support</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=35" title="Edit section: DMA Support">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The CPPI 4.1 DMA engine is interfaced with MUSB controller, and MSC device class supports DMA mode for data transfers by default. Currently, only transparent DMA mode is supported for RX and TX transactions.<b>Please note: to switch to PIO mode, the <tt>DMA_MODE</tt> macro must be removed from the compiler options</b>.
</p>
<h2><span class="mw-headline" id="Example_Application_3">Example Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=36" title="Edit section: Example Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li>Application calls <tt>USBDMSCInit()</tt> with the device instance structure as a parameter</li>
<li>Application also initializes the DMA, MUSB interrupts, MMU, etc.</li>
<li>The MSC initialization API provided by the MSC stack populates the device info structure with Endpoint numbers, descriptors, device state, etc.</li>
<li>MSC init calls <tt>DCDInit()</tt> with the device instance structure as parameter.  The core layer then performs the following steps in order to complete the enumeration:
<ol><li>Enable the PSC clock</li>
<li>Reset the USB module</li>
<li>Switch on the USB PHY</li>
<li>Initialize the USB tick module</li>
<li>Clear all the pending interrupts</li>
<li>Enable the required interrupts</li>
<li>Set the configuration parameters</li>
<li>Disconnect the device</li>
<li>Reconnect the device</li></ol></li>
<li>Once enumeration is complete, the device will appear on the host PC as a mass storage device</li>
<li>When the user attempts to access the MSC device on the host PC, the host formats the RAM disk</li>
<li>Once the format operation is complete, the device is ready for data transaction</li>
<li>If any command comes from host, the device is notified through an interrupt</li>
<li>The interrupt handler in the device core (<tt>HandleEndpoint()</tt>) reads the CBW and retrieves the command op code</li>
<li>This op-code is passed to the command handler, and command handler calls the appropriate command</li>
<li>The data transaction happens through DMA by default</li>
<li>At the end of the transaction, The device will send a command status word (CSW) to indicate the end of the command</li></ul>
<h3><span class="mw-headline" id="Running_the_Application_3">Running the Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=37" title="Edit section: Running the Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>Connect the target board to the host PC via a USB cable</li>
<li>Load and run the target application</li>
<li>Once the device is connected to the host PC, the device will enumerate as an MSC device</li>
<li>The user can check the disk drives to see the mass storage device</li>
<li>When the user attempts to access the MSC device on the host PC, the host formats the RAM disk</li>
<li>Once the format operation is complete, the device is ready for data transaction</li>
<li>Currently the device supports 16MB of RAM disk</li></ul>
<p>For connector information please check the connector information<a href="#Connector_Information">table</a>
</p><p><b>Note:</b> The MSC device class is configured and tested for Hi-Speed DMA mode only
</p><p>Modules used in this example 
</p>
<ul><li>Interrupt module</li>
<li>USB driver</li>
<li>USB stack (including Cppi 4.1 DMA)</li>
<li>LCD raster</li>
<li>Graphics library</li></ul>
<h3><span class="mw-headline" id="How_to_Integrate_Alternate_Block_Media">How to Integrate Alternate Block Media</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=38" title="Edit section: How to Integrate Alternate Block Media">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The current package is provided with 16 MB of RAM Disk. If the user wants to use another block media, the following steps are required.
</p>
<ul><li>Rename the source files <tt>usbdmscglue.c</tt> and <tt>usbdmscglue.h</tt> as appropriate</li>
<li>The alternate block media must support the following APIs:
<ol><li><tt>Disk_read()</tt></li>
<li><tt>Disk_write()</tt></li>
<li><tt>Disk_ioctl()</tt></li></ol></li>
<li>These APIs should be replaced in the new "glue" source file:
<ol><li><tt>Disk_read()</tt> should be replaced in the <tt>USBDMSCStorageRead()</tt> API</li>
<li><tt>Disk_write()</tt> should be replaced in the <tt>USBDMSCStorageWrite()</tt> API</li>
<li><tt>Disk_ioctl()</tt> should be replace in the <tt>USBDMSCStorageNumBlocks()</tt> API with appropriate parameters to return the total number of blocks.</li></ol></li></ul>
<p>The default block size is 512 bytes.  If the alternate block media has a different block size, then this must be updated in the USB stack. This can be achieved by updating macros <tt>DEVICE_BLOCK_SIZE</tt> and <tt>MAX_TRANSFER_SIZE</tt> with the new block size. 
</p>
<h1><span class="mw-headline" id="Composite_Device_Class">Composite Device Class</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=39" title="Edit section: Composite Device Class">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The USB composite device class allows classes that are already defined in the USB library to be combined into a single composite device. The device configuration descriptors for the included device classes are merged at run time and returned to the USB host controller during device enumeration as a single composite USB device. Since each device class requires some unique initialization, the device classes provide a separate initialization API that does not touch the USB controller but does perform all other initialization. The initialization of the USB controller is deferred until the USB composite device is initialized and has merged the multiple device configuration descriptors into a single configuration descriptor so that it can properly initialize the USB controller. The endpoint numbers, interface numbers, and string indexes that are included in the device configuration descriptors are modified by the USB composite device class so that the values are valid in the composite device configuration descriptor.
</p>
<h2><span class="mw-headline" id="Composite_CDC_Serial_and_HID-Mouse_device_Example_Application">Composite CDC Serial and HID-Mouse device Example Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=40" title="Edit section: Composite CDC Serial and HID-Mouse device Example Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="File_Composite_HID_CDC.html" class="image"><img alt="Composite HID CDC.JPG" src="https://processors.wiki.ti.com/images/4/43/Composite_HID_CDC.JPG" width="869" height="645" /></a>  
</p>
<h3><span class="mw-headline" id="Device_Enumeration">Device Enumeration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=41" title="Edit section: Device Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The Application must perform the following steps to enumerate the USB in Composite device mode:
</p>
<ul><li>Configure the system interrupts</li>
<li>Register the Interrupt handlers</li>
<li>Initialize the buffers</li>
<li>Call the <tt>USBDHIDMouseCompositeInit()</tt> API with the mouse device instance structure as a parameter.With this call, control passes to the HID mouse layer, which performs the following additional steps
<ul><li>Initialize the various fields in the instance structure</li>
<li>Initialize the HID device class instance structure based on input from the caller</li>
<li>Initialize the lower layer HID driver by calling the <tt>USBDHIDCompositeInit()</tt> API.With this call, control passes to the HID device class layer, which performs the following additional steps
<ul><li>Assign the endpoints to the device instance structure.</li>
<li>Assign the device, configuration descriptor to the device instance structure.</li></ul></li></ul></li>
<li>Call the USBDCDCCompositeInit API with the CDC device instance structure as a parameter.With this call, control is given to the CDC device class layer. The device class layer must perform the following steps
<ul><li>Assign endpoints to the device instance structure</li>
<li>Apply the configuration descriptor to the device instance structure</li></ul></li>
<li>Call the USBDCompositeInit API to initialize the USB composite device class, with the composite device instance structure as a parameter.with this call, contol is given to the composite device class layer. The device class layer must perform the following steps
<ul><li>Initialize the various fields in the instance structure</li>
<li>Assign the device, configuration descriptor to the device instance structure</li>
<li>Call the BuildCompositeDescriptor() API to merge the configuration descriptors into a single multiple instance device.</li>
<li>Call the USBDCDInit() API and pass the device instance structure to the core</li></ul></li></ul>
<p>With this call, control passes to the core layer, which performs the following additional steps to complete enumeration:
</p>
<ul><li>Enable the PSC clock</li>
<li>Reset the USB module</li>
<li>Switch on the USB PHY</li>
<li>Initialize the USB tick module</li>
<li>Clear all the pending interrupts</li>
<li>Enable the required interrupts</li>
<li>Set the configuration parameters</li>
<li>Disconnect the device</li>
<li>Reconnect the device</li>
<li>Now the device starts receiving interrupts from the host. The interrupt handler in the core layer identifies all the Ep0 interrupts and calls the appropriate handler. If all the standard requests are serviced by the device, then enumeration is complete and the device is ready for communication. Now the control returns to the application, where it waits for touch screen inputs and data interrupts.</li></ul>
<h3><span class="mw-headline" id="Running_the_Application_4">Running the Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=42" title="Edit section: Running the Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li><b>Since this is a USB device mode application, the target (EVM) must be connected to host (Windows PC) by a USB cable.</b></li>
<li>Load and run the target application</li>
<li>Connect your host PC's serial port to the UART connector on the EVM using a null modem cable.</li>
<li>The CDC device requires an INF file at the host side in order to enable as virtual COM port. Please use the INF provided in the <tt>tools/usb_inf</tt> folder.
<ul><li>The INF file is required only with a windows based host.</li>
<li>To use different VID and PID, the INF file must be updated with the new VID, PID and Interface ID.</li></ul></li>
<li>Once the device is connected to the host,it enumerates one device as HID mouse and for other CDC device host will ask for INF file. The user must browse to the INF file to proceed.</li></ul>
<p><a href="File_Cdc11.html" class="image"><img alt="Cdc11.JPG" src="https://processors.wiki.ti.com/images/b/be/Cdc11.JPG" width="499" height="393" /></a> 
</p>
<ul><li>Once the proper INF file is pointed out by the user, then virtual COM port will appear in the device manager</li></ul>
<p><a href="File_Cdc12.html" class="image"><img alt="Cdc12.JPG" src="https://processors.wiki.ti.com/images/2/25/Cdc12.JPG" width="639" height="448" /></a> 
</p>
<ul><li>Open a serial terminal application (ex. Teraterm, Hyperterminal) and choose the virtual COM port.</li></ul>
<p><a href="File_Cdc13.html" class="image"><img alt="Cdc13.JPG" src="https://processors.wiki.ti.com/images/f/f2/Cdc13.JPG" width="859" height="581" /></a> 
</p>
<ul><li>Set the parameters as shown.</li></ul>
<p><a href="File_Cdc14.html" class="image"><img alt="Cdc14.JPG" src="https://processors.wiki.ti.com/images/d/db/Cdc14.JPG" width="860" height="578" /></a> 
</p>
<ul><li>Open another terminal window and choose COM1 (or whichever serial port you previously connected to the EVM's UART connector).</li>
<li>Type in either terminal window on the host PC.  The text should appear on the other terminal screen.</li>
<li>For HID device, Touch screen is initialized and buttons are displayed</li>
<li>User can use the touch screen to move the cursor on the host PC and press the mouse button to trigger mouse clicks.</li>
<li>Both devices ( HID mouse and CDC Serial ) can be accessed at the same time.</li></ul>
<h2><span class="mw-headline" id="Composite_Dual_CDC_Serial_Port_device_Example_Application">Composite Dual CDC Serial Port device Example Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=43" title="Edit section: Composite Dual CDC Serial Port device Example Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="File_Composite_CDC_CDC.html" class="image"><img alt="Composite CDC CDC.JPG" src="https://processors.wiki.ti.com/images/2/24/Composite_CDC_CDC.JPG" width="858" height="645" /></a>  
</p>
<h3><span class="mw-headline" id="Device_Enumeration_2">Device Enumeration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=44" title="Edit section: Device Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The Application must perform the following steps to enumerate the USB in Composite device mode:
</p>
<ul><li>Configure the system interrupts</li>
<li>Register the Interrupt handlers</li>
<li>Initialize the buffers</li>
<li>Call the USBDCDCCompositeInit API twice with the CDC device instance structure as a parameter.With this call, control is given to the CDC device class layer. The device class layer must perform the following steps
<ul><li>Assign endpoints to the device instance structure</li>
<li>Apply the configuration descriptor to the device instance structure</li></ul></li>
<li>Call the USBDCompositeInit API to initialize the USB composite device class, with the composite device instance structure as a parameter.with this call, contol is given to the composite device class layer. The device class layer must perform the following steps
<ul><li>Initialize the various fields in the instance structure</li>
<li>Assign the device, configuration descriptor to the device instance structure</li>
<li>Call the BuildCompositeDescriptor() API to merge the configuration descriptors into a single multiple instance device.</li>
<li>Call the USBDCDInit() API and pass the device instance structure to the core</li></ul></li></ul>
<p>With this call, control passes to the core layer, which performs the following additional steps to complete enumeration:
</p>
<ul><li>Enable the PSC clock</li>
<li>Reset the USB module</li>
<li>Switch on the USB PHY</li>
<li>Initialize the USB tick module</li>
<li>Clear all the pending interrupts</li>
<li>Enable the required interrupts</li>
<li>Set the configuration parameters</li>
<li>Disconnect the device</li>
<li>Reconnect the device</li>
<li>Now the device starts receiving interrupts from the host. The interrupt handler in the core layer identifies all the Ep0 interrupts and calls the appropriate handler. If all the standard requests are serviced by the device, then enumeration is complete and the device is ready for communication. Now the control returns to the application, where it waits for data interrupts.</li></ul>
<h3><span class="mw-headline" id="Running_the_Application_5">Running the Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=45" title="Edit section: Running the Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li><b>Since this is a USB device mode application, the target (EVM) must be connected to host (Windows PC) by a USB cable.</b></li>
<li>Load and run the target application</li>
<li>The CDC device requires an INF file at the host side in order to enable as virtual COM port. Please use the INF provided in the <tt>tools/usb_inf</tt> folder.
<ul><li>The INF file is required only with a windows based host.</li>
<li>To use different VID and PID, the INF file must be updated with the new VID, PID and Interface IDs.</li></ul></li>
<li>Once the device is connected to the host,it enumerates as composite device, host will ask for INF file to enumerate one CDC device. The user must browse to the INF file to proceed.</li></ul>
<p><a href="File_Cdc11.html" class="image"><img alt="Cdc11.JPG" src="https://processors.wiki.ti.com/images/b/be/Cdc11.JPG" width="499" height="393" /></a> 
</p>
<ul><li>Once the proper INF file is pointed out by the user, then virtual COM port will appear in the device manager</li></ul>
<p><a href="File_DevMgr1.html" class="image"><img alt="DevMgr1.JPG" src="https://processors.wiki.ti.com/images/a/aa/DevMgr1.JPG" width="636" height="449" /></a> 
</p>
<ul><li>Once one device is enumerated, host will ask for INF file to enumerate other CDC device. The user must browse to the INF file to proceed.</li></ul>
<p><a href="File_Cdc11.html" class="image"><img alt="Cdc11.JPG" src="https://processors.wiki.ti.com/images/b/be/Cdc11.JPG" width="499" height="393" /></a> 
</p>
<ul><li>Once the proper INF file is pointed out by the user, then two virtual COM ports will appear in the device manager</li></ul>
<p><a href="File_DevMgr12.html" class="image"><img alt="DevMgr12.JPG" src="https://processors.wiki.ti.com/images/3/37/DevMgr12.JPG" width="638" height="447" /></a> 
</p>
<ul><li>Open a serial terminal application (ex. Teraterm, Hyperterminal) and choose the virtual COM port.</li></ul>
<p><a href="File_HyperTrm1.html" class="image"><img alt="HyperTrm1.JPG" src="https://processors.wiki.ti.com/images/8/8e/HyperTrm1.JPG" width="859" height="576" /></a> 
</p>
<ul><li>Set the parameters as shown.</li></ul>
<p><a href="File_HyperTrm2.html" class="image"><img alt="HyperTrm2.JPG" src="https://processors.wiki.ti.com/images/3/33/HyperTrm2.JPG" width="853" height="573" /></a> 
</p>
<ul><li>Do the above two steps for other virtual COM port.</li>
<li>Type in either terminal window on the host PC.  The text should appear on the other terminal screen.</li></ul>
<h1><span class="mw-headline" id="USB_Host_Class">USB Host Class</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=46" title="Edit section: USB Host Class">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The USB library host controller driver provides an interface to the host controllers hardware register interface. This is the lowest level of the driver interface, and it interacts directly with the driver library's USB APIs. The host controller driver provides all of the functionality necessary to perform enumeration of devices regardless of any type. This portion of the stack code only enumerates the device; higher level drivers handle further device operations. To allow the application to conserve code and data memory, the host controller driver only includes the host class drivers for USB device types used in the application. This allows an application to handle multiple classes of devices but only include the USB library code that the application needs for those devices that the application actually supports. While the host controller driver handles the enumeration of devices, it relies on USB pipes (allocated by the higher level class drivers) as the direct communications method with device end points.
</p>
<h2><span class="mw-headline" id="Host_Class_Enumeration">Host Class Enumeration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=47" title="Edit section: Host Class Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The USB host controller driver handles all of the details necessary to discover and enumerate any USB device. The USB host controller driver only performs enumeration and relies on the host class drivers to perform any other communications with USB devices including the allocation of the endpoints for the device. Most of the code used to enumerate devices is run in interrupt context and is contained in the enumeration handler. In order to complete the enumeration process, the host controller driver also requires that the application periodically call the USBHCDMain() function. When a host class driver or an application needs access to endpoint 0 of a device, it uses the USBHCDControlTransfer() interface to send data to the device or receive data from the device. During the enumeration process the host controller driver searches a list of host class drivers provided by the application in the USBHCDRegisterDrivers() call. The details of this structure are covered in the host class drivers section of this document. If the host controller driver finds a host class driver that matches the class of the enumerated device, it will call the open function for that host class driver. If no host class driver is found the host controller driver will ignore the device and there will be no notification to the application. The host controller driver or the host class driver can provide callbacks up through the USB library to inform the application of enumeration events. The host class drivers are responsible for configuring the USB pipes based on the type of device that is discovered. The application will be notified that a new device has been discovered by a callback from the device interface that a device of that given type has been enumerated. When the device is removed the application will also get a callback that the device is no longer present. The events USB_EVENT_CONNECTED and USB_EVENT_DISCONNECTED are the only event notifications that will make it up to the application as a result of enumeration. 
</p>
<h2><span class="mw-headline" id="USB_Pipes">USB Pipes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=48" title="Edit section: USB Pipes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The host controller driver layer uses interfaces called USB pipes as the primary method of communication with USB devices. These USB pipes are dynamically or statically allocated by the USB class drivers during enumeration. The USB pipes are usually only used within the USB library or by host class drivers and are usally not accessed directly by applications. The USB pipes are allocated and freed by calling <tt>USBHCDPipeAlloc()</tt> and <tt>USBHCDPipeFree()</tt> functions and are initially configured by calling <tt>USBHCDPipeConfig()</tt>. The <tt>USBHCDPipeAlloc()</tt> and <tt>USBHCDPipeConfig()</tt> APIs are used during USB device enumeration to allocate USB pipes for specific endpoints of the USB device. On disconnect, the <tt>USBHCDPipeFree()</tt> API is called to free up the USB pipe, which can then be used by a new USB device. While in use, the USB pipes can provide status and perform read and write operations. Calling <tt>USBHCDPipeStatus()</tt> allows a host class driver to check the status of a pipe. However, most access to the USB pipes occurs through the <tt>USBHCDPipeWrite()</tt> and <tt>USBHCDPipeRead()</tt> APIs and the callback function provided when the USB pipe was allocated. These are used to read or write to endpoints on USB devices on endpoints other than the control endpoint on endpoint 0. Since endpoint 0 is shared with all devices, the host controller interface does not use USB pipes for communications over endpoint 0 and instead uses the <tt>USBHCDControlTransfer()</tt> API. 
</p>
<h2><span class="mw-headline" id="Control_Transactions">Control Transactions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=49" title="Edit section: Control Transactions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>All USB control transactions are handled through the <tt>USBHCDControlTransfer()</tt> API. This function is primarily used inside the host controller driver itself during enumeration, but some devices may require using control transactions through endpoint 0. The HID class drivers are a good example of a USB class driver that uses control transactions to send data to a USB device. The <tt>USBHCDControlTransfer()</tt> API should not be called from within interrupt context because control transfers are blocking operations that rely on interrupts to proceed. Since most callbacks occur in interrupt context, any calls to <tt>USBHCDControlTransfer()</tt> should be deferred until running outside the callback event. 
</p>
<h2><span class="mw-headline" id="Interrupt_Handling">Interrupt Handling</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=50" title="Edit section: Interrupt Handling">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>All interrupt handling is done by the USB library host controller driver.  Most callbacks are called in interrupt context and, like interrupt handlers, should defer any real processing of events until execution returns from the interrupt context. Callbacks are used to notify the upper layers when events occur during enumeration or during normal operation. Because most of enumeration code is handled by interrupt handlers, the enumeration code requires the application to call <tt>USBHCDMain()</tt> in order to progress through the enumeration states without running all code in an interrupt context.
</p>
<h1><span class="mw-headline" id="HID_Host_Class">HID Host Class</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=51" title="Edit section: HID Host Class">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The host class drivers provide access to devices that use a common USB class interface. In order to use the class drivers, the application must call <tt>USBHCDRegisterDrivers()</tt> to provide a list of the host class drivers that the application will use. The <tt>g_USBHIDClassDriver</tt> structure defines the interface for the Host HID class driver, and the host class driver provides the following interfaces:
</p>
<ul><li>To the USB host controller driver (bottom layer)</li>
<li>Device specific interfaces (top layer)</li></ul>
<p>The lower layer interface to the USB host controller interface is the same for all USB host class drivers, while the device interface layer on top is common to all USB host device drivers of a given class. Aside from enumeration, all communication with the host class driver happens through its endpoint pipes. The host class driver parses and allocates any endpoints that it needs by calling the <tt>USBHCDPipeAlloc()</tt> and <tt>USBHCDPipeConfig()</tt> functions. These USB pipes provide methods to read/write and receive callback notification from the USB host controller driver layer. 
</p><p><a href="File_HID_host.html" class="image"><img alt="HID host.JPG" src="https://processors.wiki.ti.com/images/5/50/HID_host.JPG" width="804" height="723" /></a> 
</p><p>The HID class driver provides access to any type of HID class by leaving the details of the HID device to the layer above the HID class driver. The top layer of the HID class driver provides common functions to open or close an instance of a HID device, read a devices report descriptor so that it can be parsed by the HID device code, and get/set reports on an HID device. The lower level interface that is connected to the host controller driver is specified in the <tt>g_USBHIDClassDriver</tt> structure. This structure is used to register the HID class driver with the host class driver so that it is called when an HID device is connected and enumerated. The functions in the <tt>g_USBHIDClassDriver</tt> structure should never be called directly by and application or a host class driver as they are reserved for access by the host controller driver. In the following example, the generic HID class driver is registered with the USB host controller driver and then a call is made to open an instance of a mouse class device. Typically, the call to <tt>USBHHIDOpen()</tt> is made from within a device class interface while the call to <tt>SBHCDRegisterDrivers()</tt> is made from the application directly. For instance, the <tt>USBHHIDOpen()</tt> API for the mouse device provided with the USB library is called from <tt>USBHMouseOpen()</tt>, which is part of the USB mouse interface. 
</p>
<h2><span class="mw-headline" id="Device_Interface">Device Interface</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=52" title="Edit section: Device Interface">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>At the top layer of the HID class driver, the driver has a device class interface for use with various HID devices. In order for the HID class driver to recognize a device, the device class must call <tt>USBHHIDOpen()</tt>. This call specifies the type of device and a callback for this device type so that any events related to this device type can be passed back to the device class driver. The defined classes are in the <tt>tHIDSubClassProtocol</tt> type and are passed into the <tt>USBHHIDOpen()</tt> call via the <tt>eDeviceType</tt> parameter. In order to release an instance of an HID class driver, the HID device class or application must call <tt>USBHHIDClose()</tt> to allow a new or different type of device to be connected. In the examples provided with the USB library, the report descriptors are retrieved but are not used as the examples rely on the "boot" mode of the USB keyboard and mouse to fix the format of the report descriptors. This is accomplished by using the <tt>USBHHIDSetReport()</tt> API to force the device into its boot protocol mode. As this could be limiting or not available in other types of applications or devices, the <tt>USBHHIDGetReportDescriptor()</tt> API provides the ability for generic HID devices to query the device for its report descriptor(s). The last two remaining HID APIs, <tt>USBHHIDSetReport()</tt> and <tt>USBHHIDGetReport()</tt>, provide access to the HID reports. 
</p><p>Once a HID device has been opened, the application receives a <tt>USB_EVENT_CONNECTED</tt> callback event.  This indicates that a HID device of the type passed into the <tt>USBHHIDOpen()</tt> has been connected and the USB library host controller driver has completed enumeration of the device. When the HID device is removed, a <tt>SB_EVENT_DISCONNECTED</tt> event occurs. When shutting down or to release a device, the application must call <tt>USBHHIDClose()</tt> to disable callbacks. This does not actually power down the device, but it stops the driver from calling the application. During normal operation, the host class driver receives <tt>USB_EVENT_SCHEDULER</tt> and <tt>USB_EVENT_RX_AVAILABLE</tt> events. The <tt>USB_EVENT_SCHEDULER</tt> event indicates that the HID class driver should schedule a new request if it is ready to do so. This done by calling <tt>USBJHCDPipeSchedule()</tt> to request that a new IN request be made on the given Interrupt IN pipe. When the <tt>USB_EVENT_RX_AVAILABLE</tt> occurs, this indicates that new data is available due to completion of the previous request for data on the Interrupt IN pipe. The <tt>USB_EVENT_RX_AVAILABLE</tt> is passed on the device class interface to allow it to request the data by calling <tt>USBHHIDGetReport()</tt>. It is up to the device class driver to interpret the data in the report structure that is returned. In some cases, like the keyboard example, the device class may also need to call the host class driver to issue a set report to send data to the device. This is done by calling <tt>USBHHIDSetReport()</tt> in the host class driver. This will send data to the device by using the correct USB OUT pipe. 
</p>
<h2><span id="Example_Application_(Mouse)"></span><span class="mw-headline" id="Example_Application_.28Mouse.29">Example Application (Mouse)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=53" title="Edit section: Example Application (Mouse)">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The USB library host stack initialization is handled in the <tt>USBHCDInit()</tt> API. This function must be called after registering class drivers using <tt>USBHCDRegisterDrivers()</tt> and (optionally) configuring power pins using <tt>USBHCDPowerConfigInit()</tt>. Both of these APIs are described later. 
</p><p>The <tt>USBHCDInit()</tt> API takes three parameters, the first of which specifies which USB controller to initialize. This is a zero-based index value. The next two parameters specify a memory pool for use by the host controller driver. The size of this buffer must be large enough to hold a typical configuration descriptor for devices that are going to be supported. This value is system-dependent, so it is left to the application to set the size. It should never be less than 32 bytes; in most cases it should be at least 64 bytes. If there is not enough memory to load a configuration descriptor from a device, the device will not be recognized by USB librarys host controller driver. The USB library also provides a method to shut down an instance of the host controller driver by calling the <tt>USBHCDTerm()</tt> function. The <tt>USBHCDTerm()</tt> function should be called any time the application wants to shut down the USB host controller in order to disable it, or possibly switch modes in the case of a dual role controller. The USB library assumes that the power pin configuration has an active high signal for controlling the external power. If this is not the case or if the application wants control over the power fault logic provided by the library, then the application should call <tt>USBHCDPowerConfigInit()</tt> before calling <tt>USBHCDInit()</tt> in order to properly configure the power control pins. The polarity of the power pin, the polarity of the the power fault pin, and any actions taken in response to a power fault are all controlled by passing a combination of values in the <tt>ulPwrConfig</tt> parameter. See the documentation for the <tt>USBHCDPowerConfigInit()</tt> API for more details on this function. 
</p><p>The USB library host stack requires that some portion of the code not run in the interrupt handler, so the <tt>SBHCDMain()</tt> function  must be called periodically by the application during normal execution. This can be as a result of a timer tick or just once per main loop in a simple application. It should not be called by an interrupt handler. Calling the function too often is harmless as it will simply return if the USB host stack has no pending tasks. Calling <tt>USBHCDMain()</tt> too infrequently can cause enumeration to take longer than normal. It is up to the application to prioritize the importance of USB communications by calling <tt>USBHCDMain()</tt> at a rate that is reasonable to the application. All support devices will have a host class driver loaded in order to communicate with each type of device that is supported. The details of interacting with these host class drivers is explained in the host class driver sections that follow on this page. 
</p><p>When the application needs to shut down the host controller, it must shut down all host class drivers before shutting down the host controller itself. This gives the host class drivers a chance to close cleanly by calling each host class drivers close function. Finally, the <tt>USBHCDTerm()</tt> function should be called to shut down the host controller. This sequence will leave the USB controller and the USB library stack in a state such that it is ready to be re-initialized or switched to USB device mode (i.e. from host).
</p>
<h3><span class="mw-headline" id="Running_the_Application_6">Running the Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=54" title="Edit section: Running the Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>Connect a USB mouse to the target board
<ul><li><b>Note:</b> On the OMAP-L138/AM1808/C6748 EVM, use the J6 (mini) USB connector</li></ul></li>
<li>Load and run the target application</li>
<li>The display at the bottom left of the screen will show Connected if the mouse is enumerated and connected to the host</li>
<li>Move the mouse and see its motion tracked by the cursor on the screen</li>
<li>Press the mouse buttons and observe the button indicator on the bottom right corner of the screen</li>
<li>Press and hold the left mouse button and drag the cursor to draw lines or curves on the screen</li>
<li>Unplug the mouse from the board and see the display at bottom left changes to No device</li></ul>
<p>For connector information please check the connector information <a href="#Connector_Information">table</a> 
</p><p>Modules used in this application: 
</p>
<ul><li>USB HID host</li>
<li>LCD raster</li>
<li>Graphics lib rary</li>
<li>Timer</li>
<li>Interrupt</li></ul>
<h2><span class="mw-headline" id="Writing_a_New_HID_Host_Application">Writing a New HID Host Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=55" title="Edit section: Writing a New HID Host Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following shows the basic setup code needed for any application that is using the USB library in host mode. 
</p>
<ul><li>The <tt>g_pHCDPool</tt> array that is passed to the <tt>USBHCDInit()</tt> API is used as heap memory by the USB library. This memory should not be used by the application. In the HID host mouse example, the <tt>g_ppHostClassDrivers</tt> array holds HID driver that makes it possible to support various devices.</li>
<li>When calling <tt>USBHCDRegisterDrivers()</tt>, one argument specifies a static array of supported USB host class drivers that are be supported by the application.</li>
<li>The application must initialize the interrupt controller and register the ISR for the MUSB controller.</li>
<li>The application should always call the USB device interface open routines before calling <tt>USBHCDInit()</tt>. This enables the USB host controller and starts enumerating any connected device.</li>
<li>The initial call to <tt>USBHMouseOpen()</tt> prepares the mouse device application interface to receive notifications from any USB mouse device that is connected.</li>
<li>Since the mouse interface needs some basic configuration after being connected, the application should wait for the mouse to be connected and then call <tt>USBHMouseInit()</tt> to complete the mouse configuration.</li>
<li>Once the mouse has been configured, the applications mouse callback routine will be notified any time there is a state change with the mouse. This includes the switching to the <tt>MOUSE_INIT</tt> state when a <tt>USB_EVENT_CONNECTED</tt> event occurs in order to trigger mouse device initialization.</li>
<li>The <tt>USB_EVENT_DISCONNECTED</tt> event switches the state of the application to let it know that the mouse is no longer connected. The remaining events are mouse state changes that can be used by the application to move a cursor or take action based on a mouse click.</li></ul>
<p><a href="File_Hidhostexample1.html" class="image"><img alt="Hidhostexample1.JPG" src="https://processors.wiki.ti.com/images/b/b3/Hidhostexample1.JPG" width="512" height="946" /></a>
</p>
<h1><span class="mw-headline" id="Mass_Storage_Host_Class">Mass Storage Host Class</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=56" title="Edit section: Mass Storage Host Class">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The mass storage host class driver allows applications to access external devices that support the mass storage class protocol. The driver provides a simple block based interface to the devices that can be matched up with an applications file system. A USB host class driver for MSC devices is included with the USB library. It provides direct access to mass storage devices based on logical block address. 
</p><p><a href="File_MscHost.html" class="image"><img alt="MscHost.JPG" src="https://processors.wiki.ti.com/images/e/e2/MscHost.JPG" width="804" height="723" /></a> 
</p><p>The mass storage host class driver provides APIs to access USB mass storage drives. These APIs are meant to match with file systems that need block based read/write access to the drives. The <tt>USBHMSCBlockRead()</tt> and <tt>USBHMSCBlockWrite()</tt> APIs provide block read and block write device access. These functions perform block operations at the size specified by the drive. Since some drives require setup time after enumeration before they are ready for drive access, the mass storage class driver provides the <tt>USBHMSCDriveReady()</tt> API to check if the drive is ready for normal operation. The mass storage host class driver also provides an interface to the USB library host controller driver to complete enumeration of mass storage class devices. The mass storage class driver information is held in the global structure <tt>g_USBMSCClassDriver</tt>. This structure should only be referenced by the application, and the function pointers in this structure should never called directly by anything other than the host controller driver. The <tt>USBHMSCOpen()</tt> and <tt>USBHMSCClose()</tt> APIs allow the host controllers enumeration code to signal when a mass storage class device is detected or removed. The mass storage host class driver is responsible for providing a callback to the file system or application for notification when the drive is connected or disconnected. To make the the mass storage class driver visible to the host controller driver, it must be added in the list of drivers provided when calling <tt>USBHCDRegisterDrivers()</tt>. The class enumeration constant is set to USB_CLASS_MASS_STORAGE so any devices enumerating with value will load this class driver. 
</p>
<h2><span class="mw-headline" id="Device_Interface_2">Device Interface</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=57" title="Edit section: Device Interface">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This section describes how an application or file system interacts with the host mass storage class driver provided by the USB library. The application or file system must register the mass storage class driver with a call to USBHCDRegisterDrivers() with <tt>g_USBHostMSCClassDriver</tt> provided as a member of the array argument. Once the host mass storage class driver has been registered, the application must call <tt>USBHMSCDriveOpen()</tt> to allow the application or file system to be called when a new mass storage device is connected or disconnected or when any other mass storage class event occurs. 
</p><p>The first callback is the <tt>USB_EVENT_CONNECTED</tt> event, indicating that a mass storage class flash drive has been inserted and the USB library host stack has successfully enumerated the device. This does not indicate that the flash drive is ready for read/write operations; the device has only been detected. The <tt>USBHMSCDriveReady()</tt> API can be called to determine when the flash drive is ready for read/write operations. When the device is removed, a <tt>USB_EVENT_DISCONNECTED</tt> event occurs. When shutting down, the application must call <tt>USBHMSCDriveClose()</tt> to disable callbacks. This does not actually power down the mass storage device, but it does stop the driver from calling the application with further events. Once calling <tt>USBHMSCDriveReady()</tt> indicates that the flash drive is ready, the application can use the <tt>USBHMSCBlockRead()</tt> and <tt>USBHMSCBlockWrite()</tt> APIs to access the device. These are block-based functions that use the logical block address to indicate which block to access. It is important to note that the size passed to these functions is specified in blocks, not bytes.  The most common block size is 512 bytes. These calls always read or write a full block, so space must be allocated and managed appropriately. The following example shows calls for both reading and writing blocks from a mass storage class device.
</p>
<h2><span class="mw-headline" id="Host_SCSI_Layer">Host SCSI Layer</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=58" title="Edit section: Host SCSI Layer">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Since most mass storage class devices adhere to the SCSI protocol for block based calls, the USB library provides SCSI functions for the mass storage class driver to communicate with MSC drives. The commands and data pass over the USB pipes provided by the host controller driver. The only types of mass storage class device that are supported are devices that use the SCSI protocol. Since flash drives only support a limited subset of the SCSI protocol, only the SCSI functions needed by mass storage class to mount and access flash drives are implemented. The <tt>SCSIRead10()</tt> and <tt>SCSIWrite10()</tt> APIs are the two functions used for reading and writing to mass storage class devices. The remaining SCSI functions are used to get information about the mass storage class devices, including the device's block size and total number of blocks. Other APIs are used for error handling or to check whether or not the device is ready for a new command. 
</p>
<h2><span class="mw-headline" id="Example_Application_4">Example Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=59" title="Edit section: Example Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The application must call <tt>USBHMSCDriveOpen()</tt> in order for the application to be ready for a new mass storage device. The application should also wait for the mass storage class device to be ready to receive commands by calling <tt>USBHMSCDriveReady()</tt> and waiting for a return value of 0 before attempting to read or write to the device. Typically, reading and writing to the device is handled by a file system layer. 
</p><p>The example application executes the following sequence: 
</p>
<ol><li>Configure and enable the interrupts</li>
<li>Enable the USB clocking</li>
<li>Register the host class driver</li>
<li>Open an instance of the mass storage class driver</li>
<li>Initialize the power configuration</li>
<li>Initialize the host controller</li>
<li>Initialize the file system</li>
<li>Check for the device readiness</li></ol>
<h3><span class="mw-headline" id="Running_the_Application_7">Running the Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=60" title="Edit section: Running the Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>Connect a USB flash drive to the target board using Host cable
<ul><li><b>Note:</b> On the OMAP-L138/AM1808/C6748 EVM, use the J6 (mini) USB connector</li></ul></li>
<li>Connect the board to a PC through UART. A serial terminal application should be running on the host. Refer <a href="StarterWare_02.00.00-6.html#Host_Machine_Set_Up_requirements" title="StarterWare 02.00.00.06 User Guide">here</a> for more details. The serial terminal displays a command line interface to the user at run time</li>
<li>Load and run the example application on to target</li>
<li>Connect a mass storage device to the board</li>
<li>The PC terminal should display Mass storage device connected</li>
<li>Type "help" to see the supported commands</li>
<li>Use the necessary command to brows through the storage device</li></ul>
<p><b>Note:</b> The MSC Host class is by default configured for Hi-Speed DMA transfer mode. For Full-Speed mode, define 'USB_MODE_FULLSPEED' in 'Drivers', 'USBLib' and 'Application' make files.
</p><p>For connector information please check the connector information <a href="#Connector_Information">table</a> 
</p><p>Modules used by this example: 
</p>
<ul><li>USB MSC host</li>
<li>UART</li>
<li>Timer</li>
<li>Interrupt</li></ul>
<h3><span class="mw-headline" id="Integrating_a_Different_File_System">Integrating a Different File System</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=61" title="Edit section: Integrating a Different File System">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Using a different file system rather than the one provided with the package (i.e. FatFs) requires the following steps: 
</p>
<ul><li>Look for a source file containing the wrapper function to insert the stack APIs. In the current package, <tt>fat_usbmsc.c</tt> is the file that integrates the stack with the file system.</li>
<li>Find the appropriate file system initialization APIs and use them in the application.</li>
<li>Replace the file Open/Read/Write APIs as necessary in the application.</li></ul>
<h1><span class="mw-headline" id="Multi-instance_Support_Information">Multi-instance Support Information</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=62" title="Edit section: Multi-instance Support Information">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>StarterWare USB package provides the necessary software support for multi-instance capability. The application can select each of the USB instance and initialize, configure and start separately as per the corresponding class specific details detailed above. The multi-instance support is demonstrated/tested using below sample application(s). 
</p>
<ul><li><b>Note:</b> EVM-AM335x/EVMSK-AM335x/BeagleBone has a Micro connector for USB0 and a Standard-A receptacle for USB1. Thus, USB0 can be exercised in host mode or in device mode, while USB1 can be exercised only in host mode.</li></ul>
<h2><span id="MSC_Device_+_MSC_Host_Example_Application"></span><span class="mw-headline" id="MSC_Device_.2B_MSC_Host_Example_Application">MSC Device + MSC Host Example Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=63" title="Edit section: MSC Device + MSC Host Example Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The initialization, data flow, interfacing and other details remains same as that for MSC Device Class and MSC Host Class. In this example, USB0 is used for device mode and USB1 is used for host mode.
</p><p>The example application executes in the following sequence: 
</p>
<ol><li>Configure and enable the interrupts</li>
<li>Enable the USB clocking</li>
<li>Initialize the power configuration</li>
<li>Register the host class driver</li>
<li>Initialize the host controller with USB1</li>
<li>Initialize DMA for Host mode</li>
<li>Open an instance of the mass storage class driver</li>
<li>Initialize DMA for Device mode with endpoint details</li>
<li>Initialize the USB0 for MSC Device class</li>
<li>Initialize the file system</li>
<li>Check for the device readiness in Host mode</li></ol>
<h3><span class="mw-headline" id="Running_the_Application_8">Running the Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=64" title="Edit section: Running the Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>Connect a USB flash drive to the target board on USB1</li>
<li>Connect the target board to the host PC via a USB cable from USB0</li>
<li>Connect the board to a PC through UART. A serial terminal application should be running on the host. Refer <a href="StarterWare_02.00.00-8.html#Host_Machine_Set_Up_requirements" title="StarterWare 02.00.00.07 User Guide">here</a> for more details. The serial terminal displays a command line interface to the user at run time</li>
<li>Load and run the example application on to target</li>
<li>Host-mode: The PC terminal should display Mass storage device connected</li>
<li>Host-mode: Type "help" to see the supported commands</li>
<li>Host-mode: Use the necessary command to browse through the storage device</li>
<li>Device-mode: On the host PC, the device will appear as a mass storage device</li>
<li>Device-mode: On attempting to access the MSC device on the host PC, the host formats the RAM disk</li>
<li>Device-mode: Once the format operation is complete, the device is ready for data transaction
<ul><li><b>Note:</b> Device-mode: Currently the device supports 16MB of RAM disk</li>
<li><b>Note:</b> User will have to wait till the current issued command completes to issue next command</li></ul></li></ul>
<p>For connector information please check the connector information <a href="#Connector_Information">table</a> 
</p><p>Modules used by this example: 
</p>
<ul><li>USB MSC host</li>
<li>USB MSC Device</li>
<li>UART</li>
<li>Timer</li>
<li>Interrupt</li></ul>
<h2><span id="MSC_Host_+_MSC_Mouse_Example_Application"></span><span class="mw-headline" id="MSC_Host_.2B_MSC_Mouse_Example_Application">MSC Host + MSC Mouse Example Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=65" title="Edit section: MSC Host + MSC Mouse Example Application">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The initialization, data flow, interfacing and other details remains same as that for Mouse Host Class and MSC Host Class. In this example, USB0 is used for MSC host mode and USB1 is used for Mouse host mode.
</p><p>The example application executes in the following sequence: 
</p>
<ol><li>Configure and enable the interrupts</li>
<li>Enable the USB clocking</li>
<li>Initialize the power configuration</li>
<li>Register the Mouse host class driver</li>
<li>Initialize the host controller and register mouse driver with USB1</li>
<li>Register the MSC host class driver</li>
<li>Initialize DMA for MSC Host mode</li>
<li>Initialize the host controller for MSC with USB0</li>
<li>Initialize the file system for MSC class</li>
<li>Check for the device readiness in Host mode</li></ol>
<h3><span class="mw-headline" id="Running_the_Application_9">Running the Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=66" title="Edit section: Running the Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>Connect a USB flash drive to the target board on USB0</li>
<li>Connect a USB mouse to the target board on USB1</li>
<li>Connect the board to a PC through UART/virtual serial port. A serial terminal application should be running on the host. Refer <a href="StarterWare_02.00.00-8.html#Host_Machine_Set_Up_requirements" title="StarterWare 02.00.00.07 User Guide">here</a> for more details. The serial terminal displays a command line interface to the user at run time</li>
<li>Load and run the example application on to target</li>
<li>MSC Host-mode: The PC terminal should display Mass storage device connected</li>
<li>MSC Host-mode: Type "help" to see the supported commands</li>
<li>MSC Host-mode: Use the necessary command to browse through the storage device</li>
<li>Mouse Host-mode: The display at the bottom left of the screen will show Connected if the mouse is enumerated and connected to the host</li>
<li>Mouse Host-mode: Move the mouse and see its motion tracked by the cursor on the screen</li>
<li>Mouse Host-mode: Press the mouse buttons and observe the button indicator on the bottom right corner of the screen</li>
<li>Mouse Host-mode: Press and hold the left mouse button and drag the cursor to draw lines or curves on the screen</li>
<li>Mouse Host-mode: Unplug the mouse from the board and see the display at bottom left changes to No device</li></ul>
<p><b>Note:</b> User will have to wait till the current issued command completes
</p><p>For connector information please check the connector information <a href="#Connector_Information">table</a> 
</p><p>Modules used by this example: 
</p>
<ul><li>USB MSC host</li>
<li>USB Mouse host</li>
<li>UART</li>
<li>Timer</li>
<li>Interrupt</li></ul>
<h1><span class="mw-headline" id="Performance">Performance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=67" title="Edit section: Performance">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<h2><span class="mw-headline" id="Steps_to_capture_performance">Steps to capture performance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=68" title="Edit section: Steps to capture performance">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li>Open 'usblib\include\usblib.h'. Define 'PROFILE_USB_MSC_WRITE' OR 'PROFILE_USB_MSC_READ' based on what is being profiled. Build the example usb_dev_msc (Note: Below performance figures are captured using GCC build).</li>
<li>Setup the CCS IDE and h/w environment as documented in USB user-guide to execute usb_dev_msc example.</li>
<li>Add variable 'g_USBPerfInfo' to watch window.</li>
<li>Execute the example.</li>
<li>Format and copy two ~50MB files to USB device. Copy the two ~50MB files back to PC.</li>
<li>Eject the device.</li>
<li>"Pause" the example execution using CCS IDE.</li>
<li>Open "memory browser" of CCS,
<ul><li>select "save memory" option,</li>
<li>provide &lt;filename&gt;.hex and click 'Next' button</li>
<li>Select 'Raw Data' option for 'Format'</li>
<li>Set 'Length' to 10000</li>
<li>Set 'Start Address' to address of 'g_USBPerfInfo'</li>
<li>'Finish'</li></ul></li>
<li>Build '..\tools\hex2text.c' and execute it with command line argument being the &lt;filename&gt;.hex. E.g: hex2text write.hex</li>
<li>A file namely '&lt;filename&gt;.hex.txt' will be created.</li>
<li>Rename '&lt;filename&gt;.hex.txt' to  '&lt;filename&gt;.hex.csv', open with Windows Excel to view the data used to profile and the summary at the end.</li></ul>
<p><br />
<b>Warning:</b> Timer 7 is currently used for capturing performance figures. One should not use the 'delay' function in between the code being profiled as it too uses Timer 7.
</p>
<h2><span class="mw-headline" id="Performance_Figures_Table">Performance Figures Table</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=69" title="Edit section: Performance Figures Table">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<table style="" cellspacing="1" cellpadding="1" width="775" align="center" border="1">

<tbody><tr>
<td rowspan="2">
<p><b>Examples</b> 
</p>
</td>
<td colspan="2">
<p><b>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; EVM-AM335x</b> 
</p>
</td></tr>
<tr>
<td><b>Read (DMA Mode - Raw read) </b>
</td>
<td><b>Write (DMA Mode - Raw write)</b>
</td></tr>
<tr>
<td><b>usb_host_msc</b>
</td>
<td>16.6 MB/Sec
</td>
<td>17.0 MB/Sec
</td></tr>
<tr>
<td><b>usb_dev_msc</b>
</td>
<td>14.2 MB/Sec
</td>
<td>17.6 MB/Sec
</td></tr></tbody></table>
<h1><span class="mw-headline" id="Connector_Information">Connector Information</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=70" title="Edit section: Connector Information">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>&#160; Below table shows, which USB receptacle to use for each example in the package. 
</p>
<table style="width: 775px; height: 288px" cellspacing="1" cellpadding="1" width="775" align="center" border="1">

<tbody><tr>
<td rowspan="2">
<p><b>Examples</b>
</p>
</td>
<td colspan="3">
<p><b>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; EVMs</b>
</p>
</td></tr>
<tr>
<td><b>AM1808</b>
</td>
<td><b>AM335xEVM</b>
</td>
<td><b>Beaglebone</b>
</td></tr>
<tr>
<td><b>usb_dev_serial</b>
</td>
<td>J6 - USB0 - mini AB receptacle
</td>
<td>J14 - USB0 - micro AB receptacle
</td>
<td>P3 - USB0 - mini B&#160;receptacle&#160;
</td></tr>
<tr>
<td><b>usb_dev_bulk</b>
</td>
<td>J6 - USB0 - mini AB receptacle
</td>
<td>J14 - USB0 - micro AB receptacle
</td>
<td>P3 - USB0 - mini B receptacle
</td></tr>
<tr>
<td><b>usb_dev_mouse</b>
</td>
<td>J6 - USB0 - mini AB receptacle
</td>
<td>J14 - USB0 - micro AB receptacle
</td>
<td>NA
</td></tr>
<tr>
<td><b>usb_dev_msc</b>
</td>
<td>J6 - USB0 - mini AB receptacle
</td>
<td>J14 - USB0 - micro AB receptacle
</td>
<td>P3 - USB0 - mini B receptacle
</td></tr>
<tr>
<td><b>usb_host_mouse</b>
</td>
<td>J6 - USB0 - mini AB receptacle
</td>
<td>J18 - USB1 - USB A type receptacle
</td>
<td>NA
</td></tr>
<tr>
<td><b>usb_host_msc</b>
</td>
<td>J6 - USB0 - mini AB receptacle
</td>
<td>J18 - USB1 - USB A type receptacle
</td>
<td>NA
</td></tr></tbody></table>
<p>&#160;
</p>
<h1><span class="mw-headline" id="_Limitations">&#160;Limitations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit&amp;section=71" title="Edit section: Limitations">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<ol><li>SOF counter approach for timer cant be used in High Speed mode. Need to see other options for the functionalities where SOF counter/timer is used</li></ol>

<!-- 
NewPP limit report
Cached time: 20201130070457
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.216 seconds
Real time usage: 0.234 seconds
Preprocessor visited node count: 386/1000000
Preprocessor generated node count: 530/1000000
Postexpand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 504/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:13624-0!canonical and timestamp 20201130070457 and revision id 128280
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>StarterWare USB</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>StarterWare USB</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>StarterWare USB</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>StarterWare USB</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>StarterWare USB</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>StarterWare USB</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>StarterWare USB</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>StarterWare USB</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>StarterWare USB</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;oldid=128280">https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;oldid=128280</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="Category_StarterWare.html" title="Category:StarterWare">StarterWare</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=StarterWare+USB" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="StarterWare_USB.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk"><span><a href="Talk_StarterWare_USB.html" rel="discussion" title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="StarterWare_USB.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/StarterWare_USB.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/StarterWare_USB.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;oldid=128280" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=StarterWare_USB&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 10 December 2012, at 01:46.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.216","walltime":"0.234","ppvisitednodes":{"value":386,"limit":1000000},"ppgeneratednodes":{"value":530,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":504,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20201130070457","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":237});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/StarterWare_USB by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 07:26:04 GMT -->
</html>
