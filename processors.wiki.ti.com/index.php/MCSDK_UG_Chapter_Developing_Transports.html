<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/MCSDK_UG_Chapter_Developing_Transports by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 12:07:21 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>MCSDK UG Chapter Developing Transports - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"MCSDK_UG_Chapter_Developing_Transports","wgTitle":"MCSDK UG Chapter Developing Transports","wgCurRevisionId":211089,"wgRevisionId":211089,"wgArticleId":19656,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Software User Guides"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"MCSDK_UG_Chapter_Developing_Transports","wgRelevantArticleId":19656,"wgRequestId":"bd5e682a67f34311d347951f","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-MCSDK_UG_Chapter_Developing_Transports rootpage-MCSDK_UG_Chapter_Developing_Transports skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">MCSDK UG Chapter Developing Transports</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><p><br /><br />
</p>
<hr />
<p><a href="File_TI_Logo_oneline_twocolor.html" class="image"><img alt="TI Logo oneline twocolor.png" src="https://processors.wiki.ti.com/images/d/dc/TI_Logo_oneline_twocolor.png" width="300" height="37" /></a>
</p>
<hr />
<p><br />
</p><p><font size="5"><b><a href="MCSDK_UG_Chapter_Developing.html" title="MCSDK UG Chapter Developing">Developing with MCSDK</a>: Transports</b></font>
</p><p><font size="2">Last updated: <b>12/21/2015</b></font>
</p>
<div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Acronyms"><span class="tocnumber">2</span> <span class="toctext">Acronyms</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Transport_Network_Library"><span class="tocnumber">3</span> <span class="toctext">Transport Network Library</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#IPC_Transports"><span class="tocnumber">4</span> <span class="toctext">IPC Transports</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#KeyStone_II_IPC_Details"><span class="tocnumber">4.1</span> <span class="toctext">KeyStone II IPC Details</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#SYS.2FBIOS_DSP_TransportSrio"><span class="tocnumber">4.2</span> <span class="toctext">SYS/BIOS DSP TransportSrio</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#Architecture"><span class="tocnumber">4.2.1</span> <span class="toctext">Architecture</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#SYS.2FBIOS_DSP_TransportSrio_Source_Delivery_and_Recompilation"><span class="tocnumber">4.2.2</span> <span class="toctext">SYS/BIOS DSP TransportSrio Source Delivery and Recompilation</span></a>
<ul>
<li class="toclevel-4 tocsection-9"><a href="#Recompiling_on_Windows"><span class="tocnumber">4.2.2.1</span> <span class="toctext">Recompiling on Windows</span></a></li>
<li class="toclevel-4 tocsection-10"><a href="#Recompiling_on_Linux"><span class="tocnumber">4.2.2.2</span> <span class="toctext">Recompiling on Linux</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-11"><a href="#SYS.2FBIOS_DSP_TransportSrio_Configuration_Parameters"><span class="tocnumber">4.2.3</span> <span class="toctext">SYS/BIOS DSP TransportSrio Configuration Parameters</span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#Adding_the_SYS.2FBIOS_DSP_TransportSrio_to_a_DSP_Application"><span class="tocnumber">4.2.4</span> <span class="toctext">Adding the SYS/BIOS DSP TransportSrio to a DSP Application</span></a>
<ul>
<li class="toclevel-4 tocsection-13"><a href="#Additions_to_the_Application_RTSC_.cfg"><span class="tocnumber">4.2.4.1</span> <span class="toctext">Additions to the Application RTSC .cfg</span></a></li>
<li class="toclevel-4 tocsection-14"><a href="#Source_Code_Additions"><span class="tocnumber">4.2.4.2</span> <span class="toctext">Source Code Additions</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-15"><a href="#SYS.2FBIOS_DSP_TransportSrio_Examples"><span class="tocnumber">4.2.5</span> <span class="toctext">SYS/BIOS DSP TransportSrio Examples</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-16"><a href="#ARMv7_Linux_TransportSrio"><span class="tocnumber">4.3</span> <span class="toctext">ARMv7 Linux TransportSrio</span></a>
<ul>
<li class="toclevel-3 tocsection-17"><a href="#Architecture_2"><span class="tocnumber">4.3.1</span> <span class="toctext">Architecture</span></a></li>
<li class="toclevel-3 tocsection-18"><a href="#ARMv7_Linux_TransportSrio_Source_Delivery_and_Recompilation"><span class="tocnumber">4.3.2</span> <span class="toctext">ARMv7 Linux TransportSrio Source Delivery and Recompilation</span></a>
<ul>
<li class="toclevel-4 tocsection-19"><a href="#Recompiling_Through_Yocto.2Fbitbake"><span class="tocnumber">4.3.2.1</span> <span class="toctext">Recompiling Through Yocto/bitbake</span></a></li>
<li class="toclevel-4 tocsection-20"><a href="#Recompiling_Through_GIT_Repository"><span class="tocnumber">4.3.2.2</span> <span class="toctext">Recompiling Through GIT Repository</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-21"><a href="#ARMv7_Linux_TransportSrio_Configuration_Parameters"><span class="tocnumber">4.3.3</span> <span class="toctext">ARMv7 Linux TransportSrio Configuration Parameters</span></a>
<ul>
<li class="toclevel-4 tocsection-22"><a href="#MPM_Transport_Configuration_Effects_on_ARMv7_Linux_TransportSrio"><span class="tocnumber">4.3.3.1</span> <span class="toctext">MPM Transport Configuration Effects on ARMv7 Linux TransportSrio</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-23"><a href="#Adding_the_ARMv7_Linux_TransportSrio_to_a_User-Space_Application"><span class="tocnumber">4.3.4</span> <span class="toctext">Adding the ARMv7 Linux TransportSrio to a User-Space Application</span></a></li>
<li class="toclevel-3 tocsection-24"><a href="#ARMv7_Linux_TransportSrio_Tests"><span class="tocnumber">4.3.5</span> <span class="toctext">ARMv7 Linux TransportSrio Tests</span></a>
<ul>
<li class="toclevel-4 tocsection-25"><a href="#Building_the_Producer.2FConsumer_Test"><span class="tocnumber">4.3.5.1</span> <span class="toctext">Building the Producer/Consumer Test</span></a></li>
<li class="toclevel-4 tocsection-26"><a href="#Running_the_Producer.2FConsumer_Test"><span class="tocnumber">4.3.5.2</span> <span class="toctext">Running the Producer/Consumer Test</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-27"><a href="#SYS.2FBIOS_DSP_TransportQmss"><span class="tocnumber">4.4</span> <span class="toctext">SYS/BIOS DSP TransportQmss</span></a>
<ul>
<li class="toclevel-3 tocsection-28"><a href="#Architecture_3"><span class="tocnumber">4.4.1</span> <span class="toctext">Architecture</span></a></li>
<li class="toclevel-3 tocsection-29"><a href="#SYS.2FBIOS_DSP_TransportQmss_Source_Delivery_and_Recompilation"><span class="tocnumber">4.4.2</span> <span class="toctext">SYS/BIOS DSP TransportQmss Source Delivery and Recompilation</span></a>
<ul>
<li class="toclevel-4 tocsection-30"><a href="#Recompiling_on_Windows_2"><span class="tocnumber">4.4.2.1</span> <span class="toctext">Recompiling on Windows</span></a></li>
<li class="toclevel-4 tocsection-31"><a href="#Recompiling_on_Linux_2"><span class="tocnumber">4.4.2.2</span> <span class="toctext">Recompiling on Linux</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-32"><a href="#SYS.2FBIOS_DSP_TransportQmss_Configuration_Parameters"><span class="tocnumber">4.4.3</span> <span class="toctext">SYS/BIOS DSP TransportQmss Configuration Parameters</span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Adding_the_SYS.2FBIOS_DSP_TransportQmss_to_a_DSP_Application"><span class="tocnumber">4.4.4</span> <span class="toctext">Adding the SYS/BIOS DSP TransportQmss to a DSP Application</span></a>
<ul>
<li class="toclevel-4 tocsection-34"><a href="#Additions_to_the_Application_RTSC_.cfg_2"><span class="tocnumber">4.4.4.1</span> <span class="toctext">Additions to the Application RTSC .cfg</span></a></li>
<li class="toclevel-4 tocsection-35"><a href="#Source_Code_Additions_2"><span class="tocnumber">4.4.4.2</span> <span class="toctext">Source Code Additions</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-36"><a href="#SYS.2FBIOS_DSP_TransportQmss_Examples"><span class="tocnumber">4.4.5</span> <span class="toctext">SYS/BIOS DSP TransportQmss Examples</span></a>
<ul>
<li class="toclevel-4 tocsection-37"><a href="#Benchmark_Example"><span class="tocnumber">4.4.5.1</span> <span class="toctext">Benchmark Example</span></a>
<ul>
<li class="toclevel-5 tocsection-38"><a href="#Building"><span class="tocnumber">4.4.5.1.1</span> <span class="toctext">Building</span></a></li>
<li class="toclevel-5 tocsection-39"><a href="#Running"><span class="tocnumber">4.4.5.1.2</span> <span class="toctext">Running</span></a></li>
</ul>
</li>
<li class="toclevel-4 tocsection-40"><a href="#Heterogeneous_Processor_Test"><span class="tocnumber">4.4.5.2</span> <span class="toctext">Heterogeneous Processor Test</span></a>
<ul>
<li class="toclevel-5 tocsection-41"><a href="#Building_2"><span class="tocnumber">4.4.5.2.1</span> <span class="toctext">Building</span></a></li>
<li class="toclevel-5 tocsection-42"><a href="#Running_2"><span class="tocnumber">4.4.5.2.2</span> <span class="toctext">Running</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-43"><a href="#ARMv7_Linux_TransportQmss"><span class="tocnumber">4.5</span> <span class="toctext">ARMv7 Linux TransportQmss</span></a>
<ul>
<li class="toclevel-3 tocsection-44"><a href="#Architecture_4"><span class="tocnumber">4.5.1</span> <span class="toctext">Architecture</span></a></li>
<li class="toclevel-3 tocsection-45"><a href="#ARMv7_Linux_TransportQmss_Source_Delivery_and_Recompilation"><span class="tocnumber">4.5.2</span> <span class="toctext">ARMv7 Linux TransportQmss Source Delivery and Recompilation</span></a>
<ul>
<li class="toclevel-4 tocsection-46"><a href="#Recompiling_Through_Yocto.2Fbitbake_2"><span class="tocnumber">4.5.2.1</span> <span class="toctext">Recompiling Through Yocto/bitbake</span></a></li>
<li class="toclevel-4 tocsection-47"><a href="#Recompiling_Through_GIT_Repository_2"><span class="tocnumber">4.5.2.2</span> <span class="toctext">Recompiling Through GIT Repository</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-48"><a href="#ARMv7_Linux_TransportQmss_Configuration_Parameters"><span class="tocnumber">4.5.3</span> <span class="toctext">ARMv7 Linux TransportQmss Configuration Parameters</span></a>
<ul>
<li class="toclevel-4 tocsection-49"><a href="#MPM_Transport_Configuration_Effects_on_ARMv7_Linux_TransportQmss"><span class="tocnumber">4.5.3.1</span> <span class="toctext">MPM Transport Configuration Effects on ARMv7 Linux TransportQmss</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-50"><a href="#Adding_the_ARMv7_Linux_TransportQmss_to_a_User-Space_Application"><span class="tocnumber">4.5.4</span> <span class="toctext">Adding the ARMv7 Linux TransportQmss to a User-Space Application</span></a></li>
<li class="toclevel-3 tocsection-51"><a href="#ARMv7_Linux_TransportQmss_Tests"><span class="tocnumber">4.5.5</span> <span class="toctext">ARMv7 Linux TransportQmss Tests</span></a>
<ul>
<li class="toclevel-4 tocsection-52"><a href="#Multi-Process_Test"><span class="tocnumber">4.5.5.1</span> <span class="toctext">Multi-Process Test</span></a>
<ul>
<li class="toclevel-5 tocsection-53"><a href="#Building_3"><span class="tocnumber">4.5.5.1.1</span> <span class="toctext">Building</span></a></li>
<li class="toclevel-5 tocsection-54"><a href="#Running_3"><span class="tocnumber">4.5.5.1.2</span> <span class="toctext">Running</span></a></li>
</ul>
</li>
<li class="toclevel-4 tocsection-55"><a href="#Heterogeneous_Processor_Test_2"><span class="tocnumber">4.5.5.2</span> <span class="toctext">Heterogeneous Processor Test</span></a>
<ul>
<li class="toclevel-5 tocsection-56"><a href="#Building_4"><span class="tocnumber">4.5.5.2.1</span> <span class="toctext">Building</span></a></li>
<li class="toclevel-5 tocsection-57"><a href="#Running_4"><span class="tocnumber">4.5.5.2.2</span> <span class="toctext">Running</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-58"><a href="#MPM_Mailbox"><span class="tocnumber">5</span> <span class="toctext">MPM Mailbox</span></a></li>
<li class="toclevel-1 tocsection-59"><a href="#MPM_Sync"><span class="tocnumber">6</span> <span class="toctext">MPM Sync</span></a>
<ul>
<li class="toclevel-2 tocsection-60"><a href="#Barrier"><span class="tocnumber">6.1</span> <span class="toctext">Barrier</span></a></li>
<li class="toclevel-2 tocsection-61"><a href="#Lock"><span class="tocnumber">6.2</span> <span class="toctext">Lock</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-62"><a href="#MPM_Transport"><span class="tocnumber">7</span> <span class="toctext">MPM Transport</span></a>
<ul>
<li class="toclevel-2 tocsection-63"><a href="#Release_History"><span class="tocnumber">7.1</span> <span class="toctext">Release History</span></a>
<ul>
<li class="toclevel-3 tocsection-64"><a href="#Migration_from_MCSDK_3.1.1_to_MCSDK_3.1.3"><span class="tocnumber">7.1.1</span> <span class="toctext">Migration from MCSDK 3.1.1 to MCSDK 3.1.3</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-65"><a href="#Building_the_Library"><span class="tocnumber">7.2</span> <span class="toctext">Building the Library</span></a>
<ul>
<li class="toclevel-3 tocsection-66"><a href="#Modifying_and_Rebuilding_the_Library_for_Profiling"><span class="tocnumber">7.2.1</span> <span class="toctext">Modifying and Rebuilding the Library for Profiling</span></a></li>
<li class="toclevel-3 tocsection-67"><a href="#Building_Examples_with_SerDes_Bypass"><span class="tocnumber">7.2.2</span> <span class="toctext">Building Examples with SerDes Bypass</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-68"><a href="#Setting_Transport_Parameters_from_JSON_file"><span class="tocnumber">7.3</span> <span class="toctext">Setting Transport Parameters from JSON file</span></a></li>
<li class="toclevel-2 tocsection-69"><a href="#Transport_over_Hyperlink"><span class="tocnumber">7.4</span> <span class="toctext">Transport over Hyperlink</span></a>
<ul>
<li class="toclevel-3 tocsection-70"><a href="#Pre-requisites"><span class="tocnumber">7.4.1</span> <span class="toctext">Pre-requisites</span></a></li>
<li class="toclevel-3 tocsection-71"><a href="#JSON_Transport_Profile"><span class="tocnumber">7.4.2</span> <span class="toctext">JSON Transport Profile</span></a></li>
<li class="toclevel-3 tocsection-72"><a href="#Compiling_and_Linking_with_Hyperlink_Libraries"><span class="tocnumber">7.4.3</span> <span class="toctext">Compiling and Linking with Hyperlink Libraries</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-73"><a href="#Transport_over_QMSS"><span class="tocnumber">7.5</span> <span class="toctext">Transport over QMSS</span></a>
<ul>
<li class="toclevel-3 tocsection-74"><a href="#Pre-requisites_2"><span class="tocnumber">7.5.1</span> <span class="toctext">Pre-requisites</span></a></li>
<li class="toclevel-3 tocsection-75"><a href="#JSON_Transport_Profile_2"><span class="tocnumber">7.5.2</span> <span class="toctext">JSON Transport Profile</span></a></li>
<li class="toclevel-3 tocsection-76"><a href="#Initializing_QMSS"><span class="tocnumber">7.5.3</span> <span class="toctext">Initializing QMSS</span></a></li>
<li class="toclevel-3 tocsection-77"><a href="#QMSS_Send_and_Receive"><span class="tocnumber">7.5.4</span> <span class="toctext">QMSS Send and Receive</span></a></li>
<li class="toclevel-3 tocsection-78"><a href="#Compiling_and_Linking_with_QMSS_Libraries"><span class="tocnumber">7.5.5</span> <span class="toctext">Compiling and Linking with QMSS Libraries</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-79"><a href="#Transport_over_SRIO"><span class="tocnumber">7.6</span> <span class="toctext">Transport over SRIO</span></a>
<ul>
<li class="toclevel-3 tocsection-80"><a href="#Pre-requisites_3"><span class="tocnumber">7.6.1</span> <span class="toctext">Pre-requisites</span></a></li>
<li class="toclevel-3 tocsection-81"><a href="#JSON_Transport_Profile_3"><span class="tocnumber">7.6.2</span> <span class="toctext">JSON Transport Profile</span></a></li>
<li class="toclevel-3 tocsection-82"><a href="#Initializing_SRIO"><span class="tocnumber">7.6.3</span> <span class="toctext">Initializing SRIO</span></a></li>
<li class="toclevel-3 tocsection-83"><a href="#SRIO_Send_and_Receive"><span class="tocnumber">7.6.4</span> <span class="toctext">SRIO Send and Receive</span></a></li>
<li class="toclevel-3 tocsection-84"><a href="#Compiling_and_Linking_with_SRIO_Libraries"><span class="tocnumber">7.6.5</span> <span class="toctext">Compiling and Linking with SRIO Libraries</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-85"><a href="#Using_EDMA3"><span class="tocnumber">7.7</span> <span class="toctext">Using EDMA3</span></a>
<ul>
<li class="toclevel-3 tocsection-86"><a href="#Pre-requisites_4"><span class="tocnumber">7.7.1</span> <span class="toctext">Pre-requisites</span></a></li>
<li class="toclevel-3 tocsection-87"><a href="#MPM-Transport_Functions.2FAPI_to_use_EDMA3"><span class="tocnumber">7.7.2</span> <span class="toctext">MPM-Transport Functions/API to use EDMA3</span></a></li>
<li class="toclevel-3 tocsection-88"><a href="#Compiling_and_Linking_with_EDMA3_Libraries"><span class="tocnumber">7.7.3</span> <span class="toctext">Compiling and Linking with EDMA3 Libraries</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-89"><a href="#Using_libkeystonemmap"><span class="tocnumber">7.8</span> <span class="toctext">Using libkeystonemmap</span></a>
<ul>
<li class="toclevel-3 tocsection-90"><a href="#Pre-requisites_5"><span class="tocnumber">7.8.1</span> <span class="toctext">Pre-requisites</span></a></li>
<li class="toclevel-3 tocsection-91"><a href="#MPM-Transport_Functions.2FAPI_to_use_libkeystonemmap"><span class="tocnumber">7.8.2</span> <span class="toctext">MPM-Transport Functions/API to use libkeystonemmap</span></a>
<ul>
<li class="toclevel-4 tocsection-92"><a href="#How_the_mpm_transport_put_initiate64.28.29_API_Works_for_Hyperlink"><span class="tocnumber">7.8.2.1</span> <span class="toctext">How the mpm_transport_put_initiate64() API Works for Hyperlink</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-93"><a href="#Compiling_and_Linking_with_libkeystonemmap_Libraries"><span class="tocnumber">7.8.3</span> <span class="toctext">Compiling and Linking with libkeystonemmap Libraries</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<p><br />
</p>
<h1><span class="mw-headline" id="Overview">Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=1" title="Edit section: Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>Learn about the various Transports that are included in the MCSDK and how they move data between the ARM and DSP subsystems or between different software layers.
</p><p>MCSDK package provides multiple high level software abstractions component to facilitate applications to communicate between different processors. There are also low level drivers which talks to CPPI/QMSS/PA and can be used to communicate between separate entities. This section will focus on high level software abstractions for transport communication.
</p>
<h1><span class="mw-headline" id="Acronyms">Acronyms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=2" title="Edit section: Acronyms">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The following acronyms are used throughout this  chapter.<br />
</p>
<table border="1" style="width: 75%; height: 212px" id="acronymtable">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Acronym</b>
</td>
<td bgcolor="#c0c0c0"><b>Meaning</b>
</td></tr>
<tr>
<td>API
</td>
<td>Application Programming Interface
</td></tr>
<tr>
<td>ARM
</td>
<td>Advanced RISC Machine
</td></tr>
<tr>
<td>CCS
</td>
<td>Code Composer Studio
</td></tr>
<tr>
<td>CPPI
</td>
<td>Communications Port Programming Interface (Multicore Navigator)
</td></tr>
<tr>
<td>DSP
</td>
<td>Digital Signal Processor
</td></tr>
<tr>
<td>EVM
</td>
<td>Evaluation Module, hardware platform containing the Texas Instruments DSP
</td></tr>
<tr>
<td>IPC
</td>
<td>Texas Instruments Inter-Processor Communication
</td></tr>
<tr>
<td>LLD
</td>
<td>Low Level Driver
</td></tr>
<tr>
<td>MCSDK
</td>
<td>Texas Instruments Multi-Core Software Development Kit
</td></tr>
<tr>
<td>MSMC
</td>
<td>Multicore Shared Memory
</td></tr>
<tr>
<td>PDK
</td>
<td>Texas Instruments Programmers Development Kit
</td></tr>
<tr>
<td>QMSS
</td>
<td>Queue Manager Sub-System
</td></tr>
<tr>
<td>RM
</td>
<td>Resource Manager
</td></tr>
<tr>
<td>RTSC
</td>
<td>Eclipse Real-Time Software Components
</td></tr>
<tr>
<td>SRIO
</td>
<td>Serial RapidIO
</td></tr>
<tr>
<td>TI
</td>
<td>Texas Instruments
</td></tr>
<tr>
<td>TID
</td>
<td>MessageQ Network Transport ID
</td></tr></tbody></table>
<p><br />
</p><p><br />
</p>
<h1><span class="mw-headline" id="Transport_Network_Library">Transport Network Library</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=3" title="Edit section: Transport Network Library">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>Please see chapter <a rel="nofollow" class="external text" href="TransportNetLib_UsersGuide.html">TransportNetLib User Guide</a> for details.
</p>
<h1><span class="mw-headline" id="IPC_Transports">IPC Transports</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=4" title="Edit section: IPC Transports">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>IPC transports are the IPC MessageQ API's underlying configurable data paths over shared memory and hardware resources.  Transports are registered with MessageQ providing a common IPC interface between processors within a system that contains a single or multiple KeyStone II devices.   The transports supplied with the IPC component are shared memory based.  Additional transports, utilizing the QMSS and SRIO LLDs, are supplied via Yocto/bitbake for ARMv7 Linux IPC and MCSDK BIOS PDK for SYS/BIOS DSP IPC.  
</p><p>MessageQ can support up to nine simultaneous transports over two transport interfaces.  The first interface is the standard MessageQ, priority based, interface that has always existed.  A shared memory transport is always registered as the normal priority transport when MessageQ is initialized at IPC start.  An additional transport can be registered with MessageQ as a high priority transport.  The second interface is the Network transport interface.  The LLD transports can be registered with MessageQ as a Network transport.  Network transports are registered with MessageQ using a Transport ID, or TID.  There are seven possible TID values ranging from 1 through 7.  A MessageQ message is routed over a transport registered with a certain priority, or TID, based on the settings in the message's MessageQ header.  Editing a message's MessageQ header to contain the desired transport priority, or TID, is accomplished by calling the proper MessageQ header modification macro.
</p><p>The below table gives an overview of the transport offerings, their location, and the communication path they enable.
</p>
<table border="1" style="width: 1000px; height: 200px" id="IPC_transports">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Transport</b>
</td>
<td bgcolor="#c0c0c0"><b>MessageQ Interface Type</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td>
<td bgcolor="#c0c0c0"><b>Communication Route</b>
</td>
<td bgcolor="#c0c0c0"><b>Enabled Communication Path</b>
</td>
<td bgcolor="#c0c0c0"><b>Special Considerations</b>
</td></tr>
<tr>
<td>TransportShm...
</td>
<td>MessageQ (priority based)
</td>
<td>IPC component - SYS/BIOS subdirectories
</td>
<td>Shared memory
</td>
<td>SYS/BIOS DSP to DSP
</td>
<td>There are multiple implementations of TransportShm delivered within the IPC component.  Please see the IPC documentation provided with the component for more information on these shared memory transport implementations.
</td></tr>
<tr>
<td>TransportRpmsg
</td>
<td>MessageQ (priority based)
</td>
<td>
<ul><li>IPC component - ARMv7 Linux subdirectories</li>
<li>IPC component - SYS/BIOS subdirectories</li>
<li>Yocto/bitbake ti-ipc recipe</li></ul>
</td>
<td>Shared memory
</td>
<td>
<ul><li>ARMv7 Linux to/from SYS/BIOS DSP</li></ul>
</td>
<td>MessageQ messages sent over TransportRpmsg traveling from/to ARMv7 user space go through the Linux kernel before reaching the DSP.  This provides <i>clean</i> partitioning between user memory and DSP memory.  However, TransportRpmsg is considered a <i>slow path</i> since the user space MessageQ messages must be copied from/to DSP memory by kernel and DSP.
</td></tr>
<tr>
<td>SYS/BIOS DSP TransportSrio
</td>
<td>Network
</td>
<td>MCSDK BIOS PDK
</td>
<td>SRIO LLD
</td>
<td>
<ul><li>SYS/BIOS DSP to/from SYS/BIOS DSP (intra- and inter-device)</li>
<li>SYS/BIOS DSP to/from ARMv7 Linux (intra- and inter-device)</li></ul>
</td>
<td>
<ul><li>TransportSrio can send MessageQ messages to ARMv7 and DSP processors on remote devices in a multiple device system.  IPC MultiProc must be configured to be aware of all processors existing on all devices and all devices must be connected over a SRIO interconnect.</li>
<li>The main purpose of TransportSrio is for multi-device communication over MessageQ.  The transmission latency is greater for this transport due to the latter capability.  Therefore, it is recommended a shared memory or other LLD-based transport is used for intra-device communication due to their lower latency costs.</li></ul>
</td></tr>
<tr>
<td>ARMv7 Linux TransportSrio
</td>
<td>Network
</td>
<td>Yocto/bitbake ti-transport-srio recipe
</td>
<td>SRIO LLD
</td>
<td>
<ul><li>ARMv7 Linux to/from ARMv7 Linux (intra- and inter-device)</li>
<li>SYS/BIOS DSP to/from ARMv7 Linux (intra- and inter-device)</li></ul>
</td>
<td>
<ul><li>TransportSrio can send MessageQ messages to ARMv7 and DSP processors on remote devices in a multiple device system.  IPC MultiProc must be configured to be aware of all processors existing on all devices and all devices must be connected over a SRIO interconnect.</li>
<li>The main purpose of TransportSrio is for multi-device communication over MessageQ.  The transmission latency is greater for this transport due to the latter capability.  Therefore, it is recommended a shared memory or other LLD-based transport is used for intra-device communication due to their lower latency costs.</li></ul>
</td></tr>
<tr>
<td>ARMv7 Linux TransportQmss
</td>
<td>Network
</td>
<td>Yocto/bitbake ti-transport-qmss recipe
</td>
<td>QMSS LLD
</td>
<td>
<ul><li>ARMv7 Linux process to process</li>
<li>ARMv7 Linux to/from SYS/BIOS DSP</li></ul>
</td>
<td>
</td></tr>
<tr>
<td>SYS/BIOS DSP TransportQmss
</td>
<td>Network
</td>
<td>
</td>
<td>QMSS LLD
</td>
<td>
<ul><li>SYS/BIOS DSP to/from SYS/BIOS DSP</li>
<li>SYS/BIOS DSP to/from ARMv7 Linux</li></ul>
</td>
<td>
</td></tr></tbody></table>
<p>The IPC component (ARMv7 and SYS/BIOS) is available in MCSDK BIOS and MCSDK Linux installations.  It will be installed in  &lt;MCSDK BIOS/Linux install root&gt;/ipc_3_##_##_##&lt;version&gt;.  Additionally, the IPC component's ARMv7 source is packaged in a Yocto/bitbake recipe.  A user can develop ARMv7 Linux user-space applications with IPC on KeyStone II devices by building the ti-ipc package in Yocto.
</p><p>The IPC component is also used on OMAP-based Android devices. The component is compatible with legacy SYS/BIOS IPC MessageQ APIs available in other TI SDKs.  A rich set of documentation can be browsed at <a rel="nofollow" class="external text" href="http://processors.wiki.ti.com/index.php?title=IPC_3.x">IPC_3.x</a>.
</p><p>The following sections will give architecture, build, and configuration details for the LLD-based transports delivered via MCSDK BIOS PDK and Yocto/bitbake.  More information on the shared memory transports delivered with the IPC component can be found in the IPC_Users_Guide PDF found in the docs directory of the IPC component.
</p>
<h2><span class="mw-headline" id="KeyStone_II_IPC_Details">KeyStone II IPC Details</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=5" title="Edit section: KeyStone II IPC Details">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol><li>KeyStone II platforms must use <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Developing_System_Mgmt.html#Multiple_Processor_Manager">MPM</a> to load and run DSP applications linked with IPC 3.x that wish to perform ARM to DSP, and vice versa, over MessageQ.  MPM reads the DSP image on download and sets the kernel appropriate parameters for IPC.</li>
<li>CCS can be used to debug DSP applications after MPM has loaded and run the app using the load symbols facility.</li>
<li>Headers and libraries for the ARMv7 IPC component and IPC transports are provided as a part of <i>linux-devkit</i>.</li>
<li>The ARMv7 IPC's NameServer runs as a Linux daemon from the filesystem provided in the MCSDK LINUX component.</li></ol>
<h2><span id="SYS/BIOS_DSP_TransportSrio"></span><span class="mw-headline" id="SYS.2FBIOS_DSP_TransportSrio">SYS/BIOS DSP TransportSrio</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=6" title="Edit section: SYS/BIOS DSP TransportSrio">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The SYS/BIOS DSP TransportSrio is a MessageQ Network interface transport that can be used on a KeyStone II DSP running SYS/BIOS IPC to send and receive MessageQ messages between any ARMv7 and DSP processor on the same or different device.  Communication between any processor comes with the caveat that all processor's must have a unique ID assigned by the IPC MultiProc module.  Additionally, the ID mappings maintained by the MultiProc modules on each device must be in sync.
</p>
<h3><span class="mw-headline" id="Architecture">Architecture</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=7" title="Edit section: Architecture">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The SYS/BIOS DSP TransportSrio is a MessageQ Network interface transport that utilizes the SRIO LLD to send and receive MessageQ messages between SRIO endpoints.  The SRIO endpoints can be on the same device or on another device entirely.  All SRIO endpoints mapped through TransportSrio must have MessageQ as the upper level messaging layer.
</p><p><a href="File_SRIO_IPC_Trans_Arch.html" class="image" title="SRIO_IPC_Trans_Arch.jpg"><img alt="SRIO_IPC_Trans_Arch.jpg" src="https://processors.wiki.ti.com/images/a/ae/SRIO_IPC_Trans_Arch.jpg" width="1100" height="667" /></a>
</p><p>TransportSrio is restricted to being a MessageQ Network interface transport.  Network interface transports are registered with MessageQ with a Transport ID value, or TID, which can be any integer from 1 through seven.  The transport must be created and added to MessageQ's Network transport routing table after IPC has started, IPC has synced with all cores, and MessageQ has enabled a default intra-device, core to core transport.  The default priority-based, intra-device, MessageQ interface transport is TransportShmNotify in DSP-only cases or TransportRpmsg in ARMv7 + DSP cases.  MessageQ messages can be routed over the different transports by setting the desired transport priority, or TID value, in the MessageQ header's flags field.  A message will be sent over a registered Network transport if a valid TID and a priority are set.
</p><p>&lt;syntaxhighlight lang='C'&gt;
MessageQ_Msg msg;
</p><p>msg = MessageQ_alloc(MY_HEAP_ID, sizeof(msg));
</p><p>/* Route over MessageQ's MessageQ interface normal priority transport.
</p>
<pre>* Should never need to explicitly set since MessageQ_alloc()
* will set normal priority by default */
</pre>
<p>MessageQ_setMsgPri(msg, MessageQ_NORMALPRI);
MessageQ_put(queueId, msg);
</p><p>/* ...or... */
</p><p>/* Route over MessageQ's MessageQ interface high priority transport */
MessageQ_setMsgPri(msg, MessageQ_HIGHPRI);
MessageQ_put(queueId, msg);
</p><p>/* ...or... */
</p><p>/* Route over MessageQ's Network interface
</p>
<pre>* TID value has to be a value between 1 and 7 */
</pre>
<p>MessageQ_setTransportId(msg, transport_tid);
MessageQ_put(queueId, msg);
&lt;/syntaxhighlight&gt;
</p><p>The TransportSrio must be created and registered with MessageQ after IPC has started so that all initialization requirements for the SRIO transport can be satisfied.  First, and most importantly, TransportSrio initialization will be making resource requests from the CPPI, QMSS, and SRIO LLDs.  As a result, the Resource Manager (RM) LLD must be fully initialized and a transport path from RM Clients to the RM Server must be available.  Typically, the TransportShmNotify is used to enable RM message passing between the Clients and Server.  Second, forcing TransportSrio initialization after IPC start and sync allows any CPPI Host descriptors and attached buffers to be placed in any type of device memory.
</p><p>TransportSrio relies on IPC MultiProc's cluster functionality in order to communicate with remote device DSP cores running TransportSrio.  The application must define the entire processor topology for the MultiProc module.  The number of processors across all devices must be defined for MultiProc.  The application's RTSC .cfg file must also define the local device's cluster base ID for MultiProc.  An example for an application spanning three devices:
</p><p><u>Device A</u>
&lt;syntaxhighlight lang='C'&gt;
var MultiProc = xdc.useModule('ti.sdo.utils.MultiProc');
/* Cluster definitions - Example has three clusters, one for each device.  Each cluster
</p>
<pre>* has two DSPs within it.
* Device A [Cluster Base ID: 0] - 1 Host + 2 DSPs (Procs)
* Device B [Cluster Base ID: 3] - 1 Host + 2 DSPs (Procs)
* Device C [Cluster Base ID: 3] - 1 Host + 2 DSPs (Procs)
* Total of 3 Hosts + 6 DSPs (Procs) */
</pre>
<p>MultiProc.numProcessors = 9;
/* baseIdOfCluster and numProcessors must be set BEFORE setConfig is run */
MultiProc.numProcsInCluster = 3;
MultiProc.baseIdOfCluster = 0;
var procNameList = ["HOST", "CORE0", "CORE1"];
MultiProc.setConfig(null, procNameList);
&lt;/syntaxhighlight&gt;
</p><p><u>Device B</u>
&lt;syntaxhighlight lang='C'&gt;
var MultiProc = xdc.useModule('ti.sdo.utils.MultiProc');
/* Cluster definitions - Example has three clusters, one for each device.  Each cluster
</p>
<pre>* has two DSPs within it.
* Device A [Cluster Base ID: 0] - 1 Host + 2 DSPs (Procs)
* Device B [Cluster Base ID: 3] - 1 Host + 2 DSPs (Procs)
* Device C [Cluster Base ID: 3] - 1 Host + 2 DSPs (Procs)
* Total of 3 Hosts + 6 DSPs (Procs) */
</pre>
<p>MultiProc.numProcessors = 9;
/* baseIdOfCluster and numProcessors must be set BEFORE setConfig is run */
MultiProc.numProcsInCluster = 3;
MultiProc.baseIdOfCluster = 3;
var procNameList = ["HOST", "CORE0", "CORE1"];
MultiProc.setConfig(null, procNameList);
&lt;/syntaxhighlight&gt;
</p><p><u>Device C</u>
&lt;syntaxhighlight lang='C'&gt;
var MultiProc = xdc.useModule('ti.sdo.utils.MultiProc');
/* Cluster definitions - Example has three clusters, one for each device.  Each cluster
</p>
<pre>* has two DSPs within it.
* Device A [Cluster Base ID: 0] - 1 Host + 2 DSPs (Procs)
* Device B [Cluster Base ID: 3] - 1 Host + 2 DSPs (Procs)
* Device C [Cluster Base ID: 3] - 1 Host + 2 DSPs (Procs)
* Total of 3 Hosts + 6 DSPs (Procs) */
</pre>
<p>MultiProc.numProcessors = 9;
/* baseIdOfCluster and numProcessors must be set BEFORE setConfig is run */
MultiProc.numProcsInCluster = 3;
MultiProc.baseIdOfCluster = 6;
var procNameList = ["HOST", "CORE0", "CORE1"];
MultiProc.setConfig(null, procNameList);
&lt;/syntaxhighlight&gt;
</p>
<h3><span id="SYS/BIOS_DSP_TransportSrio_Source_Delivery_and_Recompilation"></span><span class="mw-headline" id="SYS.2FBIOS_DSP_TransportSrio_Source_Delivery_and_Recompilation">SYS/BIOS DSP TransportSrio Source Delivery and Recompilation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=8" title="Edit section: SYS/BIOS DSP TransportSrio Source Delivery and Recompilation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The SYS/BIOS DSP TransportSrio source code and examples are delivered within the MCSDK BIOS PDK component.  DSP TransportSrio can be rebuilt using the environment setup scripts provided with the PDK package.  DSP TransportSrio example applications are created as part of the pdkProjectCreate scripts.  They can be imported and built the same as PDK LLD example and test CCS projects.
</p>
<h4><span class="mw-headline" id="Recompiling_on_Windows">Recompiling on Windows</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=9" title="Edit section: Recompiling on Windows">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ol><li>Open a Windows command terminal and navigate to &lt;pdk_install_dir&gt;/packages.</li>
<li>Set the component install paths.  The following commands can be used assuming installation of MCSDK 3.1.3.6 (Presuming CCS and MCSDK 3.1.3 is installed in C:\ti\) <br /> set C6X_GEN_INSTALL_PATH="C:\ti\ccsv5\tools\compiler\c6000_7.4.8" <br /> set XDC_INSTALL_PATH=C:\ti\xdctools_3_30_05_60 <br /> set EDMA3LLD_BIOS6_INSTALLDIR="C:\ti\edma3_lld_02_11_13_17" <br /> set CG_XML_BIN_INSTALL_PATH=C:\ti\cg_xml\bin <br /> set BIOS_INSTALL_PATH=C:\ti\bios_6_41_00_26\packages <br /> set IPC_INSTALL_PATH=C:\ti\ipc_3_35_01_07\packages <br /> set PDK_INSTALL_PATH=C:\ti\pdk_keystone2_3_01_03_06</li>
<li>Run pdksetupenv.bat <br /> &gt;pdksetupenv.bat</li>
<li>Navigate to &lt;pdk_install_path&gt;/packages/ti/transport/ipc/c66/srio/</li>
<li>Build the IPC SRIO Transport library <br /> &gt;xdc</li></ol>
<p>Issue the following commands if the SRIO transport ever needs to be rebuilt:
</p>
<dl><dd><dl><dd>&gt;xdc clean <br /></dd>
<dd>&gt;xdc</dd></dl></dd></dl>
<h4><span class="mw-headline" id="Recompiling_on_Linux">Recompiling on Linux</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=10" title="Edit section: Recompiling on Linux">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ol><li>Open a Linux bash terminal and navigate to &lt;pdk_install_dir&gt;/packages.</li>
<li>Export the component install paths.  The following commands can be used assuming installation of MCSDK 3.1.3.6 (Presuming CCS and MCSDK 3.1.3 is installed in /opt/ti) <br /> export C6X_GEN_INSTALL_PATH=/opt/ti/ccsv5/tools/compiler/c6000_7.4.8 <br /> export XDC_INSTALL_PATH=/opt/ti/xdctools_3_30_05_60 <br /> export EDMA3LLD_BIOS6_INSTALLDIR=/opt/ti/edma3_lld_02_11_13_17 <br /> export CG_XML_BIN_INSTALL_PATH=/opt/ti/cg_xml/bin <br /> export BIOS_INSTALL_PATH=/opt/ti/bios_6_41_00_26/packages <br /> export IPC_INSTALL_PATH=/opt/ti/ipc_3_35_01_07/packages <br /> export PDK_INSTALL_PATH=/opt/ti/pdk_keystone2_3_01_03_06</li>
<li>Run pdksetupenv.sh <br /> $ source pdksetupenv.sh</li>
<li>Navigate to &lt;pdk_install_path&gt;/packages/ti/transport/ipc/c66/srio/</li>
<li>Build the IPC SRIO Transport library <br /> $ xdc</li></ol>
<p>Issue the following commands if the SRIO transport ever needs to be rebuilt:
</p>
<dl><dd><dl><dd>$ xdc clean <br /></dd>
<dd>$ xdc</dd></dl></dd></dl>
<h3><span id="SYS/BIOS_DSP_TransportSrio_Configuration_Parameters"></span><span class="mw-headline" id="SYS.2FBIOS_DSP_TransportSrio_Configuration_Parameters">SYS/BIOS DSP TransportSrio Configuration Parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=11" title="Edit section: SYS/BIOS DSP TransportSrio Configuration Parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Following are the configuration parameters for DSP TransportSrio instance creation.  Descriptions, default values, and programming considerations are provided for each configuration parameter.  Each parameter is an element of the TransportSrio_Params structure.  A structure of this type must be created, populated, and passed to the TransportSrio_create() function via pointer.  The structure should be initialized to its default values using the TransportSrio_Params_init() function prior to population with user specific parameters.
</p><p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>   TransportSrio_Params  transSrioParams;
</pre>
<pre>   ...
   TransportSrio_Params_init(&amp;transSrioParams);
   transSrioParams.deviceCfgParams   = ...;
   transSrioParams.txMemRegion       = ...;
   ...
   srioTransHandle = TransportSrio_create(&amp;transSrioParams, &amp;errorBlock);
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<table border="1" style="width: 1000px; height: 200px" id="srio_transport_config_params">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Configuration Parameter Element</b>
</td>
<td bgcolor="#c0c0c0"><b>Description</b>
</td>
<td bgcolor="#c0c0c0"><b>Initial Value</b>
</td>
<td bgcolor="#c0c0c0"><b>Special Considerations</b>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;TransportSrio_DeviceConfigParams *deviceCfgParams;&lt;/syntaxhighlight&gt;
</td>
<td>Pointer to the device specific TransportSrio configuration parameter structure.
</td>
<td>NULL
</td>
<td>TransportSrio configuration structure is defined in the TransportSrio_device.c source file for supported devices.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Int txMemRegion;&lt;/syntaxhighlight&gt;
</td>
<td>QMSS memory region from which to allocate transmit side Host descriptors.
</td>
<td>-1
</td>
<td>
<ul><li>Descriptors inserted into this region must be of Host type.</li>
<li>The descriptors can be located in L2, MSMC, or DDR3 memory.  The base address of the descriptors must be cache line aligned if located within a shared memory (MSMC or DDR3) and caching is enabled.</li></ul>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 txNumDesc;&lt;/syntaxhighlight&gt;
</td>
<td>Number of Host descriptors to pre-allocate for SRIO transmit operations.  MessageQ data buffers are attached to the buffers and sent out via the SRIO LLD.  Descriptors are recycled onto a completion queue.  Descriptors, and their attached buffers, are recycled in future TransportSrio_put operations.
</td>
<td>2
</td>
<td>Minimum of two descriptors needed for a ping-pong-like operation.  While one descriptor+buffer pair is sent, the other is recycled.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 txDescSize;&lt;/syntaxhighlight&gt;
</td>
<td>Size of the transmit descriptors in bytes.
</td>
<td>0
</td>
<td>Cache coherence operations may be performed on the descriptors based on their memory location.  As a result, the descriptor size should be a multiple a cache line.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 rxQType;&lt;/syntaxhighlight&gt;
</td>
<td>The QMSS queue type that will be opened and used with the receive accumulator.  The queue type does not matter.  Accumulator GEM events are mapped to the accumulator channels, not the queue type+value.
</td>
<td>0
</td>
<td>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Int rxMemRegion;&lt;/syntaxhighlight&gt;
</td>
<td>QMSS memory region from which to allocate receive side Host descriptors.
</td>
<td>-1
</td>
<td>
<ul><li>This memory region can be the same as that provided for txMemRegion.</li>
<li>Descriptors inserted into this region must be of Host type.</li>
<li>The descriptors can be located in L2, MSMC, or DDR3 memory.  The base address of the descriptors must be cache line aligned if located within a shared memory (MSMC or DDR3) and caching is enabled.</li></ul>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 rxNumDesc;&lt;/syntaxhighlight&gt;
</td>
<td>Number of Host descriptors to pre-allocate for SRIO receive operations.  MessageQ data buffers are pre-allocated and attached to the descriptors at TransportSrio_create() time.  Data received by the SRIO LLD is copied directly into the MessageQ buffer attached the receive descriptor.
</td>
<td>1
</td>
<td>Minimum of one descriptor needed to receive a packet.  The descriptors are reused for receive operations.  New MessageQ buffers are allocated and attached to descriptors prior to their reuse.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 rxDescSize;&lt;/syntaxhighlight&gt;
</td>
<td>Size of the receive descriptors in bytes.
</td>
<td>0
</td>
<td>Cache coherence operations may be performed on the descriptors based on their memory location.  As a result, the descriptor size should be a multiple a cache line.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt16 rxMsgQHeapId;&lt;/syntaxhighlight&gt;
</td>
<td>Rx-side MessageQ Heap ID.  MessageQ buffers are pre-allocated out of this heap and attached to descriptors for packets received by the SRIO interface.
</td>
<td>~1
</td>
<td>
<ul><li>The heap must have AT LEAST rxNumDesc number of buffers.</li>
<li>The heap can reside can reside in L2, MSMC, or DDR3.  TransportSrio will perform cache coherence operations on heap buffers residing in shared memory areas.</li>
<li>Buffers should be sized to be a multiple of a cache line if the heap is located in a shared memory.  This prevents corruptions when cache coherence operations are performed.</li></ul>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 maxMTU;&lt;/syntaxhighlight&gt;
</td>
<td>Maximum transmittable unit in bytes that will be handled by TransportSrio.  This is also the size of the buffers within the heap mapped to the rxMsgQHeapId.
</td>
<td>256
</td>
<td>maxMTU should be sized to be a multiple of a cache line.  This prevents corruptions when cache coherence operations are performed on rxMsgQHeapId buffers located in a shared memory.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt8 accumCh;&lt;/syntaxhighlight&gt;
</td>
<td>The accumulator channel used for SRIO packet reception.  The GEM event for the accumulator interrupt will be derived from the provided accumulator channel and the DSP core number.
</td>
<td>0
</td>
<td>Please refer to the device's Multicore Navigator specification for the proper accumulator channels for each DSP core.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 accumTimerCount;&lt;/syntaxhighlight&gt;
</td>
<td>Number of global timer ticks to delay the periodic accumulator interrupt.  A value of zero will cause an interrupt immediately upon a descriptor being placed in the accumulator ping/pong buffer.
</td>
<td>0
</td>
<td>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Void *rmServiceHandle;&lt;/syntaxhighlight&gt;
</td>
<td>RM service handle that will be given to Srio_start.  The RM service handle only needs to be provided if the intent is for RM to manage SRIO resources
</td>
<td>NULL
</td>
<td>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt rxIntVectorId;&lt;/syntaxhighlight&gt;
</td>
<td>Interrupt vector ID to tie to the receive side accumulator operation.
</td>
<td>~1
</td>
<td>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;srioSockParams *sockParams;&lt;/syntaxhighlight&gt;
</td>
<td>Pointer to socket parameters used by the SRIO transport to bind the socket and to route messages to the proper endpoints.
</td>
<td>NULL
</td>
<td>Socket parameters include the socket type (Type 11 or Type 9), the number of endpoints in the endpoint list, and a pointer to the Type 11 or Type 9 endpoint parameter list.  The endpoint parameter list contains the address information for each processor endpoint in the system.  The parameter list must be indexed by the IPC MultiProc ID so that all processors can be mapped to a unique SRIO address.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt transNetworkId;&lt;/syntaxhighlight&gt;
</td>
<td>The transport instance will be registered with MessageQ's network transport interface using the supplied network transport ID.  MessageQ messages with a matching transport ID in their MessageQ header will be sent over the transport instance.
</td>
<td>0
</td>
<td>The MessageQ network interface transport ID must have a value between 1 and 7.
</td></tr></tbody></table>
<h3><span id="Adding_the_SYS/BIOS_DSP_TransportSrio_to_a_DSP_Application"></span><span class="mw-headline" id="Adding_the_SYS.2FBIOS_DSP_TransportSrio_to_a_DSP_Application">Adding the SYS/BIOS DSP TransportSrio to a DSP Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=12" title="Edit section: Adding the SYS/BIOS DSP TransportSrio to a DSP Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>TransportSrio requires some special considerations when adding it to an application since it is not a standard, shared memory, IPC transport.  As described earlier, TransportSrio is an IPC MessageQ Network interface transport.  It relies on IPC and MessageQ being initialized with a, priority-based, shared memory transport prior to creating any TransportSrio instances.  The latter occurs by default in the RTSC configuration and Ipc_start().  Creating TransportSrio instances after IPC and MessageQ have initialized allows the transport to be initialized without any hardcoded assumptions about the locations of heaps buffers and QMSS descriptors in memory.  It also allows the LLDs used by TransportSrio to request their resources from RM since RM will use the MessageQ shared memory transport as the resource request/response path.
</p>
<h4><span class="mw-headline" id="Additions_to_the_Application_RTSC_.cfg">Additions to the Application RTSC .cfg</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=13" title="Edit section: Additions to the Application RTSC .cfg">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul><li>TransportSrio requires the CPPI, QMSS, and SRIO LLDs in order to operate.  The RM LLD is a requirement for Keystone II devices</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
var Cppi = xdc.loadPackage('ti.drv.cppi'); 
var Qmss = xdc.loadPackage('ti.drv.qmss');
var Srio = xdc.loadPackage('ti.drv.srio');
var Rm   = xdc.loadPackage('ti.drv.rm');
</p><p>Program.sectMap[".qmss"] = new Program.SectionSpec();
Program.sectMap[".qmss"] = "MSMCSRAM";
</p><p>Program.sectMap[".cppi"] = new Program.SectionSpec();
Program.sectMap[".cppi"] = "MSMCSRAM";
</p><p>Program.sectMap[".sharedGRL"] = new Program.SectionSpec();
Program.sectMap[".sharedGRL"] = "L2SRAM";
</p><p>Program.sectMap[".sharedPolicy"] = new Program.SectionSpec();
Program.sectMap[".sharedPolicy"] = "L2SRAM";
</p><p>Program.sectMap[".srioSharedMem"] = new Program.SectionSpec();
Program.sectMap[".srioSharedMem"] = "MSMCSRAM";
&lt;/syntaxhighlight&gt;
</p>
<ul><li>The TransportSrio module must be included to pull in the library.  MessageQ must be configured with reserve queue which will be used by any MessageQ Network interface transports that are registered.  The NameServer module does not work with the MessageQ Network interface transports since these transports can potentially send MessageQ messages off-device.  NameServer cannot query outside of the device.</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
var Ipc = xdc.useModule('ti.sdo.ipc.Ipc');
/* Ipc_start() will synchronize all local DSP processors */
Ipc.procSync = Ipc.ProcSync_ALL;
var MessageQ = xdc.useModule('ti.sdo.ipc.MessageQ');
/* Reserve a block of MessageQ queues for use by the MessageQ network interface
</p>
<pre>* transports since they don't use the NameServer module */
</pre>
<p>MessageQ.numReservedEntries = 4;
var TransportSrio = xdc.useModule('ti.transport.ipc.c66.srio.TransportSrio');
&lt;/syntaxhighlight&gt;
</p>
<ul><li>The device-specific low-level IPC modules must be included so that the interrupt logic properly associates the device MultiProc IDs to destination interrupt generation.  The MultiProc module and the low-level IPC module must both be aware that an ARMv7 processor exists as MultiProc ID 0 on KeyStone II devices.</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
/* Use the correct version of the low-level IPC modules so that the ARMv7
</p>
<pre>* processor is correctly factored into the notification logic */
</pre>
<p>var NotifyDriverCirc = xdc.useModule('ti.sdo.ipc.notifyDrivers.NotifyDriverCirc');
var Interrupt = xdc.useModule('ti.ipc.family.tci6638.Interrupt');
NotifyDriverCirc.InterruptProxy = Interrupt;
var VirtQueue = xdc.useModule('ti.ipc.family.tci6638.VirtQueue');
</p><p>/*  Notify brings in the ti.sdo.ipc.family.Settings module, which does
</p>
<pre>*  lots of config magic which will need to be UNDONE later, or setup
*  earlier, to get the necessary overrides to various IPC module proxies!
*/
</pre>
<p>var Notify = xdc.module('ti.sdo.ipc.Notify');
var Ipc = xdc.useModule('ti.sdo.ipc.Ipc');
</p><p>/* Note: Must call this to override what's done in Settings.xs&#160;! */
Notify.SetupProxy = xdc.module('ti.ipc.family.tci6638.NotifyCircSetup');
&lt;/syntaxhighlight&gt;
</p>
<ul><li>As shown earlier in the <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Developing_Transports.html#Architecture">Architecture</a> section, the MultiProc parameters must be configured correctly for each device.</li></ul>
<h4><span class="mw-headline" id="Source_Code_Additions">Source Code Additions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=14" title="Edit section: Source Code Additions">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul><li>A TransportSrio instance can be created between two endpoints after the following:
<ul><li>IPC has started and all local DSPs have attached</li>
<li>RM instances have been created.  Communication between the RM Clients and the RM Server will take place over the default MessageQ interface, priority-based, IPC transport.</li>
<li>QMSS and CPPI have been initialized and started</li>
<li>The SRIO IP block has been turned ON via the PSC and the SRIO device initialization routine has been executed</li>
<li>The heaps that will provide buffers for MessageQ send/receive have been created.  The same heap can be used for both transmit and receive.  <img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The heap used by the TransportSrio receive logic must have a gate that is able to operate within an interrupt context.  In the transport examples a GateMP configured for GateMP_LocalProtect_INTERRUPT is used.</li></ul></li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
/* Create the heap that will be used to allocate messages. */
GateMP_Params_init(&amp;gateMpParams);
gateMpParams.localProtect = GateMP_LocalProtect_INTERRUPT;
gateMpHandle = GateMP_create(&amp;gateMpParams);
</p><p>HeapBufMP_Params_init(&amp;heapBufParams);
heapBufParams.regionId  = 0;
...
heapBufParams.gate      = gateMpHandle;
heapHandle = HeapBufMP_create(&amp;heapBufParams);
&lt;/syntaxhighlight&gt;
</p>
<ul><li>SYS/BIOS DSP TransportSrio instances can be created between end points once all previous requirements are satisfied.  A TransportSrio instance of each SRIO type, 11 and 9, can exist on a DSP simultaneously.  The following example code comes from the MultiBoard example:</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>   /* Create SRIO type 11 &amp; 9 transport instances.  They will be a network
    * transport so won't interfere with default MessageQ transport, shared
    * memory notify transport */
       
   /* Type 11 configuration */
   TransportSrio_Params_init(&amp;transSrioParamsT11);
   /* Configure common parameters */
   transSrioParamsT11.deviceCfgParams   = &amp;srioTransCfgParams;
   transSrioParamsT11.txMemRegion       = HOST_DESC_MEM_REGION;
   /* Descriptor pool divided between all cores.  Account type 9+11 for send/receive (divide by 4) */
   transSrioParamsT11.txNumDesc         = (HOST_DESC_NUM / 4) / ipcNumLocalDspCores;
   transSrioParamsT11.txDescSize        = HOST_DESC_SIZE_BYTES;
   transSrioParamsT11.rxQType           = Qmss_QueueType_HIGH_PRIORITY_QUEUE;
   transSrioParamsT11.rxMemRegion       = HOST_DESC_MEM_REGION;
   /* Descriptor pool divided between all cores.  Account type 9+11 for send/receive (divide by 4) */
   transSrioParamsT11.rxNumDesc         = (HOST_DESC_NUM / 4) / ipcNumLocalDspCores;
   transSrioParamsT11.rxDescSize        = HOST_DESC_SIZE_BYTES;
   transSrioParamsT11.rxMsgQHeapId      = SRIO_MSGQ_HEAP_ID;
   transSrioParamsT11.maxMTU            = SRIO_MTU_SIZE_BYTES;
   transSrioParamsT11.rmServiceHandle   = rmServiceHandle;    
   /* Must map to a valid channel for each DSP core.  Follow sprugr9f.pdf Table 5-9 */
   transSrioParamsT11.accumCh           = DNUM;
   transSrioParamsT11.accumTimerCount   = 0; 
   transSrioParamsT11.transNetworkId    = SRIO_T11_TRANS_NET_ID;
   transSrioParamsT11.rxIntVectorId     = 8;
</pre>
<pre>   memset(&amp;t11EpParams, 0, sizeof(t11EpParams));
   /* Linux Host (Producer) MultiProc ID - 0 */
   t11EpParams[0].tt       = 0;
   t11EpParams[0].deviceId = DEVICE_ID1_8BIT;
   t11EpParams[0].mailbox  = 0;
   t11EpParams[0].letter   = 0;
   t11EpParams[0].segMap   = (sizeof(TstMsg) &gt; 256&#160;? 1&#160;:0);
   /* Core 0 (Producer) MultiProc ID - 1 */
   t11EpParams[1].tt       = 0;
   t11EpParams[1].deviceId = DEVICE_ID1_8BIT;
   t11EpParams[1].mailbox  = 0;
   t11EpParams[1].letter   = 1;
   t11EpParams[1].segMap   = (sizeof(TstMsg) &gt; 256&#160;? 1&#160;:0);
   /* Core 1 (Producer) MultiProc ID - 2 */
   t11EpParams[2].tt       = 0;
   t11EpParams[2].deviceId = DEVICE_ID1_8BIT;
   t11EpParams[2].mailbox  = 0;
   t11EpParams[2].letter   = 2;
   t11EpParams[2].segMap   = (sizeof(TstMsg) &gt; 256&#160;? 1&#160;:0);
   /* Linux Host (Consumer) MultiProc ID - 3 */
   t11EpParams[3].tt       = 0;
   t11EpParams[3].deviceId = DEVICE_ID2_8BIT;
   t11EpParams[3].mailbox  = 0;
   t11EpParams[3].letter   = 0;
   t11EpParams[3].segMap   = (sizeof(TstMsg) &gt; 256&#160;? 1&#160;:0);
   /* Core 0 (Consumer) MultiProc ID - 4 */
   t11EpParams[4].tt       = 0;
   t11EpParams[4].deviceId = DEVICE_ID2_8BIT;
   t11EpParams[4].mailbox  = 0;
   t11EpParams[4].letter   = 1;
   t11EpParams[4].segMap   = (sizeof(TstMsg) &gt; 256&#160;? 1&#160;:0);
   /* Core 1 (Consumer) MultiProc ID - 5 */
   t11EpParams[5].tt       = 0;
   t11EpParams[5].deviceId = DEVICE_ID2_8BIT;
   t11EpParams[5].mailbox  = 0;
   t11EpParams[5].letter   = 2;
   t11EpParams[5].segMap   = (sizeof(TstMsg) &gt; 256&#160;? 1&#160;:0);
</pre>
<pre>   memset(&amp;t11socketParams, 0, sizeof(t11socketParams));
   t11socketParams.epListSize = NUM_TOTAL_CORES;
   t11socketParams.sockType = TransportSrio_srioSockType_TYPE_11;
   t11socketParams.u.pT11Eps = &amp;t11EpParams[0];
   
   transSrioParamsT11.sockParams = &amp;t11socketParams;
</pre>
<pre>   Error_init(&amp;errorBlock);
   System_printf("IPC Core&#160;%d&#160;: "
                 "Creating SRIO Transport instance with Type 11 socket\n",
                 ipcCoreId);
   srioT11TransHandle = TransportSrio_create(&amp;transSrioParamsT11, &amp;errorBlock);
   if (srioT11TransHandle == NULL) {
       System_printf("Error IPC Core&#160;%d&#160;: "
                     "TransportSrio_create failed with id&#160;%d\n", ipcCoreId,
                     errorBlock.id);
       return;
   }  
</pre>
<pre>   /* Type 9 configuration */
   TransportSrio_Params_init(&amp;transSrioParamsT9);
   /* Configure common parameters */
   transSrioParamsT9.deviceCfgParams   = &amp;srioTransCfgParams;
   transSrioParamsT9.txMemRegion       = HOST_DESC_MEM_REGION;
   /* Descriptor pool divided between all cores.
    * Account type 9+11 for send/receive (divide by 4) */
   transSrioParamsT9.txNumDesc         = (HOST_DESC_NUM / 4) / ipcNumLocalDspCores;
   transSrioParamsT9.txDescSize        = HOST_DESC_SIZE_BYTES;
   transSrioParamsT9.rxQType           = Qmss_QueueType_HIGH_PRIORITY_QUEUE;
   transSrioParamsT9.rxMemRegion       = HOST_DESC_MEM_REGION;
   /* Descriptor pool divided between all cores.
    * Account type 9+11 for send/receive (divide by 4) */
   transSrioParamsT9.rxNumDesc         = (HOST_DESC_NUM / 4) / ipcNumLocalDspCores;
   transSrioParamsT9.rxDescSize        = HOST_DESC_SIZE_BYTES;
   transSrioParamsT9.rxMsgQHeapId      = SRIO_MSGQ_HEAP_ID;
   transSrioParamsT9.maxMTU            = SRIO_MTU_SIZE_BYTES;
   transSrioParamsT9.rmServiceHandle   = rmServiceHandle;
   /* Type 9 instance specific parameters */
   /* Must map to a valid channel for each DSP core.
    * Follow sprugr9g.pdf Table 5-9 */
   transSrioParamsT9.accumCh            = DNUM + 8; /* Next valid accum ch is
                                                     * number of device DSP
                                                     * cores away 
                                                     * (8 for K2HK) */
   transSrioParamsT9.accumTimerCount    = 0; 
   transSrioParamsT9.transNetworkId     = SRIO_T9_TRANS_NET_ID;
   transSrioParamsT9.rxIntVectorId      = 9;
   
   /* Type 9 specific */
   memset(&amp;t9EpParams, 0, sizeof(t9EpParams));
   /* Linux Host (Producer) MultiProc ID - 0 */
   t9EpParams[0].tt       = 0;
   t9EpParams[0].deviceId = DEVICE_ID1_8BIT;
   t9EpParams[0].cos      = 0;
   t9EpParams[0].streamId = 0;
   /* Core 0 (Producer) MultiProc ID - 1 */
   t9EpParams[1].tt       = 0;
   t9EpParams[1].deviceId = DEVICE_ID1_8BIT;
   t9EpParams[1].cos      = 0;
   t9EpParams[1].streamId = 1;
   /* Core 1 (Producer) MultiProc ID - 2 */
   t9EpParams[2].tt       = 0;
   t9EpParams[2].deviceId = DEVICE_ID1_8BIT;
   t9EpParams[2].cos      = 0;
   t9EpParams[2].streamId = 2;
   /* Linux Host (Consumer) MultiProc ID - 3 */
   t9EpParams[3].tt       = 0;
   t9EpParams[3].deviceId = DEVICE_ID2_8BIT;
   t9EpParams[3].cos      = 0;
   t9EpParams[3].streamId = 0;
   /* Core 0 (Consumer) MultiProc ID - 4 */
   t9EpParams[4].tt       = 0;
   t9EpParams[4].deviceId = DEVICE_ID2_8BIT;
   t9EpParams[4].cos      = 0;
   t9EpParams[4].streamId = 1;
   /* Core 1 (Consumer) MultiProc ID - 5 */
   t9EpParams[5].tt       = 0;
   t9EpParams[5].deviceId = DEVICE_ID2_8BIT;
   t9EpParams[5].cos      = 0;
   t9EpParams[5].streamId = 2;
   
   memset(&amp;t9socketParams, 0, sizeof(t9socketParams));
   t9socketParams.epListSize = NUM_TOTAL_CORES;    
   t9socketParams.sockType = TransportSrio_srioSockType_TYPE_9;
   t9socketParams.u.pT9Eps = &amp;t9EpParams[0];    
   
   transSrioParamsT9.sockParams = &amp;t9socketParams;
   
   Error_init(&amp;errorBlock);
   System_printf("IPC Core&#160;%d&#160;: Creating SRIO Transport instance with Type 9 socket\n", ipcCoreId); 
   srioT9TransHandle = TransportSrio_create(&amp;transSrioParamsT9, &amp;errorBlock);
   if (srioT9TransHandle == NULL) {
       System_printf("Error IPC Core&#160;%d&#160;: TransportSrio_create failed with id&#160;%d\n", ipcCoreId,
                     errorBlock.id);
       return;
   }
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<ul><li>MessageQ_create() and MessageQ_open() must utilize the reserve queues set-aside in MessageQ since the network interface transports, like TransportSrio, do not use the NameServer.  To utilize the reserved queues:
<ul><li>To create a local reserved queue MessageQ_create() will take NULL instead of a string containing a remote queue name</li>
<li>To open a remote reserved queue MessageQ_open() is replaced by the MessageQ_openQueueId() API</li></ul></li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>   System_printf("IPC Core&#160;%d&#160;: Creating reserved MessageQ&#160;%d\n", ipcCoreId, MESSAGEQ_RESERVED_RCV_Q);
   MessageQ_Params_init(&amp;msgQParams);
   msgQParams.queueIndex = MESSAGEQ_RESERVED_RCV_Q;
   /* Create reserved message queue. */
   localMessageQ = MessageQ_create(NULL, &amp;msgQParams);
   if (localMessageQ == NULL) {
       System_printf("Error IPC Core&#160;%d&#160;: MessageQ_create failed\n", ipcCoreId);
       return;
   }   
</pre>
<pre>   System_printf("IPC Core&#160;%d&#160;: Opening reserved MessageQ&#160;%d on IPC core&#160;%d\n", ipcCoreId,
                 MESSAGEQ_RESERVED_RCV_Q, remoteProcId);
   remoteQueueId = MessageQ_openQueueId(MESSAGEQ_RESERVED_RCV_Q, remoteProcId);
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<ul><li>MessageQ_put() and MessageQ_get() can be used normally to send and receive messages between end points using TransportSrio.  The only caveat is that messages that are to use TransportSrio must be sent with the transport ID, TID, that was used to register the TransportSrio instance with the MessageQ Network interface.</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
typedef struct {
</p>
<pre>   MessageQ_MsgHeader header; /* 32 bytes */
   int32_t            src;
   int32_t            flags;
   int32_t            numMsgs; 
   int32_t            seqNum;
   uint32_t           data[TEST_MSG_DATA_LEN_WORDS];
   uint8_t            pad[16]; /* Pad to cache line size of 128 bytes */
</pre>
<p>} TstMsg;
</p><p>...
</p><p>TstMsg   *txMsg;
</p><p>txMsg = (TstMsg *) MessageQ_alloc(SRIO_MSGQ_HEAP_ID, sizeof(TstMsg));
/* Set the transport ID to route message through Type 11 SRIO Transport instance */
MessageQ_setTransportId(txMsg, SRIO_T11_TRANS_NET_ID);
</p><p>/* OR */
</p><p>/* Set the transport ID to route message through Type 9 SRIO Transport instance */
MessageQ_setTransportId(txMsg, SRIO_T9_TRANS_NET_ID);
</p><p>/* Send message */
MessageQ_put(remoteQueueId, (MessageQ_Msg) txMsg);
&lt;/syntaxhighlight&gt;
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Please pay extra attention to the alignments and padding of CPPI descriptors and heap buffers used by the SRIO Transport.  Cache coherence operations will be performed on descriptors and buffers that are detected to be from a shared memory, such as MSMC or DDR3.  All descriptors and buffers should be cache line aligned and padded to avoid data corruptions when the coherence operations are performed.
</p>
<h3><span id="SYS/BIOS_DSP_TransportSrio_Examples"></span><span class="mw-headline" id="SYS.2FBIOS_DSP_TransportSrio_Examples">SYS/BIOS DSP TransportSrio Examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=15" title="Edit section: SYS/BIOS DSP TransportSrio Examples">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Two examples are included with the SYS/BIOS DSP TransportSrio component.  Both examples are fully integrated with RM so they can be run while ARM Linux is up:
</p>
<ul><li>transportIpcSrioBenchmarkK2XExampleProject - An example that performs latency, throughput, and data integrity tests over DSP TransportSrio.  In addition, it tests the MessageQ routing capabilities via the NORMALPRI and HIGHPRI flags.</li>
<li>transportIpcSrioMultiBoardK2XExampleProject - An example that sends packets from two DSPs on one EVM to two DSPs on another EVM.  A data integrity check is performed on the data transferred between the two devices.  Two different executables are required for this example.
<ul><li>transportIpcSrioMultiBoardProducerK2XExampleProject - The producer side of the multi-board test.  The producer opens two MessageQ's on the consumer device and uses them to send MessageQ messages to the consumer device.</li>
<li>transportIpcSrioMultiBoardConsumerK2XExampleProject - The consumer side of the multi-board test.  The consumer creates two MessageQ's and waits for the producer to open them and start sending data.  Data integrity checks are performed on the data received from the producer device.</li></ul></li></ul>
<p>The projects are built as part of the generic pdkProjectCreate process.  They can be imported, built, and run through CCS just like any other LLD example and test project.
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The multi-board test requires two Keystone II devices connected via SRIO lanes by way of a breakout card or chassis in order to operate successfully.
</p>
<h2><span class="mw-headline" id="ARMv7_Linux_TransportSrio">ARMv7 Linux TransportSrio</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=16" title="Edit section: ARMv7 Linux TransportSrio">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>ARMv7 Linux TransportSrio is the ARMv7 Linux MessageQ Network interface transport counterpart to the SYS/BIOS DSP version of TransportSrio.  The ARMv7 Linux version of TransportSrio can be registered with Network transport interface of ARMv7 Linux MessageQ to allow SRIO-based communication with other ARMv7 and DSP processors running TransportSrio on the local, or a remote, device.  Communication between local and remote device processors is achieved by each processor having a unique MultiProc ID assigned to it.  The MultiProc ID mapping is maintained within the LAD daemon in the ARMv7 Linux version of IPC.  Each Linux Host within a system must be running a LAD daemon that has been configured to know about the maximum number of processors in the system.  The LAD daemon must also be configured with a unique cluster base ID within the processor ID space.  The MultiProc ID mappings maintained by the LAD daemon on each Linux Host must be in sync with ID configurations on all other processors, ARMv7 and DSP, in the system.
</p>
<h3><span class="mw-headline" id="Architecture_2">Architecture</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=17" title="Edit section: Architecture">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>TransportSrio does not directly interact with SRIO.  Instead the transport interfaces with a MPM-Transport instance that supports SRIO.
</p><p>Only one TransportSrio instance of each Type (11 and 9) can exist across all Linux processes.  This was a design decision made so that SRIO addresses could be assigned based on MultiProc ID rather than a combination of MultiProc ID + MessageQ queue ID.  The latter scheme would overly complicate SRIO address assignments to processors in a multi-device system.  A reroute functionality exists within the TransportSrio reception logic to compensate for the lack of direct process reception for more than one Linux process.  The reroute logic checks the destination MessageQ queue in the received MessageQ message header.  The message is sent over a registered process to process MessageQ transport if the destination queue does not exist within the receiving Linux process.  The transport over which the reroute occurs is mapped to a TID provided at TransportSrio instance creation.
</p><p>An ARMv7 Linux processor running a TransportSrio instance can communicate with any other processor on any device as long as:
</p>
<ul><li>The processors are running an ARMv7 Linux TransportSrio or SYS/BIOS DSP TransportSrio instance</li>
<li>All processors have a synchronized mapping of MultiProc ID to SRIO addresses</li>
<li>All processors are physically connected over SRIO lanes.</li></ul>
<p><a href="File_Linux_TransSrio_Arch.html" class="image" title="Linux_TransSrio_Arch.jpg"><img alt="Linux_TransSrio_Arch.jpg" src="https://processors.wiki.ti.com/images/b/b3/Linux_TransSrio_Arch.jpg" width="1100" height="606" /></a>
</p><p><br />
</p><p><br />
</p>
<h3><span class="mw-headline" id="ARMv7_Linux_TransportSrio_Source_Delivery_and_Recompilation">ARMv7 Linux TransportSrio Source Delivery and Recompilation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=18" title="Edit section: ARMv7 Linux TransportSrio Source Delivery and Recompilation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The ARMv7 Linux TransportSrio source code can be downloaded and built two ways.  The transport source code is delivered and built as part of Yocto/bitbake.  The source code can also be downloaded and built directly from the GIT repository.
</p>
<h4><span id="Recompiling_Through_Yocto/bitbake"></span><span class="mw-headline" id="Recompiling_Through_Yocto.2Fbitbake">Recompiling Through Yocto/bitbake</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=19" title="Edit section: Recompiling Through Yocto/bitbake">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ol><li>Follow the instructions in the Exploring section of the user guide to configure the <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Exploring.html#Yocto">Yocto build environment</a>.  The tisdk-server-rootfs-image does not need to be built.  Instead look at the section for <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Exploring.html#Building_other_components_in_Yocto">building other components</a></li>
<li>Build the TransportSrio libraries, ipc-transport-srio recipe, and user-space tests, ipc-transport-srio-test recipe: <br />$ MACHINE=k2hk-evm TOOLCHAIN_BRAND=linaro ARAGO_BRAND=mcsdk bitbake ipc-transport-srio <br />$ MACHINE=k2hk-evm TOOLCHAIN_BRAND=linaro ARAGO_BRAND=mcsdk bitbake ipc-transport-srio-test <br /><br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The initial build may take quite some time since the kernel is built as a dependency <br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Building with just the ipc-transport-srio-test recipe will also build the ipc-transport-srio recipe since the test recipe depends on the library recipe.</li>
<li>The built TransportSrio static library will be located in <br />&lt;base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-srio/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-srio-staticdev/usr/lib/libTransportSrio.a <br /><br />The built TransportSrio shared library will be located in <br />&lt;base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-srio/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-srio/usr/lib/libTransportSrio.so.1.0.0</li>
<li>The ipc-transport-srio-test recipe will build test static and shared library executables for all supported devices.  The executables will be located in <br />base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-srio-test/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-srio-test/usr/bin/</li></ol>
<h4><span class="mw-headline" id="Recompiling_Through_GIT_Repository">Recompiling Through GIT Repository</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=20" title="Edit section: Recompiling Through GIT Repository">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Recompiling through the ARMv7 Linux TransportSrio GIT repository requires that the latest MCSDK Linux installation.  The MCSDK Linux PDK component and the Linux devkit must be installed.  The Linux devkit installation script can be found in &lt;MCSDK Linux install root&gt;/mcsdk_linux_3_XX_YY_ZZ/linux-devkit/
</p>
<ol><li>Clone the keystone-linux/ipc-transport repository from git.ti.com <br />$ git clone <a rel="nofollow" class="external free" href="git://git.ti.com/keystone-linux/ipc-transport.git">git://git.ti.com/keystone-linux/ipc-transport.git</a></li>
<li>Navigate to the MCSDK Linux installation of pdk_3_XX_YY_ZZ/packages and source armv7setupenv.sh. <br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The armv7setupenv.sh script must be modified to point to the linaro toolchain and  installed devkit path <br />$ source armv7setupenv.sh</li>
<li>Navigate back to the SRIO transport directory in the ipc-transport GIT repository <br />$ cd &lt;repo_root_path&gt;/ipc-transport/linus/srio</li>
<li>Build the TransportSrio library and user-space test executables: <br />$ make lib <br />$ make tests</li>
<li>The TransportSrio static and shared libraries will be copied directly into the Linux devkit's /usr/lib folder as long as the devkit install path was setup correctly prior to running the armv7setupenv.sh script</li>
<li>The test executables will be generated in the &lt;base_repo_path&gt;/ipc-transport/bin/&lt;k2 device&gt;/test/ folder.  Only the device specified in the armv7setupenv.sh will be built. <br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b> Setting the USEDYNAMIC_LIB environment variable to "yes" will generate the shared library test executables <br />$ export USEDYNAMIC_LIB=yes</li></ol>
<h3><span class="mw-headline" id="ARMv7_Linux_TransportSrio_Configuration_Parameters">ARMv7 Linux TransportSrio Configuration Parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=21" title="Edit section: ARMv7 Linux TransportSrio Configuration Parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Following are the configuration parameters for TransportSrio instance creation.  Descriptions, default values, and programming considerations are provided for each configuration parameter.  Each parameter is an element of the TransportSrio_Params structure.  A structure of this type must be created, populated, and passed to the TransportSrio_create() function via pointer.  The structure should be initialized to its default values using the TransportSrio_Params_init() function prior to population with application specific parameters.
</p><p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>   TransportSrio_Params  srio_trans_params;
</pre>
<pre>   ...
   TransportSrio_Params_init(&amp;srio_trans_params);
   snprintf(mpm_inst_name, MPM_INST_NAME_LEN, "arm-srio-generic");
   srio_trans_params.mpm_trans_inst_name = mpm_inst_name;
   srio_trans_params.rm_service_h        = ...;
   ...
   srio_handle = TransportSrio_create(&amp;srio_trans_params);
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<table border="1" style="width: 1000px; height: 200px" id="srio_transport_config_params">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Configuration Parameter Element</b>
</td>
<td bgcolor="#c0c0c0"><b>Description</b>
</td>
<td bgcolor="#c0c0c0"><b>Initial Value</b>
</td>
<td bgcolor="#c0c0c0"><b>Special Considerations</b>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Char *mpm_trans_inst_name;&lt;/syntaxhighlight&gt;
</td>
<td>MPM-Transport instance name.  This string must match a "slaves" name string defined within the mpm_config.json file used in the Linux filesystem
</td>
<td>NULL
</td>
<td>This string name must match the generic SRIO instance name in the filesystems /etc/mpm/mpm_config.json.  The MPM JSON file's generic SRIO string is "arm-srio-generic".
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Void *rm_service_h;&lt;/syntaxhighlight&gt;
</td>
<td>RM instance service handle needed by MPM-Transport to request hardware resources
</td>
<td>NULL
</td>
<td>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;TransportSrio_SocketParams *sock_params;&lt;/syntaxhighlight&gt;
</td>
<td>Pointer to socket parameters used by the SRIO transport to bind the socket and to route messages to the proper endpoints.
</td>
<td>NULL
</td>
<td>
<ul><li>Socket parameters include the socket type (Type 11 or Type 9), the number of endpoints in the endpoint list, and a pointer to the Type 11 or Type 9 endpoint parameter list.  The endpoint parameter list contains the address information for each processor endpoint in the system.  The parameter list must be indexed by the IPC MultiProc ID so that all processors can be mapped to a unique SRIO address.</li>
<li>This structure will be replicated within the TransportSrio instance.  So structure passed by pointer can be allocated from temporary memory.</li></ul>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Int rx_msg_size_bytes;&lt;/syntaxhighlight&gt;
</td>
<td>Maximum size in bytes of messages that will be received by this transport.  Used to allocated MessageQ messages for reception
</td>
<td>0
</td>
<td>The value specified must be in sync with the "sizebuf" values specified in the "qmss-queue-map" transmit and receive free queue nodes of the mpm_config.json configuration file.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Int reroute_tid;&lt;/syntaxhighlight&gt;
</td>
<td>MessageQ Network interface Transport ID of ARMv7 Linux TransportQmss instance.  Will be used to reroute received MessageQ messages destined for a MessageQ queue that was opened from another Linux process.  Messages received for a MessageQ queue opened from another Linux process will be dropped if this value is left as 0.
</td>
<td>0
</td>
<td>A valid TID value is between 1 and 7.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;
<p>Int (*srio_device_init) (Void *init_cfg, 
</p>
<pre>                        Void *srio_base_addr, 
                        UInt32 serdes_addr);&lt;/syntaxhighlight&gt;
</pre>
</td>
<td>Pointer to the SRIO device initialization routine.  This routine initializes the SRIO hardware with routing and address information.  MPM-Transport will call the provided function pointer during the SRIO initialization process.
</td>
<td>NULL
</td>
<td>
<ul><li>Routine should be run once per device.</li>
<li>Function pointer should be NULL if another process or device core was the first to initialize the usage of SRIO.</li>
<li>The init_cfg input parameter can be a pointer to an application specific input parameter to the srio_device_init function</li></ul>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Void *init_cfg;&lt;/syntaxhighlight&gt;
</td>
<td>Application specific input parameter to the srio_device_init implementation
</td>
<td>NULL
</td>
<td>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;
<p>Int (*srio_device_deinit) (Void *deinit_cfg, 
</p>
<pre>                          Void *srio_base_addr);&lt;/syntaxhighlight&gt;
</pre>
</td>
<td>Pointer to the SRIO device de-initialization routine.  Will be invoked by MPM-Transport when de-initializing the SRIO hardware within deletion routines.
</td>
<td>NULL
</td>
<td>
<ul><li>Routine should be run once per device</li>
<li>Function pointer should be NULL if another process or device core will be the last to delete its usage of SRIO</li>
<li>The deinit_cfg input parameter can be a pointer to an application specific input parameter to the srio_device_deinit function.</li></ul>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Void *deinit_cfg;&lt;/syntaxhighlight&gt;
</td>
<td>Application specific input parameter to the srio_device_deinit implementation
</td>
<td>NULL
</td>
<td>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Int mpm_trans_init_qmss;&lt;/syntaxhighlight&gt;
</td>
<td>Controls whether MPM-Transport will initialize the QMSS hardware <br />0 - MPM-Transport will not initialize QMSS.  Set if another entity within the system initialized the QMSS hardware. <br />1 - MPM-Transport will initialize QMSS.  Set if this is the first system entity being created that used QMSS and QMSS has not been initialized
</td>
<td>0
</td>
<td>
</td></tr></tbody></table>
<h4><span class="mw-headline" id="MPM_Transport_Configuration_Effects_on_ARMv7_Linux_TransportSrio">MPM Transport Configuration Effects on ARMv7 Linux TransportSrio</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=22" title="Edit section: MPM Transport Configuration Effects on ARMv7 Linux TransportSrio">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>TransportSrio assumes MPM Transport will manage configuration of the QMSS, CPPI, and SRIO LLDs.  As a result, descriptor and descriptor buffer management is pushed to MPM Transport in the ARMv7 Linux version of TransportSrio.  The MPM Transport JSON configuration file should be modified in order to change QMSS descriptor and buffer related parameters.
</p><p>The MPM Transport JSON configuration file is located in the Linux file system at /etc/mpm/mpm_config.json
</p>
<h3><span class="mw-headline" id="Adding_the_ARMv7_Linux_TransportSrio_to_a_User-Space_Application">Adding the ARMv7 Linux TransportSrio to a User-Space Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=23" title="Edit section: Adding the ARMv7 Linux TransportSrio to a User-Space Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A TransportSrio instance can be created after the following:
</p>
<ul><li>IPC has started</li>
<li>A RM client instance has been created.  Communication between the RM Client and the RM Server will take place over a Linux socket.</li>
<li>[<b>Optional</b>] A TransportQmss instance has been created so that TransportSrio can reroute MessageQ messages received over SRIO that are destined for a Linux process other than the process in which the TransportSrio instance will be created.</li>
<li>ARMv7 Linux TransportSrio instances can be created once all previous requirements are satisfied.  A TransportSrio instance of each SRIO type, 11 and 9, can exist simultaneously in Linux user space.  The following example code comes from the Producer-side of the Producer/Consumer example:</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>   /* Type 11 instance */
   
   TransportSrio_Params_init(&amp;srio_trans_params);
   snprintf(mpm_inst_name, MPM_INST_NAME_LEN, "arm-srio-generic");
   srio_trans_params.mpm_trans_inst_name = mpm_inst_name;
   srio_trans_params.rm_service_h        = rm_service_h;
   srio_trans_params.rx_msg_size_bytes   = MAX_PACKET_SIZE;
   srio_trans_params.reroute_tid         = TRANS_QMSS_NET_ID;
   srio_trans_params.srio_device_init    = &amp;mySrioDevice_init;
   srio_trans_params.init_cfg            = (void *)&amp;path_mode;
   srio_trans_params.srio_device_deinit  = &amp;mySrioDevice_deinit;
   srio_trans_params.deinit_cfg          = NULL;
   /* TransportQmss informs mpm-transport to init QMSS */
   srio_trans_params.mpm_trans_init_qmss = 0;
   
   /* Configure producer's static socket parameters. Structures can
    * be local since TransportSrio will make a copy */
   memset(&amp;t11_params, 0, sizeof(t11_params));
   sock_params.num_eps   = MAX_SYSTEM_PROCESSORS;
   sock_params.sock_type = sock_TYPE_11;
   
   /* Linux Host (Producer) */
   t11_params[0].tt        = 0;
   t11_params[0].device_id = DEVICE_ID1_8BIT;
   t11_params[0].letter    = 0;
   t11_params[0].mailbox   = 0;
   t11_params[0].seg_map   = (MAX_PACKET_SIZE &gt; 256)&#160;? 1&#160;: 0;
   
   /* Linux Host (Consumer) */
   t11_params[9].tt        = 0;
   t11_params[9].device_id = DEVICE_ID2_8BIT;
   t11_params[9].letter    = 0;
   t11_params[9].mailbox   = 0;
   t11_params[9].seg_map   = (MAX_PACKET_SIZE &gt; 256)&#160;? 1&#160;: 0;
   sock_params.u.t11_eps = &amp;t11_params[0];
   srio_trans_params.sock_params = &amp;sock_params;
   printf("Process&#160;%d&#160;: Creating TransportSrio Type 11 instance\n",
          local_process);
   srio_trans_t11_h = TransportSrio_create(&amp;srio_trans_params);
   if (!srio_trans_t11_h) {
       printf("ERROR Process&#160;%d&#160;: "
              "Failed to create TransportSrio Type 11 handle\n", 
              local_process);
       status = -1;
       goto err_exit;
   }
   
   /* Register transport with MessageQ as network transport */
   net_trans_h = TransportSrio_upCast(srio_trans_t11_h);
   base_trans_h = INetworkTransport_upCast(net_trans_h);
   if (MessageQ_registerTransportId(TRANS_SRIO_T11_NET_ID, base_trans_h) &lt; 0) {
       printf("ERROR Process&#160;%d&#160;: "
              "Failed to register TransportSrio Type 11 as network "
              "transport with TID\n", local_process, TRANS_SRIO_T11_NET_ID);
       status = -1;
       goto err_exit;
   }
</pre>
<pre>   /* Type 9 instance */
</pre>
<pre>   TransportSrio_Params_init(&amp;srio_trans_params);
   snprintf(mpm_inst_name, MPM_INST_NAME_LEN, "arm-srio-generic");
   srio_trans_params.mpm_trans_inst_name = mpm_inst_name;
   srio_trans_params.rm_service_h        = rm_service_h;
   srio_trans_params.rx_msg_size_bytes   = MAX_PACKET_SIZE;
   srio_trans_params.reroute_tid         = TRANS_QMSS_NET_ID;
   /* Don't run device init/deinit for second transport */
   srio_trans_params.srio_device_init    = NULL;
   srio_trans_params.init_cfg            = NULL;
   srio_trans_params.srio_device_deinit  = NULL;
   srio_trans_params.deinit_cfg          = NULL;
   /* TransportQmss informs mpm-transport to init QMSS */
   srio_trans_params.mpm_trans_init_qmss = 0;
   
   /* Configure producer's static socket parameters. Structures can
    * be local since TransportSrio will make a copy */
   memset(&amp;t9_params, 0, sizeof(t9_params));
   sock_params.num_eps   = MAX_SYSTEM_PROCESSORS;
   sock_params.sock_type = sock_TYPE_9;
   
   /* Linux Host (Producer) */
   t9_params[0].tt        = 0;
   t9_params[0].device_id = DEVICE_ID1_8BIT;
   t9_params[0].cos       = 0;
   t9_params[0].stream_id = 0;
   
   /* Linux Host (Consumer) */
   t9_params[9].tt        = 0;
   t9_params[9].device_id = DEVICE_ID2_8BIT;
   t9_params[9].cos       = 0;
   t9_params[9].stream_id = 0;
   sock_params.u.t9_eps = &amp;t9_params[0];
   srio_trans_params.sock_params = &amp;sock_params;
   printf("Process&#160;%d&#160;: Creating TransportSrio Type 9 instance\n",
          local_process);
   srio_trans_t9_h = TransportSrio_create(&amp;srio_trans_params);
   if (!srio_trans_t9_h) {
       printf("ERROR Process&#160;%d&#160;: "
              "Failed to create TransportSrio Type 9 handle\n", 
              local_process);
       status = -1;
       goto err_exit;
   }
   
   /* Register transport with MessageQ as network transport */
   net_trans_h = TransportSrio_upCast(srio_trans_t9_h);
   base_trans_h = INetworkTransport_upCast(net_trans_h);
   if (MessageQ_registerTransportId(TRANS_SRIO_T9_NET_ID, base_trans_h) &lt; 0) {
       printf("ERROR Process&#160;%d&#160;: "
              "Failed to register TransportSrio Type 9 as network "
              "transport with TID&#160;%d\n", local_process, TRANS_SRIO_T9_NET_ID);
       status = -1;
       goto err_exit;
   }
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<ul><li>MessageQ_create() and MessageQ_open() must utilize the reserve queues set-aside in MessageQ since the network interface transports do not use the NameServer.  On the Linux the IPC LAD daemon must have its configuration changed to reserve queues.  To utilize the reserved queues:
<ul><li>To create a local reserved queue MessageQ_create() will take NULL instead of a string containing a remote queue name</li>
<li>To open a remote reserved queue MessageQ_open() is replaced by the MessageQ_openQueueId() API</li></ul></li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>       /* Create queue used to receive messages from remote devices and open
        * remote device queues - one per process */
       MessageQ_Params_init(&amp;msg_params);
       msg_params.queueIndex = MESSAGEQ_RESERVED_RCV_Q;
       srio_msg_q_h = MessageQ_create(NULL, &amp;msg_params);
       if (srio_msg_q_h == NULL) {
           printf("ERROR Process&#160;%d&#160;: Failed to create MessageQ\n",
                  local_process);
           status = -1;
           goto err_exit;
       }
       printf("Process&#160;%d&#160;: "
              "Created remote device reception MessageQ with QId: 0x%x\n",
              local_process, MessageQ_getQueueId(srio_msg_q_h));
</pre>
<pre>       /* Open Consumer Linux Host MessageQ queues on each process of the
        * remote Linux Host */
       for (i = 0; i &lt; CONSUMER_PROCESSES; i++) {
           rem_srio_q_id[i] = MessageQ_openQueueId(MESSAGEQ_RESERVED_RCV_Q + i,
                                                   CONSUMER_HOST_PROC_ID);
           printf("Process&#160;%d&#160;: Opened remote device QId: 0x%x\n",
                  local_process, rem_srio_q_id[i]);
       }
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<ul><li>MessageQ_put() and MessageQ_get() can be used normally to send and receive messages between end points using TransportSrio.  The only caveat is that messages that are to use TransportSrio must be sent with the transport ID, TID, that was used to register the TransportSrio instance with the MessageQ Network interface.</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
/* TransportSrio Type 11 MessageQ Network Interface TID */
</p>
<ol><li>define SRIO_T11_TRANS_NET_ID 1</li></ol>
<p>/* TransportSrio Type 9 MessageQ Network Interface TID */
</p>
<ol><li>define SRIO_T9_TRANS_NET_ID 2</li></ol>
<p>typedef struct {
</p>
<pre>   MessageQ_MsgHeader header; /* 32 bytes */
   int32_t            src;
   int32_t            flags;
   int32_t            numMsgs; 
   int32_t            seqNum;
   uint32_t           data[TEST_MSG_DATA_LEN_WORDS];
   uint8_t            pad[16]; /* Pad to cache line size of 128 bytes */
</pre>
<p>} test_msg_t;
</p><p>...
</p><p>test_msg_t *msg = NULL;
</p><p>msg = (test_msg_t *) MessageQ_alloc(0, sizeof(*msg));
if (msg == NULL) {
</p>
<pre>   printf("ERROR Process&#160;%d&#160;: MessageQ_alloc failed\n",
          local_process);
   goto err_exit;
</pre>
<p>}
</p><p>...
</p><p>/* Set the transport ID to route message through Type 11 SRIO Transport instance */
MessageQ_setTransportId(msg, SRIO_T11_TRANS_NET_ID);
</p><p>/* OR */
</p><p>/* Set the transport ID to route message through Type 9 SRIO Transport instance */
MessageQ_setTransportId(msg, SRIO_T9_TRANS_NET_ID);
</p><p>/* Send message */
status = MessageQ_put(rem_srio_q_id, (MessageQ_Msg)msg);
if (status &lt; 0) {
</p>
<pre>   printf("ERROR Process&#160;%d&#160;: MessageQ_put failed\n",
          local_process);
   goto err_exit;
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p><p><br />
</p><p><br />
</p>
<h3><span class="mw-headline" id="ARMv7_Linux_TransportSrio_Tests">ARMv7 Linux TransportSrio Tests</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=24" title="Edit section: ARMv7 Linux TransportSrio Tests">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>ARMv7 Linux TransportSrio includes a single test that uses TransportSrio to send MessageQ messages between Linux Hosts on two different KeyStone II devices.  The test consists of two user-space executables, producer.out and consumer.out.  The producer and consumer applications will create Type 11 and Type 9 TransportSrio instances.  A TransportQmss instance will also be created in the consumer application and provided to TransportSrio for multi-process routing.  The applications will synchronize over TransportSrio and then a bulk MessageQ message transfer will take place from producer to consumer.  The bulk transfer will be run over both the Type 11 and Type 9 instance.  The producer application will send messages to two different MessageQ queues on the consumer device.  One queue will be located in the process where the TransportSrio instance exists.  The other queue will be in a process where only a TransportQmss instance exists.  Only one TransportSrio instance of each type can exist on the Linux host at any given time.  Messages received by TransportSrio that are destined for the queue located on the other process will be rerouted to that process using the TransportQmss instance.
</p>
<h4><span id="Building_the_Producer/Consumer_Test"></span><span class="mw-headline" id="Building_the_Producer.2FConsumer_Test">Building the Producer/Consumer Test</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=25" title="Edit section: Building the Producer/Consumer Test">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The producer and consumer user-space applications can be built through Yocto/bitbake or through downloading the keystone-linux/ipc-transport GIT repository.  For instructions on how to do either please see UG section on <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Developing_Transports.html#ARMv7_Linux_TransportSrio_Source_Delivery_and_Recompilation">ARMv7 Linux TransportSrio Source Delivery</a>
</p><p><br />
</p><p><br />
</p>
<h4><span id="Running_the_Producer/Consumer_Test"></span><span class="mw-headline" id="Running_the_Producer.2FConsumer_Test">Running the Producer/Consumer Test</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=26" title="Edit section: Running the Producer/Consumer Test">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Setup is needed on both the producer and consumer devices prior to running the test.  The LAD daemon provided with the release file system has been patched to assume up to 65535 processors exist in the system and to reserve 8 MessageQ queues.  It has also been patched to take the MultiProc cluster base ID as a command line input.
</p><p><b>Producer Setup:</b>
<br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Replace "K2X" and "k2x" with the proper device
</p>
<ol><li>Load the CMEM module <br />$ insmod /lib/modules/3.10.61/extra/cmemk.ko</li>
<li>Download and run the IPC DSP minimal startup applcation <br />$ mpmcl load dsp0 transportIpcStartupK2XUtilProject.out <br />$ mpmcl run dsp0</li>
<li>Start the RM Server <br />$ rmServer.out /usr/bin/device/k2x/global-resource-list.dtb /usr/bin/device/k2x/policy_dsp_arm.dtb</li></ol>
<p><b>Consumer Setup:</b>
<br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Replace "K2X" and "k2x" with the proper device
</p>
<ol><li>Kill and restart LAD with a cluster base ID of 9.  This makes the consumer device unique from the producer device from an IPC MultiProc point of view <br />$ pkill lad_tci6638 <br />$ lad_tci6638 -l log.txt -b 9</li>
<li>Load the CMEM module <br />$ insmod /lib/modules/3.10.61/extra/cmemk.ko</li>
<li>Download and run the IPC DSP minimal startup applcation <br />$ mpmcl load dsp0 transportIpcStartupK2XUtilProject.out <br />$ mpmcl run dsp0</li>
<li>Start the RM Server <br />$ rmServer.out /usr/bin/device/k2x/global-resource-list.dtb /usr/bin/device/k2x/policy_dsp_arm.dtb</li></ol>
<p>The produce and consumer executables can be run once setup is complete on both devices.  Order of execution shouldn't matter but start the consumer.out prior to the producer.out to be safe.
</p><p><br />
</p><p><br />
</p>
<h2><span id="SYS/BIOS_DSP_TransportQmss"></span><span class="mw-headline" id="SYS.2FBIOS_DSP_TransportQmss">SYS/BIOS DSP TransportQmss</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=27" title="Edit section: SYS/BIOS DSP TransportQmss">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The SYS/BIOS DSP TransportQmss is a MessageQ Network interface transport that can be used on a KeyStone II DSP running SYS/BIOS IPC to send and receive MessageQ messages between DSP processors and Linux user-space processes running the ARMv7 Linux version of TransportQmss.
</p>
<h3><span class="mw-headline" id="Architecture_3">Architecture</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=28" title="Edit section: Architecture">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The SYS/BIOS DSP TransportQmss is a MessageQ Network interface transport that utilizes the QMSS LLD to send and receive MessageQ messages between DSPs and Linux user-space processes on a Keystone II device.  The SRIO endpoints can be on the same device or on another device entirely.
</p><p><a href="File_Linux_TransSrio_Arch.html" class="image" title="Linux_TransSrio_Arch.jpg"><img alt="Linux_TransSrio_Arch.jpg" src="https://processors.wiki.ti.com/images/b/b3/Linux_TransSrio_Arch.jpg" width="1100" height="606" /></a>
</p><p>TransportQmss is restricted to being a MessageQ Network interface transport.  Network interface transports are registered with MessageQ with a Transport ID value, or TID, which can be any integer from 1 through seven.  The transport must be created and added to MessageQ's Network transport routing table after IPC has started, IPC has synced with all cores, and MessageQ has enabled a default intra-device, core to core transport.  The default priority-based, intra-device, MessageQ interface transport is TransportShmNotify in DSP-only cases or TransportRpmsg in ARMv7 + DSP cases.  MessageQ messages can be routed over the different transports by setting the desired transport priority, or TID value, in the MessageQ header's flags field.  A message will be sent over a registered Network transport if a valid TID and priority are set.
</p><p>&lt;syntaxhighlight lang='C'&gt;
MessageQ_Msg msg;
</p><p>msg = MessageQ_alloc(MY_HEAP_ID, sizeof(msg));
</p><p>/* Route over MessageQ's MessageQ interface normal priority transport.
</p>
<pre>* Should never need to explicitly set since MessageQ_alloc()
* will set normal priority by default */
</pre>
<p>MessageQ_setMsgPri(msg, MessageQ_NORMALPRI);
MessageQ_put(queueId, msg);
</p><p>/* ...or... */
</p><p>/* Route over MessageQ's MessageQ interface high priority transport */
MessageQ_setMsgPri(msg, MessageQ_HIGHPRI);
MessageQ_put(queueId, msg);
</p><p>/* ...or... */
</p><p>/* Route over MessageQ's Network interface
</p>
<pre>* TID value has to be a value between 1 and 7 */
</pre>
<p>MessageQ_setTransportId(msg, transport_tid);
MessageQ_put(queueId, msg);
&lt;/syntaxhighlight&gt;
</p><p>The TransportQmss must be created and registered with MessageQ after IPC has started so that all initialization requirements for the QMSS transport can be satisfied.  First, and most importantly, TransportQmss initialization will be making resource requests from the CPPI and QMSS LLDs.  As a result, the Resource Manager (RM) LLD must be fully initialized and a transport path from RM Clients to the RM Server must be available.  Typically, the TransportShmNotify is used to enable RM message passing between the Clients and Server in a DSP-only use case.  TransportRpmsg must be used as the RM control messaging backbone in a mixed ARM Linux and DSP use case.  Second, forcing TransportQmss initialization after IPC start and sync allows any CPPI Host descriptors and attached buffers to be placed in any type of device memory.
</p>
<h3><span id="SYS/BIOS_DSP_TransportQmss_Source_Delivery_and_Recompilation"></span><span class="mw-headline" id="SYS.2FBIOS_DSP_TransportQmss_Source_Delivery_and_Recompilation">SYS/BIOS DSP TransportQmss Source Delivery and Recompilation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=29" title="Edit section: SYS/BIOS DSP TransportQmss Source Delivery and Recompilation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The SYS/BIOS DSP TransportQmss source code and examples are delivered within the MCSDK BIOS PDK component.  DSP TransportQmss can be rebuilt using the environment setup scripts provided with the PDK package.  DSP TransportQmss example applications are created as part of the pdkProjectCreate scripts.  They can be imported and built the same as PDK LLD example and test CCS projects.
</p>
<h4><span class="mw-headline" id="Recompiling_on_Windows_2">Recompiling on Windows</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=30" title="Edit section: Recompiling on Windows">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ol><li>Open a Windows command terminal and navigate to &lt;pdk_install_dir&gt;/packages.</li>
<li>Set the component install paths.  The following commands assume CCS and MCSDK are installed in the default location C:\ti\) <br /> set C6X_GEN_INSTALL_PATH="C:\ti\ccsv6\tools\compiler\c6000_[version]" <br /> set XDC_INSTALL_PATH=C:\ti\xdctools_[version] <br /> set EDMA3LLD_BIOS6_INSTALLDIR="C:\ti\edma3_lld_[version]" <br /> set CG_XML_BIN_INSTALL_PATH=C:\ti\cg_xml\bin <br /> set BIOS_INSTALL_PATH=C:\ti\bios_[version]\packages <br /> set IPC_INSTALL_PATH=C:\ti\ipc_[version]\packages <br /> set PDK_INSTALL_PATH=C:\ti\pdk_keystone2_[version]</li>
<li>Run pdksetupenv.bat <br /> &gt;pdksetupenv.bat</li>
<li>Navigate to &lt;pdk_install_path&gt;/packages/ti/transport/ipc/c66/qmss/</li>
<li>Build the IPC QMSS Transport library <br /> &gt;xdc</li></ol>
<p>Issue the following commands if the QMSS transport ever needs to be rebuilt:
</p>
<dl><dd><dl><dd>&gt;xdc clean <br /></dd>
<dd>&gt;xdc</dd></dl></dd></dl>
<h4><span class="mw-headline" id="Recompiling_on_Linux_2">Recompiling on Linux</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=31" title="Edit section: Recompiling on Linux">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ol><li>Open a Linux bash terminal and navigate to &lt;pdk_install_dir&gt;/packages.</li>
<li>Export the component install paths.  The following commands assume CCS and MCSDK are installed in the default location /opt/ti) <br /> export C6X_GEN_INSTALL_PATH=/opt/ti/ccsv5/tools/compiler/c6000_[version] <br /> export XDC_INSTALL_PATH=/opt/ti/xdctools_[version] <br /> export EDMA3LLD_BIOS6_INSTALLDIR=/opt/ti/edma3_lld_[version] <br /> export CG_XML_BIN_INSTALL_PATH=/opt/ti/cg_xml/bin <br /> export BIOS_INSTALL_PATH=/opt/ti/bios_[version]/packages <br /> export IPC_INSTALL_PATH=/opt/ti/ipc_[version]/packages <br /> export PDK_INSTALL_PATH=/opt/ti/pdk_keystone2_[version]</li>
<li>Run pdksetupenv.sh <br /> $ source pdksetupenv.sh</li>
<li>Navigate to &lt;pdk_install_path&gt;/packages/ti/transport/ipc/c66/qmss/</li>
<li>Build the IPC QMSS Transport library <br /> $ xdc</li></ol>
<p>Issue the following commands if the QMSS transport ever needs to be rebuilt:
</p>
<dl><dd><dl><dd>$ xdc clean <br /></dd>
<dd>$ xdc</dd></dl></dd></dl>
<h3><span id="SYS/BIOS_DSP_TransportQmss_Configuration_Parameters"></span><span class="mw-headline" id="SYS.2FBIOS_DSP_TransportQmss_Configuration_Parameters">SYS/BIOS DSP TransportQmss Configuration Parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=32" title="Edit section: SYS/BIOS DSP TransportQmss Configuration Parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Following are the configuration parameters for DSP TransportQmss instance creation.  Descriptions, default values, and programming considerations are provided for each configuration parameter.  Each parameter is an element of the TransportQmss_Params structure.  A structure of this type must be created, populated, and passed to the TransportQmss_create() function via pointer.  The structure should be initialized to its default values using the TransportQmss_Params_init() function prior to population with user specific parameters.
</p><p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>   TransportQmss_Params  transQmssParams;
</pre>
<pre>   ...
   TransportQmss_Params_init(&amp;transQmssParams);
   transQmssParams.deviceCfgParams   = ...;
   transQmssParams.txMemRegion       = ...;
   ...
   qmssTransHandle = TransportQmss_create(&amp;transQmssParams, &amp;errorBlock);
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<table border="1" style="width: 1000px; height: 200px" id="qmss_transport_config_params">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Configuration Parameter Element</b>
</td>
<td bgcolor="#c0c0c0"><b>Description</b>
</td>
<td bgcolor="#c0c0c0"><b>Initial Value</b>
</td>
<td bgcolor="#c0c0c0"><b>Special Considerations</b>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;TransportQmss_DeviceConfigParams *deviceCfgParams;&lt;/syntaxhighlight&gt;
</td>
<td>Pointer to the device specific TransportQmss configuration parameter structure.
</td>
<td>NULL
</td>
<td>TransportQmss configuration structure is defined in the TransportQmss_device.c source file for supported devices.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Int txMemRegion;&lt;/syntaxhighlight&gt;
</td>
<td>QMSS memory region from which to allocate transmit side Host descriptors.
</td>
<td>-1
</td>
<td>
<ul><li>Descriptors inserted into this region must be of Host type.</li>
<li>The descriptors can be located in L2, MSMC, or DDR3 memory.  The base address of the descriptors must be cache line aligned if located within a shared memory (MSMC or DDR3) and caching is enabled.</li></ul>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 txNumDesc;&lt;/syntaxhighlight&gt;
</td>
<td>Number of Host descriptors to pre-allocate for QMSS transmit operations.  MessageQ data buffers are attached to the buffers and sent out via the QMSS LLD.  Descriptors are recycled onto a completion queue.  Descriptors, and their attached buffers, are recycled in future TransportQmss_put operations.
</td>
<td>2
</td>
<td>Minimum of two descriptors needed for a ping-pong-like operation.  While one descriptor+buffer pair is sent, the other is recycled.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 txDescSize;&lt;/syntaxhighlight&gt;
</td>
<td>Size of the transmit descriptors in bytes.
</td>
<td>0
</td>
<td>Cache coherence operations may be performed on the descriptors based on their memory location.  As a result, the descriptor size should be a multiple a cache line.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Int rxMemRegion;&lt;/syntaxhighlight&gt;
</td>
<td>QMSS memory region from which to allocate receive side Host descriptors.
</td>
<td>-1
</td>
<td>
<ul><li>This memory region can be the same as that provided for txMemRegion.</li>
<li>Descriptors inserted into this region must be of Host type.</li>
<li>The descriptors can be located in L2, MSMC, or DDR3 memory.  The base address of the descriptors must be cache line aligned if located within a shared memory (MSMC or DDR3) and caching is enabled.</li></ul>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 rxNumDesc;&lt;/syntaxhighlight&gt;
</td>
<td>Number of Host descriptors to pre-allocate for QMSS receive operations.  MessageQ data buffers are pre-allocated and attached to the descriptors at TransportQmss_create() time.  Data received by the QMSS LLD is copied directly into the MessageQ buffer attached the receive descriptor.
</td>
<td>1
</td>
<td>Minimum of one descriptor needed to receive a packet.  The descriptors are reused for receive operations.  New MessageQ buffers are allocated and attached to descriptors prior to their reuse.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 rxDescSize;&lt;/syntaxhighlight&gt;
</td>
<td>Size of the receive descriptors in bytes.
</td>
<td>0
</td>
<td>Cache coherence operations may be performed on the descriptors based on their memory location.  As a result, the descriptor size should be a multiple a cache line.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt16 rxMsgQHeapId;&lt;/syntaxhighlight&gt;
</td>
<td>Rx-side MessageQ Heap ID.  MessageQ buffers are pre-allocated out of this heap and attached to descriptors for packets received by the QMSS interface.
</td>
<td>~1
</td>
<td>
<ul><li>The heap must have AT LEAST rxNumDesc number of buffers.</li>
<li>The heap can reside can reside in L2, MSMC, or DDR3.  TransportQmss will perform cache coherence operations on heap buffers residing in shared memory areas.</li>
<li>Buffers should be sized to be a multiple of a cache line if the heap is located in a shared memory.  This prevents corruptions when cache coherence operations are performed.</li></ul>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt32 maxMTU;&lt;/syntaxhighlight&gt;
</td>
<td>Maximum transmittable unit in bytes that will be handled by TransportQmss.  This is also the size of the buffers within the heap mapped to the rxMsgQHeapId.
</td>
<td>256
</td>
<td>maxMTU should be sized to be a multiple of a cache line.  This prevents corruptions when cache coherence operations are performed on rxMsgQHeapId buffers located in a shared memory.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;TransportQmss_QueueRcvParams rcvQParams;&lt;/syntaxhighlight&gt;
</td>
<td>Parameters that define the type of receive QMSS queue that will be used by the transport.  TransportQmss supports two receive queue types, accumulator or QPEND
</td>
<td>
</td>
<td>Please refer to example/src/bench_qmss.c for examples on how to configure TransportQmss for the different receive queue types
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Void *rmServiceHandle;&lt;/syntaxhighlight&gt;
</td>
<td>RM service handle that will be given to Qmss_init/start.  The RM service handle only needs to be provided if the intent is for RM to manage QMSS resources
</td>
<td>NULL
</td>
<td>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt rxIntVectorId;&lt;/syntaxhighlight&gt;
</td>
<td>Interrupt vector ID to tie to the receive side accumulator operation.
</td>
<td>~1
</td>
<td>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;UInt transNetworkId;&lt;/syntaxhighlight&gt;
</td>
<td>The transport instance will be registered with MessageQ's network transport interface using the supplied network transport ID.  MessageQ messages with a matching transport ID in their MessageQ header will be sent over the transport instance.
</td>
<td>0
</td>
<td>The MessageQ network interface transport ID must have a value between 1 and 7.
</td></tr></tbody></table>
<h3><span id="Adding_the_SYS/BIOS_DSP_TransportQmss_to_a_DSP_Application"></span><span class="mw-headline" id="Adding_the_SYS.2FBIOS_DSP_TransportQmss_to_a_DSP_Application">Adding the SYS/BIOS DSP TransportQmss to a DSP Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=33" title="Edit section: Adding the SYS/BIOS DSP TransportQmss to a DSP Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>TransportQmss requires some special considerations when adding it to an application since it is not a standard, shared memory, IPC transport.  As described earlier, TransportQmss is an IPC MessageQ Network interface transport.  It relies on IPC and MessageQ being initialized with a, priority-based, shared memory transport prior to creating any TransportQmss instances.  The latter occurs by default in the RTSC configuration and Ipc_start().  Creating TransportQmss instances after IPC and MessageQ have initialized allows the transport to be initialized without any hardcoded assumptions about the locations of heaps buffers and QMSS descriptors in memory.  It also allows the LLDs used by TransportQmss to request their resources from RM since RM will use the MessageQ shared memory transport as the resource request/response path.
</p>
<h4><span class="mw-headline" id="Additions_to_the_Application_RTSC_.cfg_2">Additions to the Application RTSC .cfg</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=34" title="Edit section: Additions to the Application RTSC .cfg">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul><li>TransportQmss requires the CPPI and QMSS LLDs in order to operate.  The RM LLD is a requirement for Keystone II devices</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
var Cppi = xdc.loadPackage('ti.drv.cppi'); 
var Qmss = xdc.loadPackage('ti.drv.qmss');
var Rm   = xdc.loadPackage('ti.drv.rm');
</p><p>Program.sectMap[".qmss"] = new Program.SectionSpec();
Program.sectMap[".qmss"] = "MSMCSRAM";
</p><p>Program.sectMap[".cppi"] = new Program.SectionSpec();
Program.sectMap[".cppi"] = "MSMCSRAM";
&lt;/syntaxhighlight&gt;
</p>
<ul><li>The TransportQmss module must be included to pull in the library.  MessageQ must be configured with reserve queue which will be used by any MessageQ Network interface transports that are registered.  The NameServer module does not work with the MessageQ Network interface transports since these transports can potentially send MessageQ messages off-device.  NameServer cannot query outside of the device.</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
var Ipc = xdc.useModule('ti.sdo.ipc.Ipc');
/* Ipc_start() will synchronize all local DSP processors */
Ipc.procSync = Ipc.ProcSync_ALL;
var MessageQ = xdc.useModule('ti.sdo.ipc.MessageQ');
/* Reserve a block of MessageQ queues for use by the MessageQ network interface
</p>
<pre>* transports since they don't use the NameServer module */
</pre>
<p>MessageQ.numReservedEntries = 4;
var TransportQmss = xdc.useModule('ti.transport.ipc.c66.qmss.TransportQmss');
&lt;/syntaxhighlight&gt;
</p>
<ul><li>The device-specific low-level IPC modules must be included so that the interrupt logic properly associates the device MultiProc IDs to destination interrupt generation.  The MultiProc module and the low-level IPC module must both be aware that an ARMv7 processor exists as MultiProc ID 0 on KeyStone II devices.</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
/* Use the correct version of the low-level IPC modules so that the ARMv7
</p>
<pre>* processor is correctly factored into the notification logic */
</pre>
<p>var NotifyDriverCirc = xdc.useModule('ti.sdo.ipc.notifyDrivers.NotifyDriverCirc');
var Interrupt = xdc.useModule('ti.ipc.family.tci6638.Interrupt');
NotifyDriverCirc.InterruptProxy = Interrupt;
var VirtQueue = xdc.useModule('ti.ipc.family.tci6638.VirtQueue');
</p><p>/*  Notify brings in the ti.sdo.ipc.family.Settings module, which does
</p>
<pre>*  lots of config magic which will need to be UNDONE later, or setup
*  earlier, to get the necessary overrides to various IPC module proxies!
*/
</pre>
<p>var Notify = xdc.module('ti.sdo.ipc.Notify');
var Ipc = xdc.useModule('ti.sdo.ipc.Ipc');
</p><p>/* Note: Must call this to override what's done in Settings.xs&#160;! */
Notify.SetupProxy = xdc.module('ti.ipc.family.tci6638.NotifyCircSetup');
&lt;/syntaxhighlight&gt;
</p>
<ul><li>As shown earlier in the <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Developing_Transports.html#Architecture">Architecture</a> section, the MultiProc parameters must be configured correctly for each device.</li></ul>
<h4><span class="mw-headline" id="Source_Code_Additions_2">Source Code Additions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=35" title="Edit section: Source Code Additions">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul><li>A TransportQmss instance can be created between two endpoints after the following:
<ul><li>IPC has started and all local DSPs have attached</li>
<li>RM instances have been created.  Communication between the RM Clients and the RM Server will take place over the default MessageQ interface, priority-based, IPC transport.</li>
<li>QMSS and CPPI have been initialized and started</li>
<li>The heaps that will provide buffers for MessageQ send/receive have been created.  The same heap can be used for both transmit and receive.  <img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The heap used by the TransportQmss receive logic must have a gate that is able to operate within an interrupt context.  In the transport examples a GateMP configured for GateMP_LocalProtect_INTERRUPT is used.</li></ul></li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
/* Create the heap that will be used to allocate messages. */
GateMP_Params_init(&amp;gateMpParams);
gateMpParams.localProtect = GateMP_LocalProtect_INTERRUPT;
gateMpHandle = GateMP_create(&amp;gateMpParams);
</p><p>HeapBufMP_Params_init(&amp;heapBufParams);
heapBufParams.regionId  = 0;
...
heapBufParams.gate      = gateMpHandle;
heapHandle = HeapBufMP_create(&amp;heapBufParams);
&lt;/syntaxhighlight&gt;
</p>
<ul><li>SYS/BIOS DSP TransportQmss instances can be created between end points once all previous requirements are satisfied.  Only a single TransportQmss instance, regardless of receive queue type, accumulator and QPEND, can exist on a DSP.  This restriction does not affect receiving from other TransportQmss instances configured with different receive queue types.  The following example code comes from the Benchmark example:</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
/* Create QMSS Accumulator or QPEND transport instance.  They will be
</p>
<pre>    * network transports so won't interfere with default MessageQ transport,
    * shared memory notify transport */
   TransportQmss_Params_init(&amp;transQmssParams);
   /* Configure common parameters */
   transQmssParams.deviceCfgParams = &amp;qmssTransCfgParams;
   transQmssParams.txMemRegion     = HOST_DESC_MEM_REGION;
   /* Descriptor pool divided between all cores.  Account for send/receive
    * (divide by 2) */
   transQmssParams.txNumDesc       = (HOST_DESC_NUM / 2) / NUM_DSP_CORES;
   transQmssParams.txDescSize      = HOST_DESC_SIZE_BYTES;
   transQmssParams.rxMemRegion     = HOST_DESC_MEM_REGION;
   /* Descriptor pool divided between all cores.  Account for send/receive
    * (divide by 2) */
   transQmssParams.rxNumDesc       = (HOST_DESC_NUM / 2) / NUM_DSP_CORES;
   transQmssParams.rxDescSize      = HOST_DESC_SIZE_BYTES;
   transQmssParams.rxMsgQHeapId    = QMSS_MSGQ_HEAP_ID;
   transQmssParams.maxMTU          = QMSS_MTU_SIZE_BYTES;
   transQmssParams.rmServiceHandle = rmServiceHandle;
   transQmssParams.rxIntVectorId   = 8;
   transQmssParams.transNetworkId  = QMSS_TRANS_NET_ID;
</pre>
<pre>   /* Receive type specific parameters */
   if (testIterations &amp; 0x1) {
       /* Odd iterations create TransportQmss instance with QPEND receive
        * logic */
       transQmssParams.rcvQParams.qType             = TransportQmss_queueRcvType_QPEND;
       /* Choose an arbitrary system event from Table 6-22 System Event
        * Mapping in tci6638k2k.pdf.  System event can be anything that is not
        * already in use and maps to a different CIC host interrupt per DSP */
       transQmssParams.rcvQParams.qpend.systemEvent = 43;
</pre>
<pre>       System_printf("Core&#160;%d&#160;: "
                     "Creating QMSS Transport instance with rx QPEND queue\n",
                     coreNum);
   } else {
       /* Even iterations create TransportQmss instance with accumulator
        * receive logic */
       transQmssParams.rcvQParams.qType             = TransportQmss_queueRcvType_ACCUMULATOR;
       transQmssParams.rcvQParams.accum.rxAccQType  = Qmss_QueueType_HIGH_PRIORITY_QUEUE;
       /* Use PDSP3 since Linux uses PDSP1.  Using the same PDSP as Linux can
        * cause a potential PDSP firmware lockup since Linux does not use the
        * critical section preventing commands being sent to a PDSP
        * simultaneously */
       transQmssParams.rcvQParams.accum.qmPdsp      = (UInt32)Qmss_PdspId_PDSP3;
       /* Must map to a valid channel for each DSP core.  Follow sprugr9f.pdf
        * Table 5-9 */
       transQmssParams.rcvQParams.accum.accCh       = DNUM;
       transQmssParams.rcvQParams.accum.accTimerCnt = 0;
</pre>
<pre>       System_printf("Core&#160;%d&#160;: "
                     "Creating QMSS Transport instance with rx Accumulator "
                     "queue\n", coreNum);
   }
</pre>
<pre>   Error_init(&amp;errorBlock);
   qmssTransHandle = TransportQmss_create(&amp;transQmssParams, &amp;errorBlock);
   if (qmssTransHandle == NULL) {
       System_printf("Error Core&#160;%d&#160;: "
                     "TransportQmss_create failed with id&#160;%d\n", coreNum,
                     errorBlock.id);
       return;
   }
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<ul><li>MessageQ_create() and MessageQ_open() must utilize the reserve queues set-aside in MessageQ since the network interface transports, like TransportQmss, do not use the NameServer.  To utilize the reserved queues:
<ul><li>To create a local reserved queue MessageQ_create() will take NULL instead of a string containing a remote queue name</li>
<li>To open a remote reserved queue MessageQ_open() is replaced by the MessageQ_openQueueId() API</li></ul></li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>   System_printf("IPC Core&#160;%d&#160;: Creating reserved MessageQ&#160;%d\n", ipcCoreId, MESSAGEQ_RESERVED_RCV_Q);
   MessageQ_Params_init(&amp;msgQParams);
   msgQParams.queueIndex = MESSAGEQ_RESERVED_RCV_Q;
   /* Create reserved message queue. */
   localMessageQ = MessageQ_create(NULL, &amp;msgQParams);
   if (localMessageQ == NULL) {
       System_printf("Error IPC Core&#160;%d&#160;: MessageQ_create failed\n", ipcCoreId);
       return;
   }   
</pre>
<pre>   System_printf("IPC Core&#160;%d&#160;: Opening reserved MessageQ&#160;%d on IPC core&#160;%d\n", ipcCoreId,
                 MESSAGEQ_RESERVED_RCV_Q, remoteProcId);
   remoteQueueId = MessageQ_openQueueId(MESSAGEQ_RESERVED_RCV_Q, remoteProcId);
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<ul><li>MessageQ_put() and MessageQ_get() can be used normally to send and receive messages between end points using TransportQmss.  The only caveat is that messages that are to use TransportQmss must be sent with the transport ID, TID, that was used to register the TransportQmss instance with the MessageQ Network interface.</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
typedef struct {
</p>
<pre>   MessageQ_MsgHeader header; /* 32 bytes */
   int32_t            src;
   int32_t            flags;
   int32_t            numMsgs; 
   int32_t            seqNum;
   uint32_t           data[TEST_MSG_DATA_LEN_WORDS];
   uint8_t            pad[16]; /* Pad to cache line size of 128 bytes */
</pre>
<p>} TstMsg;
</p><p>...
</p><p>TstMsg   *txMsg;
</p><p>txMsg = (TstMsg *) MessageQ_alloc(SRIO_MSGQ_HEAP_ID, sizeof(TstMsg));
/* Set the transport ID to route message through QMSS Transport instance */
MessageQ_setTransportId(txMsg, transId);
&lt;/syntaxhighlight&gt;
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Please pay extra attention to the alignments and padding of CPPI descriptors and heap buffers used by the QMSS Transport.  Cache coherence operations will be performed on descriptors and buffers that are detected to be from a shared memory, such as MSMC or DDR3.  All descriptors and buffers should be cache line aligned and padded to avoid data corruptions when the coherence operations are performed.
</p>
<h3><span id="SYS/BIOS_DSP_TransportQmss_Examples"></span><span class="mw-headline" id="SYS.2FBIOS_DSP_TransportQmss_Examples">SYS/BIOS DSP TransportQmss Examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=36" title="Edit section: SYS/BIOS DSP TransportQmss Examples">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>SYS/BIOS DSP TransportQmss includes two tests.  A DSP-only benchmark test and the DSP portion of the Heterogeneous Processor test.  Both examples are fully integrated with RM so they can be run while ARM Linux is up:
</p>
<h4><span class="mw-headline" id="Benchmark_Example">Benchmark Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=37" title="Edit section: Benchmark Example">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>An example that performs latency, throughput, and data integrity tests over DSP TransportQmss using both receive queue configurations.  It also runs the same measurements for a shared memory transport for comparison.
</p>
<h5><span class="mw-headline" id="Building">Building</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=38" title="Edit section: Building">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The Heterogeneous processor test's DSP endpoint application is called transportIpcQmssBenchmarkK2XExampleProject.out.  The source code is located in &lt;install_base&gt;/pdk_keystone2_[version]/packages/ti/transport/ipc/c66/qmss/test.  The project can be imported into CCS from &lt;install_base&gt;/pdk_keystone2_[version]/packages/exampleProjects folder.  Build the project and copy the generated .out to the Linux file system.  The project has been configured to be downloaded and run to DSP cores 0 and 1 from Linux.
</p>
<h5><span class="mw-headline" id="Running">Running</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=39" title="Edit section: Running">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<ol><li>Load the DSP endpoints (Repeat for both DSPs) <br />$ mpmcl load dsp0 transportIpcQmssBenchmarkK2XExampleProject.out <br />$ mpmcl load dsp1 transportIpcQmssBenchmarkK2XExampleProject.out <br />$ mpmcl run dsp0 <br />$ mpmcl run dsp1</li>
<li>The DSP endpoint logs can be dumped from /sys/kernel/debug/remoteproc/remoteproc#/trace0 where # is the DSP whose trace to dump</li></ol>
<h4><span class="mw-headline" id="Heterogeneous_Processor_Test">Heterogeneous Processor Test</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=40" title="Edit section: Heterogeneous Processor Test">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The Heterogeneous processor test uses TransportQmss to send MessageQ messages between Linux user-space processes and DSP cores.  The MessageQ interface is used to send messages between a Linux process and a configurable number of DSP cores.  Each Linux process and DSP runs an exclusive TransportQmss instance.  Data integrity of the message is checked after each transfer.
</p>
<h5><span class="mw-headline" id="Building_2">Building</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=41" title="Edit section: Building">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>For instructions on how to build the DSP-side of the Heterogeneous processor test please see the <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Developing_Transports.html#Building_4">ARMv7 TransportQmss section</a>
</p>
<h5><span class="mw-headline" id="Running_2">Running</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=42" title="Edit section: Running">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>For instructions on how to run the DSP-side of the Heterogeneous processor test please see the <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Developing_Transports.html#Running_4">ARMv7 TransportQmss section</a>
</p>
<h2><span class="mw-headline" id="ARMv7_Linux_TransportQmss">ARMv7 Linux TransportQmss</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=43" title="Edit section: ARMv7 Linux TransportQmss">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>ARMv7 Linux TransportQmss is the ARMv7 Linux MessageQ Network interface transport counterpart to the SYS/BIOS DSP version of TransportQmss.  The ARMv7 Linux version of TransportQmss can be registered with Network transport interface of ARMv7 Linux MessageQ to allow QMSS-based communication with other Linux user-space processes and DSP processors running TransportQmss.
</p>
<h3><span class="mw-headline" id="Architecture_4">Architecture</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=44" title="Edit section: Architecture">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>TransportQmss does not directly interact with QMSS.  Instead the transport interfaces with a MPM-Transport instance that supports QMSS.
</p><p>Each Linux user-space process can create its own TransportQmss instance.  MessageQ APIs can be used to send messages between user-space processes as long as each process registers a TransportQmss instance with MessageQ.  Communication with DSPs on the same device will be possible once development of SYS/BIOS DSP TransportQmss is complete.
</p><p><a href="File_Linux_TransSrio_Arch.html" class="image" title="Linux_TransSrio_Arch.jpg"><img alt="Linux_TransSrio_Arch.jpg" src="https://processors.wiki.ti.com/images/b/b3/Linux_TransSrio_Arch.jpg" width="1100" height="606" /></a>
</p>
<h3><span class="mw-headline" id="ARMv7_Linux_TransportQmss_Source_Delivery_and_Recompilation">ARMv7 Linux TransportQmss Source Delivery and Recompilation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=45" title="Edit section: ARMv7 Linux TransportQmss Source Delivery and Recompilation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The ARMv7 Linux TransportQmss source code can be downloaded and built two ways.  The transport source code is delivered and built as part of Yocto/bitbake.  The source code can also be downloaded and built directly from the GIT repository.
</p>
<h4><span id="Recompiling_Through_Yocto/bitbake_2"></span><span class="mw-headline" id="Recompiling_Through_Yocto.2Fbitbake_2">Recompiling Through Yocto/bitbake</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=46" title="Edit section: Recompiling Through Yocto/bitbake">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ol><li>Follow the instructions in the Exploring section of the user guide to configure the <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Exploring.html#Yocto">Yocto build environment</a>.  The tisdk-server-rootfs-image does not need to be built.  Instead look at the section for <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Exploring.html#Building_other_components_in_Yocto">building other components</a></li>
<li>Build the TransportQmss libraries, ipc-transport-qmss recipe, and user-space tests, ipc-transport-qmss-test recipe: <br />$ MACHINE=k2hk-evm TOOLCHAIN_BRAND=linaro ARAGO_BRAND=mcsdk bitbake ipc-transport-qmss <br />$ MACHINE=k2hk-evm TOOLCHAIN_BRAND=linaro ARAGO_BRAND=mcsdk bitbake ipc-transport-qmss-test <br /><br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The initial build may take quite some time since the kernel is built as a dependency <br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Building with just the ipc-transport-qmss-test recipe will also build the ipc-transport-qmss recipe since the test recipe depends on the library recipe.</li>
<li>The built TransportQmss static library will be located in <br />&lt;base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-qmss/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-qmss-staticdev/usr/lib/libTransportQmss.a <br /><br />The built TransportQmss shared library will be located in <br />&lt;base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-qmss/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-qmss/usr/lib/libTransportQmss.so.1.0.0</li>
<li>The ipc-transport-qmss-test recipe will build test static and shared library executables for all supported devices.  The executables will be located in <br />base_path&gt;/oe-layersetup/build/arago-tmp-external-linaro-toolchain/work/cortexa15hf-vfp-neon-3.8-oe-linux-gnueabi/ipc-transport-qmss-test/&lt;tag-ver_recipe-ver&gt;/packages-split/ipc-transport-qmss-test/usr/bin/</li></ol>
<h4><span class="mw-headline" id="Recompiling_Through_GIT_Repository_2">Recompiling Through GIT Repository</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=47" title="Edit section: Recompiling Through GIT Repository">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Recompiling through the ARMv7 Linux TransportQmss GIT repository requires that the latest MCSDK Linux installation.  The MCSDK Linux PDK component and the Linux devkit must be installed.  The Linux devkit installation script can be found in &lt;MCSDK Linux install root&gt;/mcsdk_linux_3_XX_YY_ZZ/linux-devkit/
</p>
<ol><li>Clone the keystone-linux/ipc-transport repository from git.ti.com <br />$ git clone <a rel="nofollow" class="external free" href="git://git.ti.com/keystone-linux/ipc-transport.git">git://git.ti.com/keystone-linux/ipc-transport.git</a></li>
<li>Navigate to the MCSDK Linux installation of pdk_3_XX_YY_ZZ/packages and source armv7setupenv.sh. <br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The armv7setupenv.sh script must be modified build for the correct K2 device, and to point to the linaro toolchain and installed devkit path <br />$ source armv7setupenv.sh</li>
<li>Navigate back to the QMSS transport directory in the ipc-transport GIT repository <br />$ cd &lt;repo_root_path&gt;/ipc-transport/linus/qmss</li>
<li>Build the TransportQmss library and user-space test executables: <br />$ make lib <br />$ make tests</li>
<li>The TransportQmss static and shared libraries will be copied directly into the Linux devkit's /usr/lib folder as long as the devkit install path was setup correctly prior to running the armv7setupenv.sh script</li>
<li>The test executables will be generated in the &lt;base_repo_path&gt;/ipc-transport/bin/&lt;k2 device&gt;/test/ folder.  Only the device specified in the armv7setupenv.sh will be built. <br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b> Setting the USEDYNAMIC_LIB environment variable to "yes" will generate the shared library test executables <br />$ export USEDYNAMIC_LIB=yes</li></ol>
<h3><span class="mw-headline" id="ARMv7_Linux_TransportQmss_Configuration_Parameters">ARMv7 Linux TransportQmss Configuration Parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=48" title="Edit section: ARMv7 Linux TransportQmss Configuration Parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Following are the configuration parameters for TransportQnss instance creation.  Descriptions, default values, and programming considerations are provided for each configuration parameter.  Each parameter is an element of the TransportQmss_Params structure.  A structure of this type must be created, populated, and passed to the TransportQmss_create() function via pointer.  The structure should be initialized to its default values using the TransportQmss_Params_init() function prior to population with application specific parameters.
</p><p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>   TransportQmss_Params  qmss_trans_params;
</pre>
<pre>   ...
   TransportQmss_Params_init(&amp;qmss_trans_params);
   snprintf(mpm_inst_name, MPM_INST_NAME_LEN, "arm-qmss-generic");
   qmss_trans_params.mpm_trans_inst_name = mpm_inst_name;
   qmss_trans_params.rm_service_h        = ...;
   ...
   qmss_handle = TransportQmss_create(&amp;qmss_trans_params);
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<table border="1" style="width: 1000px; height: 200px" id="qmss_transport_config_params">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Configuration Parameter Element</b>
</td>
<td bgcolor="#c0c0c0"><b>Description</b>
</td>
<td bgcolor="#c0c0c0"><b>Initial Value</b>
</td>
<td bgcolor="#c0c0c0"><b>Special Considerations</b>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Char *mpm_trans_inst_name;&lt;/syntaxhighlight&gt;
</td>
<td>MPM-Transport instance name.  This string must match a "slaves" name string defined within the mpm_config.json file used in the Linux filesystem
</td>
<td>NULL
</td>
<td>This string name must match the generic QMSS instance name in the filesystem's /etc/mpm/mpm_config.json.  The MPM JSON file's generic QMSS string is "arm=qmss-generic".
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Void *rm_service_h;&lt;/syntaxhighlight&gt;
</td>
<td>RM instance service handle needed by MPM-Transport to request hardware resources
</td>
<td>NULL
</td>
<td>
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Int rx_msg_size_bytes;&lt;/syntaxhighlight&gt;
</td>
<td>Maximum size in bytes of messages that will be received by this transport.  Used to allocated MessageQ messages for reception
</td>
<td>0
</td>
<td>The value specified must be in sync with the "sizebuf" values specified in the "qmss-queue-map" transmit and receive free queue nodes of the mpm_config.json configuration file.
</td></tr>
<tr>
<td>&lt;syntaxhighlight lang='C'&gt;Int mpm_trans_init_qmss;&lt;/syntaxhighlight&gt;
</td>
<td>Controls whether MPM-Transport will initialize the QMSS hardware <br />0 - MPM-Transport will not initialize QMSS.  Set if another entity within the system initialized the QMSS hardware. <br />1 - MPM-Transport will initialize QMSS.  Set if this is the first system entity being created that used QMSS and QMSS has not been initialized
</td>
<td>0
</td>
<td>
</td></tr></tbody></table>
<h4><span class="mw-headline" id="MPM_Transport_Configuration_Effects_on_ARMv7_Linux_TransportQmss">MPM Transport Configuration Effects on ARMv7 Linux TransportQmss</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=49" title="Edit section: MPM Transport Configuration Effects on ARMv7 Linux TransportQmss">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>TransportQmss assumes MPM Transport will manage configuration of the QMSS and CPPI LLDs.  As a result, descriptor and descriptor buffer management is pushed to MPM Transport in the ARMv7 Linux version of TransportQmss.  The MPM Transport JSON configuration file should be modified in order to change QMSS descriptor and buffer related parameters.
</p><p>The MPM Transport JSON configuration file is located in the Linux file system at /etc/mpm/mpm_config.json
</p>
<h3><span class="mw-headline" id="Adding_the_ARMv7_Linux_TransportQmss_to_a_User-Space_Application">Adding the ARMv7 Linux TransportQmss to a User-Space Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=50" title="Edit section: Adding the ARMv7 Linux TransportQmss to a User-Space Application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A TransportQmss instance can be created after the following:
</p>
<ul><li>IPC has started</li>
<li>A RM client instance has been created.  Communication between the RM Client and the RM Server will take place over a Linux socket.</li>
<li>ARMv7 Linux TransportQmss instances can be created once all previous requirements are satisfied.  A TransportQmss instance can be created per user-space process.  The number of TransportQmss instances that can exist simultaneously is limited to the number of QMSS queue pend queues available for use outside the kernel.  The following example code comes from the TransportQmss multi-process test:</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>   TransportQmss_Params_init(&amp;qm_trans_params);
   snprintf(mpm_inst_name, MPM_INST_NAME_LEN, "arm-qmss-generic");
   qm_trans_params.mpm_trans_inst_name = mpm_inst_name;
   qm_trans_params.rm_service_h        = rm_client_service_handle;
   qm_trans_params.rx_msg_size_bytes   = MAX_PACKET_SIZE;
   qm_trans_params.mpm_trans_init_qmss = 1;
   printf("Process&#160;%d&#160;: Creating TransportQmss instance\n", local_process);
   qmss_trans_h = TransportQmss_create(&amp;qm_trans_params);
   if (!qmss_trans_h) {
       printf("ERROR Process&#160;%d&#160;: Failed to create TransportQmss handle\n", 
              local_process);
       status = -1;
       goto err_exit;
   }
</pre>
<pre>   /* Register transport with MessageQ as network transport */
   net_trans_h = TransportQmss_upCast(qmss_trans_h);
   base_trans_h = INetworkTransport_upCast(net_trans_h);
   if (MessageQ_registerTransportId(TRANS_QMSS_NET_ID, base_trans_h) &lt; 0) {
       printf("ERROR Process&#160;%d&#160;: "
              "Failed to register TransportQmss as network transport\n",
              local_process);
       status = -1;
       goto err_exit;
   }
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<ul><li>Use the standard MessageQ_create() and MessageQ_open() APIs to create a local process MessageQ and open a remote process MessageQ, respectively.  The LAD daemon's NameServer will store created queues and respond to queue open queries.</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>   /* Create a MessageQ */
   snprintf(msg_q_name, MSGQ_Q_NAME_LEN, "Process_%d_MsgQ", local_process);
   MessageQ_Params_init(&amp;msg_params);
   msg_q_h = MessageQ_create(msg_q_name, &amp;msg_params);
   if (msg_q_h == NULL) {
       printf("ERROR Process&#160;%d&#160;: Failed to create MessageQ\n", local_process);
       status = -1;
       goto err_exit;
   }
   printf("Process&#160;%d&#160;: Local MessageQ:&#160;%s, QId: 0x%x\n", local_process,
          msg_q_name, MessageQ_getQueueId(msg_q_h));
</pre>
<pre>   /* Open next process's MessageQ */
   snprintf(remote_q_name, MSGQ_Q_NAME_LEN, "Process_%d_MsgQ", next_process);
   printf ("Process&#160;%d&#160;: Attempting to open remote queue:&#160;%s\n",
           local_process, remote_q_name);
   do {
       status = MessageQ_open(remote_q_name, &amp;remote_q_id);
       sleep(1);
   } while ((status == MessageQ_E_NOTFOUND) || (status == MessageQ_E_TIMEOUT));
   if (status &lt; 0) {
       printf("ERROR Process&#160;%d&#160;: Error&#160;%d when opening next process MsgQ\n",
              local_process, status);
       status = -1;
       goto err_exit;
   } else {
       printf("Process&#160;%d&#160;: Opened Remote queue:&#160;%s, QId: 0x%x\n",
              local_process, remote_q_name, remote_q_id);
   }
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<ul><li>MessageQ_put() and MessageQ_get() can be used normally to send and receive messages between processes using TransportQmss.  The only caveat is that messages that are to use TransportQmss must be sent with the transport ID, TID, that was used to register the TransportQmss instance with the MessageQ Network interface.</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
/* TransportQmss MessageQ Network Interface TID */
</p>
<ol><li>define TRANS_QMSS_NET_ID 4</li></ol>
<p>typedef struct {
</p>
<pre>   MessageQ_MsgHeader header; /* 32 bytes */
   int32_t            src;
   int32_t            flags;
   int32_t            numMsgs; 
   int32_t            seqNum;
   uint32_t           data[TEST_MSG_DATA_LEN_WORDS];
   uint8_t            pad[16]; /* Pad to cache line size of 128 bytes */
</pre>
<p>} test_msg_t;
</p><p>...
</p><p>test_msg_t *msg = NULL;
</p><p>msg = (test_msg_t *) MessageQ_alloc(0, sizeof(*msg));
if (msg == NULL) {
</p>
<pre>   printf("ERROR Process&#160;%d&#160;: MessageQ_alloc failed\n",
          local_process);
   goto err_exit;
</pre>
<p>}
</p><p>...
</p><p>/* Set the transport ID to route message through TransportQmss instance */
MessageQ_setTransportId(msg, TRANS_QMSS_NET_ID);
status = MessageQ_put(remote_q, (MessageQ_Msg)msg);
if (status &lt; 0) {
</p>
<pre>   printf("ERROR Process&#160;%d&#160;: MessageQ_put failed\n",
          local_process);
   goto err_exit;
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="ARMv7_Linux_TransportQmss_Tests">ARMv7 Linux TransportQmss Tests</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=51" title="Edit section: ARMv7 Linux TransportQmss Tests">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>ARMv7 Linux TransportQmss includes two tests.  The Multi-Process test and the ARM Linux portion of the Heterogeneous Processor test.
</p>
<h4><span class="mw-headline" id="Multi-Process_Test">Multi-Process Test</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=52" title="Edit section: Multi-Process Test">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The Multi-Process test uses TransportQmss to send MessageQ messages between Linux user-space processes.  The MessageQ interface is used to send a message, round-robin, between a configurable number of Linux processes.  Each process runs an exclusive TransportQmss instance.  Data integrity of the message is checked after each process to process transfer.  The default number of processes and round-robin iterations is 4, and 100, respectively.
</p>
<h5><span class="mw-headline" id="Building_3">Building</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=53" title="Edit section: Building">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The Multi-Process user-space application can be built through Yocto/bitbake or through downloading the keystone-linux/ipc-transport GIT repository.  For instructions on how to do either please see UG section on <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Developing_Transports.html#ARMv7_Linux_TransportQmss_Source_Delivery_and_Recompilation">ARMv7 Linux TransportQmss Source Delivery</a>.  Once built, the multiProcessTest binary can be moved to the Linux filesystem.
</p>
<h5><span class="mw-headline" id="Running_3">Running</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=54" title="Edit section: Running">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Replace "K2X" and "k2x" with the proper device
</p>
<ol><li>Load the CMEM module <br />$ insmod /lib/modules/3.10.61/extra/cmemk.ko</li>
<li>Start the RM Server <br />$ rmServer.out /usr/bin/device/k2x/global-resource-list.dtb /usr/bin/device/k2x/policy_dsp_arm.dtb</li>
<li>Execute the Multi-Process test binary <br />$ ./multiProcessTest.out</li></ol>
<p>&lt;syntaxhighlight lang='bash'&gt;
root@k2e-evm:~# ./multiProcessTest.out
</p>
<ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li class="mw-empty-elt"></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li>
<li>TransportQmss Linux Multi-Process Test *********
<ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li class="mw-empty-elt"></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
<p>TransportQmss Version&#160;: 0x02000000
Version String: Linux IPC Transports Revision: 2.0.0.00:Nov  4 2015:17:46:03
Process 1&#160;: Initialized RM_Client1
Process 3&#160;: Initialized RM_Client3
Process 0&#160;: Initialized RM_Client0
Process 2&#160;: Initialized RM_Client2
Process 1&#160;: Creating TransportQmss instance
Process 0&#160;: Creating TransportQmss instance
Process 3&#160;: Creating TransportQmss instance
Process 2&#160;: Creating TransportQmss instance
Process 1&#160;: Local MessageQ: Process_1_MsgQ, QId: 0x80
Process 1&#160;: Attempting to open remote queue: Process_2_MsgQ
Process 0&#160;: Local MessageQ: Process_0_MsgQ, QId: 0x81
Process 0&#160;: Attempting to open remote queue: Process_1_MsgQ
Process 3&#160;: Local MessageQ: Process_3_MsgQ, QId: 0x82
Process 3&#160;: Attempting to open remote queue: Process_0_MsgQ
Process 2&#160;: Local MessageQ: Process_2_MsgQ, QId: 0x83
Process 2&#160;: Attempting to open remote queue: Process_3_MsgQ
Process 0&#160;: Opened Remote queue: Process_1_MsgQ, QId: 0x80
Process 0&#160;: Allocating round trip test MessageQ msg
Round Trip -    1
Process 0&#160;: Sending msg to Process 1
Process 3&#160;: Opened Remote queue: Process_0_MsgQ, QId: 0x81
Process 2&#160;: Opened Remote queue: Process_3_MsgQ, QId: 0x82
Process 1&#160;: Opened Remote queue: Process_2_MsgQ, QId: 0x83
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -    2
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -    3
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -    4
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -    5
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -    6
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -    7
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -    8
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -    9
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   10
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   11
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   12
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   13
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   14
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   15
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   16
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   17
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   18
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   19
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   20
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   21
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   22
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   23
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   24
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   25
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   26
Process 0&#160;: Flushing transport's dst cache of dst MessageQ queue ID 0x80
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Flushing transport's dst cache of dst MessageQ queue ID 0x83
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Flushing transport's dst cache of dst MessageQ queue ID 0x82
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Flushing transport's dst cache of dst MessageQ queue ID 0x81
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   27
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   28
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   29
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   30
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   31
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   32
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   33
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   34
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   35
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   36
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   37
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   38
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   39
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   40
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   41
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   42
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   43
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   44
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   45
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   46
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   47
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   48
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   49
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   50
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   51
Process 0&#160;: Flushing transport's entire dst cache
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Flushing transport's entire dst cache
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Flushing transport's entire dst cache
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Flushing transport's entire dst cache
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   52
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   53
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   54
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   55
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   56
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   57
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   58
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   59
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   60
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   61
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   62
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   63
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   64
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   65
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   66
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   67
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   68
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   69
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   70
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   71
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   72
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   73
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   74
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   75
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   76
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   77
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   78
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   79
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   80
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   81
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   82
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   83
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   84
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   85
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   86
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   87
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   88
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   89
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   90
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   91
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   92
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   93
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   94
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   95
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   96
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   97
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   98
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -   99
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Sending msg to Process 0
Process 0&#160;: Received msg with good data from Process 3
Round Trip -  100
Process 0&#160;: Sending msg to Process 1
Process 1&#160;: Received msg with good data from Process 0
Process 1&#160;: Sending msg to Process 2
Process 2&#160;: Received msg with good data from Process 1
Process 2&#160;: Sending msg to Process 3
Process 3&#160;: Received msg with good data from Process 2
Process 3&#160;: Freeing round trip test MessageQ msg
Test PASSED
Cleaning up
Test Complete!
&lt;/syntaxhighlight&gt;
</p>
<h4><span class="mw-headline" id="Heterogeneous_Processor_Test_2">Heterogeneous Processor Test</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=55" title="Edit section: Heterogeneous Processor Test">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The Heterogeneous processor test uses TransportQmss to send MessageQ messages between Linux user-space processes and DSP cores.  The MessageQ interface is used to send messages between a Linux process and a configurable number of DSP cores, the default is 2 DSPs.  Each Linux process and DSP runs an exclusive TransportQmss instance.  Data integrity of the message is checked after each transfer.
</p>
<h5><span class="mw-headline" id="Building_4">Building</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=56" title="Edit section: Building">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The Heterogeneous processor test's ARM Linux endpoint, a user-space application, can be built through Yocto/bitbake or through downloading the keystone-linux/ipc-transport GIT repository.  For instructions on how to do either please see UG section on <a rel="nofollow" class="external text" href="MCSDK_UG_Chapter_Developing_Transports.html#ARMv7_Linux_TransportQmss_Source_Delivery_and_Recompilation">ARMv7 Linux TransportQmss Source Delivery</a>.  Once built, the armEpTest binary can be moved to the Linux filesystem.
</p><p>The Heterogeneous processor test's DSP endpoint application is called transportIpcQmssDspEpK2XTestProject.out.  The source code is located in &lt;install_base&gt;/pdk_keystone2_&lt;ver&gt;/packages/ti/transport/ipc/c66/qmss/test.  The project can be imported into CCS from &lt;install_base&gt;/pdk_keystone2_&lt;ver&gt;/packages/exampleProjects folder.  Build the project and copy the generated .out to the Linux file system.
</p><p><br />
</p>
<h5><span class="mw-headline" id="Running_4">Running</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=57" title="Edit section: Running">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Replace "K2X" and "k2x" with the proper device
</p>
<ol><li>Start the RM Server (Only applicable if the rmServer is not started during Linux boot) <br />$ rmServer.out /usr/bin/device/k2x/global-resource-list.dtb /usr/bin/device/k2x/policy_dsp_arm.dtb</li>
<li>Load the DSP endpoints (Repeat for the # of DSPs, default is 2) <br />$ mpmcl load dsp# transportIpcQmssDspEpK2XTestProject.out <br />$ mpmcl run dsp#</li>
<li>Execute Linux endpoint binary <br />$ ./armEpTest.out</li>
<li>The DSP endpoint logs can be dumped from /sys/kernel/debug/remoteproc/remoteproc#/trace0 where # is the DSP whose trace to dump</li></ol>
<p>&lt;syntaxhighlight lang='bash'&gt;
</p><p>root@k2e-evm:~# ./armEpTest.out
</p>
<ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li class="mw-empty-elt"></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li>
<li>ARMv7 Linux TransportQmss Heterogeneous Test (ARM EP) *
<ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li class="mw-empty-elt"></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
<p>TransportQmss Version&#160;: 0x02000000
Version String: Linux IPC Transports Revision: 2.0.0.00:Nov  4 2015:17:59:08
Process 1&#160;: Initialized RM_Client0
Process 1&#160;: Opening RM client socket /var/run/rm/rm_client0
Process 1&#160;: Creating TransportQmss instance
Process 0&#160;: Starting RM Message Hub
Process 0&#160;: Created RM hub queue: RM_Message_Hub, Qid: 0x80
Process 0&#160;: Opening RM_Client_DSP_1
Process 1&#160;: Local MessageQ: TEST_MsgQ_Proc_0, QId: 0x81
Process 1&#160;: Attempting to open DSP 1 queue: TEST_MsgQ_Proc_1
Process 0&#160;: Opened Remote queue: RM_Client_DSP_1, QId: 0x10080
Process 0&#160;: Sending handshake to DSP 1
Process 0&#160;: Received handshake response from DSP 1
Process 0&#160;: Opening RM hub socket /var/run/rm/rm_msg_hub
Process 0&#160;: Opening RM Server socket /var/run/rm/rm_server
Process 0&#160;: Sending ready msg to DSP 1
Process 0&#160;: Wait for RM messages from DSP RM clients
Process 1&#160;: Opened DSP 1 queue: TEST_MsgQ_Proc_1, QId: 0x10081
Process 1&#160;: Allocating bidirectional test MessageQ msg
Process 1&#160;: ### Round Trip -    1 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -    2 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -    3 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -    4 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -    5 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -    6 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -    7 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -    8 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -    9 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   10 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   11 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   12 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   13 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   14 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   15 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   16 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   17 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   18 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   19 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   20 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   21 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   22 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   23 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   24 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   25 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   26 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   27 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   28 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   29 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   30 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   31 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   32 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   33 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   34 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   35 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   36 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   37 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   38 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   39 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   40 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   41 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   42 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   43 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   44 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   45 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   46 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   47 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   48 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   49 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   50 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   51 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   52 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   53 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   54 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   55 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   56 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   57 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   58 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   59 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   60 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   61 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   62 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   63 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   64 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   65 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   66 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   67 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   68 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   69 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   70 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   71 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   72 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   73 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   74 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   75 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   76 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   77 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   78 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   79 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   80 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   81 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   82 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   83 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   84 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   85 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   86 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   87 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   88 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   89 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   90 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   91 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   92 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   93 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   94 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   95 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   96 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   97 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   98 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -   99 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: ### Round Trip -  100 ###
Process 1&#160;: Sending msg to DSP 1 using Qid 0x10081
Process 1&#160;: Received msg with good data from DSP 1
Process 1&#160;: Freeing bidirectional test MessageQ msg
Test PASSED
Cleaning test process
Process 0&#160;: Cleaning up RM Message Hub
Test Complete!
&lt;/syntaxhighlight&gt;
</p>
<h1><span class="mw-headline" id="MPM_Mailbox">MPM Mailbox</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=58" title="Edit section: MPM Mailbox">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>Mailbox is used for exchanging control messages between the host and individual DSP cores. As shown in the picture below, a mailbox is uni-directional, either host-&gt;DSP or DSP-&gt;host. Mailboxes are identified by a unique integer value which is returned after a mailbox is created on the host and opened on the DSP core. There exists a maximum of 2 mailboxes per DSP core (1 mailbox for Host -&gt; DSP messages and 1 mailbox for DSP -&gt; Host messages). Each mailbox has configurable amount of memory space to allocate slots which store a pending message.
</p><p><a href="File_DLSDK_Mailbox_A.html" class="image" title="Mailbox Block diagram"><img alt="Mailbox Block diagram" src="https://processors.wiki.ti.com/images/b/ba/DLSDK_Mailbox_A.png" width="750" height="396" class="thumbborder" /></a>
</p><p>An empty Mailbox slot must be allocated prior to sending a message. Receiving a message frees a slot and marks it as being empty. Mailboxes can be queried to obtain the number of unread messages within the mailbox.
</p><p>Here is the high-level API for this module:
</p>
<ul><li><b>mpm_mailbox_create </b>is called by the host and dsp to create a mailbox at the location specified</li>
<li><b>mpm_mailbox_open</b>&#160;is called by both Host and DSP core to open the mailbox</li>
<li><b>mpm_mailbox_write </b>is a non-blocking call,  writes a message to the mailbox. Returns with error message indicating full, if all the mailbox slots are occupied</li>
<li><b>mpm_mailbox_read&#160;</b>is a non-blocking call. A message is picked up and returned to the application when available. Returns error message indicating empty, if there are no messages to be processed.</li>
<li><b>mpm_mailbox_query </b>obtains the number of unread messages in the mailbox</li></ul>
<p><br />
</p>
<h1><span class="mw-headline" id="MPM_Sync">MPM Sync</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=59" title="Edit section: MPM Sync">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>Sync Module implements support for Multicore Barriers and Locks.
</p>
<h2><span class="mw-headline" id="Barrier">Barrier</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=60" title="Edit section: Barrier">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Step-1) Number of participants in a barrier need to be defined up front, and using the below API, the memory size required for that many participants can be obtained.
</p><p><code>int32_t mpm_sync_barr_get_sizes(int32_t num_users)</code>
</p><p>Step-2) One of the participants has to invoke a barrier init. It is not harmful to invoke this by some or all the participants. If a barrier is already initialized, subsequent calls (by other cores) simply returns.
</p><p><code>mpm_sync_barr_init(void *barr, int32_t num_users)</code>
</p><p>Step-3) Participants call mpm_sync_barr_wait function to busy wait until all the participants arrive at that location.
</p><p><code>mpm_sync_barr_wait(void *barr)</code>
</p><p><br />
</p>
<h2><span class="mw-headline" id="Lock">Lock</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=61" title="Edit section: Lock">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Lock module implements Lamports bakery algorithm using shared memory.  It is a multi-process safe lock.
</p><p>Maximum number of participants in a lock need to be determined up front for memory allocation reasons. The required memory can be queried using mpm_sync_lock_get_sizes() API.
</p><p>Here is the high-level API for this module: 
</p>
<ul><li><b>mpm_sync_lock_init() </b>needs to be called once to initialize the lock.</li>
<li><b>mpm_sync_lock_check() </b>is a non-blocking call to check if lock is in use.</li>
<li><b>mpm_sync_lock_acquire() </b>is a blocking call to acquire the lock and</li>
<li><b>mpm_sync_lock_release() </b>releases the lock.</li></ul>
<h1><span class="mw-headline" id="MPM_Transport">MPM Transport</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=62" title="Edit section: MPM Transport">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The MPM transport is designed to provide access to memory associated with remote cores/nodes. The current supported transport modes are: <i>shared memory transport</i> and <i>Hyperlink transport</i>. <br />
</p>
<div class="thumb tright"><div class="thumbinner" style="width:302px;"><a href="File_Mpm-transport.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/6/6c/Mpm-transport.jpg" width="300" height="246" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Mpm-transport.html" class="internal" title="Enlarge"></a></div>MPM Transport</div></div></div>
<p>Following are some implementation details:
</p>
<ul><li>The API's to access transport and its static library are provided in <i>linux-devkit</i>.</li>
<li>The APIs can be reviewed from <a rel="nofollow" class="external text" href="http://git.ti.com/cgit/cgit.cgi/keystone-linux/mpm-transport.git/tree/include/mpm_transport.h">mpm_transport.h</a>.</li>
<li>The parameters of transport can be configured from the JSON config file <a rel="nofollow" class="external text" href="http://git.ti.com/cgit/cgit.cgi/keystone-linux/mpm-transport.git/tree/scripts/mpm_config.json">mpm_config.json</a>. Currently the MPM downloader shares same config file, it is likely to change in future.</li>
<li>The static library to be linked for the transport is <i>libmpmtransport.a</i>, which is in linux-devkit provided in the release. The link option should be <i>-lmpmtransport</i>.</li>
<li>An example application of the transport component is provided in <a rel="nofollow" class="external text" href="http://git.ti.com/cgit/cgit.cgi/keystone-linux/mpm-transport.git/tree/src/transport/test">test</a>.</li></ul>
<h2><span class="mw-headline" id="Release_History">Release History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=63" title="Edit section: Release History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Refer to following table for release history:
</p>
<table border="1" style="width: 75%">

<tbody><tr>
<td bgcolor="#88aabb"><b>MCSDK Version</b>
</td>
<td bgcolor="#88aabb"><b>MPM-Transport Version</b>
</td>
<td bgcolor="#88aabb"><b>Major Updates / Features Release</b>
</td></tr>
<tr>
<td>3.0.1
</td>
<td>1.0.0
</td>
<td>Initial MPM-Transport release. Shared memory functionality.
</td></tr>
<tr>
<td>3.0.2
</td>
<td>1.0.0
</td>
<td>No major changes
</td></tr>
<tr>
<td>3.0.3
</td>
<td>1.0.1
</td>
<td>Hyperlink support for transfers. JSON to add new slaves and additional array segment for hyperlink peripheral parameters. Leverages hyperlink user mode driver.
</td></tr>
<tr>
<td>3.0.4
</td>
<td>1.0.4
</td>
<td>Added support for EDMA3 and 36-bit addresses. Intersect with MCSDK-HPC developments.
</td></tr>
<tr>
<td>3.1.0, 3.1.1
</td>
<td>1.0.5
</td>
<td>Multiple optimizations for hyperlink, such as linked transfers, parsing DTB for params, K2E support
</td></tr>
<tr>
<td>3.1.2
</td>
<td>1.0.6
</td>
<td>Added hyperlink interrupt support
</td></tr>
<tr>
<td>3.1.3
</td>
<td>1.0.7
</td>
<td>Added QMSS and SRIO support
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Migration_from_MCSDK_3.1.1_to_MCSDK_3.1.3">Migration from MCSDK 3.1.1 to MCSDK 3.1.3</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=64" title="Edit section: Migration from MCSDK 3.1.1 to MCSDK 3.1.3">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The default examples using hyperlink are changed to serdes_init = 0, which means that you need to enable the serdes externally before running the examples. You can do this by using mpmcl:
&lt;syntaxhighlight lang='bash'&gt;
user@k2hk-evm&gt; mpmcl transport &lt;slave name&gt; open
&lt;/syntaxhighlight&gt;
</p><p>Additionally, hyperlink and SRIO LLD symbols are now declared as weak to accommodate devices without these peripherals. If you are linking with the static MPM Transport library (libmpmtransport.a), you will have to link with --whole-archive so that the user space LLDs will override the weak symbols. No changes if you use the shared library (libmpmtransport.so).
</p><p><br />
</p><p><br />
</p>
<h2><span class="mw-headline" id="Building_the_Library">Building the Library</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=65" title="Edit section: Building the Library">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>1) Clone the git repository for the source code:
</p>
<dl><dd>git clone <a rel="nofollow" class="external free" href="git://git.ti.com/keystone-linux/mpm-transport.git">git://git.ti.com/keystone-linux/mpm-transport.git</a></dd>
<dd>cd mpm-transport</dd></dl>
<p>2) Set up your environment
</p>
<dl><dd>export BUILD_LOCAL=true</dd>
<dd>export PATH="$PATH:&lt;your_linaro_toolchain&gt;/bin"</dd></dl>
<p>3) Source the general MCSDK environment setup file (used also for building other LLDs)
</p>
<dl><dd>cd &lt;your_mcsdk_install&gt;/pdk_keystone2_3_xx_xx_xx/packages</dd>
<dd>source armv7setupenv.sh</dd>
<dd>cd -</dd></dl>
<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  armv7setupenv.sh is located in the pdk_keystone2_3_xx_xx_xx folder that came with MCSDK installation. Your setup should have linux-devkit installed and use the resource in there for development. <b>Modify</b> armv7setupenv.sh according to your system as necessary
</p><p>4) Run make:
</p>
<dl><dd>make clean</dd>
<dd>make</dd></dl>
<h3><span class="mw-headline" id="Modifying_and_Rebuilding_the_Library_for_Profiling">Modifying and Rebuilding the Library for Profiling</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=66" title="Edit section: Modifying and Rebuilding the Library for Profiling">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>MPM-Transport provides some internal time profiling for its provided API. Prior to running make (to rebuild the library as the steps state above), modify the file mpm_transport_time_profile.h to enable the areas you want to profile.
Edit the mpm_transport_time_profile.h file:
</p>
<dl><dd>vi &lt;mpm_transport&gt;/src/utils/time_profile/mpm_transport_time_profile.h</dd></dl>
<p>You should see
&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>#define TIME_PROFILING 0
#if TIME_PROFILING
#define TIME_PROFILE_HYPLNK_PUT_INITIATE			0
#define TIME_PROFILE_HYPLNK_GET_INITIATE			0
#define TIME_PROFILE_HYPLNK_PUT_INITIATE_LINKED		0
#define TIME_PROFILE_HYPLNK_GET_INITIATE_LINKED		0
...
...
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<ul><li>To enable TIME_PROFILING, change "#define TIME_PROFILING 0" to "#define TIME_PROFILING 1"</li>
<li>Change the define to 1 for the function you want to profile, or vice versa, to 0 for regular usage</li>
<li>The variables are named according to the functions it targets. For example, "TIME_PROFILE_HYPLNK_PUT_INITIATE" refers to the mpm_transport_put_initiate() function that is using Hyperlink transport</li>
<li>Please account for nested timestamps. For example, "TIME_PROFILE_HYPLNK_GET_WINDOW" profiles the portion where it maps hyperlink to a remote address, which is within any of the read/write operations. Enabling this will also skew the results for those read/write APIs (such as "TIME_PROFILE_HYPLNK_PUT_INITIATE"</li></ul>
<h3><span class="mw-headline" id="Building_Examples_with_SerDes_Bypass">Building Examples with SerDes Bypass</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=67" title="Edit section: Building Examples with SerDes Bypass">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In the transport modes that uses SerDes, examples may need to explicitly skip the SerDes initialization portion if it is already handled by another process. Motivation to do so would be to minimize risk of breaking the SerDes link or to use the given setup as-is. To do so, set the serdes_init variable in the open structure to 0 before calling mpm_transport_open()
</p><p>&lt;syntaxhighlight lang='C'&gt;
</p>
<pre>   ...
   mpm_transport_open_t ocfg = {
       .open_mode	= (O_SYNC|O_RDWR),
       .msec_timeout = 5000,
       .serdes_init = 0,
   };
   ...
   h = mpm_transport_open("arm-remote-hyplnk-0", &amp;ocfg);
   ...
</pre>
<p>&lt;/syntaxhighlight&gt;
</p><p>In this case, "arm-remote-hyplnk-0" is the slave name to be opened and the slave peripheral specification can be found in the JSON file. Since serdes_init is 0, a separate process should manage opening and closing the transport associated with the slave. MPM has the capability to do so by: "mpmcl transport arm-remote-hyplnk-0 open" and "mpmcl transport arm-remote-hyplnk-0 close", respectively.
</p>
<h2><span class="mw-headline" id="Setting_Transport_Parameters_from_JSON_file">Setting Transport Parameters from JSON file</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=68" title="Edit section: Setting Transport Parameters from JSON file">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The JSON configuration file for MPM-Transport is
<a rel="nofollow" class="external text" href="http://git.ti.com/cgit/cgit.cgi/keystone-linux/mpm-transport.git/tree/scripts/mpm_config.json">mpm_config.json</a>. There are four major arrays in this file that you should be aware of:
</p>
<dl><dt>1) segments - The target destination address has be within the range specified in a memory segment.</dt>
<dd>name - the name of the segment</dd>
<dd>localaddr - address from a local point of view. This is <i>NOT</i> needed for transport modes outside of sharedmem because peripherals see the globaladdr instead.</dd>
<dd>globaladdr - address from the soc point of view</dd>
<dd>length - how long the segment is</dd>
<dd>devicename - /dev/* to open. This only applies to sharedmem. All other transport modes will have their respective transport device.</dd></dl>
<dl><dt>2) slaves - The top-level profile that includes all the information about the transport you want to use</dt>
<dd>name - name of the slave</dd>
<dd>transport - points to a profile in the "transports" array. Exception is "sharedmem", which does not need a profile</dd>
<dd>dma - points to a profile in the "dma-params" array.</dd>
<dd>memorymap - points to profiles in the "segments" array. This entry is an array of segment names.</dd>
<dd>crashcallback - points to the script for crash callback. This is optional for mpm-transport, but is used by mpmcl.</dd></dl>
<dl><dt>3) transports - Individual transport configurations for the transport mode being used</dt>
<dd>name - name of the transport profile</dd>
<dd>transporttype - the transport mode, eg. hyperlink, pcie, srio</dd>
<dd><b>Note:</b> peripheral and transport parameters will vary based on the transport used. See peripheral-related section for mpm-transport</dd></dl>
<dl><dt>4) dma-params - Configuration for using EDMA3</dt>
<dd>name - name of the DMA profile</dd>
<dd>edma3inst - the EDMA3 instance number to use (0-4, total of 5)</dd>
<dd>shadowregion - the shadowregion of the EDMA3 instance to use (0-7, total of 8)</dd></dl>
<dl><dt>5) mpax-params - Configuration for using keystonemmap library</dt>
<dd>name - name of the profile</dd>
<dd>base - base address to use for creating logical addresses (32-bit addresses aliased to specific 36-bit addresses)</dd>
<dd>size - length of the space allow, from the base, to do the logical mapping</dd>
<dd>index - entry number in the MPAX table</dd></dl>
<dl><dt>6) qmss-mem-regions - parameters to figure a QMSS memory region</dt>
<dd>name - name of the memory region</dd>
<dd>regiondescnum - number of descriptors this region will have</dd>
<dd>regiondescsize - size per descriptor</dd>
<dd>regiondescflag - to be used for manageDescFlag</dd>
<dd>regionnum - the region number. Use -1 for next available</dd>
<dd>regionstartidx - the index number to offset from</dd></dl>
<dl><dt>7) qmss-queue-map - parameters to setup a queue</dt>
<dd>name - the name of the queue</dd>
<dd>queue - the queue number. Use -1 for next available</dd>
<dd>qtype - to be used for the queue type to request</dd>
<dd>numdesc - number of descriptors to init for this queue</dd>
<dd>sizebuf - size of the buffer for each descriptor. Will be allocated with CMEM.</dd></dl>
<p><br />
</p>
<h2><span class="mw-headline" id="Transport_over_Hyperlink">Transport over Hyperlink</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=69" title="Edit section: Transport over Hyperlink">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Hyperlink can be configured point-to-point or loopback. There are two Hyperlink ports in Keystone 2. Please refer to the Hyperlink user guide under your SOC's product page for more detailed explanation of the Hyperlink settings and how they are used.
</p>
<h3><span class="mw-headline" id="Pre-requisites">Pre-requisites</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=70" title="Edit section: Pre-requisites">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>MCSDK 3.0.3 or higher. The Hyperlink user mode driver and associated hyplnk_device.c file will be available in the linux-devkit.</li>
<li>libhyplnk*.so* - you will need the shared libraries at runtime. Please ensure that your filesystem has the Hyperlink libs under /usr/lib</li></ul>
<h3><span class="mw-headline" id="JSON_Transport_Profile">JSON Transport Profile</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=71" title="Edit section: JSON Transport Profile">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Fields needed for a Hyperlink transport profile in the JSON file:
</p>
<ul><li>name - name of the profile</li>
<li>transporttype - transport mode. valid value = hyperlink (for using Hyperlink)</li>
<li>direction - valid values = "loopback" for loopback mode, "remote" for sending outside of SOC</li>
<li>hyplnkinterface - Hyperlink instance to use. Valid values = "hyplnk0" to use port 0, "hyplnk1" to use port 1</li>
<li>txprivid - transmit privid overlay field</li>
<li>rxprivid - receiving side's privid select field</li>
<li>rxsegsel - receiving side's segment select field</li>
<li>rxlenval - Length of the Hyperlink segment</li>
<li>lanerate - Valid values = full, half, quarter</li>
<li>numlanes - Valid values = 4, 1, 0</li></ul>
<p>Example:
</p><p>&lt;syntaxhighlight lang='C'&gt;
{
</p>
<pre> "name": "hyplnk0-loopback",
 "transporttype": "hyperlink",
 "direction": "loopback",
 "hyplnkinterface": "hyplnk0",
 "txprivid": 0,
 "rxprivid": 0,
 "rxsegsel": 6,
 "rxlenval": 21,
 "numlanes": "4"
</pre>
<p>},
&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="Compiling_and_Linking_with_Hyperlink_Libraries">Compiling and Linking with Hyperlink Libraries</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=72" title="Edit section: Compiling and Linking with Hyperlink Libraries">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>If you are compiling with the dynamic MPM Transport library, your application will link in the needed user space LLDs at runtime. Please make sure that libhyplnk_device.so.1 exists in your linker path and points to the appropriate device-specific library in your filesystem.</li></ul>
<ul><li>If you are compiling with static libraries, you will need to link in the Hyperlink library for your application. Please use --whole-archive, -lhyplnk_&lt;device&gt;, and -L${DEVKIT_USR_LIB} (DEVKIT_USR_LIB is your devkit's user library directory containing the needed libs).</li></ul>
<p><br />
</p>
<h2><span class="mw-headline" id="Transport_over_QMSS">Transport over QMSS</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=73" title="Edit section: Transport over QMSS">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>QMSS transport is set up to push and pop descriptors from queues. This is a cornerstone for many of the packet-based transports that is used in the system.
</p>
<h3><span class="mw-headline" id="Pre-requisites_2">Pre-requisites</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=74" title="Edit section: Pre-requisites">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>MCSDK 3.1.3 or higher. The Hyperlink user mode driver and associated hyplnk_device.c file will be available in the linux-devkit.</li>
<li>libqmss*.so* and libcppi*.so* - you will need these shared libraries at runtime. Please ensure that your filesystem has them under /usr/lib.</li>
<li>TI CMEM - the cmem module will be needed to allocate continuous memory.</li></ul>
<h3><span class="mw-headline" id="JSON_Transport_Profile_2">JSON Transport Profile</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=75" title="Edit section: JSON Transport Profile">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Fields needed:
</p>
<ul><li>name - name of the profile</li>
<li>transporttype - needs to be "qmss" to signify QMSS transport</li>
<li>qmssmaxdesc - max number of descriptors to initialize QMSS with. This is done once per process</li>
<li>initregion - looks for the corresponding qmss-mem-region for params to setup a memory region</li>
<li>txfreeq - looks for the corresponding qmss-queue-map to setup a TX queue</li>
<li>rxfreeq - looks for the corresponding qmss-queue-map to setup a RX queue</li>
<li>writefifodepth - FIFO depth to setup CPPI with</li>
<li>cpdmatimeout - timeout value for cpdma to setup CPPI with</li></ul>
<h3><span class="mw-headline" id="Initializing_QMSS">Initializing QMSS</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=76" title="Edit section: Initializing QMSS">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>Setup Resource Manager - applications will need to initialize the RM driver and pass in the RM client handle for QMSS and CPPI LLDs to use:</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
mpm_transport_open_t ocfg;
ocfg.rm_info.rm_client_handle        = rmClientServiceHandle;
&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="QMSS_Send_and_Receive">QMSS Send and Receive</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=77" title="Edit section: QMSS Send and Receive">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>For receiving:
int mpm_transport_packet_recv(mpm_transport_h h, char **buf, int *len, mpm_transport_recv_t *cfg);
</p>
<ul><li>buf - a pointer to a buffer of space to copy content to</li>
<li>len - length to copy</li>
<li>cfg - receive options, will be used to specified memcpy or direct linking of buffer</li></ul>
<p>When you open a QMSS handle, you will set up your MPM Transport handle to listen in on a specific RX flow. You can get this flow ID from the mpm_transport_open_t structure that you opened with.
</p><p>&lt;syntaxhighlight lang='C'&gt;
mpm_transport_open_t ocfg;
mpm_transport_open("arm-qmss-generic", &amp;ocfg);
flow_id = ocfg.transport_info.qmss.flowId;
&lt;/syntaxhighlight&gt;
</p><p>For sending:
int mpm_transport_packet_send(mpm_transport_h h, char **buf, int *len, mpm_transport_packet_addr_t *addr_info, mpm_transport_send_t *cfg);
</p>
<ul><li>buf - a pointer to a buffer of space to copy content from</li>
<li>len - length to copy</li>
<li>addr_info - the address to send to</li>
<li>cfg - send options, will be used to specified memcpy or direct linking of buffer</li></ul>
<p>To send a packet in QMSS, addr_info needs to be specified with packet_addr_type_QMSS and the flow ID to send to.
</p><p>&lt;syntaxhighlight lang='C'&gt;
mpm_transport_packet_addr_t send_addr;
send_addr.addr_type = packet_addr_type_QMSS;
send_addr.addr.qmss.flowId = 16;
&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="Compiling_and_Linking_with_QMSS_Libraries">Compiling and Linking with QMSS Libraries</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=78" title="Edit section: Compiling and Linking with QMSS Libraries">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>If you are compiling with the dynamic MPM Transport library, your application will link in the needed user space LLDs at runtime. Please make sure that libqmss_device.so.1 and libcppi_device.so.1 exists in your linker path and points to the appropriate device-specific library in your filesystem.</li></ul>
<ul><li>If you are compiling with static libraries, you will need to link in the needed peripheral LLDs for your application. Please use --whole-archive, -lqmss_&lt;device&gt;, -lcppi_&lt;device&gt; and -L${DEVKIT_USR_LIB} (DEVKIT_USR_LIB is your devkit's user library directory containing the needed libs).</li></ul>
<p><br />
</p>
<h2><span class="mw-headline" id="Transport_over_SRIO">Transport over SRIO</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=79" title="Edit section: Transport over SRIO">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>SRIO is a high speed transport that can transfer data between multiple SOCs or loopback to the same device. This builds on top of the QMSS packet-based transport and abstracts the SRIO user space driver for ease of use.
</p>
<h3><span class="mw-headline" id="Pre-requisites_3">Pre-requisites</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=80" title="Edit section: Pre-requisites">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>MCSDK 3.1.3 or higher. The Hyperlink user mode driver and associated hyplnk_device.c file will be available in the linux-devkit.</li>
<li>libqmss*.so*, libcppi*.so*, and libsrio*.so* - you will need these shared libraries at runtime. Please ensure that your filesystem has them under /usr/lib.</li>
<li>TI CMEM - the cmem module will be needed to allocate continuous memory.</li></ul>
<h3><span class="mw-headline" id="JSON_Transport_Profile_3">JSON Transport Profile</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=81" title="Edit section: JSON Transport Profile">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Fields needed:
</p>
<ul><li>name - name of the profile</li>
<li>transporttype - needs to be "srio" to signify SRIO transport</li>
<li>qmssmaxdesc - max number of descriptors to initialize QMSS with. This is done once per process</li>
<li>initregion - looks for the corresponding qmss-mem-region for params to setup a memory region</li>
<li>txfreeq - looks for the corresponding qmss-queue-map to setup a TX queue</li>
<li>rxfreeq - looks for the corresponding qmss-queue-map to setup a RX queue</li></ul>
<h3><span class="mw-headline" id="Initializing_SRIO">Initializing SRIO</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=82" title="Edit section: Initializing SRIO">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>Setup Resource Manager - applications will need to initialize the RM driver and pass in the RM client handle for QMSS and CPPI LLDs to use:</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
mpm_transport_open_t ocfg;
ocfg.rm_info.rm_client_handle        = rmClientServiceHandle;
&lt;/syntaxhighlight&gt;
</p>
<ul><li>SRIO specific initialization - applications will need to tell MPM Transport the handle's SRIO address information. Example for type 11:</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
ocfg.transport_info.srio.type             = packet_addr_type_SRIO_TYPE11;
ocfg.transport_info.srio.type11.tt        = 1;
ocfg.transport_info.srio.type11.id        = coreDeviceID[coreNum];
ocfg.transport_info.srio.type11.letter    = 2;
ocfg.transport_info.srio.type11.mailbox   = 3;
ocfg.transport_info.srio.type11.segmap    = 0x0;
&lt;/syntaxhighlight&gt;
</p>
<ul><li>SRIO device initialization - applications will to provide MPM Transport a function to initialize/deinitialize the SRIO device:</li></ul>
<p>&lt;syntaxhighlight lang='C'&gt;
ocfg.transport_info.srio.deviceInit   = &amp;mySrioDevice_init;
ocfg.transport_info.srio.initCfg      = NULL; //param for device init function if needed
ocfg.transport_info.srio.deviceDeinit = &amp;mySrioDevice_deinit;
ocfg.transport_info.srio.deinitCfg    = NULL; //param for device deinit function if needed
&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="SRIO_Send_and_Receive">SRIO Send and Receive</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=83" title="Edit section: SRIO Send and Receive">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>For receiving:
int mpm_transport_packet_recv(mpm_transport_h h, char **buf, int *len, mpm_transport_recv_t *cfg);
</p>
<ul><li>buf - a pointer to a buffer of space to copy content to</li>
<li>len - length to copy</li>
<li>cfg - receive options, will be used to specified memcpy or direct linking of buffer</li></ul>
<p>When you open a SRIO handle, it will internally open a SRIO socket handle to listen in on.
</p><p>For sending:
int mpm_transport_packet_send(mpm_transport_h h, char **buf, int *len, mpm_transport_packet_addr_t *addr_info, mpm_transport_send_t *cfg);
</p>
<ul><li>buf - a pointer to a buffer of space to copy content from</li>
<li>len - length to copy</li>
<li>addr_info - the address to send to</li>
<li>cfg - send options, will be used to specified memcpy or direct linking of buffer</li></ul>
<p>To send a packet in SRIO, addr_info needs to be specified with packet_addr_type_SRIO_TYPE9 or packet_addr_type_SRIO_TYPE11, and the SRIO information associated with that type. For example, in type 11:
</p><p>&lt;syntaxhighlight lang='C'&gt;
mpm_transport_packet_addr_t send_addr;
send_addr.addr_type = packet_addr_type_SRIO_TYPE11;
send_addr.addr.srio.type11.tt = 1;
send_addr.addr.srio.type11.id = 0xABCD;
send_addr.addr.srio.type11.letter = 2;
send_addr.addr.srio.type11.mailbox = 3;
&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="Compiling_and_Linking_with_SRIO_Libraries">Compiling and Linking with SRIO Libraries</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=84" title="Edit section: Compiling and Linking with SRIO Libraries">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>If you are compiling with the dynamic MPM Transport library, your application will link in the needed user space LLDs at runtime. Please make sure that libqmss_device.so.1, libcppi_device.so.1, and libsrio.so.1 exists in your linker path and points to the appropriate device-specific library in your filesystem.</li></ul>
<ul><li>If you are compiling with static libraries, you will need to link in the needed peripheral LLDs for your application. Please use --whole-archive, -lqmss_&lt;device&gt;, -lcppi_&lt;device&gt;, -lsrio_&lt;device&gt; and -L${DEVKIT_USR_LIB} (DEVKIT_USR_LIB is your devkit's user library directory containing the needed libs).</li></ul>
<h2><span class="mw-headline" id="Using_EDMA3">Using EDMA3</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=85" title="Edit section: Using EDMA3">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Using the Enhanced Direct Memory Access controller will provide performance increase in transporting large chunks of data over using memcpy.
</p>
<ul><li>currently only supports hyperlink transport mode</li></ul>
<h3><span class="mw-headline" id="Pre-requisites_4">Pre-requisites</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=86" title="Edit section: Pre-requisites">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>MCSDK 3.0.4 or higher. The EDMA3 user mode driver and associated evmTCI6636K2HSample.c file will be available in the linux-devkit.</li>
<li>libedma3.so* and libedma3rm.so* - you will need the shared libraries at runtime. Please ensure that your filesystem has the EDMA3 libs under /usr/lib</li></ul>
<h3><span id="MPM-Transport_Functions/API_to_use_EDMA3"></span><span class="mw-headline" id="MPM-Transport_Functions.2FAPI_to_use_EDMA3">MPM-Transport Functions/API to use EDMA3</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=87" title="Edit section: MPM-Transport Functions/API to use EDMA3">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The tranport functions are named get/put to signify direction of transfer, and "initiate" to signify it is a call to the EDMA3 controller to start a transfer. All transfer calls has a parameter input, <i>boolean is_blocking</i>, to determine whether EDMA3 should wait for completion before continuing. If this parameter is false, mpm_transport_transfer_check() must be called to check for transfer completion and clear EDMA3 flags. All transfer API returns a transfer handle, mpm_transport_trans_h, for mpm_transport_transfer_check() to check.
</p><p>Note that all from_addr and to_addr are physical addresses.
</p>
<ul><li><b>mpm_transport_get_initiate()</b> - Get length data from remote from_addr and store it in local to_addr</li>
<li><b>mpm_transport_put_initiate()</b> - Put length data from local from_addr to remote destination to_addr</li>
<li><b>mpm_transport_get_initiate_linked()</b> - Same as mpm_transport_get_initiate(), except that this API accepts arrays of to_addr, from_addr, and length and complete all transfer with a single call. Parameter num_links must specify number of linked transfer and should equal the size of the three aforementioned arrays.</li>
<li><b>mpm_transport_put_initiate_linked()</b> - Same as mpm_transport_put_initiate(), except that this API accepts arrays of to_addr, from_addr, and length and complete all transfer with a single call. Parameter num_links must specify number of linked transfer and should equal the size of the three aforementioned arrays.</li></ul>
<h3><span class="mw-headline" id="Compiling_and_Linking_with_EDMA3_Libraries">Compiling and Linking with EDMA3 Libraries</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=88" title="Edit section: Compiling and Linking with EDMA3 Libraries">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>You will need to compile and link in your device's evm[DEVICE].c file. This is located in <code>linux-devkit/sysroots/armv7ahf-vfp-neon-oe-linux-gnueabi/usr/include/ti/sdo/edma3/drv/sample/src/platforms/evm[DEVICE].c</code>.</li></ul>
<ul><li>You will need to link in the EDMA3 drv and rm libraries for your application. Please use -ledma3 and -ledma3rm with -L${DEVKIT_USR_LIB}, where DEVKIT_USR_LIB is your devkit's user library directory containing the needed libs.</li></ul>
<h2><span class="mw-headline" id="Using_libkeystonemmap">Using libkeystonemmap</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=89" title="Edit section: Using libkeystonemmap">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Using the Keystone MMAP driver will allow you to access the 36-bit physical memory space.
</p>
<ul><li>currently only supports hyperlink transport mode</li></ul>
<h3><span class="mw-headline" id="Pre-requisites_5">Pre-requisites</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=90" title="Edit section: Pre-requisites">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>MCSDK 3.0.4 or higher. The libkeystonemmap user mode driver and headers will be available in the linux-devkit</li>
<li>libkeystonemmap.so* - you will need the shared libraries at runtime. Please ensure that your filesystem has the libkeystonemmap libs under /usr/lib</li>
<li>All EDMA3 pre-requisites</li></ul>
<h3><span id="MPM-Transport_Functions/API_to_use_libkeystonemmap"></span><span class="mw-headline" id="MPM-Transport_Functions.2FAPI_to_use_libkeystonemmap">MPM-Transport Functions/API to use libkeystonemmap</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=91" title="Edit section: MPM-Transport Functions/API to use libkeystonemmap">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The 36-bit address space is accessed by modifying an entry in the MPAX table. Access to the newly mapped 32-bit address space will be done by the EDMA3 peripheral. Thus, the EDMA3 driver and requirements are needed, and the API provided are forms of "put/get_initiate()"
</p>
<ul><li><b>mpm_transport_get_initiate64()</b> - Same as mpm_transport_get_initiate(), except from_addr and to_addr are 64-bit values (uses MPAX to access 36-bit SOC addresses)</li>
<li><b>mpm_transport_put_initiate64()</b> - Same as mpm_transport_put_initiate(), except from_addr and to_addr are 64-bit values (uses MPAX to access 36-bit SOC addresses)</li></ul>
<h4><span id="How_the_mpm_transport_put_initiate64()_API_Works_for_Hyperlink"></span><span class="mw-headline" id="How_the_mpm_transport_put_initiate64.28.29_API_Works_for_Hyperlink">How the mpm_transport_put_initiate64() API Works for Hyperlink</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=92" title="Edit section: How the mpm transport put initiate64() API Works for Hyperlink">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p><a href="File_Mpm-transport-put-initiate64.html" class="image" title="MPM Transport"><img alt="MPM Transport" src="https://processors.wiki.ti.com/images/b/ba/Mpm-transport-put-initiate64.jpg" width="960" height="342" /></a>
</p>
<ol><li>keystone_mmap() is used to translate the local 36-bit source address to a local 32-bit location. The 32-bit location that is used is specified by the MPAX entry in the JSON file.</li>
<li>A hyperlink segment will be created from SOC1 to SOC2's MPAX registers</li>
<li>SOC1 calls keystone_mmap() again, but with Hyperlink Segement 1 as the base address. This allows SOC1 to update SOC2's MPAX entries remotely, to translate the 36-bit destination address to a 32-bit logical address in SOC2.</li>
<li>A second hyperlink segment will be created to map to the 32-bit destination address in SOC2. EDMA3 can then take the source data from the 32-bit local address (via step 1) and put it into Hyperlink Segment 2</li>
<li>When data hits Hyperlink Segment 2, it will be written to the remote 32-bit logical address (via step 3). This has the same effect as writing to the remote 36-bit destination address.</li></ol>
<h3><span class="mw-headline" id="Compiling_and_Linking_with_libkeystonemmap_Libraries">Compiling and Linking with libkeystonemmap Libraries</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;section=93" title="Edit section: Compiling and Linking with libkeystonemmap Libraries">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>You will need to link in the libkeystonemmap library for your application. Please use -lkeystonemmap with -L${DEVKIT_USR_LIB}, where DEVKIT_USR_LIB is your devkit's user library directory containing the needed libs.
</p><p><br />
</p>
<!-- 
NewPP limit report
Cached time: 20201201072956
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.285 seconds
Real time usage: 0.291 seconds
Preprocessor visited node count: 443/1000000
Preprocessor generated node count: 600/1000000
Postexpand include size: 1016/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 3/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    4.199      1 -total
 47.10%    1.978     18 Template:Note
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:19656-0!canonical and timestamp 20201201072956 and revision id 211089
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>MCSDK UG Chapter Developing Transports</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>MCSDK UG Chapter Developing Transports</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>MCSDK UG Chapter Developing Transports</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>MCSDK UG Chapter Developing Transports</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>MCSDK UG Chapter Developing Transports</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>MCSDK UG Chapter Developing Transports</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>MCSDK UG Chapter Developing Transports</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>MCSDK UG Chapter Developing Transports</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>MCSDK UG Chapter Developing Transports</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;oldid=211089">https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;oldid=211089</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="Category_Software_User_Guides.html" title="Category:Software User Guides">Software User Guides</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=MCSDK+UG+Chapter+Developing+Transports" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="MCSDK_UG_Chapter_Developing_Transports.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Talk:MCSDK_UG_Chapter_Developing_Transports&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="MCSDK_UG_Chapter_Developing_Transports.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/MCSDK_UG_Chapter_Developing_Transports.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/MCSDK_UG_Chapter_Developing_Transports.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;oldid=211089" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=MCSDK_UG_Chapter_Developing_Transports&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 21 December 2015, at 10:40.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.285","walltime":"0.291","ppvisitednodes":{"value":443,"limit":1000000},"ppgeneratednodes":{"value":600,"limit":1000000},"postexpandincludesize":{"value":1016,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":3,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    4.199      1 -total"," 47.10%    1.978     18 Template:Note"]},"cachereport":{"timestamp":"20201201072956","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":234});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/MCSDK_UG_Chapter_Developing_Transports by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 12:07:27 GMT -->
</html>
