<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/Template:RemoTI-1.4.0_ZRC_Dongle_Voice by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 03:19:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>Template:RemoTI-1.4.0 ZRC Dongle Voice - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"Template","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":10,"wgPageName":"Template:RemoTI-1.4.0_ZRC_Dongle_Voice","wgTitle":"RemoTI-1.4.0 ZRC Dongle Voice","wgCurRevisionId":208281,"wgRevisionId":208281,"wgArticleId":40113,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["RF4CE"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Template:RemoTI-1.4.0_ZRC_Dongle_Voice","wgRelevantArticleId":40113,"wgRequestId":"8efec3be3d08ea3d9d3facd5","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-10 ns-subject page-Template_RemoTI-1_4_0_ZRC_Dongle_Voice rootpage-Template_RemoTI-1_4_0_ZRC_Dongle_Voice skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">Template:RemoTI-1.4.0 ZRC Dongle Voice</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Detailed_guide_to_add_Voice_support_for_the_ZRC_Dongle_project"><span class="tocnumber">1</span> <span class="toctext">Detailed guide to add Voice support for the ZRC Dongle project</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Project_options_update"><span class="tocnumber">1.1</span> <span class="toctext">Project options update</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Source_files_update"><span class="tocnumber">1.2</span> <span class="toctext">Source files update</span></a>
<ul>
<li class="toclevel-3 tocsection-4"><a href="#Application"><span class="tocnumber">1.2.1</span> <span class="toctext">Application</span></a></li>
<li class="toclevel-3 tocsection-5"><a href="#Profile"><span class="tocnumber">1.2.2</span> <span class="toctext">Profile</span></a></li>
<li class="toclevel-3 tocsection-6"><a href="#Driver"><span class="tocnumber">1.2.3</span> <span class="toctext">Driver</span></a>
<ul>
<li class="toclevel-4 tocsection-7"><a href="#USB"><span class="tocnumber">1.2.3.1</span> <span class="toctext">USB</span></a></li>
<li class="toclevel-4 tocsection-8"><a href="#DMA"><span class="tocnumber">1.2.3.2</span> <span class="toctext">DMA</span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

<h2><span class="mw-headline" id="Detailed_guide_to_add_Voice_support_for_the_ZRC_Dongle_project">Detailed guide to add Voice support for the ZRC Dongle project</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=edit&amp;section=1" title="Edit section: Detailed guide to add Voice support for the ZRC Dongle project">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This section describes all steps required to add the Voice remote functionality to RemoTI-1.4.0. There are several aspects and gotchas to consider. Each code snippet that is added comes with a brief comment of why it is added.
</p>
<h3><span class="mw-headline" id="Project_options_update">Project options update</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=edit&amp;section=2" title="Edit section: Project options update">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ol>
 <li>Add <code>$PROJ_DIR$\..\..\..\..\COMPONENTS\audio\include</code> to the include paths</li>
 <li>Add to the pre-compiler options the following two defines</li>
 <table>
  <tbody><tr><td>
<pre>  <code>
  VOICE_STREAM
  HAL_USB_DMA=TRUE
  </code>
</pre>
  </td></tr>
 <tr><td><a href="File_IncludePath-Define-ForVoiceDongle.html" class="image"><img alt="IncludePath-Define-ForVoiceDongle.png" src="https://processors.wiki.ti.com/images/3/36/IncludePath-Define-ForVoiceDongle.png" width="550" height="513" /></a></td></tr>
 </tbody></table>
 <li>We need to link with the audio library, in addition to the network library. Instead of adding the path to the compile options, we add a folder in the project, and then place both libraries there.</li>
<pre><a href="File_AudioLibraryFolderInIARprojectTarget.html" class="image"><img alt="AudioLibraryFolderInIARprojectTarget.png" src="https://processors.wiki.ti.com/images/3/39/AudioLibraryFolderInIARprojectTarget.png" width="393" height="172" /></a>
</pre>
 <li>Uncheck the box which includes command line arguments for the linker. This is required since we add the library to the project in a new folder.</li>
<pre><a href="File_UncheckIncludeCommandLineArgumentsForLinkerTarget.html" class="image"><img alt="UncheckIncludeCommandLineArgumentsForLinkerTarget.png" src="https://processors.wiki.ti.com/images/9/93/UncheckIncludeCommandLineArgumentsForLinkerTarget.png" width="550" height="218" /></a>
</pre>
 <li>To improve throughput and processing time we need to use compiler optimization settings for speed</li>
<pre><a href="File_AudioIARprojectOptimizationForSpeed.html" class="image"><img alt="AudioIARprojectOptimizationForSpeed.png" src="https://processors.wiki.ti.com/images/4/46/AudioIARprojectOptimizationForSpeed.png" width="550" height="302" /></a>
</pre>
 <li>Add USB audio files <code>usb_aud.c/h</code></li>
<pre><a href="File_AddAudioUSBinIARproject.html" class="image"><img alt="AddAudioUSBinIARproject.png" src="https://processors.wiki.ti.com/images/9/9d/AddAudioUSBinIARproject.png" width="390" height="269" /></a>
</pre>
</ol>
<h3><span class="mw-headline" id="Source_files_update">Source files update</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=edit&amp;section=3" title="Edit section: Source files update">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span class="mw-headline" id="Application">Application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=edit&amp;section=4" title="Edit section: Application">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>In the main application code, <code>zrc_dongle.c</code>
</p>
<ol>
 <li>Include headers</li>
<pre><code>
#ifdef VOICE_STREAM
#include "usb_aud.h"
#include "ratl_lib.h"
#endif
</code>
</pre>
 <li>Add defines for audio buffer management, and audio decoding configuration structure</li>
<pre><code>
#ifdef VOICE_STREAM
#define USB_AUDIO_NB_FRAME_TO_BUF               3
#define USB_MAX_AUDIO_RX_QUEUE_SIZE            13
#define AUDIO_DEAD_LINK_TIMER                1000   //if no packet is received during this time, link is dead, so stop everything.
ratl_Config_t UsbDecodeconfig;
#endif
</code>
</pre>
 <li>Add function prototype to handle stop event. Also add a global counter, which is used to count audio frames to toggle LED in a pattern based on received data</li>
<pre><code>
#ifdef VOICE_STREAM
static void audio_EventStop( void );
uint8 kk;
#endif
</code>
</pre>
 <li>In the function <code>Dongle_Init()</code> add code to initialize and configure Audio Target library</li>
<pre><code>
#ifdef VOICE_STREAM
 // Want Audio buffer initialized as early as possible, so do it here
 extern void RATL_DecodeInit( void );
 extern CBAudioBuf_t pUsbAudioTxBuffer;
 RATL_DecodeInit();
 pUsbAudioTxBuffer.usbSamples = usbDataBuf;  
 pUsbAudioTxBuffer.size = MAX_USB_AUDIO_BUFFER_SIZE;
 
 
 UsbDecodeconfig.CircBuf            = &amp;pUsbAudioTxBuffer;
 UsbDecodeconfig.MaxNbByteToDecode  = USB_NB_BYTES_TO_DECODE;
 UsbDecodeconfig.MaxRxQueueSize     = USB_MAX_AUDIO_RX_QUEUE_SIZE;
 UsbDecodeconfig.BufferingSize      = USB_AUDIO_NB_FRAME_TO_BUF;
 
 RATL_decodeCfg( &amp;UsbDecodeconfig);
#endif
</code>
</pre>
 <li>Add processing of Audio events to <code>Dongle_ProcessEvent()</code></li>
<pre><code>
#ifdef VOICE_STREAM
  if (events &amp; ZRC_DONGLE_EVT_DEAD_LINK )
  {    
    audio_EventStop();
    return (events ^ ZRC_DONGLE_EVT_DEAD_LINK );
  }
  if ( events &amp; ZRC_DONGLE_EVT_AUD_DECODE )
  {
    if (RATL_DecodeAudioSamples()) 
    {
      return events;
    }
    else
    {
      return (events ^ ZRC_DONGLE_EVT_AUD_DECODE );
    }
  }
#endif
</code>
</pre>
 <li>Add received data processing in <code>RTI_ReceiveDataInd()</code>. This includes detecting whether or not we are already receiving audio data, and if not already receiving disable Frequency Agility.</li>
<pre><code>
#if defined VOICE_STREAM
 else if (len &gt; 0 &amp;&amp; profileId == RTI_PROFILE_ZRC &amp;&amp; (rxFlags &amp; RTI_RX_FLAGS_VENDOR_SPECIFIC) )
 {
   if (pData[0] == RTI_PROTOCOL_RAS)
   {
     uint8 res;
     halIntState_t intState;
     audioDataEvent_t audData;
     audData.len = len-1;
     audData.pData = (pData+1);
     HAL_ENTER_CRITICAL_SECTION(intState);
     uint8 temp = usbStatus;
     HAL_EXIT_CRITICAL_SECTION(intState);
     osal_start_timerEx(zrcDongleTaskId, ZRC_DONGLE_EVT_DEAD_LINK, AUDIO_DEAD_LINK_TIMER);       
     if ( RATL_COPY_ALLOWED == (res = RATL_ProcessDataPacket( &amp;audData, temp)))
     {
       streamStatus = STREAM_START_COPY;
     }
     else if (RATL_STOPPED == res)
     {
       //Stop Cmd Receive
        audio_EventStop();
     }
     else if (RATL_DECODING_ALLOWED == res)
     {
       //Start Decoding (needed for buffering...)
       osal_set_event(zrcDongleTaskId, ZRC_DONGLE_EVT_AUD_DECODE);
     }
     //Play LED:
     if (temp == USB_START)
     {
        if (kk++ == 50)
         HalLedSet(HAL_LED_1, HAL_LED_MODE_ON);
       if (kk &gt;= 100)
       {
         HalLedSet(HAL_LED_1, HAL_LED_MODE_OFF);
         HalLedSet(HAL_LED_2, HAL_LED_MODE_OFF);
         kk = 0;
       }
     }
     else
     {
       if (kk++ == 50)
         HalLedSet(HAL_LED_2, HAL_LED_MODE_ON);
       if (kk &gt;= 100)
       {
         HalLedSet(HAL_LED_1, HAL_LED_MODE_OFF);
         HalLedSet(HAL_LED_2, HAL_LED_MODE_OFF);
         kk = 0;
       }
     }                
   }
 }
#endif
</code>
</pre>
 <li>Implement function to handle stop stream event</li>
<pre><code>
#ifdef VOICE_STREAM
static void audio_EventStop( void )
{
  streamStatus = STREAM_STOP;
 
  RATL_audioStop();
 
  osal_clear_event(zrcDongleTaskId, ZRC_DONGLE_EVT_AUD_DECODE);
  osal_stop_timerEx(zrcDongleTaskId, ZRC_DONGLE_EVT_DEAD_LINK);
  osal_clear_event(zrcDongleTaskId, ZRC_DONGLE_EVT_DEAD_LINK);
}
#endif
</code>
</pre>
</ol>
<p>In <code>zrc_dongle.h</code>
</p>
<ol>
 <li>Add audio stream events to the list</li>
<pre><code>
#ifdef VOICE_STREAM
#define ZRC_DONGLE_EVT_AUD_DECODE         0x0010 // event to decode audio frame
#define ZRC_DONGLE_EVT_DEAD_LINK          0x0020 // timed event to detect dead link
#endif
</code>
</pre>
</ol>
<h4><span class="mw-headline" id="Profile">Profile</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=edit&amp;section=5" title="Edit section: Profile">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Audio data are sent as Texas Instruments vendor specific ZRC data. TI use the first byte of the payload to indicate the specific TI protocol. For Audio, add:
</p><p><code>
</code></p><code><pre>#define RTI_PROTOCOL_RAS            0x50
</pre></code><code></code><p><code></code>
</p>
<h4><span class="mw-headline" id="Driver">Driver</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=edit&amp;section=6" title="Edit section: Driver">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<h5><span class="mw-headline" id="USB">USB</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=edit&amp;section=7" title="Edit section: USB">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>In <code>zrc_usb.h</code>
</p>
<ol>
 <li>Add audio interface enumeration macros</li>
<pre><code>
#ifdef VOICE_STREAM
#define INTERFACE_NUMBER_AUDIO_CONTROL      0x02
#define INTERFACE_NUMBER_AUDIO_STREAM       0x03
#define INTERFACE_NUMBER_ZRC                0x04
#else
#define INTERFACE_NUMBER_ZRC                0x02
#endif
</code>
</pre>
 <li>Modify endpoint macros to better reflect endpoint direction. Also update code to use these new macros.</li>
<pre><code>
//#define ZRC_PROXY_RNP_EP_OUT_ADDR        0x03
//#define ZRC_PROXY_RNP_EP_IN_ADDR         ZRC_PROXY_RNP_EP_OUT_ADDR
//#define ZRC_PROXY_ZRC_EP_OUT_ADDR        0x04
//#define ZRC_PROXY_ZRC_EP_IN_ADDR         0x05

#define CE_ENPOINT_ADDR                 0x02  
#define RNP_ENPOINT_ADDR                0x03  
#define ZRC_ENPOINT_ADDR                0x04  
#define AUD_ENPOINT_ADDR                0x05  

#define IN_ENPOINT_ADDR                 0x80
#define OUT_ENPOINT_ADDR                0x00

#define CE_EP_IN_ADDR                   IN_ENPOINT_ADDR  | CE_ENPOINT_ADDR 
#define CE_EP_OUT_ADDR                  OUT_ENPOINT_ADDR | CE_ENPOINT_ADDR
#define RNP_EP_IN_ADDR                  IN_ENPOINT_ADDR  | RNP_ENPOINT_ADDR
#define RNP_EP_OUT_ADDR                 OUT_ENPOINT_ADDR | RNP_ENPOINT_ADDR
#define ZRC_EP_IN_ADDR                  IN_ENPOINT_ADDR  | ZRC_ENPOINT_ADDR
#define ZRC_EP_OUT_ADDR                 OUT_ENPOINT_ADDR | ZRC_ENPOINT_ADDR
#define AUDIO_EP_IN_ADDR                IN_ENPOINT_ADDR  | AUD_ENPOINT_ADDR
#define AUDIO_EP_OUT_ADDR               OUT_ENPOINT_ADDR | AUD_ENPOINT_ADDR
#define RNP_EP_OUT_PACKET_LEN           ZRC_DONGLE_OUTBUF_SIZE
</code>
</pre>
</ol>
<p>In <code>zrc_usb.c</code>
</p>
<ol>
 <li>Update macros to account for the extended USB descriptor, now that audio is added</li>
<pre><code>
#ifdef VOICE_STREAM
#define ZRC_USB_NUM_INTERFACES                5
#else
#define ZRC_USB_NUM_INTERFACES                3
#endif
...
#ifdef VOICE_STREAM
#define DBLBUF_LUT_INFO_SIZE                 (sizeof(DBLBUF_LUT_INFO) * 6)
#else //VOICE_STREAM
#define DBLBUF_LUT_INFO_SIZE                 (sizeof(DBLBUF_LUT_INFO) * 3)
#endif //VOICE_STREAM
</code>
</pre>
 <li>Add audio descriptors</li>
<pre><code>
#ifdef VOICE_STREAM
// Interface Descriptor for audio control 
const uint8 usb_iface_desc_audio_control[] = {
  DESC_SIZE_INTERFACE,            // bLength
  DESC_TYPE_INTERFACE,            // bDescriptorType
  INTERFACE_NUMBER_AUDIO_CONTROL, // bInterfaceNumber
  0x00,                           // bAlternateSetting (none)
  0x00,                           // bNumEndpoints (none)
  0x01,                           // bInterfaceClass (AUDIO)
  0x01,                           // bInterfaceSubClass (AUDIO CONTROL)
  0x00,                           // bInterfaceProcotol (N/A)
  0x00                            // iInterface
};

//Audio Descriptor: HEADER
const uint8 usb_audio_desc_header[] = {
  DESC_SIZE_AUDIO_HEADER,         // bLength
  DESC_TYPE_CS_INTERFACE,         // bDescriptorType
  DESC_AUDIO_TYPE_HEADER,         // bDescriptorSubType
  0x01, 0x00,                     // bcdADC (1.0)
                                  // wTotalLength   //SIZE EQUAL TO SUM OF DESCRIPTOR of the audio control descriptor, including tis header: 
                                  //  == size of (usb_audio_desc_input_term) + 
                                  //  == size of (usb_audio_desc_feat_unit)  +
  0x27, 0x00,                     //  == size of (usb_audio_desc_out_term) 
  0x01,                           // bInCollection (1 stream interface)
  0x03,                           // bInterfaceNr (interface 4 is stream)
};

//Audio Descriptor: INPUT TERMINAL
const uint8 usb_audio_desc_input_term[] = {
  DESC_SIZE_AUDIO_INPUT_TERM,     // bLength
  DESC_TYPE_CS_INTERFACE,         // bDescriptorType
  DESC_AUDIO_TYPE_INPUT_TERM,     // bDescriptorSubType
  0x01,                           // bTerminalID
  0x01, 0x02,                     // wTerminalType
  0x00,                           // bAssocTerminal (none)
  0x01,                           // bNrChannel
  0x00, 0x00,                     // wChannelConfig //No predifined spatial position
  0x00,                           //iChannelNames
  0x00,                           //iTerminal (none)
};

//Audio Descriptor: FEATURE UNIT
const uint8 usb_audio_desc_feat_unit[] = {
  DESC_SIZE_AUDIO_FEAT_UNIT,  // bLength (9)
  DESC_TYPE_CS_INTERFACE,     // bDescriptorType (CS_INTERFACE)
  DESC_AUDIO_TYPE_FEAT_UNIT,  // bDescriptorSubtype (FEATURE_UNIT)
  0x02,                       // bUnitID (2)
  0x01,                       // bSourceID (input terminal 1)
  0x01,                       // bControlSize (2 bytes)
  0x03, 0x00,                 // Master controls (volume and mute supported)
  0x00                        // iFeature (none)
};

//Audio Descriptor: OUTPUT TERMINAL
const uint8 usb_audio_desc_out_term[] = {
  DESC_SIZE_AUDIO_OUTPUT_TERM,    // bLength
  DESC_TYPE_CS_INTERFACE,         // bDescriptorType
  DESC_AUDIO_TYPE_OUTPUT_TERM,    // bDescriptorSubType
  0x03,                           // bTerminalID
  0x01, 0x01,                     // wTerminalType
  0x00,                           // bAssocTerminal (none)
  0x02,                           // bSourceID (feature unit 2)
  0x00                            // iTerminal (none)
};

// Interface Descriptor for audio stream 
const uint8 usb_iface_desc_audio_stream0[] = {
  DESC_SIZE_INTERFACE,            // bLength
  DESC_TYPE_INTERFACE,            // bDescriptorType
  INTERFACE_NUMBER_AUDIO_STREAM , // bInterfaceNumber
  0x00,                           // bAlternateSetting (0)
  0x00,                           // bNumEndpoints (none)
  0x01,                           // bInterfaceClass (AUDIO)
  0x02,                           // bInterfaceSubClass (AUDIO STREAM)
  0x00,                           // bInterfaceProcotol (N/A)
  0x00                            // iInterface
};

// Interface Descriptor for audio stream, ALTERNATE SETTING 
const uint8 usb_iface_desc_audio_stream1[] = {
  DESC_SIZE_INTERFACE,            // bLength
  DESC_TYPE_INTERFACE,            // bDescriptorType
  INTERFACE_NUMBER_AUDIO_STREAM , // bInterfaceNumber
  0x01,                           // bAlternateSetting (1)
  0x01,                           // bNumEndpoints (1)
  0x01,                           // bInterfaceClass (AUDIO)
  0x02,                           // bInterfaceSubClass (AUDIO STREAM)
  0x00,                           // bInterfaceProcotol (N/A)
  0x00                            // iInterface
};

//Audio Descriptor: aduio Stream, general
const uint8 usb_audio_desc_AS_general[] = {
  DESC_SIZE_AUDIO_STREAM,         // bLength
  DESC_TYPE_CS_INTERFACE,         // bDescriptorType
  DESC_AUDIO_TYPE_GENERAL,        // bDescriptorSubType
  0x03,                           // bTerminalLink (terminal 3)
  0x00,                           // bDelay (none)
  0x01, 0x00                      // wFormatTag (PCM format)
};

//Audio Descriptor: FORMAT TYPE
const uint8 usb_audio_desc_AS_format_type[] = {
  DESC_SIZE_AUDIO_FORMAT_TYPEI,       // bLength
  DESC_TYPE_CS_INTERFACE,             // bDescriptorType
  DESC_AUDIO_TYPE_FORMAT_TYPE,        // bDescriptorSubType
  0x01,                               // bFormatType (TYPE_I)
  0x01,                               // bNrChannels (1)
  0x02,                               // bSubFrameSize (2)
  0x10,                               // bBitResolution (16)
  0x01,                               // bSamFreqType (1 sampling frequency)
  0x80,                               // 16,000 Hz (byte 0)
  0x3E,                               // 16,000 Hz (byte 1)
  0x00                                // 16,000 Hz (byte 2)
};

//Audio Descriptor: Audio Stream endpoint
const uint8 usb_audio_desc_AS_endpoint[] = {
  DESC_SIZE_AUDIO_ENDPOINT,       // bLength
  DESC_TYPE_ENDPOINT,             // bDescriptorType
  AUDIO_EP_IN_ADDR,               // bEndpointAddress (EP1 in)
  0x05,                           // bmAttributes (isochronous + asynchronous)
  0x20, 0x00,                     // wMaxPacketSize (256)
  0x01,                           // bInterval (1 millisecond)
  0x00,                           // bRefresh (0)
  0x00                            // bSynchAddress (no synchronization) 
};

//Audio Descriptor: Isochronous endpoint
const uint8 usb_audio_desc_AS_isoendpoint[] = {
  DESC_SIZE_AUDIO_ISO_ENDPOINT,   // bLength
  DESC_TYPE_CS_ENDPOINT,          // bDescriptorType
  DESC_AUDIO_TYPE_EP_GENERAL,     // bDescriptorSubType
  0x00,                           // bmAttributes (none)
  0x02,                           // bLockDelayUnits (PCM samples)
  0x00, 0x00                      // wLockDelay (0)
 };
#endif 
</code>
</pre>
 <li>Update Product String</li>
<pre><code>
const uint8 string2Product[] = {
#ifdef VOICE_STREAM
  38,                          // bLength
#else
  30,						   // bLength
#endif
  DESC_TYPE_STRING,            // bDescriptorType
  'U', 0,                      // unicode string
...
  'C', 0,
#ifdef VOICE_STREAM
  ' ', 0,
  'A', 0,
  'U', 0,
  'D', 0
#endif
};
</code>
</pre>
 <li>Update all macros to define endpoint enumeration, and also update descriptors to use it</li>
 <table>
  <tbody><tr>
   <td>
<pre>   <code>ZRC_PROXY_RNP_EP_OUT_ADDR</code>
</pre>
   </td>
   <td>--&gt;</td>
   <td>
<pre>   <code>RNP_EP_OUT_ADDR</code>
</pre>
   </td>
  </tr>
  <tr>
   <td>
<pre>   <code>ZRC_PROXY_RNP_EP_IN_ADDR</code>
</pre>
   </td>
   <td>--&gt;</td>
   <td>
<pre>   <code>RNP_EP_IN_ADDR</code>
</pre>
   </td>
  </tr>
  <tr>
   <td>
<pre>   <code>ZRC_PROXY_ZRC_EP_OUT_ADDR</code>
</pre>
   </td>
   <td>--&gt;</td>
   <td>
<pre>   <code>ZRC_EP_OUT_ADDR</code>
</pre>
   </td>
  </tr>
  <tr>
   <td>
<pre>   <code>ZRC_PROXY_ZRC_EP_IN_ADDR</code>
</pre>
   </td>
   <td>--&gt;</td>
   <td>
<pre>   <code>ZRC_EP_IN_ADDR</code>
</pre>
   </td>
  </tr>
 </tbody></table>
<pre><code>
-  0x85,                        // bEndpointAddress
+  ZRC_EP_IN_ADDR,              // bEndpointAddress
...
-  0x04,                        // bEndpointAddress
+  ZRC_EP_OUT_ADDR,             // bEndpointAddress
...
-  0x83,                        // bEndpointAddress
+  RNP_EP_IN_ADDR,              // bEndpointAddress
...
-  0x82,                        // bEndpointAddress
+  CE_EP_IN_ADDR,               // bEndpointAddress
</code>
</pre>
 <li>Add USB audio descriptor components offset defines</li>
<pre><code>
#ifdef VOICE_STREAM
#define ZRC_AUD_CTRL_IFACE_DESC       (ZRC_CE_IN_EP_DESC                  +  DESC_SIZE_ENDPOINT)
#define ZRC_AUD_CTRL_HDR_DESC         (ZRC_AUD_CTRL_IFACE_DESC          +  DESC_SIZE_INTERFACE)
#define ZRC_AUD_CTRL_IN_TERM_DESC     (ZRC_AUD_CTRL_HDR_DESC            +  DESC_SIZE_AUDIO_HEADER)
#define ZRC_AUD_CTRL_FEAT_DESC        (ZRC_AUD_CTRL_IN_TERM_DESC        +  DESC_SIZE_AUDIO_INPUT_TERM)
#define ZRC_AUD_CTRL_OUT_TERM_DESC    (ZRC_AUD_CTRL_FEAT_DESC           +  DESC_SIZE_AUDIO_FEAT_UNIT)
//#define ZRC_AUD_CTRL_OUT_TERM_DESC    (ZRC_AUD_CTRL_IN_TERM_DESC           +  DESC_SIZE_AUDIO_INPUT_TERM)
#define ZRC_AUD_STREAM_IFACE0_DESC    (ZRC_AUD_CTRL_OUT_TERM_DESC       +  DESC_SIZE_AUDIO_OUTPUT_TERM)
#define ZRC_AUD_STREAM_IFACE1_DESC    (ZRC_AUD_STREAM_IFACE0_DESC       +  DESC_SIZE_INTERFACE)
#define ZRC_AUD_STREAM_GENERAL_DESC   (ZRC_AUD_STREAM_IFACE1_DESC       +  DESC_SIZE_INTERFACE)
#define ZRC_AUD_STREAM_FORMAT_DESC    (ZRC_AUD_STREAM_GENERAL_DESC      +  DESC_SIZE_AUDIO_STREAM)
#define ZRC_AUD_STREAM_EP_DESC        (ZRC_AUD_STREAM_FORMAT_DESC       +  DESC_SIZE_AUDIO_FORMAT_TYPEI)
#define ZRC_AUD_STREAM_ISO_EP_DESC    (ZRC_AUD_STREAM_EP_DESC           +  DESC_SIZE_AUDIO_ENDPOINT)
#define ZRC_IFACE_DESC                (ZRC_AUD_STREAM_ISO_EP_DESC       +  DESC_SIZE_AUDIO_ISO_ENDPOINT)
#else //VOICE STREAM
#define ZRC_IFACE_DESC                (ZRC_CE_IN_EP_DESC       +  DESC_SIZE_AUDIO_ISO_ENDPOINT)
#endif //VOICE STREAM
</code>
</pre>
 <li>Add to total length calculation</li>
<pre><code>
#ifdef VOICE_STREAM  
  // Add Audio class descriptor to the total length.
  wTotalLength += DESC_SIZE_INTERFACE; // Audio Control interface
  wTotalLength += DESC_SIZE_AUDIO_HEADER; // Audio Control Header descriptor
  wTotalLength += DESC_SIZE_AUDIO_INPUT_TERM; // Audio Control input terminal descriptor
  wTotalLength += DESC_SIZE_AUDIO_FEAT_UNIT; // Audio Control feature unit descriptor
  wTotalLength += DESC_SIZE_AUDIO_OUTPUT_TERM; // Audio Control output terminal descriptor
  wTotalLength += DESC_SIZE_INTERFACE; // Audio Stream interface, alternate 0
  wTotalLength += DESC_SIZE_INTERFACE; // Audio Stream interface, alternate 1
  wTotalLength += DESC_SIZE_AUDIO_STREAM; // Audio Stream, general descriptor
  wTotalLength += DESC_SIZE_AUDIO_FORMAT_TYPEI; // Audio Stream, format type  descriptor
  wTotalLength += DESC_SIZE_AUDIO_ENDPOINT; // Audio Stream, endpoint  descriptor
  wTotalLength += DESC_SIZE_AUDIO_ISO_ENDPOINT; // Audio Stream, isochronous endpoint  descriptor
#endif  
</code>
</pre>
 <li>Add interfaces to the dynamically built descriptor</li>
<pre><code>
#ifdef VOICE_STREAM  
//Add  Voice descriptor and interface
   ptr = osal_memcpy(ptr, usb_iface_desc_audio_control,    sizeof(usb_iface_desc_audio_control));
   ptr = osal_memcpy(ptr, usb_audio_desc_header,           sizeof(usb_audio_desc_header));
   ptr = osal_memcpy(ptr, usb_audio_desc_input_term,       sizeof(usb_audio_desc_input_term));
   ptr = osal_memcpy(ptr, usb_audio_desc_feat_unit,        sizeof(usb_audio_desc_feat_unit));
   ptr = osal_memcpy(ptr, usb_audio_desc_out_term,         sizeof(usb_audio_desc_out_term));
   ptr = osal_memcpy(ptr, usb_iface_desc_audio_stream0,    sizeof(usb_iface_desc_audio_stream0));
   ptr = osal_memcpy(ptr, usb_iface_desc_audio_stream1,    sizeof(usb_iface_desc_audio_stream1));
   ptr = osal_memcpy(ptr, usb_audio_desc_AS_general,       sizeof(usb_audio_desc_AS_general));
   ptr = osal_memcpy(ptr, usb_audio_desc_AS_format_type,   sizeof(usb_audio_desc_AS_format_type));
   ptr = osal_memcpy(ptr, usb_audio_desc_AS_endpoint,      sizeof(usb_audio_desc_AS_endpoint));
   ptr = osal_memcpy(ptr, usb_audio_desc_AS_isoendpoint,   sizeof(usb_audio_desc_AS_isoendpoint));
#endif
</code>
</pre>
 <li>There are two additional USB interfaces if <code>VOICE_STREAM</code> is defined</li>
<pre><code>
#ifdef VOICE_STREAM  
   *ptr = 4; // bNumInterfaces
#else
   *ptr = 2; // bNumInterfaces
#endif
</code>
</pre>
 <li>Add endpoint configuration for audio interfaces</li>
<pre><code>
#ifdef VOICE_STREAM
  usbDescriptorMarker.pUsbDblbufLut[2].pInterface = (USB_INTERFACE_DESCRIPTOR *)ZRC_AUD_CTRL_IFACE_DESC;
  usbDescriptorMarker.pUsbDblbufLut[2].inMask = 0;
  usbDescriptorMarker.pUsbDblbufLut[2].outMask = 0;

  usbDescriptorMarker.pUsbDblbufLut[3].pInterface = (USB_INTERFACE_DESCRIPTOR *)ZRC_AUD_STREAM_IFACE0_DESC;
  usbDescriptorMarker.pUsbDblbufLut[3].inMask = 0;
  usbDescriptorMarker.pUsbDblbufLut[3].outMask = 0;

  usbDescriptorMarker.pUsbDblbufLut[4].pInterface = (USB_INTERFACE_DESCRIPTOR *)ZRC_AUD_STREAM_IFACE1_DESC;
  usbDescriptorMarker.pUsbDblbufLut[4].inMask = (1&lt;&lt;AUD_ENPOINT_ADDR ); //0x02; // Set EP1 to double buffering on IN
  usbDescriptorMarker.pUsbDblbufLut[4].outMask = 0;

  usbDescriptorMarker.pUsbDblbufLut[5].pInterface = (USB_INTERFACE_DESCRIPTOR *)ZRC_IFACE_DESC;
  usbDescriptorMarker.pUsbDblbufLut[5].inMask =  0; 
  usbDescriptorMarker.pUsbDblbufLut[5].outMask = 0;
#else
  usbDescriptorMarker.pUsbDblbufLut[2].pInterface = (USB_INTERFACE_DESCRIPTOR *)ZRC_IFACE_DESC;
  usbDescriptorMarker.pUsbDblbufLut[2].inMask =  0; 
  usbDescriptorMarker.pUsbDblbufLut[2].outMask = 0;
#endif
</code>
</pre>
</ol>
<p>In <code>usb_zrc.h</code>
</p>
<ol>
 <li>Add audio events</li>
<pre><code>
#ifdef VOICE_STREAM
#define AUDIOD_CMD_START        0x04
#define AUDIOD_CMD_STOP         0x08
#define AUDIOD_STREAM_STARTED   0x10
#define AUDIOD_STREAM_REQUESTED 0x20
#endif
</code>
</pre>
</ol>
<p>In the <code>usb_zrc_class_request.c</code>
</p>
<ol>
 <li>Add USB audio class request handles</li>
<pre><code>
#if defined VOICE_STREAM
uint8 audioCVolumeMin[2]={0x00,0x80};
uint8 audioCVolumeMax[2]={0x00,0x06};
uint8 audioCVolumeRes[2]={0x00,0x01};
uint8 audioCVolumeCur[2]={0x00,0x00};

uint8 audioMuteValue = 0;

void usbcrGetMin(void) 
{
  if (usbfwData.ep0Status == EP_IDLE) 
  {
    // Is the length stall correct?
    if ( (usbSetupHeader.length == 0) || (HI_UINT16(usbSetupHeader.index) &gt; 2)) 
    {
      usbfwData.ep0Status = EP_STALL;
    } 
    else 
    {
      switch (HI_UINT16(usbSetupHeader.value)) 
      {
        
      case 2: //Volume
        usbSetupData.pBuffer = (uint8 *)&amp;audioCVolumeMin;
        usbSetupData.bytesLeft = 2;
        usbfwData.ep0Status = EP_TX;
        break;
      default:
        usbfwData.ep0Status = EP_STALL;
        break;
      }
    }
  }
}// usbcrGetReport

void usbcrGetMax(void) 
{
  if (usbfwData.ep0Status == EP_IDLE) 
  {
    // Is the length stall correct?
    if ( (usbSetupHeader.length == 0) || (HI_UINT16(usbSetupHeader.index) &gt; 2)) 
    {
      usbfwData.ep0Status = EP_STALL;
    } 
    else 
    {
      switch (HI_UINT16(usbSetupHeader.value)) 
      {  
      case 2: //Volume
        usbSetupData.pBuffer = (uint8 *)&amp;audioCVolumeMax;
        usbSetupData.bytesLeft = 2;
        usbfwData.ep0Status = EP_TX;
        break;
      default:
        usbfwData.ep0Status = EP_STALL;
        break;  
      }
    }
  }
}// usbcrGetReport

void usbcrGetRes(void) 
{
  if (usbfwData.ep0Status == EP_IDLE) 
  {
    // Is the length stall correct?
    if ( (usbSetupHeader.length == 0) || (HI_UINT16(usbSetupHeader.index) &gt; 2)) 
    {
      usbfwData.ep0Status = EP_STALL;
    } else 
    {
      switch (HI_UINT16(usbSetupHeader.value)) 
      {
      case 2:
        usbSetupData.pBuffer = (uint8 *)&amp;audioCVolumeRes;
        usbSetupData.bytesLeft = 2;
        usbfwData.ep0Status = EP_TX;
        break;
      default:
        usbfwData.ep0Status = EP_STALL;
        break;  
      }
    }
  }
}// usbcrGetReport


void usbcrGetCur(void) 
{
  if (usbfwData.ep0Status == EP_IDLE) 
  {
    // Is the length stall correct?
    if ( (usbSetupHeader.length == 0) || (HI_UINT16(usbSetupHeader.index) &gt; 2)) 
    {
      usbfwData.ep0Status = EP_STALL;
    } 
    else 
    {
      switch (HI_UINT16(usbSetupHeader.value)) 
      {  
      case 1:
        usbSetupData.pBuffer = (uint8 *)&amp;audioMuteValue;
        usbSetupData.bytesLeft = 1;
        usbfwData.ep0Status = EP_TX;
        break;
      case 2:
        usbSetupData.pBuffer = (uint8 *)&amp;audioCVolumeCur;
        usbSetupData.bytesLeft = 2;
        usbfwData.ep0Status = EP_TX;
        break;
      default:
        usbfwData.ep0Status = EP_STALL;
        break;  
      }
    }
  }
}// usbcrGetReport

uint8 *pVolumeCur;
uint8 *pMuteCur;

void usbcrSetCur(void) 
{
  // Received header
  if (usbfwData.ep0Status == EP_IDLE) 
  {
    // Is the length stall correct?
    if ( (usbSetupHeader.length == 0) || (HI_UINT16(usbSetupHeader.index) &gt; 2)) 
    {
      usbfwData.ep0Status = EP_STALL;
    } 
    else 
    {
      switch (HI_UINT16(usbSetupHeader.value)) 
      {  
      case 1: //Mute
        pMuteCur = (uint8 *)osal_mem_alloc(usbSetupHeader.length);
        
        usbfwData.ep0Status = EP_RX;
        
        usbSetupData.bytesLeft = usbSetupHeader.length;
        usbSetupData.pBuffer = pMuteCur;
        break;
      case 2: //Volume
        pVolumeCur = (uint8 *)osal_mem_alloc(usbSetupHeader.length);
        
        usbfwData.ep0Status = EP_RX;
        
        usbSetupData.bytesLeft = usbSetupHeader.length;
        usbSetupData.pBuffer = pVolumeCur;
        break;
      default:
        usbfwData.ep0Status = EP_STALL;
        break;  
      }
    }
  }
  else if (usbfwData.ep0Status == EP_RX) 
  {
    switch (HI_UINT16(usbSetupHeader.value)) 
    {
    case 1: //Mute
      // Send OUT report up to Application
      //zrcPxyServeHIDClassRequests(usbSetupHeader.request, zrcClassRequestDataOut);
      audioMuteValue = *pMuteCur;
      osal_mem_free(pMuteCur);
      break;
    case 2: //Volume
      // Send OUT report up to Application
      //zrcPxyServeHIDClassRequests(usbSetupHeader.request, zrcClassRequestDataOut);
      audioCVolumeCur[0] = pVolumeCur[0];
      audioCVolumeCur[1] = pVolumeCur[1];
      osal_mem_free(pVolumeCur);
      break;
    default:
      break;
    }
  }
}// usbcrSetReport

uint8 *pVolumeRes;
void usbcrSetRes(void)
{
  // Received header
  if (usbfwData.ep0Status == EP_IDLE) 
  {
    // Is the length stall correct?
    if ( (usbSetupHeader.length == 0) || (HI_UINT16(usbSetupHeader.index) &gt; 2)) 
    {
      usbfwData.ep0Status = EP_STALL;
    } 
    else 
    {
      switch (HI_UINT16(usbSetupHeader.value)) 
      {  
        //              case 2: //Volume
        //#ifdef IO_BENCHMARK
        //              HAL_BM_TURN_ON_IO1 (); //RF4CE task on
        //#endif  
        //                pVolumeRes = (uint8 *)osal_mem_alloc(usbSetupHeader.length);
        //                
        //                usbfwData.ep0Status = EP_RX;
        //
        //                usbSetupData.bytesLeft = usbSetupHeader.length;
        //                usbSetupData.pBuffer = pVolumeRes;
        //                break;
      default:
        usbfwData.ep0Status = EP_STALL;
        break;  
      }
    }
  }
  else if (usbfwData.ep0Status == EP_RX) 
  {
    // Send OUT report up to Application
    //zrcPxyServeHIDClassRequests(usbSetupHeader.request, zrcClassRequestDataOut);
    audioCVolumeRes[0] = pVolumeRes[0];
    audioCVolumeRes[1] = pVolumeRes[1];
    osal_mem_free(pVolumeRes);
  }
}

void usbcrSetMin(void) 
{
  if (usbfwData.ep0Status == EP_IDLE) 
  {
    if ( (usbSetupHeader.value &amp; 0xFFFE) || 
        (usbSetupHeader.length&#160;!= 0) || 
          (usbSetupHeader.index &gt; INTERFACE_NUMBER_AUDIO_STREAM)) 
    {
      usbfwData.ep0Status = EP_STALL;
    } 
    else 
    {
    }
  }
}// usbcrSetProtocol
#endif
</code>
</pre>
</ol>
<p>In <code>usb_zrc_class_requests.h</code>
</p>
<ol>
 <li>Add audio class requests macros</li>
<pre><code>
#ifdef VOICE_STREAM
// Audio Request Codes
#define GET_CUR  0x81                  // Code for Get Current Value
#define GET_MIN  0x82
#define GET_MAX  0x83
#define GET_RES  0x84
#define SET_CUR  0x01                  // Code for Get Current Value
#define SET_MIN  0x02
#define SET_MAX  0x03
#define SET_RES  0x04
#endif
</code>
</pre>
 <li>And add audio class requests function prototypes</li>
<pre><code>
#ifdef VOICE_STREAM
void usbcrSetCur(void);
void usbcrSetRes(void);
void usbcrGetCur(void);
void usbcrGetMin(void);
void usbcrGetMax(void);
void usbcrGetRes(void);
#endif
</code>
</pre>
</ol>
<p>In the <code>usb_zrc_hooks.c</code>
</p>
<ol>
 <li>Add include files</li>
<pre><code>
#ifdef VOICE_STREAM
#include "usb_zrc.h"
#include "zrc_common.h"
#include "zrc_usb.h"
#endif
</code>
</pre>
 <li>In <code>usbcrHookProcessOut()</code></li>
<pre><code>
#ifdef VOICE_STREAM    
     case SET_CUR:
       usbcrSetCur(); 
       break;
     case SET_RES:
       usbcrSetRes(); 
       break;
#endif  //VOICE_STREAM   
</code>
</pre>
 <li>In <code>usbcrHookProcessIn()</code></li>
<pre><code>
#ifdef VOICE_STREAM    
     case GET_CUR:
       usbcrGetCur(); break;
     case GET_MIN:
       usbcrGetMin(); break;
     case GET_MAX:
       usbcrGetMax(); break;
     case GET_RES:
       usbcrGetRes(); break;
#endif   //VOICE_STREAM 
</code>
</pre>
 <li>Define start and stop streaming functions as extern hooks. These are defined in <code>usb_aud.c</code></li>
<pre><code>
#ifdef VOICE_STREAM
//extern void InitBuffer(void);
extern void StartAudioStreamingCommand(void);
extern void StopAudioStreamingCommand(void);
#endif

// ************************ USB standard request event processing *************************
void usbsrHookProcessEvent(uint8 event, uint8 index)
{
...
   // Process relevant events, one at a time.
   switch (event) {
 ...
#ifdef VOICE_STREAM
     // interface 3 and alternate Setting 1 ==&gt; start audio
     if ( (index == INTERFACE_NUMBER_AUDIO_STREAM) &amp;&amp; (usbfwData.pAlternateSetting[usbSetupHeader.index] == 1) )
     {
       StartAudioStreamingCommand();
     }
     else if ( (index == INTERFACE_NUMBER_AUDIO_STREAM) &amp;&amp; (usbfwData.pAlternateSetting[usbSetupHeader.index] == 0) )
     {
       StopAudioStreamingCommand();
     }
#endif
</code>
</pre>
</ol>
<p>In <code>usb_descriptor.h</code>
</p>
<ol>
 <li>Add audio descriptor macros</li>
<pre><code>
#define DESC_TYPE_CS_INTERFACE    0x24
#define DESC_TYPE_CS_ENDPOINT     0x25
#define DESC_AUDIO_TYPE_HEADER        0x01
#define DESC_AUDIO_TYPE_INPUT_TERM    0x02
#define DESC_AUDIO_TYPE_OUTPUT_TERM   0x03
#define DESC_AUDIO_TYPE_FEAT_UNIT     0x06

//Audio Stream
#define DESC_AUDIO_TYPE_GENERAL       0x01
#define DESC_AUDIO_TYPE_FORMAT_TYPE   0x02

#define DESC_AUDIO_TYPE_EP_GENERAL    0x01
   
#define DESC_SIZE_DEVICE              0x12
#define DESC_SIZE_CONFIG              0x09
#define DESC_SIZE_INTERFACE           0x09
#define DESC_SIZE_ENDPOINT            0x07
#define DESC_SIZE_AUDIO_HEADER        0x09
#define DESC_SIZE_AUDIO_INPUT_TERM    0x0C
#define DESC_SIZE_AUDIO_OUTPUT_TERM   0x09
#define DESC_SIZE_AUDIO_FEAT_UNIT     0x09
#define DESC_SIZE_AUDIO_STREAM        0x07
#define DESC_SIZE_AUDIO_FORMAT_TYPEI  0x0B //for one discrete Fs
#define DESC_SIZE_AUDIO_ENDPOINT      0x09
#define DESC_SIZE_AUDIO_ISO_ENDPOINT  0x07
</code>
</pre>
</ol>
<p>In <code>usb_interrupt.c</code>
</p>
<ol>
 <li>Add files to include</li>
<pre><code>
#ifdef VOICE_STREAM
#include "usb_aud.h"
#endif
</code>
</pre>
 <li>Add hooks for isochronous interrupt service routines, implemented in <code>usb_aud.c</code></li>
<pre><code>
#ifdef VOICE_STREAM
extern void usbIsoInIsr(void);
extern void usbSofIsr(void);
#endif
</code>
</pre>
 <li>In <code>usbirqHandler()</code> add
 <code>
 #ifdef VOICE_STREAM
    uint8 usbiif;
 #endif   
 ... 
 #ifdef VOICE_STREAM
    usbiif = USBIIF;
 #endif
 ...
 #ifdef VOICE_STREAM
    if (usbcif &amp; USBCIF_SOFIF)
    {
      usbSofIsr();
    }
    if ( (usbiif &amp; (1&lt;&lt;AUDIO_ENPOINT_ADDR) /*USBIIF_INEP1IF*/)  ) //|| (usbcif &amp; USBCIF_SOFIF)
    {
      // Handle Audio stream
      usbIsoInIsr();
      if (usbiif &amp; (1&lt;&lt;AUDIO_ENPOINT_ADDR))
      {
        usbiif &amp;= ~((1&lt;&lt;AUDIO_ENPOINT_ADDR));
      }
    }
 #endif
    
    eventMask  = usbcif;
 #ifdef VOICE_STREAM
    eventMask |= (uint16)usbiif &lt;&lt; 4;
 #else
    eventMask |= (uint16)USBIIF &lt;&lt; 4;
 #endif
 </code>
</li></ol>
<h5><span class="mw-headline" id="DMA">DMA</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=edit&amp;section=8" title="Edit section: DMA">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>In the DMA driver file <code>hal_dma.c</code>, add hooks for the audio library.
</p>
<ol>
 <li>Include header</li>
<pre><code>
#if (defined HAL_USB_DMA) &amp;&amp; (HAL_USB_DMA == TRUE)
#include "usb_aud.h"
#endif
</code>
</pre>
 <li>Add <code>HAL_USB_DMA</code> to precompiler clause to enable DMA interrupt, and to implement interrupt handler</li>
<pre><code>
void HalDmaInit( void )
{
</code></pre><code>
<p>...
</p>
<pre>#if (HAL_UART_DMA || \
  ((defined HAL_SPI) &amp;&amp; (HAL_SPI == TRUE))  || \
  ((defined HAL_USB_DMA) &amp;&amp; (HAL_USB_DMA == TRUE)) || \
  ((defined HAL_IRGEN) &amp;&amp; (HAL_IRGEN == TRUE)))
 DMAIE = 1;
#endif
}
</pre>
</code><pre><code>#if (HAL_UART_DMA || \
   ((defined HAL_SPI) &amp;&amp; (HAL_SPI == TRUE))  || \
  ((defined HAL_USB_DMA) &amp;&amp; (HAL_USB_DMA == TRUE)) || \
   ((defined HAL_IRGEN) &amp;&amp; (HAL_IRGEN == TRUE)))
/******************************************************************************
 * @fn      HalDMAInit
</code>
</pre>
 <li>Add call to usb audio driver <code>usb_aud.c</code> DMA interrupt handler</li>
<pre><code>
#if (defined HAL_USB_DMA) &amp;&amp; (HAL_USB_DMA == TRUE)
  if ( HAL_DMA_CHECK_IRQ( HAL_DMA_CH_RX ) )
  {
    usbDmaIsr();
    HAL_DMA_CLEAR_IRQ( HAL_DMA_CH_RX );
  }
#endif
</code>
</pre>
 <li>Add macro to check if DMA has started in <code>hal_dma.h</code></li>
<pre><code>
#define HAL_DMA_CHECK_STARTED( ch )   (DMAREQ &amp; ( 1 &lt;&lt; (ch) ))
</code>
</pre>
</ol>

<!-- 
NewPP limit report
Cached time: 20201130082348
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.073 seconds
Real time usage: 0.077 seconds
Preprocessor visited node count: 30/1000000
Preprocessor generated node count: 36/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:40113-0!canonical and timestamp 20201130082348 and revision id 208281
 -->
</div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;oldid=208281">https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;oldid=208281</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="Category_RF4CE.html" title="Category:RF4CE">RF4CE</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=Template%3ARemoTI-1.4.0+ZRC+Dongle+Voice" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-template" class="selected"><span><a href="Template_RemoTI-1.4-2.html" title="View the template [c]" accesskey="c">Template</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Template_talk:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="Template_RemoTI-1.4-2.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/Template_RemoTI-1.4-2.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/Template_RemoTI-1.4-2.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;oldid=208281" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=Template:RemoTI-1.4.0_ZRC_Dongle_Voice&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 13 October 2015, at 05:04.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.073","walltime":"0.077","ppvisitednodes":{"value":30,"limit":1000000},"ppgeneratednodes":{"value":36,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20201130082348","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":183});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/Template:RemoTI-1.4.0_ZRC_Dongle_Voice by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 03:19:35 GMT -->
</html>
