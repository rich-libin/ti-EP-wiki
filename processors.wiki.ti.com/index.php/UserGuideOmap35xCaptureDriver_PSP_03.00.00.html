<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/UserGuideOmap35xCaptureDriver_PSP_03.00.00.04 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 06:36:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>UserGuideOmap35xCaptureDriver PSP 03.00.00.04 - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"UserGuideOmap35xCaptureDriver_PSP_03.00.00.04","wgTitle":"UserGuideOmap35xCaptureDriver PSP 03.00.00.04","wgCurRevisionId":23100,"wgRevisionId":23100,"wgArticleId":4128,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"UserGuideOmap35xCaptureDriver_PSP_03.00.00.04","wgRelevantArticleId":4128,"wgRequestId":"09d58bfcb7469dc9a5fd8daa","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-UserGuideOmap35xCaptureDriver_PSP_03_00_00_04 rootpage-UserGuideOmap35xCaptureDriver_PSP_03_00_00_04 skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">UserGuideOmap35xCaptureDriver PSP 03.00.00.04</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext"><b>Introduction</b></span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#References"><span class="tocnumber">1.1</span> <span class="toctext"><b>References</b></span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Acronyms_.26_Definitions"><span class="tocnumber">1.2</span> <span class="toctext"><b>Acronyms &amp; Definitions</b></span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#System_Diagram"><span class="tocnumber">1.3</span> <span class="toctext"><b>System Diagram</b></span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Software_Design_Interfaces"><span class="tocnumber">1.4</span> <span class="toctext"><b>Software Design Interfaces</b></span></a>
<ul>
<li class="toclevel-3 tocsection-6"><a href="#Opening_and_Closing_of_driver"><span class="tocnumber">1.4.1</span> <span class="toctext"><b>Opening and Closing of driver</b></span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Buffer_Management"><span class="tocnumber">1.4.2</span> <span class="toctext"><b>Buffer Management</b></span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Query_Capabilities"><span class="tocnumber">1.4.3</span> <span class="toctext"><b>Query Capabilities</b></span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Input_Enumeration"><span class="tocnumber">1.4.4</span> <span class="toctext"><b>Input Enumeration</b></span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#Set_Input"><span class="tocnumber">1.4.5</span> <span class="toctext"><b>Set Input</b></span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Get_Input"><span class="tocnumber">1.4.6</span> <span class="toctext"><b>Get Input</b></span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#Standard_Enumeration"><span class="tocnumber">1.4.7</span> <span class="toctext"><b>Standard Enumeration</b></span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#Standard_Detection"><span class="tocnumber">1.4.8</span> <span class="toctext"><b>Standard Detection</b></span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Set_Standard"><span class="tocnumber">1.4.9</span> <span class="toctext"><b>Set Standard</b></span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Get_Standard"><span class="tocnumber">1.4.10</span> <span class="toctext"><b>Get Standard</b></span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#.27Format_Enumeration"><span class="tocnumber">1.4.11</span> <span class="toctext">'<i>Format Enumeration</i></span></a></li>
<li class="toclevel-3 tocsection-17"><a href="#Set_Format"><span class="tocnumber">1.4.12</span> <span class="toctext"><b>Set Format</b></span></a></li>
<li class="toclevel-3 tocsection-18"><a href="#Get_Format"><span class="tocnumber">1.4.13</span> <span class="toctext"><b>Get Format</b></span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#Try_Format"><span class="tocnumber">1.4.14</span> <span class="toctext"><b>Try Format</b></span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Query_Control"><span class="tocnumber">1.4.15</span> <span class="toctext"><b>Query Control</b></span></a></li>
<li class="toclevel-3 tocsection-21"><a href="#Set_Control"><span class="tocnumber">1.4.16</span> <span class="toctext"><b>Set Control</b></span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#Get_Control"><span class="tocnumber">1.4.17</span> <span class="toctext"><b>Get Control</b></span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#Queue_Buffer"><span class="tocnumber">1.4.18</span> <span class="toctext"><b>Queue Buffer</b></span></a></li>
<li class="toclevel-3 tocsection-24"><a href="#Dequeue_Buffer"><span class="tocnumber">1.4.19</span> <span class="toctext"><b>Dequeue Buffer</b></span></a></li>
<li class="toclevel-3 tocsection-25"><a href="#Stream_On"><span class="tocnumber">1.4.20</span> <span class="toctext"><b>Stream On</b></span></a></li>
<li class="toclevel-3 tocsection-26"><a href="#Stream_Off"><span class="tocnumber">1.4.21</span> <span class="toctext"><b>Stream Off</b></span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-27"><a href="#Configuration_Steps"><span class="tocnumber">1.5</span> <span class="toctext"><b>Configuration Steps</b></span></a></li>
<li class="toclevel-2 tocsection-28"><a href="#Installation"><span class="tocnumber">1.6</span> <span class="toctext"><b>Installation</b></span></a>
<ul>
<li class="toclevel-3 tocsection-29"><a href="#Driver_built_statically"><span class="tocnumber">1.6.1</span> <span class="toctext"><b>Driver built statically</b></span></a></li>
<li class="toclevel-3 tocsection-30"><a href="#Driver_built_as_loadable_module"><span class="tocnumber">1.6.2</span> <span class="toctext"><b>Driver built as loadable module</b></span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-31"><a href="#Introduction_2"><span class="tocnumber">1.7</span> <span class="toctext"><b>Introduction</b></span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#Hardware_Setup"><span class="tocnumber">1.8</span> <span class="toctext"><b>Hardware Setup</b></span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Applications"><span class="tocnumber">1.9</span> <span class="toctext"><b>Applications</b></span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Introduction"><b>Introduction</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=1" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The camera ISP is a key component for imaging and video applications such as video preview, video record, and still-image capture with or without digital zooming. 
<br />
The camera ISP provides the system interface and the processing capability to connect RAW image-sensor modules and video decoders to the OMAP35x device.
<br />
The capture module consists of the following interfaces:
</p>
<ul><li>One S-video SD input in BT.656 format.</li>
<li>One Composite SD input in BT.656 format.</li></ul>
<p>Both these video inputs are connected to one TVP5146 decoder and the application can select between these two inputs using standard V4L2 interface.
</p><p><br />
<b>NOTE:</b> Only one input can be captured or selected at any given point of time.
<br />
</p><p>The following figure shows the basic block diagram of capture interface.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:553px;"><a href="File_Omap35x_capture_overview.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/4/4b/Omap35x_capture_overview.png" width="551" height="432" class="thumbimage" /></a>  <div class="thumbcaption">Capture Driver Component Overview</div></div></div></div>
<p><br />
The following figure shows the physical connection and inputs for TVP5146 decoder.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:308px;"><a href="File_Omap35x_capture_input.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/4/46/Omap35x_capture_input.png" width="306" height="400" class="thumbimage" /></a>  <div class="thumbcaption">Capture Physical Input Interface</div></div></div></div>
<p><br />
</p><p>The V4L2 Capture driver model is used for capture module. The V4L2 driver model is widely used across many platforms in the Linux community. V4L2 provides good streaming support and support for many buffer formats. It also has its own buffer management mechanism that can be used.
</p><p><br />
</p>
<h2><span class="mw-headline" id="References"><b>References</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=2" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li>OMAP35x Camera Interface Subsystem (ISP) TRM</li></ul>
<p>Author: Texas Instruments, Inc.
Literature Number: SPRUFA2
</p>
<ul><li>OMAP35x Memory Management Units (MMUs)TRM</li></ul>
<p>Author: Texas Instruments, Inc.
Literature Number: SPRUFF5
</p>
<ul><li>Video for Linux Two API Specification</li></ul>
<p>Author: Michael H Schimek
Version: 0.23
</p><p><br />
</p>
<h2><span id="Acronyms_&amp;_Definitions"></span><span class="mw-headline" id="Acronyms_.26_Definitions"><b>Acronyms &amp; Definitions</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=3" title="Edit section: Acronyms &amp; Definitions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<table border="1" cellspacing="0" cellpadding="5" width="40%">
<caption><b>Capture Driver: Acronyms</b>
</caption>
<tbody><tr>
<th align="left">Acronym
</th>
<th align="left">Definition
</th></tr>
<tr>
<td>MMDC
</td>
<td>Mass Market Daughter Card/Customer Daughter Card
</td></tr>
<tr>
<td>3A
</td>
<td>Auto White Balance, Auto Focus, Auto Exposure
</td></tr>
<tr>
<td>API
</td>
<td>Application Programming Interface
</td></tr>
<tr>
<td>CCDC
</td>
<td>Input interface block of ISP
</td></tr>
<tr>
<td>DMA
</td>
<td>Direct Memory Access
</td></tr>
<tr>
<td>I/O
</td>
<td>Input &amp; Output
</td></tr>
<tr>
<td>IOCTL
</td>
<td>Input &amp; Output Control
</td></tr>
<tr>
<td>MMU
</td>
<td>Memory Management Unit
</td></tr>
<tr>
<td>V4L2
</td>
<td>Video for Linux specification version 2
</td></tr>
<tr>
<td>YUV
</td>
<td>Luminance + 2 Chrominance Difference Signals (Y, Cr, Cb) Color Encoding
</td></tr></tbody></table>
<p><br />
</p>
<pre><b>Features</b> 
</pre>
<p>The ISP Capture Driver provides the following features:
<br />
</p>
<ul><li>Supports one software channel of capture and a corresponding device node (/dev/video0) is created.</li>
<li>Supports single I/O instance and multiple control instances.</li>
<li>Supports buffer access mechanism through memory mapping and user pointers.</li>
<li>Supports dynamic switching among input interfaces with some necessary restrictions wherever applicable.</li>
<li>Supports NTSC and PAL standard on Composite and S-Video interfaces.</li>
<li>Supports 8-bit BT.656 capture in UYVY and YUYV interleaved formats.</li>
<li>Supports standard V4L2 IOCTLs to get/set various control parameters like brightness, contrast, saturation, hue and auto gain control.</li>
<li>TVP5146 (TVP514x) decoder driver module can be used statically or dynamically (insmod and rmmod supported).</li>
<li>In USERPTR mode of operation both malloc'd and IO mapped buffers are supported.</li>
<li>The camera ISP driver supports both static into kernel and modular build.</li></ul>
<p><br />
</p>
<pre><b>Architecture</b> 
</pre>
<p><br />
</p>
<h2><span class="mw-headline" id="System_Diagram"><b>System Diagram</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=4" title="Edit section: System Diagram">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Following block diagram shows basic architecture of the ISP Capture Driver.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:593px;"><a href="File_Omap35x_capture_system_diagram.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/8/80/Omap35x_capture_system_diagram.png" width="591" height="463" class="thumbimage" /></a>  <div class="thumbcaption">Capture Driver Basic Architecture</div></div></div></div>
<p><br />
The system architecture diagram illustrates the software components that are relevant to the Camera Driver. Some components are outside the scope of this design document. The following is a brief description of each component in the figure.
</p><p><br />
<b>Camera Applications:</b> 
<br />
Camera applications refer to any application that accesses the device node that is served by the Camera Driver. These applications are not in the scope of this design. They are here to present the environment in which the Camera Driver is used.
<br />
<b>V4L2 Subsystem:</b> 
<br />
The Linux V4L2 subsystem is used as an infrastructure to support the operation of the Camera Driver. Camera applications mainly use the V4L2 API to access the Camera Driver functionality. A Linux 2.6 V4L2 implementation is used in order to support the standard features that are defined in the V4L2 specification.
<br />
<b>Video Buffer Library:</b> 
<br />
This library comes with V4L2. It provides helper functions to cleanly manage the video buffers through a video buffer queue object.
<br />
<b>Camera Driver:</b> 
<br />
The Camera Driver allows capturing video through an external decoder. It is a V4L2-compliant driver with addition of an OMAP35x ISP hardware feature. This driver conforms to the Linux driver model for power management. The camera driver is registered to the V4L2 layer as a master device driver. Any slave decoder driver added to the V4L2 layer will be attached to this driver through the new V4L2 master-slave interface layer. The current implementation supports only one slave device.
<br />
<b>Decoder Driver:</b> 
<br />
The Camera Driver is designed to be OMAP35x dependent, but platform and board independent.  It is the decoder driver that manages the board connectivity. A decoder driver must implement the new V4L2 master-slave interface. It should register to the V4L2 layer as a slave device. Changing a decoder requires implementation of a new decoder driver; it does not require changing the Camera Driver. Each decoder driver exports a set of IOCTLs to the master device through function pointers.
<br />
<b>ISP Library:</b> 
<br />
The ISP library exports APIs to configure ISP module and clocks to the sensor/decoder. It is the central interrupt handler where callback routines for ISP interrupts are handled. This also manages the video buffers.
<br />
<b>CCDC library:</b> 
<br />
CCDC is a HW block in Camera ISP which acts as a data input port. It receives data from the sensor/decoder through parallel or serial interface. The CCDC library exports API to configure CCDC module. It is configured by the ISP driver based on the sensor/decoder attached and desired output from the camera driver.
<br />
<b>MMU library:</b> 
<br />
MMU is a HW block in Camera ISP that handles the translation from virtual into physical addresses. The camera subsystem issues virtual addresses to the ISP MMU and the ISP MMU translates these virtual addresses into physical addresses to access the actual memory. Using this the camera driver captures video data in fragmented physical memory without moving data. The MMU library exports API to configure MMU module.
<br />
<b>Preview library:</b> 
<br />
Preview is a HW block in Camera ISP which is responsible for image processing and color conversion. It has HW blocks for image processing algorithms. Preview library allows camera driver to configure, enable and disable the individual HW blocks in the preview module. This module will be used only when a RAW sensor is connected to the ISP.
<br />
<b>Resizer library:</b> 
<br />
Resizer is a HW block in Camera ISP which is responsible for image downscaling and upscaling. It has HW filters which resize the input image based on configuration. Resizer library allows camera driver to query and configure the resizer module. Resizer in OMAP35x ISP supports resizing ratios from 1/4 to 4. Resizer also has multipass approach which can be used to overcome this limitation. Current camera driver only supports on the fly mode of operation. In this mode image is taken from sensor and passed to application without any memory to memory operations in ISP and so multipass resizer operations are not supported.
<br />
<b>H3A library:</b> 
<br />
H3A is a HW block in Camera ISP which is responsible for collecting image statistics that can be used by other algorithms. It generates auto focus, auto white balance, auto exposure and histogram statistics. H3A library allows user space algorithms to configure and request these statistics through custom IOCTLs.
</p><p><br />
</p>
<h2><span class="mw-headline" id="Software_Design_Interfaces"><b>Software Design Interfaces</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=5" title="Edit section: Software Design Interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><br />
</p>
<h3><span class="mw-headline" id="Opening_and_Closing_of_driver"><b>Opening and Closing of driver</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=6" title="Edit section: Opening and Closing of driver">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The device can be opened using open call from the application, with the device name and mode of operation as parameters. Application should open the driver in blocking mode. In this mode, DQBUF IOCTL will not return until an empty frame is available.
</p>
<pre>/* Open a video capture logical channel in blocking mode */
fd = open("/dev/video0", O_RDWR);
if (fd == -1) {
    perror("failed to open Capture device\n");
    return -1;
}
/* closing of channel */
close (fd);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Buffer_Management"><b>Buffer Management</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=7" title="Edit section: Buffer Management">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>ISP Capture driver can work with physically non-contiguous buffers. It uses the ISP MMU to capture data to buffers scattered to a set of page frames. Hence, in user pointer mode the application can allocate buffers in user space, which need not be physically contiguous, and pass this directly to driver for capture operation. The only restriction for the user buffer is that, the buffer should be aligned to 32 bytes boundary. 
<br />
The driver supports both memory usage modes:
</p>
<ol><li>Memory map buffer mode</li>
<li>User Pointer mode</li></ol>
<p><br />
In Memory map buffer mode, application can request memory from the driver by calling <i>VIDIOC_REQBUFS</i> IOCTL. In user buffer mode, application needs to allocate memory using some other mechanism in user space like <i>malloc</i> or <i>memalign</i>. In driver buffer mode, maximum number of buffers is limited to <i>VIDEO_MAX_FRAME</i> (defined in driver header files) and is limited by the available memory in the kernel.
<br />
The main steps that the application must perform for buffer allocation are:
<br />
</p>
<ol><li>Allocating Memory</li>
<li>Getting Physical Address</li>
<li>Mapping Kernel Space Address to User Space</li></ol>
<p><br />
<b>Allocating Memory </b>
<br />
This IOCTL is used to allocate memory for frame buffers. This is the necessary IOCTL for streaming IO. It has to be called for both driver buffer mode and user buffer mode. Using this IOCTL, driver will know whether driver buffer mode or user buffer mode will be used.
<br />
<i>Ioctl: VIDIOC_REQBUFS </i>
<br />
It takes a pointer to instance of <i>v4l2_requestbuffers</i> structure as an argument. User should specify buffer type as <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i>, number of buffers, and memory type <i>V4L2_MEMORY_MMAP</i>, <i>V4L2_MEMORY_USERPTR</i> at the time of buffer allocation.
<br />
<i> Constraint:</i> This IOCTL can be called only once from the application. This IOCTL is necessary IOCTL.
</p><p><b>Example:</b>
</p>
<pre>/* structure to store buffer request parameters */
struct v4l2_requestbuffers reqbuf;
reqbuf.count = numbuffers;
reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
reqbuf.memory = V4L2_MEMORY_MMAP;
ret = ioctl(fd, VIDIOC_REQBUFS, &amp;reqbuf);
if (ret &lt; 0) {
    printf("cannot allocate memory\n");
    close(fd);
    return -1;
}
printf("Number of buffers allocated =&#160;%d\n", reqbuf.count);
</pre>
<p><br />
<b> Getting Physical Address </b>
<br />
This IOCTL is used to query buffer information like buffer size and buffer physical address. This physical address is used in mmapping the buffers. This IOCTL is necessary for driver buffer mode as it provides the physical address of buffers, which are used to mmap system call the buffers.
<br />
<i> Ioctl: VIDIOC_QUERYBUF </i>
<br />
It takes a pointer to instance of <i>v4l2_buffer</i> structure as an argument. User has to specify buffer type as <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i>, buffer index, and memory type <i>(V4L2_MEMORY_MMAP)</i> at the time of querying.
<br />
<b>Example:</b>
</p>
<pre>/* allocate buffer by VIDIOC_REQBUFS */
/* structure to query the physical address of allocated buffer */
struct v4l2_buffer buffer;
buffer.index = 0; /* buffer index for quering -0 */
buffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
buffer.memory = V4L2_MEMORY_MMAP;
if (ioctl(fd, VIDIOC_QUERYBUF, &amp;buffer) &lt; -1) {
    printf("buffer query error.\n");
    close(fd);
    exit(-1);
}
The buffer.m.offset will contain the physical address returned from driver.
</pre>
<p><br />
<b>Mapping Kernel Space Address to User Space </b>
<br />
Mapping the kernel buffer to the user space can be done via mmap. This is only required for MMAP buffer mode. User can pass buffer size and physical address of buffer for getting the user space address.
<br />
<b>Example:</b>
<br />
</p>
<pre>/* allocate buffer by VIDIOC_REQBUFS */
/* query the buffer using VIDIOC_QUERYBUF */
/* addr hold the user space address */
int addr;
addr = mmap(NULL, buffer.size,PROT_READ | PROT_WRITE, MAP_SHARED, fd, buffer.m.offset);
/* buffer.m.offset is same as returned from VIDIOC_QUERYBUF */
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Query_Capabilities"><b>Query Capabilities</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=8" title="Edit section: Query Capabilities">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to verify kernel devices compatibility with V4L2 specification and to obtain information about individual hardware capabilities. In this case, it will return capabilities provided by ISP capture driver and current decoder driver.
<br />
<i> Ioctl: VIDIOC_QUERYCAP </i>
<br />
Capabilities can be video capture <i>V4L2_CAP_VIDEO_CAPTURE</i> and streaming <i>V4L2_CAP_STREAMING</i>. It takes pointer to <i>v4l2_capability</i> structure as an argument. Capabilities can be accessed by capabilities field in the <i>v4l2_capability</i> structure.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_capability capability;
ret = ioctl(fd, VIDIOC_QUERYCAP, &amp;capability);
if (ret &lt; 0) {
    printf("Cannot do QUERYCAP\n");
    return -1;
}
if (capability.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE) {
    printf("Capture capability is supported\n");
}
if (capability.capabilities &amp; V4L2_CAP_STREAMING) {
    printf("Streaming is supported\n");
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Input_Enumeration"><b>Input Enumeration</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=9" title="Edit section: Input Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enumerate the information of available inputs (analog interface). It includes information like name of input type and supported standards for that input type.
<br />
<i> Ioctl: VIDIOC_ENUMINPUT</i>
<br />
It takes pointer to <i>v4l2_input</i> structure. Application provides the index number for which it requires the information, in index member of <i>v4l2_input</i> structure. Index with value zero indicates first input type of the decoder. It returns combination of the standards supported on this input in the std member of <i>v4l2_input</i> structure.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_input input;
i = 0;
while(1) {
	input.index = i;
	ret = ioctl(fd, VIDIOC_ENUMINPUT, &amp;input);
	if (ret &lt; 0)
	break;
	printf("name =&#160;%s\n", input.name);
	i++;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Set_Input"><b>Set Input</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=10" title="Edit section: Set Input">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set input type (analog interface type). 
<br />
<i> Ioctl: VIDIOC_S_INPUT</i>
<br />
This IOCTL takes pointer to integer containing index of the input which has to be set. Application will provide the index number as an argument.
<br />
0 - Composite input, 
1 - S-Video input.
<br />
<b>Example:</b>
</p>
<pre>int index = 1; /*To set S-Video input*/
struct v4l2_input input;
ret = ioctl(fd, VIDIOC_S_INPUT, &amp;index);
if (ret &lt; 0) {
    perror("VIDIOC_S_INPUT\n");
    close(fd);
    return -1;
}
input.index = index;
ret = ioctl(fd, VIDIOC_ENUMINPUT, &amp;input);
if (ret &lt; 0) {
    perror("VIDIOC_ENUMINPUT\n");
    close(fd);
    return -1;
}
printf("name of the input =&#160;%s\n",input.name);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Get_Input"><b>Get Input</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=11" title="Edit section: Get Input">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the current input type (analog interface type). 
<br />
<i> Ioctl: VIDIOC_G_INPUT</i>
<br />
This IOCTL takes pointer to integer using which the detected inputs will be returned. It will return the software managed input detected during open system call. Application will provide the index number as an output argument.
<br />
<b>Example:</b>
</p>
<pre>int input;
struct v4l2_input input;
ret = ioctl(fd, VIDIOC_G_INPUT, &amp;input);
if (ret &lt; 0) {
    perror("VIDIOC_G_INPUT\n");
    close(fd);
    return -1;
}
input.index = index;
ret = ioctl(fd, VIDIOC_ENUMINPUT, &amp;input);
if (ret &lt; 0) {
    perror("VIDIOC_ENUMINPUT\n");
    close(fd);
    return -1;
}
printf("name of the input =&#160;%s\n", input.name);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Standard_Enumeration"><b>Standard Enumeration</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=12" title="Edit section: Standard Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enumerate the information regarding video standards. This IOCTL is used to enumerate all the standards supported by the registered decoder.
<br />
<i> Ioctl: VIDIOC_ENUMSTD</i>
<br />
This IOCTL takes a pointer to <i>v4l2_standard</i> structure. Application provides the index of the standard to be enumerated in the index member of this structure. It provides information like standard name, standard ID defined at V4L2 header files (few new standards are included in the respective decoder header files, which were not available in standard V4L2 header files), and numerator and denominator values for frame period and frame lines. It takes index as an argument as a part of <i>v4l2_standard</i> structure.
<br />
Index with value zero provides information for the first standard among all the standards of all the registered decoders.
If the index value exceeds the number of supported standards, it returns an error.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_standard standard;
i = 0;
while(1) {
	standard.index = i;
	ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
	if (ret &lt; 0)
		break;
	printf("name =&#160;%s\n", std.name);
	printf("framelines =&#160;%d\n", std.framelines);
	printf("numerator =&#160;%d\n",
	std.frameperiod.numerator);
	printf("denominator =&#160;%d\n",
	std.frameperiod.denominator);
	i++;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Standard_Detection"><b>Standard Detection</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=13" title="Edit section: Standard Detection">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to detect the current video standard set in the current decoder.
<br />
<i> Ioctl: VIDIOC_QUERYSTD</i>
<br />
It takes a pointer to <i>v4l2_std_id</i> instance as an output argument. Driver will call the current decoder's function internally (which has been initialized) to detect the current standard set in hardware. Support of this IOCTL depends on decoder device, whether it can detect a standard or not.
<br />
<b>Note:</b> This IOCTL should be called by the application so that the camera driver can configure ISP properly with the detected decoder standard. Standard IDs are defined in the V4L2 header files
<br />
<b>Example:</b>
</p>
<pre>v4l2_std_id std;
struct v4l2_standard standard;
ret = ioctl(fd, VIDIOC_QUERYSTD, &amp;std);
if (ret &lt; 0) {
	perror("VIDIOC_QUERYSTD\n");
	close(fd);
	return -1;
}
while(1) {
	standard.index = i;
	ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
	if (ret &lt; 0)
		break;
	if (standard.std &amp; std) {
		printf("%s standard detected\n", standard.name);
		break;
	}
	i++;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Set_Standard"><b>Set Standard</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=14" title="Edit section: Set Standard">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set the standard in the decoder.
<br />
<i> Ioctl: VIDIOC_S_STD</i>
<br />
It takes a pointer to <i>v4l2_std_id</i> instance as an input argument. If the standard is not supported by the decoder, the driver will return an error Standard IDs are defined in the V4L2 header files (few new standards are included in respective decoder header files, which were not available in standard V4L2 header files).
</p><p><b>Note:</b> Application need not call this IOCTL as the decoder can auto detect the current standard. This is required only when the application needs to set a particular standard. In this case, the decoder driver auto detect function is disabled. Auto detect can be enabled again only by closing and re-opening the driver.
<br />
<b>Example:</b>
</p>
<pre>v4l2_std_id std = V4L2_STD_NTSC;
ret = ioctl(fd, VIDIOC_S_STD, &amp;std);
if (ret &lt; 0) {
	perror("S_STD\n");
	close(fd);
	return -1;
}
while(1) {
	standard.index = i;
	ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
	if (ret &lt; 0)
		break;
	if (standard.std &amp; std) {
		printf("%s standard is selected\n");
		break;
	}
	i++;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Get_Standard"><b>Get Standard</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=15" title="Edit section: Get Standard">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the current standard in the current decoder.
<br />
<i> Ioctl: VIDIOC_G_STD</i>
<br />
It takes a pointer to <i>v4l2_std_id</i> instance as an output argument. Standard IDs are defined in the V4L2 header files
<br />
<b>Example:</b>
</p>
<pre>v4l2_std_id std;
ret = ioctl(fd, VIDIOC_G_STD, &amp;std);
if (ret &lt; 0) {
	perror("G_STD\n");
	close(fd);
	return -1;
}
while(1) {
	standard.index = i;
	ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
	if (ret &lt; 0)
		break;
	if (standard.std &amp; std) {
		printf("%s standard is selected\n");
		break;
	}
	i++;
}
</pre>
<p><br />
</p>
<h3><span id="'Format_Enumeration"></span><span class="mw-headline" id=".27Format_Enumeration">'<i>Format Enumeration</i></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=16" title="Edit section: &#039;Format Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enumerate the information of pixel formats. The driver supports only two pixel form at -8-bit UYVY interleaved and 8-bit YUYV interleaved.
<br />
<i> Ioctl: VIDIOC_ENUM_FMT </i>
<br />
It takes a pointer to instance of <i>v4l2_fmtdesc</i> structure as an output parameter. Application must provide the buffer type in the type argument of <i>v4l2_fmtdesc</i> structure as <i> V4L2_BUF_TYPE_VIDEO_CAPTURE </i> and index member of this structure as zero.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_fmtdesc fmt;
i = 0;
while(1) {
	fmt.index = i;
	ret = ioctl(fd, VIDIOC_ENUM_FMT, &amp;fmt);
	if (ret &lt; 0)
		break;
	printf("description =&#160;%s\n",fmt.description);
	if (fmt.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
		printf("Video capture type\n");
	if (fmt.pixelformat == V4L2_PIX_FMT_YUYV)
		printf("V4L2_PIX_FMT_YUYV\n");
	i++;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Set_Format"><b>Set Format</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=17" title="Edit section: Set Format">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set the format parameters. The format parameters are line offset, storage format, pixel format, and so on. This IOCTL is one of the necessary IOCTL. If it is not set, it uses the following default values:
<br />
</p>
<ul><li>Default storage format - V4L2_FIELD_INTERLACED</li></ul>
<p><br />
This IOCTL expects proper width and height members of the <i>v4l2_format</i> structure from application as per the standard selected. Please note that, <i>V4L2_FIELD_INTERLACED</i> is the only storage format supported.
<br />
The application can decide the buffer pixel format using pixelformat member of this IOCTL. The current driver supports - 8-bit UYVY interleaved and 8-bit YUYV interleaved formats.
<br />
The desired pitch of the buffer can be set by using the bytesperline member. The pitch should be at least one line size in bytes. When changing the pitch, the application should also modify the sizeimage member accordingly - sizeimage should be at least pitch * image height.
<br />
The driver allocates buffer of size sizeimage member of the <i>v4l2_format</i> structure passed through this IOCTL for both mmap buffer and user pointer mode. Driver validates the provided buffer size along with the other members and uses this buffer size for calculating offsets for storing video data.
<br />
This IOCTL is a necessary IOCTL for the user buffer mode because driver will know the buffer size for user buffer mode. If it not called for the user buffer mode, driver assumes the default buffer size and calculates offsets accordingly.
<br />
<i> Ioctl: VIDIOC_S_FMT </i>
<br />
It will take pointer to instance of v4l2_format structure as an input parameter. If the type member is <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i>, it checks pixel format, pitch value, and image size. It returns an error, if the parameters are invalid.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_format fmt;
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
/* for  NTSC standard */
fmt.fmt.pix.width = 720;
fmt.fmt.pix.height = 480;
fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;
ret = ioctl(fd, VIDIOC_S_FMT, &amp;fmt);
if (ret &lt; 0) {
	perror("VIDIOC_S_FMT\n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Get_Format"><b>Get Format</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=18" title="Edit section: Get Format">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the current format parameters.
<br />
<i>Ioctl: VIDIOC_G_FMT </i>
<br />
It takes a pointer to instance of <i>v4l2_format</i> structure as an input parameter. Driver provides format parameters in the structure pointer passed as an argument. <i>v4l2_format</i> structure contains parameters like pixel format, image size, bytes per line, and field type. For type <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i>, the <i>v4l2_pix_format</i> structure of fmt union is filled.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_format fmt;
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ret = ioctl(fd, VIDIOC_G_FMT, &amp;fmt);
if (ret &lt; 0) {
	perror("VIDIOC_G_FMT\n");
	close(fd);
	return -1;
}
if (fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV)
	printf("8-bit UYVY pixel format\n");
printf("Size of the buffer =&#160;%d\n", fmt.fmt.pix.sizeimage);
printf("Line offset =&#160;%d\n", fmt.fmt.pix.bytesperline);
if (fmt.fmt.pix.field == V4L2_FIELD_INTERLACED)
	printf("Storate format is interlaced frame format");
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Try_Format"><b>Try Format</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=19" title="Edit section: Try Format">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to validate the format parameters provided by the application. It checks parameters and returns the correct parameter, if any parameter is incorrect. It returns error only if the parameters passed are ambiguous.
<br />
<i>Ioctl: VIDIOC_TRY_FMT</i>
<br />
It takes a pointer to instance of v4l2_format structure as an input/output parameter If the type member is <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i>, it checks pixel format, pitch value, and image size. It returns errors to the application, if the parameters are invalid.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_format fmt;
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
fmt.fmt.pix.sizeimage = size;
fmt.fmt.pix.bytesperline = pitch;
fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;
ret = ioctl(fd, VIDIOC_TRY_FMT, &amp;fmt);
if (ret &lt; 0) {
	perror("VIDIOC_TRY_FMT\n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Query_Control"><b>Query Control</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=20" title="Edit section: Query Control">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the information of controls that is, brightness, contrast, and so on supported by the current decoder.
<br />
<i>Ioctl: VIDIOC_QUERYCTRL</i>
<br />
This IOCTL takes a pointer to the instance of <i>v4l2_queryctrl</i> structure as the argument and returns the control information in the same pointer. Application provides the control ID in the <i>v4l2_queryctrl</i> id member in this structure. This control ID is defined in V4L2 header file, for which information is needed. If the control command specified by Id is not supported in current decoder, driver will return an error.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_queryctrl ctrl;
ctrl.id = V4L2_CID_CONTRAST;
ret = ioctl(fd, VIDIOC_QUERYCTRL, &amp;ctrl);
if (ret &lt; 0) {
	perror("VIDIOC_QUERYCTRL \n");
	close(fd);
	return -1;
}
printf("name =&#160;%s\n", ctrl.name);
printf("min =&#160;%d max =&#160;%d step =&#160;%d default =&#160;%d\n",
ctrl.minimum, ctrl.maximum, ctrl.step, ctrl.default_value);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Set_Control"><b>Set Control</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=21" title="Edit section: Set Control">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set the value for a particular control in current decoder. To set the control value, this IOCTL can also be called when streaming is on.
<br />
<i>Ioctl: VIDIOC_S_CTRL</i>
<br />
It takes a pointer to instance of <i>v4l2_control</i> structure as an input parameter. Application provides control ID and control values in the <i>v4l2_control</i> id and value member in this structure. If the control command specified by Id is not supported in the current decoder and if value of the control is out of range, driver returns an error. Otherwise, it sets the control in the registers.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_control ctrl;
ctrl.id = V4L2_CID_CONTRAST;
ctrl.value = 100;
ret = ioctl(fd, VIDIOC_S_CTRL, &amp;ctrl);
if (ret &lt; 0) {
	perror("VIDIOC_S_CTRL\n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Get_Control"><b>Get Control</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=22" title="Edit section: Get Control">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the value for a particular control in the current decoder.
<br />
<i>Ioctl: VIDIOC_G_CTRL</i>
<br />
It takes a pointer to instance of <i>v4l2_control</i> structure as an output parameter. Application provides the control ID of id member in this structure. If the control command specified by Id is not supported in the current decoder, driver returns an error. Otherwise, it returns the value of the control in the value member of the <i>v4l2_control</i> structure.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_control ctrl;
ctrl.id = V4L2_CID_CONTRAST;
ret = ioctl(fd, VIDIOC_G_CTRL, &amp;ctrl);
if (ret &lt; 0) {
	perror("VIDIOC_G_CTRL\n");
	close(fd);
	return -1;
}
printf("value =&#160;%x\n", ctrl.value);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Queue_Buffer"><b>Queue Buffer</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=23" title="Edit section: Queue Buffer">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enqueue the buffer in buffer queue. This IOCTL will enqueue an empty buffer in the driver buffer queue. This IOCTL is one of necessary IOCTL for streaming IO. If no buffer is enqueued before starting streaming, driver returns an error as there is no buffer available. So at least one buffer must be enqueued before starting streaming. This IOCTL is also used to enqueue empty buffers after streaming is started. 
<br />
<i>Ioctl: VIDIOC_QBUF</i>
<br />
This IOCTL takes a pointer to instance of <i>v4l2_buffer</i> structure as an argument. Application has to specify the buffer type
<i>(V4L2_BUF_TYPE_VIDEO_CAPTURE)</i>, buffer index, and memory type <i>V4L2_MEMORY_MMAP</i> or <i>V4L2_MEMORY_USERPTR</i> at the time of queuing. For the user pointer buffer exchange mechanism, application also has to provide buffer pointer in the m.userptr member of <i>v4l2_buffer</i> structure.
<br />
Driver will enqueue buffer in the driver's incoming queue. It will take pointer to instance of v4l2_ buffer structure as an input parameter.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_buffer buf;
buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
buf.type = V4L2_MEMORY_MMAP;
buf.index = 0;
ret = ioctl(fd, VIDIOC_QBUF, &amp;buf);
if (ret &lt; 0) {
	perror("VIDIOC_QBUF\n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Dequeue_Buffer"><b>Dequeue Buffer</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=24" title="Edit section: Dequeue Buffer">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to dequeue the buffer in the buffer queue. This IOCTL will dequeue the captured buffer from buffer queue of the driver. This IOCTL is one of necessary IOCTL for the streaming IO. This IOCTL can be used only after streaming is started. This IOCTL will block until an empty buffer is available.
<br />
<b>Note:</b> The application can dequeue all buffers from the driver - the driver will not hold the last buffer to itself. In this case, the driver will disable the capture operation and the capture operation resumes when a buffer is queued to the driver again.
<br />
<i>Ioctl: VIDIOC_DQBUF</i>
<br />
It takes a pointer to instance of v4l2_buffer structure as an output parameter. Application has to specify the buffer type <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i> and memory type <i>V4L2_MEMORY_MMAP</i> or <i>V4L2_MEMORY_USERPTR</i> at the time of dequeueing.
<br />
If this IOCTL is called with the file descriptor, with which <i>VIDIOC_REQBUF</i> is not performed, driver will return an error. Driver will enqueue buffer, if the buffer queue is not empty.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_buffer buf;
buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
buf.type = V4L2_MEMORY_MMAP;
ret = ioctl(fd, VIDIOC_DQBUF, &amp;buf);
if (ret &lt; 0) {
	perror("VIDIOC_DQBUF\n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Stream_On"><b>Stream On</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=25" title="Edit section: Stream On">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to start video capture functionality. 
<br />
<i>Ioctl: VIDIOC_STREAMON</i>
<br />
If streaming is already started, this IOCTL call returns an error. 
<br />
<b>Example:</b>
</p>
<pre>v4l2_buf_type buftype = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ret = ioctl(fd, VIDIOC_STREAMON, &amp;buftype);
if (ret &lt; 0) {
	perror("VIDIOC_STREAMON \n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Stream_Off"><b>Stream Off</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=26" title="Edit section: Stream Off">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to stop video capture functionality. 
<br />
<i>Ioctl: VIDIOC_STREAMOFF</i>
<br />
If streaming is not started, this IOCTL call returns an error.
<br />
<b>Example:</b>
</p>
<pre>v4l2_buf_type buftype = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ret = ioctl(fd, VIDIOC_STREAMOFF, &amp;buftype);
if (ret &lt; 0) {
	perror("VIDIOC_STREAMOFF \n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<pre><b>Driver Configuration</b> 
</pre>
<p><br />
</p>
<h2><span class="mw-headline" id="Configuration_Steps"><b>Configuration Steps</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=27" title="Edit section: Configuration Steps">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To enable capture driver support in the kernel, start <i>Linux Kernel Configuration</i> tool.
</p><p><br />
</p>
<pre>$ make menuconfig  ARCH=arm
</pre>
<ul><li>Select <i>Device Drivers</i> from the main menu.</li></ul>
<pre>...
...
Kernel Features  ---&gt;
Boot options  ---&gt;
CPU Power Management  ---&gt;
Floating point emulation  ---&gt;
Userspace binary formats  ---&gt;
Power management options  ---&gt;
[*] Networking support  ---&gt;
<b>Device Drivers  ---&gt;</b>
...
...
</pre>
<ul><li>Select <i>Multimedia support</i> from the menu.</li></ul>
<pre>...
...
Sonics Silicon Backplane  ---&gt;
Multifunction device drivers  ---&gt;
[*] Voltage and Current Regulator Support  ---&gt;
<b>&lt;*&gt; Multimedia support  ---&gt;</b>
Graphics support  ---&gt;
&lt;*&gt; Sound card support  ---&gt;
[*] HID Devices  ---&gt;
[*] USB support  ---&gt;
...
...
</pre>
<ul><li>Select <i>Video For Linux</i> from the menu.</li></ul>
<pre>...
...
*** Multimedia core support ***
<b>&lt;*&gt;   Video For Linux</b>
[*]     Enable Video For Linux API 1 (DEPRECATED)
&lt; &gt;   DVB for Linux
...
...
</pre>
<ul><li>Select <i>Video capture adapters</i> from the same menu. Press &lt;ENTER&gt; to enter the corresponding sub-menu.</li></ul>
<pre>...
...
[ ]   Customize analog and hybrid tuner modules to build  ---&gt;
<b>[*]   Video capture adapters  ---&gt;</b>
[ ]   Radio Adapters  ---&gt;
[ ]   DAB adapters
...
...
</pre>
<ul><li>Select <i>OMAP3 Camera Support</i> from the menu.</li></ul>
<pre>...
...
&lt; &gt;   SAA5249 Teletext processor
<b>&lt;*&gt;   OMAP 3 Camera support</b>
&lt; &gt;   OMAP ISP Previewer
&lt;*&gt;   OMAP ISP Resizer
...
...
</pre>
<ul><li>De-Select <i>Autoselect pertinent encoders/decoders and other helper chips</i> from the same menu option. After De-selecting this</li></ul>
<p>option, new option <i>Encoders/decoders and other helper chips</i> will drop down.
</p>
<pre>...
--- Video capture adapters
[ ]   Enable advanced debug functionality
[ ]   Enable old-style fixed minor ranges for video devices
<b>[ ]   Autoselect pertinent encoders/decoders and other helper chips</b>
Encoders/decoders and other helper chips  ---&gt;
&lt; &gt;   Virtual Video Driver
&lt; &gt;   CPiA Video For Linux
</pre>
<ul><li>Go inside option <i>Encoders/decoders and other helper chips</i>.</li></ul>
<pre>...
--- Video capture adapters
[ ]   Enable advanced debug functionality
[ ]   Enable old-style fixed minor ranges for video devices
[ ]   Autoselect pertinent encoders/decoders and other helper chips
<b>        Encoders/decoders and other helper chips ---&gt;</b>
&lt; &gt;   Virtual Video Driver
&lt; &gt;   CPiA Video For Linux
</pre>
<ul><li>Select TVP514x Video decoder driver from the menu.</li></ul>
<pre>...
...
&lt; &gt; Philips SAA7171/3/4 audio/video decoders
&lt; &gt; Philips SAA7191 video decoder
<b>&lt;*&gt; Texas Instruments TVP514x video decoder</b>
&lt; &gt; Texas Instruments TVP5150 video decoder
...
...
</pre>
<h2><span class="mw-headline" id="Installation"><b>Installation</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=28" title="Edit section: Installation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><b>NOTE:</b> Please note that the software detects and configures the peripherals dynamically/run-time depending on EVM revision. In case of OMAP3EVM-1 (&lt;Rev-E) it configures the peripherals on MMDC and in case of OMAP3EVM-2 (&gt;=Rev-E) it configures On-board peripherals.
<br />
</p>
<h3><span class="mw-headline" id="Driver_built_statically"><b>Driver built statically</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=29" title="Edit section: Driver built statically">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If the OMAP35x Camera driver and TVP514x driver are built statically into the kernel, it is activated during boot-up. There is no special procedure to install the driver.
<br />
</p>
<h3><span class="mw-headline" id="Driver_built_as_loadable_module"><b>Driver built as loadable module</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=30" title="Edit section: Driver built as loadable module">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The OMAP35x Camera driver and OMAP35x daughter card (applicable for OMAP3EVM-1 (&lt;Rev-E)) driver cannot be build as a loadable module. both the TVP514x driver and Capture master driver can be build as a module.
<br />
If the driver has been configured to be a loadable module, then the driver is built as a module with the name tvp514x.ko and omap34xxcam.ko, which will be placed under the directory <i>drivers/media/video</i> in the kernel tree. Copy this driver file on to the target board and issue the following command to insert the driver:
<br />
</p>
<pre>$ insmod omap34xxcam.ko
$ insmod tvp514x.ko
</pre>
<p><br />
To remove the driver, issue the following command:
<br />
</p>
<pre>$ rmmod omap34xxcam.ko
$ rmmod tvp514x.ko
</pre>
<p><br />
</p>
<pre><b>Sample Applications</b> 
</pre>
<p>This chapter describes the sample application provided along with the package. The binary and the source for these sample application can are available in the Examples directory of the Release Package folder.
</p>
<h2><span class="mw-headline" id="Introduction_2"><b>Introduction</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=31" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Writing a capture application involves the following steps:
<br />
</p>
<ul><li>Opening the capture device.</li>
<li>Set the parameters of the device.</li>
<li>Allocate and initialize capture buffer</li>
<li>Receive video data from the device.</li>
<li>Close the device.</li></ul>
<p><br />
</p>
<h2><span class="mw-headline" id="Hardware_Setup"><b>Hardware Setup</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=32" title="Edit section: Hardware Setup">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Following are the steps required to run the capture sample application:
<br />
</p>
<ul><li>If you are using OMAP3EVM-1 (&lt;Rev-E) revision board, connect the OMAP35x daughter card module containing the TVP5146 decoder to the OMAP35x main board. For OMAP3EVM-2 (&gt;=Rev-E), all the peripherals including TVP5146 decoder is present on board.</li>
<li>Connect a DVD player/camera generating a NTSC video signal to the S-Video or Composite jack of the daughter card or EVM.</li>
<li>Run the sample application after booting the kernel.</li></ul>
<p><br />
</p>
<h2><span class="mw-headline" id="Applications"><b>Applications</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;section=33" title="Edit section: Applications">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Following are the list of capture sample application provided with the release:
<br />
</p>
<ul><li><b>MMAP Loopback Application (saMmapLoopback.c):</b></li></ul>
<p>This sample application using driver allocated buffers to capture videodata from any one of the active inputs and displays the video in the LCD using display driver.
<br />
</p>
<ul><li><b>USERPTR Loopback Application (saUserPtrLoopback.c):</b></li></ul>
<p>This sample application using User allocated buffers to capture video data from any one of the active inputs and displays the video in the LCD using display driver. The application makes use of V4L2 display driver buffers as a user pointer in capture driver.
</p><p><b>NOTE:</b> sauserPtrLoopback application configures the parameters for NTSC, so User will have to change it for PAL.
</p>
<!-- 
NewPP limit report
Cached time: 20201201035147
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.090 seconds
Real time usage: 0.093 seconds
Preprocessor visited node count: 337/1000000
Preprocessor generated node count: 596/1000000
Postexpand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 7289/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:4128-0!canonical and timestamp 20201201035147 and revision id 23100
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>UserGuideOmap35xCaptureDriver PSP 03.00.00.04</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>UserGuideOmap35xCaptureDriver PSP 03.00.00.04</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 03.00.00.04</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 03.00.00.04</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 03.00.00.04</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 03.00.00.04</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 03.00.00.04</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 03.00.00.04</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 03.00.00.04</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;oldid=23100">https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;oldid=23100</a>"					</div>
				<div id="catlinks" class="catlinks catlinks-allhidden" data-mw="interface"></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=UserGuideOmap35xCaptureDriver+PSP+03.00.00.04" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="UserGuideOmap35xCaptureDriver_PSP_03.00.00.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Talk:UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="UserGuideOmap35xCaptureDriver_PSP_03.00.00.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/UserGuideOmap35xCaptureDriver_PSP_03.00.00.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/UserGuideOmap35xCaptureDriver_PSP_03.00.00.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;oldid=23100" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_03.00.00.04&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 8 February 2010, at 07:59.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.090","walltime":"0.093","ppvisitednodes":{"value":337,"limit":1000000},"ppgeneratednodes":{"value":596,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":7289,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20201201035147","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":308});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/UserGuideOmap35xCaptureDriver_PSP_03.00.00.04 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 06:36:42 GMT -->
</html>
