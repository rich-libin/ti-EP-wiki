<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/Processor_SDK_RTOS_ICSS-EMAC-Design by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 11:53:00 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>Processor SDK RTOS ICSS-EMAC-Design - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Processor_SDK_RTOS_ICSS-EMAC-Design","wgTitle":"Processor SDK RTOS ICSS-EMAC-Design","wgCurRevisionId":233605,"wgRevisionId":233605,"wgArticleId":39956,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["ICSS-EMAC"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Processor_SDK_RTOS_ICSS-EMAC-Design","wgRelevantArticleId":39956,"wgRequestId":"dc9ada0aec76ff931d9f3e08","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Processor_SDK_RTOS_ICSS-EMAC-Design rootpage-Processor_SDK_RTOS_ICSS-EMAC-Design skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">Processor SDK RTOS ICSS-EMAC-Design</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Driver_Overview"><span class="tocnumber">1</span> <span class="toctext">Driver Overview</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Sofware_Architecture"><span class="tocnumber">1.1</span> <span class="toctext">Sofware Architecture</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Driver_Features"><span class="tocnumber">1.2</span> <span class="toctext">Driver Features</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#EMAC_and_Switch"><span class="tocnumber">1.3</span> <span class="toctext">EMAC and Switch</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Ports_in_Driver_context"><span class="tocnumber">1.4</span> <span class="toctext">Ports in Driver context</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Driver_Architecture_and_Memory_Map"><span class="tocnumber">1.5</span> <span class="toctext">Driver Architecture and Memory Map</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#DDR"><span class="tocnumber">1.5.1</span> <span class="toctext">DDR</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#L3_OCMC_RAM"><span class="tocnumber">1.5.2</span> <span class="toctext">L3 OCMC RAM</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Shared_Data_RAM"><span class="tocnumber">1.5.3</span> <span class="toctext">Shared Data RAM</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#PRU0_Data_RAM"><span class="tocnumber">1.5.4</span> <span class="toctext">PRU0 Data RAM</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#PRU1_Data_RAM"><span class="tocnumber">1.5.5</span> <span class="toctext">PRU1 Data RAM</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-12"><a href="#Quality_of_Service_and_Queues"><span class="tocnumber">2</span> <span class="toctext">Quality of Service and Queues</span></a>
<ul>
<li class="toclevel-2 tocsection-13"><a href="#How_QoS_works"><span class="tocnumber">2.1</span> <span class="toctext">How QoS works</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Querying_queue_fill_level"><span class="tocnumber">2.2</span> <span class="toctext">Querying queue fill level</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-15"><a href="#Data_Path"><span class="tocnumber">3</span> <span class="toctext">Data Path</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="#Rx_Data_Path"><span class="tocnumber">3.1</span> <span class="toctext">Rx Data Path</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Tx_Data_Path"><span class="tocnumber">3.2</span> <span class="toctext">Tx Data Path</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Usage"><span class="tocnumber">3.3</span> <span class="toctext">Usage</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-19"><a href="#Interrupts_and_Tasks"><span class="tocnumber">4</span> <span class="toctext">Interrupts and Tasks</span></a>
<ul>
<li class="toclevel-2 tocsection-20"><a href="#Interrupts"><span class="tocnumber">4.1</span> <span class="toctext">Interrupts</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Tasks"><span class="tocnumber">4.2</span> <span class="toctext">Tasks</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-22"><a href="#Interrupt_Pacing"><span class="tocnumber">5</span> <span class="toctext">Interrupt Pacing</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="#Pacing_Modes"><span class="tocnumber">5.1</span> <span class="toctext">Pacing Modes</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-24"><a href="#Half_Duplex_Support"><span class="tocnumber">6</span> <span class="toctext">Half Duplex Support</span></a></li>
<li class="toclevel-1 tocsection-25"><a href="#Learning.2FFDB"><span class="tocnumber">7</span> <span class="toctext">Learning/FDB</span></a>
<ul>
<li class="toclevel-2 tocsection-26"><a href="#Design"><span class="tocnumber">7.1</span> <span class="toctext">Design</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-27"><a href="#API_Guide_.26_Data_Structures"><span class="tocnumber">8</span> <span class="toctext">API Guide &amp; Data Structures</span></a>
<ul>
<li class="toclevel-2 tocsection-28"><a href="#Usage_2"><span class="tocnumber">8.1</span> <span class="toctext">Usage</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-29"><a href="#Storm_Control"><span class="tocnumber">9</span> <span class="toctext">Storm Control</span></a>
<ul>
<li class="toclevel-2 tocsection-30"><a href="#Design_2"><span class="tocnumber">9.1</span> <span class="toctext">Design</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#API_Guide_.26_Data_Structures_2"><span class="tocnumber">9.2</span> <span class="toctext">API Guide &amp; Data Structures</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#Usage_3"><span class="tocnumber">9.3</span> <span class="toctext">Usage</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-33"><a href="#Statistics"><span class="tocnumber">10</span> <span class="toctext">Statistics</span></a>
<ul>
<li class="toclevel-2 tocsection-34"><a href="#Design_3"><span class="tocnumber">10.1</span> <span class="toctext">Design</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#API_Guide_.26_Data_Structures_3"><span class="tocnumber">10.2</span> <span class="toctext">API Guide &amp; Data Structures</span></a></li>
<li class="toclevel-2 tocsection-36"><a href="#Usage_4"><span class="tocnumber">10.3</span> <span class="toctext">Usage</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-37"><a href="#Memory_Map"><span class="tocnumber">11</span> <span class="toctext">Memory Map</span></a></li>
<li class="toclevel-1 tocsection-38"><a href="#RTOS"><span class="tocnumber">12</span> <span class="toctext">RTOS</span></a>
<ul>
<li class="toclevel-2 tocsection-39"><a href="#Porting_Driver_to_LINUX"><span class="tocnumber">12.1</span> <span class="toctext">Porting Driver to LINUX</span></a>
<ul>
<li class="toclevel-3 tocsection-40"><a href="#Memory_Map_2"><span class="tocnumber">12.1.1</span> <span class="toctext">Memory Map</span></a></li>
<li class="toclevel-3 tocsection-41"><a href="#Interrupts_2"><span class="tocnumber">12.1.2</span> <span class="toctext">Interrupts</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-42"><a href="#TCP.2FIP"><span class="tocnumber">13</span> <span class="toctext">TCP/IP</span></a></li>
<li class="toclevel-1 tocsection-43"><a href="#IOCTL"><span class="tocnumber">14</span> <span class="toctext">IOCTL</span></a>
<ul>
<li class="toclevel-2 tocsection-44"><a href="#Design_4"><span class="tocnumber">14.1</span> <span class="toctext">Design</span></a></li>
<li class="toclevel-2 tocsection-45"><a href="#API_Guide_.26_Data_Structures_4"><span class="tocnumber">14.2</span> <span class="toctext">API Guide &amp; Data Structures</span></a></li>
<li class="toclevel-2 tocsection-46"><a href="#Usage_5"><span class="tocnumber">14.3</span> <span class="toctext">Usage</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-47"><a href="#ICSS_EMAC_LLD_Dependencies"><span class="tocnumber">15</span> <span class="toctext">ICSS EMAC LLD Dependencies</span></a>
<ul>
<li class="toclevel-2 tocsection-48"><a href="#Interrupt_Configuration"><span class="tocnumber">15.1</span> <span class="toctext">Interrupt Configuration</span></a>
<ul>
<li class="toclevel-3 tocsection-49"><a href="#Rx_Interrupt"><span class="tocnumber">15.1.1</span> <span class="toctext">Rx Interrupt</span></a></li>
<li class="toclevel-3 tocsection-50"><a href="#Link_Interrupt"><span class="tocnumber">15.1.2</span> <span class="toctext">Link Interrupt</span></a></li>
<li class="toclevel-3 tocsection-51"><a href="#Transmit_Complete_Interrupt"><span class="tocnumber">15.1.3</span> <span class="toctext">Transmit Complete Interrupt</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-52"><a href="#Learning_module_Increment_counter_implementation"><span class="tocnumber">15.2</span> <span class="toctext">Learning module Increment counter implementation</span></a></li>
<li class="toclevel-2 tocsection-53"><a href="#MDIO_Configurations"><span class="tocnumber">15.3</span> <span class="toctext">MDIO Configurations</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-54"><a href="#EMAC_Configuration_and_How_To"><span class="tocnumber">16</span> <span class="toctext">EMAC Configuration and How To</span></a>
<ul>
<li class="toclevel-2 tocsection-55"><a href="#Configuration_Parameters"><span class="tocnumber">16.1</span> <span class="toctext">Configuration Parameters</span></a></li>
<li class="toclevel-2 tocsection-56"><a href="#Network_related"><span class="tocnumber">16.2</span> <span class="toctext">Network related</span></a>
<ul>
<li class="toclevel-3 tocsection-57"><a href="#How_to_configure_IP_address_and_other_IPv4_parameters"><span class="tocnumber">16.2.1</span> <span class="toctext">How to configure IP address and other IPv4 parameters</span></a></li>
<li class="toclevel-3 tocsection-58"><a href="#How_to_configure_MAC_address"><span class="tocnumber">16.2.2</span> <span class="toctext">How to configure MAC address</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-59"><a href="#Additional_documentation_reference"><span class="tocnumber">16.3</span> <span class="toctext">Additional documentation reference</span></a></li>
</ul>
</li>
</ul>
</div>

<h3><span class="mw-headline" id="Driver_Overview">Driver Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=1" title="Edit section: Driver Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The ICSS_EMAC (industrial communications subsystem Ethernet Media Access Controller) driver provide APIs to transmit and receive packets with a firmware based ethernet switch that has been implemented on TI’s PRU-ICSS (Programmable Real-Time Unit Subsystem and Industrial Communication SubSystem) 32-bit RISC cores. 
</p><p><br />
</p>
<h4><span class="mw-headline" id="Sofware_Architecture">Sofware Architecture</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=2" title="Edit section: Sofware Architecture">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The ICSS EMAC consists of driver + firmware implementation. Firmware refers to the code running on the two PRU's which are part of ICSS while driver refers to that portion of code running on host which is directly associated with the firmware. The two PRU's are responsible for reception of packets while Host runs higher level tasks.
</p><p>Logically the software on host can be partitioned into
</p>
<ul><li>Ethernet Driver - Copying packet data and providing to upper layers. Managing PRU/ICSS.</li>
<li>TCP/IP and other network stack. NDK in this case</li>
<li>RTOS code. SYS/BIOS in this case</li>
<li>Peripheral initialization and management</li></ul>
<p>Out of these the first three are relevant to this discussion. Only the driver is discussed in depth while NDK and SYS/BIOS are mentioned in passing whenever relevant.
</p><p><br />
</p>
<h4><span class="mw-headline" id="Driver_Features">Driver Features</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=3" title="Edit section: Driver Features">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The icss_emac LLD implements the following:
</p>
<ul><li><ul><li>Rx - Copying the packet received from the firmware and providing it to the TCP/IP stack</li>
<li>Tx - Providing packet from TCP/IP stack to the firmware</li>
<li>Learning/Forwarding Data Base - refer <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#Learning.2FFDB">here</a></li>
<li>Storm Prevention implementation - refer <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#Storm_Control">here</a></li>
<li>Host Statistics implementation - refer <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#Statistics">here</a></li>
<li>TCP/IP stack related initialization</li>
<li>Configuring IP address</li>
<li>ARM interrupt management</li>
<li>Support For Multi ICSS EMAC instance support</li></ul></li></ul>
<p><br />
</p>
<h4><span class="mw-headline" id="EMAC_and_Switch">EMAC and Switch</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=4" title="Edit section: EMAC and Switch">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>It is important to differentiate between the two different types of implementations in SDK context because this keeps coming up while discussing SDK and it's components. An EMAC example implements two independent Ethernet MAC's using PRU 0/1, they have two different MAC, IP addresses and two different instances of the TCP/IP stack while a switch presents a single IP and MAC address for any external entity. 
</p><p>The icss_emac LLD only provides a simple EMAC loopback example, right now there is no example for a standalone switch on the lines of EMAC. 
</p><p>There are some important differences between an EMAC and Switch
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">
  
<caption><i>Differences between EMAC and Switch</i>
</caption>
<tbody><tr>
<th>EMAC
</th>
<th>Ethernet Switch
<p>(Profinet and EtherNet/IP)
</p>
</th></tr>
<tr>
<td>Two interface MAC addresses
</td>
<td>Single Interface MAC addresses
</td></tr>
<tr>
<td>PRU0 transmits on Port0 and PRU1 on Port1
</td>
<td>PRU0 transmits on Port1 and PRU1 on Port0
<p>This configuration is done in software
</p>
</td></tr>
<tr>
<td>Two TCP/IP instances and two IP addresses
</td>
<td>One TCP/IP instance and one IP address
</td></tr>
<tr>
<td>Two Rx interrupts, semaphores and tasks for two ports
</td>
<td>Single Rx interrupt, semaphore and task
</td></tr>
<tr>
<td>Two ICSS EMAC Handles
</td>
<td>Single ICSS EMAC Handle
</td></tr>
<tr>
<td>No collision handling (independent MAC's)
</td>
<td>Colilsion buffer with Collision Handling
<p>Collision refers to Queue contention
</p>
</td></tr></tbody></table>
<p><br />
</p>
<h4><span class="mw-headline" id="Ports_in_Driver_context">Ports in Driver context</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=5" title="Edit section: Ports in Driver context">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Before beginning it’s important to explain the conventions used in this document, although there are two physical ports for every ICSS for the sake of convenience the Host is considered as a third port. In fact for some protocols this is the logical partitioning used. 
The convention used here is two physical ports and one host port.
</p><p>The ports are referred to as
</p>
<ul><li>Host Port       - <i>ICSS_EMAC_PORT_0</i></li>
<li>Physical Port 0 - <i>ICSS_EMAC_PORT_1</i></li>
<li>Physical Port 1 - <i>ICSS_EMAC_PORT_2</i></li></ul>
<p>This convention is followed throughout the document as well as inside the driver and firmware
</p>
<h4><span class="mw-headline" id="Driver_Architecture_and_Memory_Map">Driver Architecture and Memory Map</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=6" title="Edit section: Driver Architecture and Memory Map">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>A detailed discussion of the architecture is beyond the scope of this document. A brief summary is provided below to explain where the data is copied to and how.  
</p><p>While discussing the ICSS Switch we are mainly concerned with 4 types of memories.
</p>
<h5><span class="mw-headline" id="DDR">DDR</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=7" title="Edit section: DDR">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>This is the memory from where ARM core operates. It's not on the SoC and hence has a lower performance, this is cached.
</p><p>This contains
</p>
<ul><li>TCP/IP Buffers.</li>
<li>Learning/FDB tables</li>
<li>Host Statistics</li>
<li>Control structures and variables</li></ul>
<h5><span class="mw-headline" id="L3_OCMC_RAM">L3 OCMC RAM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=8" title="Edit section: L3 OCMC RAM">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>This is where the actual Packet buffers or queues are located. There are 15 queues in total. 4 queues for each port (including host) and 1 additional queue for each port to handle collision. This is covered later in QoS section. Developer needs to know that firmware copies the packet data here after receiving them and this is where the driver writes the packet data meant for transmission using the firmware. So this acts as a place holder for packet data before it received or transmitted.
</p><p>This memory resides inside the SoC (but outside ICSS) and is faster than DDR. It's buffered but non-cached. Size varies from SoC to SoC, please refer to the TRM for more details.
</p><p>This contains
</p>
<ul><li>Host receive queues</li>
<li>Port transmit queues</li>
<li>Collision queues</li></ul>
<h5><span class="mw-headline" id="Shared_Data_RAM">Shared Data RAM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=9" title="Edit section: Shared Data RAM">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>This is specific to the PRU subsystem although access is possible from Host albeit slowly. Data common to both PRU's such as Host queue descriptors are stored here. A lot of the memory is available for protocol or application specific usage, for more details refer to the memory map.
</p><p>Size varies from SoC to SoC, please refer to the TRM for more details.
</p><p>This contains
</p>
<ul><li>Host queue descriptors</li></ul>
<p><b>Note</b>&#160;: This memory map is applicable only for EMAC application. Other applications might have their own map.
</p>
<h5><span class="mw-headline" id="PRU0_Data_RAM">PRU0 Data RAM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=10" title="Edit section: PRU0 Data RAM">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>This is similar to Shared Data RAM though meant for use only by PRU0. Access from PRU1 is also possible, so the separation is only logical, not in hardware. 
</p><p>Size varies from SoC to SoC, please refer to the TRM for more details.
</p><p>Contains 
</p>
<ul><li>Port 0 Statistics</li>
<li>Port 0 MAC ID</li>
<li>Port 0 Port, Speed and Duplex information</li></ul>
<p><b>Note</b>&#160;: This memory map is applicable only for EMAC application. Other applications might have their own map.
</p>
<h5><span class="mw-headline" id="PRU1_Data_RAM">PRU1 Data RAM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=11" title="Edit section: PRU1 Data RAM">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>Similar to PRU0 Data RAM but for PRU1.
</p>
<h3><span class="mw-headline" id="Quality_of_Service_and_Queues">Quality of Service and Queues</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=12" title="Edit section: Quality of Service and Queues">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Quality of Service is very important for an Ethernet switch as it allows high priority packets to be processed separately from regular packets. This provides reliability for real time traffic.
</p><p>In EMAC this is done using queues which are mapped to 8 VLAN based priority levels. Each queue is a block of memory on L3 used to store the packet data. Queue sizes may vary and are build time configurable from <i>icss_emacSwitch.h</i>, for example host queue sizes used for default EMAC application are given below, the sizes are denoted by blocks. Each block is 32 bytes in size. The sizes are limited by L3 size which are dictated by SoC. 
</p>
<pre>#define HOST_QUEUE_1_SIZE		194	
#define HOST_QUEUE_2_SIZE		194	
#define HOST_QUEUE_3_SIZE		194	
#define HOST_QUEUE_4_SIZE		194
</pre>
<p><br />
The transmit queues sizes are denoted separately (allows up to approximately 3KB queue size for each queue). 
</p>
<pre>#define QUEUE_1_SIZE		97 	
#define QUEUE_2_SIZE		97	
#define QUEUE_3_SIZE		97	
#define QUEUE_4_SIZE		97	
</pre>
<p>So in total there are 15 queues, 4 receive queues for Host and 4 transmit queues for each of the two physical ports. In addition to these there is 1 collision queue each for Host and 2 ports which can hold one packet irrespective of packet size.
</p><p>The figure below is illustrative to remember this
</p><p><a href="File_Switch_Queues.html" class="image"><img alt="Switch Queues.png" src="https://processors.wiki.ti.com/images/d/df/Switch_Queues.png" width="600" height="363" /></a>
</p>
<h5><span class="mw-headline" id="How_QoS_works">How QoS works</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=13" title="Edit section: How QoS works">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>When a packet is received in firmware the 3 bit PCP field of a VLAN tag is read and the packet is copied to the appropriate queue based on fixed mapping which maps 2 levels(out of 8) of QoS to one queue. So 7 &amp; 6 map to Queue 0, 5 &amp; 4 to Queue 1 and so on. On the driver this queue number then translates to the priority value and is used to decide how to process the packet. More on this in the next section where driver side Rx processing is discussed in detail.
</p><p>On Tx side there is no special handling with regards to QoS. Data is copied to one of the four queues based on the <b>queuePriority</b> field of the API <b>ICSS_EmacTxPacket</b>
</p><p><span style="color: Red">At the moment driver/firmware doesn't support DSCP</span>
</p><p><br />
In the testing domain, there might be a need to ping the EVM with the size which greatly exceeds the MTU size, for example doing a ping with size set to 10KB. Because the default configuration above only allows for up to 3KB of buffering per queue on the transmit direction, these parameters will need to be re-tuned to allow successful transmission of the 10 KB ping response. The following is a sample configuration of QUEUE sizes (Note that these settings does not exceed the L3 size which are dictated by the SOC).
</p>
<pre>#define QUEUE_1_SIZE		13 	
#define QUEUE_2_SIZE		15	
#define QUEUE_3_SIZE		15	
#define QUEUE_4_SIZE		345	/* allows up to approximately 11 KB queue size */
</pre>
<p><br />
Please refer to <a rel="nofollow" class="external autonumber" href="https://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_overview.html#rebuild-pdk">[1]</a> for details of how to rebuild the icss-emac LLD PDK component.
</p><p>Note the NDK's default configuration allows reassembly of packets up to "3012" bytes. To be able to ping bigger sizes, the stack needs to be reconfigured as follows:
</p>
<ul><li>Change the "MMALLOC_MAXSIZE" definition in "pbm.c" file. (i.e. #define MMALLOC_MAXSIZE</li></ul>
<p>65500) and rebuild the library.
</p>
<ul><li>Increase the Memory Manager Buffer Page Size in the Buffers tab of the Global configuration.</li>
<li>Increase the Maximum IP Reassembly Size property of the IP module configuration</li></ul>
<h4><span class="mw-headline" id="Querying_queue_fill_level">Querying queue fill level</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=14" title="Edit section: Querying queue fill level">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>It's possible to find out the queue fill levels before inserting a new frame or if the intention is to just find out usage levels. The API for this is <i>ICSS_EmacGetMaxQueueFillLevel()</i>. Usage is explained in the Doxygen guide.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Data_Path">Data Path</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=15" title="Edit section: Data Path">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Data path refers to the control flow which is executed on the driver and firmware to send or receive a packet. A basic understanding of it goes a long way in explaining the software architecture and if a developer is only trying to use the Rx and Tx capabilities of EMAC or Switch a knowledge of this is sufficient to build an application.
</p>
<h5><span class="mw-headline" id="Rx_Data_Path">Rx Data Path</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=16" title="Edit section: Rx Data Path">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p><a href="File_Rx_Data_path.html" class="image"><img alt="Rx Data path.png" src="https://processors.wiki.ti.com/images/c/c5/Rx_Data_path.png" width="500" height="325" /></a>
</p><p>Packets are received in the ICSS from where they are copied by the PRU's to L3 memory. The PRU's then assert an interrupt to tell the Host about the presence of a packet. Till the packet is copied by the Host, PRU does not write over the memory so there is no corruption.
</p><p>The flowchart shown above shows the sequence in very broad strokes. A detailed description is given below.
</p>
<ol><li>PRU Posts an Rx interrupt to the ARM interrupt controller. For EMAC each PRU has a separate Rx interrupt, the configuration for which is done in the application (details in Interrupts)</li>
<li>The interrupt triggers the ISR <b>ICSS_EmacRxInterruptHandler</b> which in turn posts a semaphore rxSemaphoreHandle to signal <b>RxTask</b> to empty the Rx queues.</li>
<li>The <b>RxTask</b> function goes through all the queues, extracts the port/queue number and provides it to an API which copies data from L3 to DDR. The code excerpt is shown below with explanations.</li></ol>
<pre>/*Read till all queues are empty*/
while(allQueuesEempty&#160;!= 1 &amp;&amp; numPacketsInLoop &lt;= ((((ICSS_EmacObject*)icssEmacHandle-&gt;object)-&gt;emacInitcfg)-&gt;pacingThreshold))
{
  /*This API reads the queues and gets the queue and port number for each packet*/
  pLength = ICSS_EmacRxPktInfo(icssEmacHandle, &amp;port_number, &amp;queue_number);
  if(pLength &gt; 0) {
   if(queue_number &gt;= ((ICSS_EmacObject*)(icssEmacHandle-&gt;object))-&gt;emacInitcfg-&gt;ethPrioQueue) {
     /*Based on queue priority settings decide if the packet is to be sent to the TCP/IP stack*/
     /*This API is hooked to NDK*/
     icssEmacHwIntRx(&amp;queue_number,icssEmacHandle);
   else {
     /*Protocol specific callback*/
     if(((((ICSS_EmacObject*)icssEmacHandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;callBack&#160;!= NULL) {
        ((((ICSS_EmacObject*)icssEmacHandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;callBack(&amp;queue_number,
        ((((ICSS_EmacObject*)icssEmacHandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;userArg);
      }
      else {
            /* just dump the packet here so we do no stall the queues*/
            ICSS_EmacRxPktGet(icssEmacHandle,(uint32_t)dest_address, queue_number, &amp;port_number, &amp;more);   
      }
   }
</pre>
<p>In the code snippet above function <b>ICSS_EmacRxPktInfo</b> goes through each queue one at a time, extracts the port &amp; queue number information for every packet and provides it to functions below. Based on the priority of the packet which is decided by the queue number (refer to <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#How_QoS_works#How_QoS_works">discussion</a> on QoS and queues) driver decides to either forward it to NDK, done by <b>icssEmacHwIntRx</b> or give it to the callback function.
</p><p>The threshold for this decision is decided by the user settable parameter shown in the code above.
</p>
<pre>((ICSS_EmacObject*)(icssEmacHandle-&gt;object))-&gt;emacInitcfg-&gt;ethPrioQueue)
</pre>
<p>Anything lower than this configured value goes to the callback function.
</p><p>If a callback is not registered then the queue is just emptied to prevent queues from overflowing. This is done by the function <b>ICSS_EmacRxPktGet</b> which takes a single packet and copies it into <b>dest_address</b> provided as a parameter. This is not a dummy API but a basic Rx API which performs the basic task of copying data from L3 to DDR, even the NDK API <b>icssEmacHwIntRx</b> calls <b>ICSS_EmacRxPktGet</b> underneath it.
</p><p>If a developer is building a custom API to process packets then he/she needs to call the API <b>ICSS_EmacRxPktGet</b> in their respective function, this is explained with an example below.
</p><p><i><b> Doing customized packet processing </b></i>
</p>
<hr />
<p>For example, a user application where some DLR packets are processed different from other packets using a callback.
</p><p>For this example the value of <b>ethPrioQueue</b> is set to 4 or <i>ICSS_EMAC_QUEUEPRIO4</i> and in this case these DLR frames have a the highest priority so they go to the callback function, developers need to set an appropriate value for <b>ethPrioQueue</b> based on their requirements. The callback would be configured as follows in teh user application's <b>main</b> routine like this
</p>
<pre>/*Packet processing callback*/
((((ICSS_EmacObject*)icssEmacHandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;callBack = (ICSS_EmacCallBack)processProtocolFrames;
((((ICSS_EmacObject*)icssEmacHandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;userArg = icssEmacHandle;
</pre>
<p>Where <b>icssEmacHandle</b> is the main driver handle and <b>processProtocolFrames</b> is the callback function whose outline is given below
</p>
<pre>void processProtocolFrames(uint32_t* queue_number, void* userArg) {
...
...
uint8_t *dstMacId = tempFrame;
ICSS_EmacHandle eipIcssEmacHandle = (ICSS_EmacHandle)userArg;
/*Fetch the packet*/
size = ICSS_EmacRxPktGet(IcssEmacHandle,(uint32_t)tempFrame, *queue_number, &amp;port, &amp;more); 
...
/*Compare Destination MAC ID and determine if this is a DLR packet*/
if(COMPARE_MAC(dstMacId, dlrMAC)) {
  processDLRFrame(eipIcssEmacHandle, tempFrame, port-1, size);
...
...
}

</pre>
<p>As can be seen <b>processProtocolFrames</b> function calls <b>ICSS_EmacRxPktGet</b> internally and passes the data to <b>processDLRFrame</b> for further processing.
</p>
<hr />
<p><br />
</p>
<h5><span class="mw-headline" id="Tx_Data_Path">Tx Data Path</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=17" title="Edit section: Tx Data Path">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p><a href="File_Tx_data_path.html" class="image"><img alt="Tx data path.png" src="https://processors.wiki.ti.com/images/e/e4/Tx_data_path.png" width="500" height="330" /></a>
</p><p>The Transmit path on host is simpler than the Rx path, as far as the developer is concerned the main API call is <b>ICSS_EmacTxPacket</b>, this API implements the Learning/FDB functionality.  <b>ICSS_EmacTxPacket</b> in turn calls another API <b>ICSS_EmacTxPacketEnqueue</b> which performs the actual task of copying data from DDR to L3 and signals the PRU to transmit the data.
</p><p><b>ICSS_EmacTxPacket</b> when called with the parameter <i>ICSS_EMAC_PORT_0</i> in <b>portNumber</b> field enables learning/FDB and calls the <b>ICSS_EmacTxPacketEnqueue</b> with the correct port number and when called with parameter <i>ICSS_EMAC_PORT_1</i> or <i>ICSS_EMAC_PORT_1</i> the API directly calls the underlying API.
</p><p>To avoid confusion developers must always call the API <b>ICSS_EmacTxPacket</b> <span style="color: Red">(not <b>ICSS_EmacTxPacketEnqueue</b>)</span> with <b>portNumber</b> as
</p>
<ul><li><i>ICSS_EMAC_PORT_0</i>&#160;: If they do not know the port number on which to transmit.</li>
<li><i>ICSS_EMAC_PORT_1</i> or <i>ICSS_EMAC_PORT_2</i>&#160;: If they know the port number</li></ul>
<h4><span class="mw-headline" id="Usage">Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=18" title="Edit section: Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>For simple and/or non time critical applications it makes more sense to use the NDK socket API's to perform Receive and Transmit operations. An example using NDK sockets which performs both Rx and Tx is given below. For in depth information on how to use sockets please consult <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/spru523i/spru523i.pdf">NDK User's guide</a> and <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/spru524i/spru524i.pdf">NDK API Reference guide</a>.
</p>
<pre>/*Transmit to System with IP Address*/
#define DST_IP "192.168.1.64"
#define DST_PORT 7
/*Open file session*/
fdOpenSession( (HANDLE)Task_self() );		
SOCKET s = INVALID_SOCKET;
struct sockaddr_in sin1;
struct timeval timeout; 
/*Create UDP socket*/
s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
/*Prepare address for connect*/
IPN IPAddr;
IPAddr = inet_addr(DST_IP);
bzero( &amp;sin1, sizeof(struct sockaddr_in) );
sin1.sin_family = AF_INET;
sin1.sin_addr.s_addr = IPAddr;
sin1.sin_port = htons(DST_PORT); 
 /*Configure our Tx and Rx timeout*/
timeout.tv_sec = 0;
timeout.tv_usec = 1;
setsockopt( s, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, sizeof( timeout ) );
setsockopt( s, SOL_SOCKET, SO_RCVTIMEO, &amp;timeout, sizeof( timeout ) );
/*Transmit packet*/
sendto( s, pBuf, testsize, 0, (PSA)&amp;sin1, sizeof(sin1) );
/*Receive packet*/
recv(s, pBuf, MAX_UDP_SIZE, 0);

</pre>
<p>For time critical applications with low latency requirements directly calling the API's is recommended. For Transmit this can be done by populating the packet directly(or through a stack) in a memory buffer and calling <b>ICSS_EmacTxPacket</b> with the buffer in a task in <b>main()</b>. Shown below is an example of a periodic transmit being done in main function.
</p>
<pre>/**A dummy packet*/
uint8_t dummyPkt[ETHERNET_FRAME_SIZE_60] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,
0x45,0x00,0x00,0x2E,0x00,0x00,0x40,0x00,0x40,0x00,0x3A,0xD1};
Void taskSendPacket(UArg a0, UArg a1) {
  /*wait for system to initialize*/
  /*Send packet in a loop every 500ms*/
  Task_sleep(5000);
  while(1) {
    /*Send packet on PORT 1*. Size is known previously/     
    ICSS_EmacTxPacket(emachandle,dummyPkt, ICSS_EMAC_PORT_1, 1, ETHERNET_FRAME_SIZE_60);
    Task_sleep(500);
  }
}
</pre>
<p>For receive the application/stack can receive the packet data directly in <b>(uint32_t)dest_address</b> from <b>ICSS_EmacRxPktGet</b> inside <b>RxTask</b>. Modify the <b>ethPrioQueue</b> value as per requirement. (Explained above)
</p>
<h3><span class="mw-headline" id="Interrupts_and_Tasks">Interrupts and Tasks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=19" title="Edit section: Interrupts and Tasks">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This section deals with Interrupts and Tasks required to implement an EMAC LLD application. Since they are tied to the RTOS used, they are exported via the driver handle to the application as well as through the OSAL layer. Developers must take care to maintain correct priorities and order so as not to alter the behavior of the driver.
</p><p>All the interrupts and tasks enabled in an application can be checked using the SYSBIOS ROV. For more details on this tool refer to the <a href="ICSS_EMAC_LLD_debug_guide.html#SYS.2FBIOS" title="ICSS EMAC LLD debug guide">SYS/BIOS</a> section of EMAC LLD Debug Guide.
</p>
<h4><span class="mw-headline" id="Interrupts">Interrupts</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=20" title="Edit section: Interrupts">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>There are two types of interrupts 
</p>
<ul><li><i><b>ICSS Interrupts</b></i>&#160;: These are interrupts that are routed through the ICSS Interrupt controller to the Host (Refer to section 4.4.2 of <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/spruh73l/spruh73l.pdf">AM335x TRM</a>). It consists of interrupts asserted by the PRU as well as interrupts asserted by the peripherals (MDIO, ECAP etc) attached to the ICSS Interrupt controller.</li></ul>
<p>The Host Interrupt controller has 8 usable interrupts mapped to the ICSS interrupt controller, this mapping is programmable and varies from example to example. Every example has a <i>x_pruss_intc_mapping.h</i> file in the <i>sdk/examples</i> folder where x stands for the example name. For EMAC this file is called <i>tiemac_pruss_intc_mapping.h</i>.
</p><p><i><b>Mapping Explained</b></i>
</p><p>The interrupt mapping consists of 3 parts
</p>
<ol><li>8 PRU user interrupts (can be set in the firmware by writing to R31) - represented by <i>PRU_ARM_EVENT0</i> to <i>PRU_ARM_EVENT7</i>. These are part of the 64 system interrupts (out of which 32 are usable). This includes the two link interrupts for two ports <i>MII_LINK0_EVENT</i> and <i>MII_LINK1_EVENT</i>.</li>
<li>10 ICSS Host channels <i>CHANNEL0</i> to <i>CHANNEL9</i> out of which the first two <i>CHANNEL0</i> and <i>CHANNEL1</i> are used internally.</li>
<li>8 ARM PRU interrupts represented by <i>PRU_EVTOUT0</i> to <i>PRU_EVTOUT7</i>. These can also be seen in the ARM INTC in SoC TRM. Provided below is a screenshot from AM335x TRM showing the 8 interrupts mapped to the PRU.</li></ol>
<p><a href="File_AM335x-PRUINT.html" class="image"><img alt="AM335x-PRUINT.png" src="https://processors.wiki.ti.com/images/6/6d/AM335x-PRUINT.png" width="500" height="201" /></a>
</p><p>The complete mapping follows the pattern 
</p>
<pre>PRU user interrupts --&gt; Host Channels --&gt; ARM PRU Interrupts

</pre>
<p>To take an example of Rx interrupt for Port 0 (EMAC only). For switch this is the Rx interrupt for both ports.
</p><p>The following line maps PRU user interrupt 0 to Host channel 2.
</p>
<pre>{PRU_ARM_EVENT0,CHANNEL2, SYS_EVT_POLARITY_HIGH ,SYS_EVT_TYPE_PULSE}
</pre>
<p>Host channel <i>CHANNEL2</i> in turn maps to the first ARM interrupt <i>PRU_ICSS_EVTOUT_0</i> through this line.
</p>
<pre>{CHANNEL2, PRU_EVTOUT0}
</pre>
<p>As seen from the screenshot the interrupt number for <i>PRU_ICSS_EVTOUT_0</i> on AM335x is <i>20</i>, so the interrupt number that must be configured for this in application should be 20 if the platform is AM335x. This is done in the following line (defined in <i>main.c</i>)
</p>
<pre>switchEmacCfg-&gt;rxIntNum = 20; 
</pre>
<p>This mapping alone determines which ARM interrupt number will be associated with a particular PRU user interrupt. For example the line above where PRU user interrupt 0 maps to Host channel 2 can be modified to
</p>
<pre>{PRU_ARM_EVENT0,CHANNEL2, SYS_EVT_POLARITY_HIGH ,SYS_EVT_TYPE_PULSE} ---&gt; {PRU_ARM_EVENT0,CHANNEL4, SYS_EVT_POLARITY_HIGH ,SYS_EVT_TYPE_PULSE}
</pre>
<p>and the Channel to ARM interrupt map can be configured as, and the interrupt number on ARM would still remain the same i.e. 20
</p>
<pre>{CHANNEL2, PRU_EVTOUT0} ---&gt;  {CHANNEL4, PRU_EVTOUT0}
</pre>
<p>A question arises in this case as to the usefulness of <i>CHANNELx</i>. The answer is that channels allow us to map multiple PRU User interrupts and system interrupts to a single channel and in turn to a single ARM interrupt. For example take a look at the link interrupt mapping
</p>
<pre>{MII_LINK0_EVENT, CHANNEL7, SYS_EVT_POLARITY_HIGH ,SYS_EVT_TYPE_PULSE},	\
{MII_LINK1_EVENT, CHANNEL7, SYS_EVT_POLARITY_HIGH ,SYS_EVT_TYPE_PULSE},	\
</pre>
<p>and 
</p>
<pre>{CHANNEL7, PRU_EVTOUT6}
</pre>
<p>This configuration maps both Port 0 and Port 1 interrupts to a single channel and in turn to a single ARM interrupt <i>PRU_ICSS_EVTOUT6</i>, which is interrupt number 26 (shown by the line below in <i>main.c</i>)
</p>
<pre>switchEmacCfg-&gt;linkIntNum=26;
</pre>
<p>The link interrupt binds to a single ISR <b>ICSS_EmacLinkISR</b> on Host. Inside the ISR an ICSS register <b>HW_ICSS_INTC_SECR1</b>is checked to find out which link event <i>MII_LINK0_EVENT</i> or <i>MII_LINK1_EVENT</i> asserted the interrupt. The advantage of such an approach is that both interrupts are serviced even if they are raised at the same time.
</p><p>These interrupt numbers can change from SoC to SoC so please consult TRM before making any modifications to the interrupt map. This is also one of the reasons for exporting these configurations to application so that a single driver can handle multiple SoC's others being ease of use, porting other operating systems etc.
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">
  
<caption>PRU interrupts in EMAC
</caption>
<tbody><tr>
<th>PRU Interrupt number
</th>
<th>Channel number
</th>
<th>Host Interrupt number
</th>
<th>ISR
</th></tr>
<tr>
<td>PRU_ARM_EVENT0
</td>
<td>CHANNEL2
</td>
<td>20
</td>
<td><i>ICSS_EmacRxInterruptHandler</i>
<p>(emachandle)
</p>
</td></tr>
<tr>
<td>PRU_ARM_EVENT1
</td>
<td>CHANNEL3
</td>
<td>21
</td>
<td><i>ICSS_EmacRxInterruptHandler</i>
<p>(emachandle1)
</p>
</td></tr>
<tr>
<td>MII_LINK0_EVENT
<p>Port 0 Link interrupt
</p>
</td>
<td>CHANNEL7
</td>
<td>26
</td>
<td><i>ICSS_EmacLinkISR</i>
</td></tr>
<tr>
<td>MII_LINK1_EVENT
<p>Port 1 Link interrupt
</p>
</td>
<td>CHANNEL8
</td>
<td>27
</td>
<td><i>ICSS_EmacLinkISR</i>
</td></tr></tbody></table>
<ul><li><i><b>Host Interrupts</b></i>&#160;: Host interrupts are interrupts that are not coming via ICSS Interrupt controller. These include peripherals, EDMA, timers etc. A full list is present inside the Interrupt section of any TRM. On AM335x a total of 128 interrupts are available through this (including 8 PRU ICSS interrupts). Discussion of Host interrupts is beyond the scope of this guide as we only deal with the EMAC LLD driver here.</li></ul>
<h4><span class="mw-headline" id="Tasks">Tasks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=21" title="Edit section: Tasks">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Tasks are the Linux equivalent of processes in SysBIOS. A simple example to create a task from EMAC application is given below
</p>
<pre> Task_Params_init(&amp;taskParams);
 taskParams.priority = 15;
 taskParams.instance-&gt;name = "SwitchTask";
 Task_create(taskPruss, &amp;taskParams, &amp;eb);
</pre>
<p>Here <b>taskPruss</b> is given the job of initializing the PRU's and loading the firmware onto them. The task itself is a simple function with two arguments
</p>
<pre>/*
 *	---task to initialize PRU---
 */
Void taskPruss(UArg a0, UArg a1)
{
  ...
  ...
  ...
}
</pre>
<p>They can be used for simple tasks like sending or receiving a packet. To get an idea <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#Usage">refer</a> to the example usage for sending a packet through a call to transmit API <b>ICSS_EmacTxPacket</b> in a loop.
</p><p>If calling the task in an endless while loop developers must add a small delay inside the loop using <i>Task_sleep(time in milliseconds)</i> to let other tasks get some time as well, failure to do so is a common mistake that developers make.
</p>
<h3><span class="mw-headline" id="Interrupt_Pacing">Interrupt Pacing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=22" title="Edit section: Interrupt Pacing">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Interrupt pacing is the technique of pausing Rx interrupt to Host so that Host is not interrupted continuously when receiving high traffic. The scenario is explained in the form of a buffer fill and consumer/producer problem. With pacing enabled interrupt is not given until some threshold has been reached. This allows maximum use of buffer space and also allows Host to perform other tasks. 
</p><p><a href="File_Interrupt_pacing.html" class="image"><img alt="Interrupt pacing.png" src="https://processors.wiki.ti.com/images/4/49/Interrupt_pacing.png" width="500" height="254" /></a>
</p><p>The downside is that if a single frame comes then interrupt is not enabled until certain level is reached, causing a delay in response. So the pacing threshold must be chosen carefully.
</p>
<h4><span class="mw-headline" id="Pacing_Modes">Pacing Modes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=23" title="Edit section: Pacing Modes">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Two pacing modes are supported by EMAC/Switch
</p>
<ol><li>Pacing mode 1&#160;: This is based on number of frames. When first interrupt is received, interrupts are disabled until a certain threshold of frames are received. The threshold is programmable. The mode is defined by the enum type <code>INTR_PACING_MODE1</code> and the threshold is defined by the EMAC config variable <code>pacingThreshold</code></li>
<li>Pacing mode 2&#160;: This is based on time. When first interrupt is received, interrupts are disabled and a timer is enabled. The timer upon expiry triggers an interrupt which enables the interrupt again. The mode is defined by the enum type <code>INTR_PACING_MODE2</code> and the timer is a compile time option given by <code>DEFAULT_PACING_TIMER_VAL</code>. DMTimer 4 is used by default for this purpose so please make sure that there are no resource usage conflicts.</li></ol>
<h3><span class="mw-headline" id="Half_Duplex_Support">Half Duplex Support</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=24" title="Edit section: Half Duplex Support">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Half Duplex support is enabled in the Firmware for EMAC and certain protocols like EtherNet/IP. To enable support, the flag <code>halfDuplexEnable</code> must be enabled in EMAC Config. Another requirement for Half Duplex support is enabling the Collision and Carrier Sense signals in MII. This requires pin muxing, consult the Data Sheet for respective protocols to get more details.
</p>
<h3><span id="Learning/FDB"></span><span class="mw-headline" id="Learning.2FFDB">Learning/FDB</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=25" title="Edit section: Learning/FDB">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Learning/FDB where FDB stands for Forwarding Data Base is a module that learns source MAC addresses of packets addressed to the Host and thus maintains a list of which devices reside on which port. While transmitting a packet when provided with the destination MAC address the module returns the port number on which the device resides. This avoids duplication of traffic on both ports. This module is applicable only in Switch mode, in EMAC mode this module is disabled since there is only one port.
</p>
<h4><span class="mw-headline" id="Design">Design</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=26" title="Edit section: Design">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Learning table is currently implemented as a Hash table. There is one table for each physical port. Each table has 256 buckets where a bucket has a size of 4. The bucket size and number of buckets are in turn dictated by the choice of Hashing algorithm. A detailed discussion on this topic is beyond the scope of this document, suffice to say that theoretically a hash table is capable of learning 256 * 4 = 1024 entries. The actual capacity may be lower owing to collisions. 
</p><p>A single bucket has
</p>
<ul><li>Four entries - For storing four MAC Id's</li>
<li>Four ageing counters - One associated with each entry</li>
<li>Number of Entries - A value which tells how many entries are there in the bucket.</li></ul>
<p>A single table has
</p>
<ul><li>256 buckets</li>
<li>Total number of entries - Sum of entries in all the buckets</li>
<li>Port State - A table has three states
<ul><li>Learning - This is the default state. All actions are permitted</li>
<li>Not Learning - No new addresses are learnt. Deletions possible.</li>
<li>Locked - No additions/deletions allowed</li></ul></li></ul>
<p>Collisions are handled using ageing counters, one ageing counter is associated with each of the 4 entries inside a bucket. It tells the module which entries are old and which ones are new.
</p>
<h3><span id="API_Guide_&amp;_Data_Structures"></span><span class="mw-headline" id="API_Guide_.26_Data_Structures">API Guide &amp; Data Structures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=27" title="Edit section: API Guide &amp; Data Structures">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A learning table has the following structure
</p>
<pre>typedef struct HashTable_t{
       
 uint32_t totalNumEntries;	      /**Total number of entries in the hash table*/
 portState state;		      /**State of the hash table, see enum portState above*/
 HashBucket_t  entries[NUMBUCKETS];  /**Number of bucket entries*/
       
} HashTable_t;
</pre>
<p>The individual bucket which makes up the learning table has the following structure
</p>
<pre>typedef struct {
 
 MAC mac[MAX_NUM_ENTRIES];            /**Four MAC Id per bucket*/
 uint8_t timerCount[MAX_NUM_ENTRIES]; /**Timer count used for ageing and conflict resolution*/
 uint8_t numEntries;                  /**Number of MAC entries in the bucket, 4 means it is full*/
  
} HashBucket_t;
</pre>
<p>The default values are 
</p>
<ul><li>NUMBUCKETS      256</li>
<li>MAX_NUM_ENTRIES 4</li></ul>
<p>The algorithm assumes these values and they cannot be changed at present.
</p><p>API descriptions are only for information, developers are requested to use corresponding <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#IOCTL">IOCTL</a> calls. The IOCTL command for Learning/FDB modules is <i><b>ICSS_EMAC_IOCTL_LEARNING_CTRL</b></i>
</p><p><i><b>Adding A MAC address</b></i>&#160;: The corresponding API for this is 
</p>
<pre>void updateHashTable(uint8_t* macId, uint8_t portNum, HashTable_t *tablePtr,ICSS_EmacCallBackConfig* exceptionCallBack)
</pre>
<p>The API is integrated inside <b>ICSS_EmacRxPktGet</b> so developer need not call it separately, if at all it is required please use the IOCTL call for this. IOCTL Param value is <i>ICSS_EMAC_LEARN_CTRL_UPDATE_TABLE</i>
</p><p><i><b>Looking up an Entry</b></i>&#160;: The corresponding API for this is 
</p>
<pre>uint8_t findMAC(const uint8_t * macId, HashTable_t *tablePtr)
</pre>
<p>Integrated with driver inside <b>ICSS_EmacTxPacket</b>, use IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_FIND_MAC</i>
</p><p><i><b>Removing a MAC address</b></i>&#160;: The corresponding API for this is 
</p>
<pre>uint8_t removeMAC(uint8_t * macId, HashTable_t *tablePtr)
</pre>
<p>Entries are removed automatically upon ageing, if forced removal is required use IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_REMOVE_MAC</i>
</p><p><i><b>Ageing an Entry</b></i>&#160;: The driver already implements this inside the periodic task which is called every 100 NDK Ticks <i><b>_HwPktPoll()</b></i> but users can call it as well. IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_INC_COUNTER</i>
</p><p>The corresponding API for this is 
</p>
<pre>void incrementCounter(HashTable_t *tablePtr)
</pre>
<p><i><b>Removing an Aged Entry</b></i>&#160;: The corresponding API for this is 
</p>
<pre>void ageingRoutine(uint8_t portNum, HashTable_t *tablePtr)
</pre>
<p>Integrated with driver. IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_AGEING</i>
</p><p><i><b>Changing Port State</b></i>&#160;: Change the port state to appropriate value. This is useful in the implementation of requirements specified by IEEE 802.1D.
</p><p>The corresponding API for this is
</p>
<pre>void changePortState(portState state, HashTable_t *tablePtr)
</pre>
<p>As part of changing port state the module implements locking of a port (where addition/deletion of entries is not possible), ageing (age the entries to simulate passage of time). Not integrated with driver, application must do it. IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_SET_PORTSTATE</i>
</p><p><i><b>Flushing/Clearing the entire Table</b></i>&#160;: The corresponding API for this is 
</p>
<pre>void purgeTable(uint8_t portNum, HashTable_t *tablePtr)
</pre>
<p>Not integrated with driver, call separately using IOCTL Param value <i>ICSS_EMAC_LEARN_CTRL_CLR_TABLE</i>
</p>
<h4><span class="mw-headline" id="Usage_2">Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=28" title="Edit section: Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The module is integrated with the driver so a developer need not bother about calling the API's separately in the application unless there is a specific need to 
</p>
<ul><li>Add a MAC ID</li>
<li>Remove a MAC ID</li>
<li>Lock the Port or change it's state</li></ul>
<p>The ageing module is called inside <b>_HwPktPoll</b> (which is a periodic NDK task, more info in the porting guide) via an IOCTL call, to age faster please call the routine separately in another task. Changing the time period of <b>_HwPktPoll</b> is not recommended as many other tasks are performed in this.
</p>
<h3><span class="mw-headline" id="Storm_Control">Storm Control</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=29" title="Edit section: Storm Control">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Storm control or Storm prevention is a feature that limits the number of broadcast and multicast packets going to the host and/or cutting through to the other port. Since broadcast and multicast packets are sent over all the ports of a switch they have the potential to create a storm which drowns all other traffic on the network, in this regard this is a very important feature for the switch.
</p>
<h4><span class="mw-headline" id="Design_2">Design</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=30" title="Edit section: Design">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Storm prevention is implemented on the two PRU's as a credit based scheme. When the feature is enabled, every time a multicast or broadcast packet is received a counter referred to as storm prevention credits is decremented and the packet is sent to the host as well as cut through. If the counter value is 0 then the packet is dropped. The counter is stored on respective PRU DMEM's and is reset after a fixed period by the Host. The combination of this period and credit value decides the rate of acceptance/rejection.
</p><p>The mechanism is shown below in the diagram
</p><p><a href="File_Storm_Prevention_architecture_Industrial.html" class="image"><img alt="Storm Prevention architecture Industrial.jpeg" src="https://processors.wiki.ti.com/images/6/66/Storm_Prevention_architecture_Industrial.jpeg" width="300" height="311" /></a>
</p><p>The Storm prevention implementation is similar in both PRU's but implemented separately, so it's possible to turn it off selectively for each port. As of now the multicast and broadcast storm prevention functionalities are clubbed together but it is proposed to have them separate in the future.
</p>
<h4><span id="API_Guide_&amp;_Data_Structures_2"></span><span class="mw-headline" id="API_Guide_.26_Data_Structures_2">API Guide &amp; Data Structures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=31" title="Edit section: API Guide &amp; Data Structures">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The main parent structure for Storm Prevention is 
</p>
<pre>typedef struct {
         
 uint8_t suppressionEnabled;   /** enable/disable storm prevention*/
 uint16_t credits;             /** Number of packets allowed in a time interval*/
  
} stormPrevention_t;
</pre>
<p>There is an instance of this structure for each port
</p><p>API descriptions are only for information, developers are requested to use corresponding <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#IOCTL">IOCTL</a> calls. The IOCTL command for Learning/FDB modules is <i><b>ICSS_EMAC_IOCTL_STORM_PREV_CTRL</b></i>
</p><p><i><b>Enabling Storm Prevention </b></i>&#160;: The corresponding API for this is
</p>
<pre>void ICSS_EmacEnableStormPrevention(uint8_t portnum, ICSS_EmacHandle icssEmacHandle)
</pre>
<p>Corresponding IOCTL Param value is <i>ICSS_EMAC_STORM_PREV_CTRL_ENABLE</i>
</p><p><i><b>Disabling Storm Prevention</b></i>&#160;: Similar to enablement, variable set to False.
The corresponding API for this is
</p>
<pre>void ICSS_EmacDisableStormPrevention(uint8_t portnum, ICSS_EmacHandle icssEmacHandle)
</pre>
<p>IOCTL Param value is <i>ICSS_EMAC_STORM_PREV_CTRL_DISABLE</i>
</p><p><i><b>Resetting the counters</b></i>&#160;: This is called inside <b>_HwPktPoll</b> which is the NDK tick function. The time period of this tick function (default 100ms) in combination with <b>credits</b> value decides the rate at which Storm Prevention works. This is called by default inside the driver.
</p><p>The corresponding API for this is
</p>
<pre>void ICSS_EmacResetStormPreventionCounter(ICSS_EmacHandle icssEmacHandle)
</pre>
<p>IOCTL Param value is <i>ICSS_EMAC_STORM_PREV_CTRL_RESET</i>
</p><p><i><b>Changing the rate</b></i>&#160;: To change how many packets are accepted or rejected change the value in the structure. At every iteration these values are written to the data RAM by the <b>ICSS_EmacResetStormPreventionCounter</b> API. The scheme through which this occurs is explained in the design description above
</p><p>The corresponding API for this is
</p>
<pre>void setCreditValue(uint16_t creditValue, stormPrevention_t* stormPrevPtr)
</pre>
<p>IOCTL Param value is <i>ICSS_EMAC_STORM_PREV_CTRL_SET_CREDITS</i>
</p>
<h4><span class="mw-headline" id="Usage_3">Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=32" title="Edit section: Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Most often Storm Prevention is the main reason for users not being able to receive a packet, esp if the rate is configured incorrectly. So first verify if it is enabled for that port. This can be done by 
</p>
<ul><li>Checking structure variable&#160;: See the value of <b>suppressionEnabled</b> variable in the structure.</li>
<li>Checking memory&#160;: See the memory offset STORM_PREVENTION_OFFSET in the corresponding data RAM. The first bit of the byte location tells you whether the logic is enabled on the port.</li>
<li>Disabling Storm Prevention&#160;: This is the easiest and preferable for someone not using an emulator. Use the corresponding IOCTL call.</li></ul>
<p>To quickly verify if the logic is indeed dropping packets, try sending some broadcast packets at line rate to the device and check the value of PRU statistics variable <b>stormPrevCounter</b>. See statistics section on how to read this variable.
</p>
<h3><span class="mw-headline" id="Statistics">Statistics</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=33" title="Edit section: Statistics">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Statistics on ICSS Switch provide a great deal of information on what's going on with the switch. They are enabled by default and provide provide port specific statistics. They are also a great debugging tool and should be the first thing a developer should look at if they suspect any issue with Rx or Tx.
</p>
<h4><span class="mw-headline" id="Design_3">Design</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=34" title="Edit section: Design">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The Statistics are divided into
</p>
<ul><li><i><b>Statistics on PRU</b></i>&#160;: Since the LLD functionality is implemented on the PRU's the majority of statistics are implemented on them. The count for each port is stored on the respective Data RAM's starting at the offset STATISTICS_OFFSET. The map is shown below</li>
<li><i><b>Statistics on Host</b></i>&#160;: The packets coming to the Host are counted once again, this is useful for debugging purposes and to measure throughput (from the PRU to Host) if required. Some statistics like "Unknown protocol type" are only implemented on the Host.</li></ul>
<p>Functionally the statistics are classified into 
</p>
<ul><li><i><b>Rx/Tx related statistics</b></i>&#160;: This includes count of broadcast, multicast and unicast packets and their derivatives. Only valid packets are part of this which means that an Rx packet which has been dropped because of storm prevention will not be counted.</li>
<li><i><b>Error Counters</b></i>&#160;: This includes statistics such as Dropped frames, Rx/Tx errors etc.</li>
<li><i><b>Other statistics</b></i>&#160;: Includes statistics related to 802.1 CSMA/CD, number of link breaks etc.</li></ul>
<p>A description of PRU statistics along with corresponding memory map is given below. 
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">
<caption><i><b>PRU Statistics Description &amp; Memory Map</b></i>
</caption>
<tbody><tr>
<th>Name of Variable
</th>
<th>Description
</th>
<th>Name of Offset
<p>Refer to <i>icss_emacSwitch.h</i>
</p>
</th>
<th>Offset in PRU DRAM 0/1
</th></tr>
<tr>
<td><b>txBcast</b>
</td>
<td>Number of broadcast packets sent
</td>
<td><i>TX_BC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F00</i>
</td></tr>
<tr>
<td><b>txMcast</b>
</td>
<td>Number of multicast packets sent
</td>
<td><i>TX_MC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F04</i>
</td></tr>
<tr>
<td><b>txUcast</b>
</td>
<td>Number of unicast packets sent
</td>
<td><i>TX_UC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F08</i>
</td></tr>
<tr>
<td><b>txOctets</b>
</td>
<td>Total number of octets sent, includes all packets
</td>
<td><i>TX_BYTE_CNT_OFFSET</i>
</td>
<td><i>0x1F0C</i>
</td></tr>
<tr>
<td><b>rxBcast</b>
</td>
<td>Number of broadcast packets received
</td>
<td><i>RX_BC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F10</i>
</td></tr>
<tr>
<td><b>rxMcast</b>
</td>
<td>Number of multicast packets received
</td>
<td><i>RX_MC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F14</i>
</td></tr>
<tr>
<td><b>rxUcast</b>
</td>
<td>Number of unicast packets received
</td>
<td><i>RX_UC_FRAMES_OFFSET</i>
</td>
<td><i>0x1F18</i>
</td></tr>
<tr>
<td><b>rxOctets</b>
</td>
<td>Total number of octets received, includes all packets
</td>
<td><i>RX_BYTE_CNT_OFFSET</i>
</td>
<td><i>0x1F1C</i>
</td></tr>
<tr>
<td><b>tx64byte</b>
</td>
<td>Transmitted frames with size &lt;= 64 bytes
</td>
<td><i>TX_64_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F20</i>
</td></tr>
<tr>
<td><b>tx65_127byte</b>
</td>
<td>Transmitted frames with size &gt;= 65 bytes and &lt;= 127 bytes
</td>
<td><i>TX_65_127_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F24</i>
</td></tr>
<tr>
<td><b>tx128_255byte</b>
</td>
<td>Transmitted frames with size &gt;= 128 bytes and &lt;= 255 bytes
</td>
<td><i>TX_128_255_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F28</i>
</td></tr>
<tr>
<td><b>tx256_511byte</b>
</td>
<td>Transmitted frames with size &gt;= 256 bytes and &lt;= 511 bytes
</td>
<td><i>TX_256_511_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F2C</i>
</td></tr>
<tr>
<td><b>tx512_1023byte</b>
</td>
<td>Transmitted frames with size &gt;= 512 bytes and &lt;= 1023 bytes
</td>
<td><i>TX_512_1023_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F30</i>
</td></tr>
<tr>
<td><b>rx64byte</b>
</td>
<td>Received frames with size &lt;= 64 bytes
</td>
<td><i>RX_64_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F34</i>
</td></tr>
<tr>
<td><b>rx65_127byte</b>
</td>
<td>Received frames with size &gt;= 65 bytes and &lt;= 127 bytes
</td>
<td><i>RX_65_127_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F38</i>
</td></tr>
<tr>
<td><b>rx128_255byte</b>
</td>
<td>Received frames with size &gt;= 128 bytes and &lt;= 255 bytes
</td>
<td><i>RX_128_255_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F3C</i>
</td></tr>
<tr>
<td><b>rx256_511byte</b>
</td>
<td>Received frames with size &gt;= 256 bytes and &lt;= 511 bytes
</td>
<td><i>RX_256_511_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F40</i>
</td></tr>
<tr>
<td><b>rx512_1023byte</b>
</td>
<td>Received frames with size &gt;= 512 bytes and &lt;= 1023 bytes
</td>
<td><i>RX_512_1023_BYTE_FRAME_OFFSET</i>
</td>
<td><i>0x1F44</i>
</td></tr>
<tr>
<td><b>lateColl</b>
</td>
<td>Number of packets that suffered collisions late into Tx
</td>
<td><i>LATE_COLLISION_OFFSET</i>
</td>
<td><i>0x1F48</i>
</td></tr>
<tr>
<td><b>singleColl</b>
</td>
<td>Number of packets that suffered collision only once
</td>
<td><i>SINGLE_COLLISION_OFFSET</i>
</td>
<td><i>0x1F4C</i>
</td></tr>
<tr>
<td><b>multiColl</b>
</td>
<td>Number of packets that suffered collisions more than once
</td>
<td><i>MULTIPLE_COLLISION_OFFSET</i>
</td>
<td><i>0x1F50</i>
</td></tr>
<tr>
<td><b>excessColl</b>
</td>
<td>Number of packets that suffered collisions more than 15 times
</td>
<td><i>EXCESS_COLLISION_OFFSET</i>
</td>
<td><i>0x1F54</i>
</td></tr>
<tr>
<td><b>rxMisAlignmentFrames</b>
</td>
<td>Number of frames with uneven number of bytes in an octet
<p>(This is not tested)
</p>
</td>
<td><i>RX_MISALIGNMENT_COUNT_OFFSET</i>
</td>
<td><i>0x1F58</i>
</td></tr>
<tr>
<td><b>stormPrevCounter</b>
</td>
<td>Number of packets dropped due to storm prevention
</td>
<td><i>STORM_PREVENTION_COUNTER</i>
</td>
<td><i>0x1F5C</i>
</td></tr>
<tr>
<td><b>macRxError</b>
</td>
<td>Number of packets with Rx MAC Error
</td>
<td><i>RX_ERROR_OFFSET</i>
</td>
<td><i>0x1F60</i>
</td></tr>
<tr>
<td><b>SFDError</b>
</td>
<td>Number of packets with incorrect SFD
</td>
<td><i>SFD_ERROR_OFFSET</i>
</td>
<td><i>0x1F64</i>
</td></tr>
<tr>
<td><b>defTx</b>
</td>
<td>Number of packets deferred at least once due to CS high signal
</td>
<td><i>TX_DEFERRED_OFFSET</i>
</td>
<td><i>0x1F68</i>
</td></tr>
<tr>
<td><b>macTxError</b>
</td>
<td>Number of packets facing Tx MAC Error
</td>
<td><i>TX_ERROR_OFFSET</i>
</td>
<td><i>0x1F6C</i>
</td></tr>
<tr>
<td><b>rxOverSizedFrames</b>
</td>
<td>Number of packets &gt;1518 bytes
</td>
<td><i>RX_OVERSIZED_FRAME_OFFSET</i>
</td>
<td><i>0x1F70</i>
</td></tr>
<tr>
<td><b>rxUnderSizedFrames</b>
</td>
<td>Number of packets &lt; 60 bytes
</td>
<td><i>RX_UNDERSIZED_FRAME_OFFSET</i>
</td>
<td><i>0x1F74</i>
</td></tr>
<tr>
<td><b>rxCRCFrames</b>
</td>
<td>Frames with CRC/FCS Error
</td>
<td><i>RX_CRC_COUNT_OFFSET</i>
</td>
<td><i>0x1F78</i>
</td></tr>
<tr>
<td><b>droppedPackets</b>
</td>
<td>Number of Received packets that were not transmitted because of link loss
</td>
<td><i>RX_DROPPED_FRAMES_OFFSET</i>
</td>
<td><i>0x1F7C</i>
</td></tr>
<tr>
<td><b>txOverFlow</b>
</td>
<td>Transmit FIFO overflow count, not part of standard MIB, for debug
</td>
<td><i>TX_FIFO_OVERFLOW_COUNT_OFFSET</i>
</td>
<td><i>0x1F80</i>
</td></tr>
<tr>
<td><b>txUnderFlow</b>
</td>
<td>Transmit FIFO underflow count, not part of standard MIB, for debug
</td>
<td><i>TX_FIFO_UNDERFLOW_COUNT_OFFSET</i>
</td>
<td><i>0x1F84</i>
</td></tr></tbody></table>
<h4><span id="API_Guide_&amp;_Data_Structures_3"></span><span class="mw-headline" id="API_Guide_.26_Data_Structures_3">API Guide &amp; Data Structures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=35" title="Edit section: API Guide &amp; Data Structures">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>As discussed above there are two data structures for Statistics.
</p>
<ol><li>PRU based</li>
<li>On Host</li></ol>
<p>Shown below are the members of Host Statistics. The members of PRU statistics are listed in the memory map.
</p>
<pre>typedef struct {
 
 volatile uint32_t txUcast;			/**Number of unicast packets sent*/
 volatile uint32_t txBcast;			/**Number of broadcast packets sent*/
 volatile uint32_t txMcast;			/**Number of multicast packets sent*/
 volatile uint32_t txOctets;			/**Number of bytes sent*/
 volatile uint32_t rxUcast;			/**Number of unicast packets rcvd*/
 volatile uint32_t rxBcast;			/**Number of broadcast packets rcvd*/
 volatile uint32_t rxMcast;			/**Number of multicast packets rcvd*/
 volatile uint32_t rxOctets;			/**Number of Rx packets*/
 volatile uint32_t rxUnknownProtocol;	        /**Number of packets with unknown protocol*/
 volatile uint32_t linkBreak;			/**Number of link breaks*/
 
}ICSS_EmacHostStatistics_t;
</pre>
<p>As one can see most of the members are identical to that of PRU statistics (they are a subset) and if all packets are sent to the Host then these member values for PRU and Host statistics should match.
</p><p>API descriptions are only for information, developers are requested to use corresponding <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#IOCTL">IOCTL</a> calls. The IOCTL command for Statistics module is <i><b>ICSS_EMAC_IOCTL_STATS_CTRL</b></i>
</p><p><i><b>Reading PRU Statistics </b></i>&#160;: To fetch PRU statistics an M2M copy is done from the PRU Data RAM to the PRU statistics structure on DDR. To get the values correctly the memory layout on both sides should be identical. <span style="color: red">Developers should not modify the member order in <b>pruStatistics_t. Doing so can give incorrect results</b></span>
</p><p>Host statistics are updated on the fly in the structure as packets are received (<b>ICSS_EmacUpdateRxStats</b> ) or transmitted (<b>ICSS_EmacUpdateTxStats</b> ) so there is no separate API to collate them.
</p><p>The corresponding API for this is
</p>
<pre>void ICSS_EmacReadStats(uint8_t portNum, ICSS_EmacHandle icssEmacHandle)
</pre>
<p>IOCTL Param value is <i>ICSS_EMAC_IOCTL_STAT_CTRL_GET</i>
</p><p><i><b>Clearing PRU and Host Statistics </b></i>&#160;: To clear the values do memory write to the structure memory, PRU data RAM and initialize to 0. 
</p><p>The corresponding API for this is
</p>
<pre>void PurgeStats(uint8_t portNum, ICSS_EmacHandle icssEmacHandle)
</pre>
<p>IOCTL Param value is <i>ICSS_EMAC_IOCTL_STAT_CTRL_CLEAR</i>
</p>
<h4><span class="mw-headline" id="Usage_4">Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=36" title="Edit section: Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Statistics are a great tool to debug issues on the switch. To get them in the application use the IOCTL calls to get and clear statistics
</p><p>While IOCTL calls provide access to statistics in the application. If someone is using CCS then another quick way to see if there is any activity on the Ports is to directly go to the PRU data RAM offset <i>STATISTICS_OFFSET</i> and see the values directly in memory Refer Debug guide on how to see data RAM values directly in CCS.
</p>
<h2><span class="mw-headline" id="Memory_Map">Memory Map</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=37" title="Edit section: Memory Map">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The memory map here refers to the Shared Data RAM memory map in ICSS. L3 map is not of much use to the developer while DDR map is dynamic and is part of the application. The goal of providing this is to help the developer in debugging. Based on the memory map one can directly look at the memory in a CCS + Emulator environment and verify if driver/firmware is working correctly.
</p><p>What is depicted below is the Memory map for icss_dualmac firmware. 
The memory map can be found in <i>icss_emacSwitch.h</i> under <i>ti/drv/icss_emac/firmware/icss_dualemac/src</i>. Memory map details for switch firmware 
can also be found in icss_emacSwitch.h.
</p><p><br />
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">
  
<caption><i><b>ICSS Shared Memory Map</b></i>
</caption>
<tbody><tr>
<th>Shared Memory Offset
</th>
<th>Value
</th>
<th>PRU0 Data RAM
</th>
<th>Value
</th>
<th>PRU1 Data RAM
</th>
<th>Value
</th></tr>
<tr>
<td>0x0000 - 0x0400
</td>
<td>Reserved for Future Use
</td>
<td>0x0000 - 0x0400
</td>
<td>Reserved for Future Use
</td>
<td>0x0000 - 0x0400
</td>
<td>Reserved for Future Use
</td></tr>
<tr>
<td>0x0400-0x1CA0
</td>
<td>Buffer Descriptor Offsets
</td>
<td>0x0400-0x1E98
</td>
<td>Available for Protocol/Application
</td>
<td>0x0400-0x1E98
</td>
<td>Available for Protocol/Application
</td></tr>
<tr>
<td>0x1CA0-0x1FA0
</td>
<td>Available for Protocol/Application
</td>
<td>0x1E98-0x1F00
</td>
<td>Queue Context Offsets, TTS Control Variables
</td>
<td>0x1E98-0x1F00
</td>
<td>Queue Context Offsets, TTS Control Variables
</td></tr>
<tr>
<td>0x1FA0-0x3000
</td>
<td>Empty
</td>
<td>0x1F00-0x1FA9
</td>
<td>Port0 Statistics
<p>(Map provided <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#Design_3">above</a>)
</p>
</td>
<td>0x1F00-0x1FA9
</td>
<td>Port1 Statistics
<p>(Map provided <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#Design_3">above</a>)
</p>
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>0x1F90
</td>
<td>Port0 Storm Prevention
<p>Control Variable
</p>
</td>
<td>0x1F90
</td>
<td>Port1 Storm Prevention
<p>Control Variable
</p>
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>0x1F94
</td>
<td>Port0 Link Speed
<p>0x64 - 100Mbps
</p><p>0xA - 10Mbps
</p>
</td>
<td>0x1F94
</td>
<td>Port1 Link Speed
<p>Same as Port0
</p><p>Any other value is illegal
</p>
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>0x1F98
</td>
<td>Port0 Link Status
<p>0x1 - Link Up
</p><p>0x0 - Link Down
</p>
</td>
<td>0x1F98
</td>
<td>Port1 Link Status
<p>Same as Port0
</p>
</td></tr>

<tr>
<td>
</td>
<td>
</td>
<td>0x1F98
</td>
<td>Port0 Duplex Status
<p>Uses same location as link status, 2nd bit shows duplexity.
A 1 in 2nd bit means port is HD
</p>
</td>
<td>0x1F98
</td>
<td>Port1 Duplex Status
<p>Same as Port0
</p>
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>0x1F9E
</td>
<td>Port0 Control
<p>0x1 - Rx Enabled
</p><p>0x0 - Rx Disabled
</p>
</td>
<td>0x1F9E
</td>
<td>Port1 Control
<p>Same as Port0
</p>
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>0x1FA2
</td>
<td>Port0 MAC ID
<p>6 bytes
</p>
</td>
<td>0x1FA2
</td>
<td>Port1 MAC ID
<p>6 bytes
</p>
</td></tr></tbody></table>
<h2><span class="mw-headline" id="RTOS">RTOS</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=38" title="Edit section: RTOS">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The Processor SDK uses <a rel="nofollow" class="external text" href="Category_SYSBIOS.html">SYS/BIOS</a> as it's RTOS. Configuration for the RTOS is done through RTSC tool chain integrated with CCS. SYS/BIOS is provided free of cost and is a very capable RTOS for typical use cases with minimal latency. 
</p><p>The driver is written in a manner such that there is very little dependency on the Operating System. All dependence on SYS/BIOS is abstracted to OSAL (Operating System Abstraction Layer) and developers are integrate their own operating systems.
</p><p>OSAL consists of
</p>
<ol><li>Interrupt management which is provided as part of TI's OSAL library (ti/osal)</li>
<li>Task and Semaphore management which is provided as part to TI's OSAL library (ti/osal)</li>
<li>Management of peripherals like BIOS Timers which is currently being provided as part of the ICSS_EMAC LLD under the "test" directory. Please refer to ti/drv/icss_emac/test/src/icss_emac_osal.c</li></ol>
<h4><span class="mw-headline" id="Porting_Driver_to_LINUX">Porting Driver to LINUX</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=39" title="Edit section: Porting Driver to LINUX">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The icss-emac driver was initially written using TI-RTOS. The following areas should be considered when porting to another OS (operating system), for example LINUX.
</p>
<h5><span class="mw-headline" id="Memory_Map_2">Memory Map</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=40" title="Edit section: Memory Map">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<ul><li>Memory Map: The ICSS_EMAC driver requires base addresses for different memory regions and control registers to be provided as part of driver initialization. It is the responsibility of the application to configure these addresses with the driver. For TI-RTOS, no address mapping is required and the addresses as defined by the SOC memory map header file provided by the CSL layer can be used directly.  For other operating systems, eg LINUX, these addresses need to be mapped to a virtual address space before user space can access them. It will be the responsibility of the user space application to memory map the required regions. This can be accomplished by using the  Userspace I/O (UIO) driver. The UIO driver utilized linux like file I/O operations (such as open(), close(), read(), write(), etc) to perform the memory mapping. Once the regions are memory mapped, they can be provided to the driver at time of driver initialization.</li></ul>
<h5><span class="mw-headline" id="Interrupts_2">Interrupts</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=41" title="Edit section: Interrupts">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<ul><li>Interrupt Registration: For TI-RTOS use case, interrupts generated on the PRU-ICSS core need to be crossbar-ed to an available in interrupt line on the CORE on which the application is running in order for the interrupt to be detected by the CORE. The interrupt and its corresponding ISR then can be registered with SYSBIOS using the OSAL layer provided by the driver and ti-osal library. For LINUX use case, the UIO driver will be required to memory map PRU-ICSS core device interrupts and have them available linux user space application. This is similar to what is required to memory map the regions as specified in the Memory Map section above.</li></ul>
<p><br />
</p>
<h2><span id="TCP/IP"></span><span class="mw-headline" id="TCP.2FIP">TCP/IP</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=42" title="Edit section: TCP/IP">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The Industrial SDK uses <a rel="nofollow" class="external text" href="http://www.ti.com/tool/NDKTCPIP">NDK</a> as it's TCP/IP stack. API reference guide <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/spru524i/spru524i.pdf">here</a>. Like SYS/BIOS the module is imported externally through RTSC (refer Debug Guide) and managed through the application configuration file (<i><b>am335x_app.cfg</b></i> and <i><b>am437x_app.cfg</b></i>) 
</p><p>NDK recommends it's own abstraction layer which is called NIMU (Network Interface Management Unit). This layer is implemented in the nimu_icss driver (ti/transport/ndk/nimu_icss). Relevant source files are
</p>
<ul><li><i>nimu_icssEth.c</i></li>
<li><i>nimu_icssEthDriver.c</i></li>
<li><i>nimu_icssSwitchEmac.c</i></li>
<li><i>nimu_icssMdio.c</i></li></ul>
<p>Understanding the NIMU layer helps in porting another TCP/IP stack to the example. The NIMU layer is explained in this <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/sprufp2a/sprufp2a.pdf">guide</a>
</p><p><br />
</p>
<h2><span class="mw-headline" id="IOCTL">IOCTL</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=43" title="Edit section: IOCTL">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>IOCTL implementation for the switch drivers is identical to the Unix/Linux based IOCTL calls. They provide the application a convenient method to access driver/kernel space parameters or modify them. 
</p><p>Developers are expected to familiarize themselves with the full list of IOCTL calls so that they can utilize all the features provided. This is even more important when working in an Application/OS kind of environment where access to an emulator is not available.
</p>
<h3><span class="mw-headline" id="Design_4">Design</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=44" title="Edit section: Design">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The primary IOCTL call is through the API <b>ICSS_EmacIoctl</b> which is implemented in the file icss_emacFwInit.c
An IOCTL call uses two parameters to find out which driver API to call
</p>
<ol><li><b>ioctlCommand</b>&#160;: Is used to locate the module (Statistics/ Port control etc) which should be called.</li>
<li><b>ioctlParams</b>&#160;: Is used to give module specific instructions</li></ol>
<p><i><b>ioctlParams</b></i> consists of
</p>
<ul><li><b>command</b>&#160;: Indicates which specific API to execute</li>
<li><b>ioctlVal</b>&#160;: Sometimes the API may require specific input, this is used to provide that.</li></ul>
<p>For <u>example</u> to disable receive functionality on a port the following code is used. This code is part of Link interrupt functionality where receive is disabled when PHY detects a link down.
</p>
<pre>ioctlvalue = ICSS_EMAC_IOCTL_PORT_CTRL_DISABLE;
ioctlParams.ioctlVal = &amp;ioctlvalue;
ICSS_EmacIoctl(icssEmacHandle, ICSS_EMAC_IOCTL_PORT_CTRL, ICSS_EMAC_PORT_1, (void*)&amp;ioctlParams); 
</pre>
<p>Here <i>ICSS_EMAC_IOCTL_PORT_CTRL</i> refers to the <i><b>ioctlCommand</b></i> while <i>ICSS_EMAC_IOCTL_PORT_CTRL_DISABLE</i> is the <i><b>command</b></i> part of  <b>ioctlParams</b> which tells which action to perform, in this case disabling the port. Port selected is <i>ICSS_EMAC_PORT_1</i> which refers to Port 1.
</p><p>A complete list of commands and actions is given below.
</p>
<h3><span id="API_Guide_&amp;_Data_Structures_4"></span><span class="mw-headline" id="API_Guide_.26_Data_Structures_4">API Guide &amp; Data Structures</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=45" title="Edit section: API Guide &amp; Data Structures">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>IOCTL Command structure
</p>
<pre> typedef struct ICSSEMAC_IoctlCmd {
   uint8_t command;
   uint8_t* ioctlVal;
 }ICSSEMAC_IoctlCmd;
</pre>
<p>There is only one API for IOCTL. It's defined below
</p>
<pre>uint8_t ICSS_EmacIoctl(ICSS_EmacHandle icssEmacHandle, uint32_t ioctlCommand, uint8_t portNo, void *ioctlParams)
</pre>
<p>The possible values for <i><b>ioctlCommand</b></i> are 
</p>
<ul><li><i>ICSS_EMAC_IOCTL_PORT_CTRL</i>&#160;: Select Port Control operations. Enable/Disable Rx for the specified port</li>
<li><i>ICSS_EMAC_IOCTL_LEARNING_CTRL</i>&#160;: Select Learning/FDB module.</li>
<li><i>ICSS_EMAC_IOCTL_STORM_PREV_CTRL</i>&#160;: Select Storm Prevention module</li>
<li><i>ICSS_EMAC_IOCTL_STATS_CTRL</i>&#160;: Select statistics module</li></ul>
<p>Possible values for <i><b>ioctlParams</b></i> are
</p>
<ul><li><b>ICSS_EMAC_IOCTL_LEARNING_CTRL</b>&#160;: Refer to Learning/FDB API's
<ul><li><i>ICSS_EMAC_LEARN_CTRL_UPDATE_TABLE</i>&#160;: Add an entry to the Hash table.</li>
<li><i>ICSS_EMAC_LEARN_CTRL_CLR_TABLE</i>&#160;: Clear the Learning Table for the specified port.</li>
<li><i>ICSS_EMAC_LEARN_CTRL_AGEING</i>&#160;: Age out old entries from the table.</li>
<li><i>ICSS_EMAC_LEARN_CTRL_FIND_MAC</i>&#160;: Find the port number given a MAC ID.</li>
<li><i>ICSS_EMAC_LEARN_CTRL_REMOVE_MAC</i>&#160;: Remove a MAC ID from the Learning Table</li>
<li><i>ICSS_EMAC_LEARN_CTRL_INC_COUNTER</i>&#160;: Age the entries with time by calling this periodically</li>
<li><i>ICSS_EMAC_LEARN_CTRL_INIT_TABLE</i>&#160;: Initialize the learning table</li>
<li><i>ICSS_EMAC_LEARN_CTRL_SET_PORTSTATE</i>&#160;: Set the Port state to value defined by the enum type <b>portState</b></li></ul></li></ul>
<ul><li><b>ICSS_EMAC_IOCTL_STATS_CTRL</b>&#160;: Refer to Statistics API's
<ul><li><i>ICSS_EMAC_IOCTL_STAT_CTRL_GET</i>&#160;: Get the statistics</li>
<li><i>ICSS_EMAC_IOCTL_STAT_CTRL_CLEAR</i>&#160;: Clear all stat counters</li></ul></li></ul>
<ul><li><b>ICSS_EMAC_IOCTL_STORM_PREV_CTRL</b>&#160;: Refer to Storm prevention API's
<ul><li><i>ICSS_EMAC_STORM_PREV_CTRL_ENABLE</i>&#160;: Enable Storm Prevention</li>
<li><i>ICSS_EMAC_STORM_PREV_CTRL_DISABLE</i>&#160;: Disable Storm Prevention</li>
<li><i>ICSS_EMAC_STORM_PREV_CTRL_SET_CREDITS</i>&#160;: Set how many BC/MC packets are allowed in a period of 100 NDK Ticks (Time period of <b>_HwPktPoll()</b>)</li>
<li><i>ICSS_EMAC_STORM_PREV_CTRL_INIT</i>&#160;: Initialize Storm Prevention</li>
<li><i>ICSS_EMAC_STORM_PREV_CTRL_RESET</i>&#160;: Renew the storm prevention counters, this allows more packets to come through once existing credits have expired. This must be called periodically in <b>_HwPktPoll()</b></li></ul></li></ul>
<ul><li><b>ICSS_EMAC_IOCTL_PORT_CTRL</b>&#160;: For Rx Enable/Disable operations. There are no sub-commands here. Whether to enable or disable is decided by the value of <i><b>ioctlVal</b></i></li></ul>
<h3><span class="mw-headline" id="Usage_5">Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=46" title="Edit section: Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Using IOCTL to debug the issues is encouraged. This is easier than trying to connect an emulator and reading the values at run time. There are numerous instances of it's usage. A quick search for the API <b>ICSS_EmacIoctl</b> throughout the code reveals numerous examples. One of them pertaining to Storm Control module is shown below.
</p><p>In this example the storm prevention counters are reset in PRU Data RAM using IOCTL. The <b>if/else</b> refers to Switch or EMAC mode, rest of the code is self-explanatory
</p>
<pre> ioctlParams.command = ICSS_EMAC_STORM_PREV_CTRL_RESET;
 /*Reset the credit values used for Storm prevention*/
 if(ICSS_EMAC_MODE_SWITCH == ((ICSS_EmacObject*)(pi-&gt;nimuDrvHandle)-&gt;object)-&gt;emacInitcfg-&gt;portMask)
 {
   strmPreventionEnable1 = (stormPrevention_t*)(((ICSS_EmacObject*)(pi-&gt;nimuDrvHandle)-&gt;object)-&gt;stormPrevPtr);
   strmPreventionEnable2 = (stormPrevention_t*)(((ICSS_EmacObject*)(pi-&gt;nimuDrvHandle)-&gt;object)-&gt;stormPrevPtr +1);
   if(strmPreventionEnable1-&gt;suppressionEnabled ||	strmPreventionEnable2-&gt;suppressionEnabled)
   	ICSS_EmacIoctl(pi-&gt;nimuDrvHandle, ICSS_EMAC_IOCTL_STORM_PREV_CTRL, NULL, (void*)&amp;ioctlParams);
 }
 else
 {
   strmPreventionEnable1 = (stormPrevention_t*)(((ICSS_EmacObject*)(pi-&gt;nimuDrvHandle)-&gt;object)-&gt;stormPrevPtr);
   if(strmPreventionEnable1-&gt;suppressionEnabled)
   	ICSS_EmacIoctl(pi-&gt;nimuDrvHandle, ICSS_EMAC_IOCTL_STORM_PREV_CTRL, NULL, (void*)&amp;ioctlParams);
 }
</pre>
<h2><span class="mw-headline" id="ICSS_EMAC_LLD_Dependencies">ICSS EMAC LLD Dependencies</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=47" title="Edit section: ICSS EMAC LLD Dependencies">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>ICSS EMAC LLD is dependent on the Application/Transport layer for its proper functioning. These dependencies have been consolidated and exported to the application layer (example) to make it easy for developer to integrate the LLD with their own RTOS and TCP/IP stack.
</p>
<h3><span class="mw-headline" id="Interrupt_Configuration">Interrupt Configuration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=48" title="Edit section: Interrupt Configuration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>ICSS EMAC LLD expects the Interrupt configuration to come from Application/Transport layer. The interrupt configuration is explained in detail in the interrupts <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#Interrupts">section</a>. Please refer to it for more details.
</p><p>The LLD makes use of two interrupts for copying packets from the queues to the TCP/IP stack.
</p>
<h4><span class="mw-headline" id="Rx_Interrupt">Rx Interrupt</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=49" title="Edit section: Rx Interrupt">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The ICSS EMAC LLD depends on the Rx interrupt for receiving packets.The application should do the interrupt creation and should use the API ICSS_EmacRxInterruptHandler as the ISR.This will enable the ICSS EMAC LLD to receive packets. The user should make sure the arm interrupt (Rx) is mapped to correct PRUSS Event. The PRUSS Event that is used for Rx will be determined by the firmware which will be used along with the ICSS EMAC LLD. The LLD expects a single interrupt for both Ports in Switch Mode and single interrupt per Port in Emac Mode.
</p>
<h4><span class="mw-headline" id="Link_Interrupt">Link Interrupt</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=50" title="Edit section: Link Interrupt">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Link Interrupt informs the ICSS EMAC LLD of any Link state change. This is where the LLD informs the firmware about the Link status and the Phy configuration.The LLD expects single interrupt for both Ports in Switch Mode and a single interrupt per Port in Emac Mode. In case the Interrupt mechanism is not available, the application should call <code>ICSS_EmacLinkISR</code> whenever there is a link change.
</p><p><br />
</p>
<h4><span class="mw-headline" id="Transmit_Complete_Interrupt">Transmit Complete Interrupt</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=51" title="Edit section: Transmit Complete Interrupt">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Transmit Complete Interrupt informs the ICSS EMAC LLD when the PRU-ICSS firmware has finished placing the frame be be transmitted on the wire. The LLD expects a single interrupt for both Ports in Switch Mode and single interrupt per Port in Emac Mode.
</p>
<h3><span class="mw-headline" id="Learning_module_Increment_counter_implementation">Learning module Increment counter implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=52" title="Edit section: Learning module Increment counter implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This is required for Switch implementation only. The application needs to call the IOCTL periodically, this is already done by the NDK. Refer to the API <a rel="nofollow" class="external text" href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#API_Guide_.26_Data_Structures">section</a> of Learning for more details.
</p>
<h3><span class="mw-headline" id="MDIO_Configurations">MDIO Configurations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=53" title="Edit section: MDIO Configurations">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>ICSS EMAC LLD does not do any of the MDIO configurations. It expects the application to do following MDIO operations 
</p>
<ul><li>MDIO Initialization</li>
<li>MDIO Link Interrupt enable if MDIO Link interrupt is used</li></ul>
<p>Please refer to ti/drv/icss_emac/test/src/test_mdio.c for implementation details.
</p><p><br />
</p>
<h2><span class="mw-headline" id="EMAC_Configuration_and_How_To">EMAC Configuration and How To</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=54" title="Edit section: EMAC Configuration and How To">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="Configuration_Parameters">Configuration Parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=55" title="Edit section: Configuration Parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>EMAC configuration is defined by the structure <code>ICSSEMAC_InitConfig</code>
The structure members are
</p>
<ul><li><code>phyAddr</code>&#160;: is a two element array which contains the MDIO PHY Address for each of the two ports.</li>
<li><code>halfDuplexEnable</code>&#160;: If Half Duplex must be supported then this variable has to be enabled. Please note that Half Duplex also must be supported by the specific protocol firmware</li>
<li><code>enableIntrPacing</code>&#160;: Enable interrupt pacing. Interrupt pacing is explained above.</li>
<li><code>pacingThreshold</code>&#160;: Threshold for number of frames in interrupt pacing mode 1. See explanation of interrupt pacing.</li>
<li><code>ethPrioQueue</code>&#160;: If there is a packet in this queue or a queue number higher than this then the frame goes to TCP/IP stack, else it goes to the registered handler. See <a href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#Rx_Data_Path" title="Processor SDK RTOS ICSS-EMAC-Design">this</a> for explanation. Valid values are ICSS_EMAC_QUEUE1 to ICSS_EMAC_QUEUE4</li>
<li><code>learningEn</code>&#160;: As name suggests this enables/disables FDB learning on the switch. This flag is not applicable to EMAC.</li>
<li><code>portMask</code>&#160;: Specify if device is acting as a switch or MAC. Valid values are
<ul><li><code>ICSS_EMAC_MODE_SWITCH</code>&#160;: Switch Mode</li>
<li><code>ICSS_EMAC_MODE_MAC1</code>&#160;: Enable Port 1 MAC</li>
<li><code>ICSS_EMAC_MODE_MAC2</code>&#160;: Enable Port 2 MAC</li>
<li><code>ICSS_EMAC_MODE_DUALMAC</code>&#160;: Enable both ports in MAC mode.</li></ul></li>
<li><code>rxIntNum</code>&#160;: Rx interrupt number for Host. See <a rel="nofollow" class="external text" href="http://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design#Interrupts">Interrupt mapping section</a> for explanation.</li>
<li><code>linkIntNum</code>&#160;: Link interrupt number for Host. See above.</li>
<li><code>macId</code>&#160;: Pointer to 6 byte MAC ID.</li>
<li><code>intrPacingMode</code>&#160;: Which pacing mode to use. See interrupt pacing explanation.</li></ul>
<h3><span class="mw-headline" id="Network_related">Network related</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=56" title="Edit section: Network related">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span class="mw-headline" id="How_to_configure_IP_address_and_other_IPv4_parameters">How to configure IP address and other IPv4 parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=57" title="Edit section: How to configure IP address and other IPv4 parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>IP address, network mask and other params can be set through the NDK configuration file. An example of such configuration file can be found in ti/transport/ndk/nimu_icss/example/am572x/armv7/biosnimu_icss_arm_wSocLib.cfg. You will see "Ip" configuration parameters that can be set for ip address, network mask and gateway ip address.
</p><p><br />
</p>
<h4><span class="mw-headline" id="How_to_configure_MAC_address">How to configure MAC address</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=58" title="Edit section: How to configure MAC address">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>MAC address is variable <b>macId</b> in the configuration ICSS_EmacInitConfig<b>. It can be set as per the application requirements. The following excerpt from </b>ethernet_mac<b> example shows how to do this</b>
</p>
<pre>/*Get MAC address from eFUSE*/
SOCCtrlGetPortMacAddr(1,lclMac);
/*Assign MAC ID for that particular port*/
switchEmacCfg-&gt;macId = lclMac;
</pre>
<p><br /> 
</p>
<h3><span class="mw-headline" id="Additional_documentation_reference">Additional documentation reference</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;section=59" title="Edit section: Additional documentation reference">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<table cellpadding="2" border="1" style="width: 720px">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_INSTALL_DIR)\packages\ti\drv\icss_emac\docs\doxygen\html\index.html
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_INSTALL_DIR)\packages\ti\drv\icss_emac\docs\ReleaseNotes_ICSS_EMAC_LLD.pdf
</td></tr></tbody></table>

<!-- 
NewPP limit report
Cached time: 20201201065623
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.161 seconds
Real time usage: 0.172 seconds
Preprocessor visited node count: 253/1000000
Preprocessor generated node count: 295/1000000
Post‐expand include size: 604/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    2.346      1 -total
 69.32%    1.626      4 Template:Prettytable
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:39956-0!canonical and timestamp 20201201065623 and revision id 233605
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Processor SDK RTOS ICSS-EMAC-Design</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Processor SDK RTOS ICSS-EMAC-Design</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>Processor SDK RTOS ICSS-EMAC-Design</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>Processor SDK RTOS ICSS-EMAC-Design</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>Processor SDK RTOS ICSS-EMAC-Design</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Processor SDK RTOS ICSS-EMAC-Design</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Processor SDK RTOS ICSS-EMAC-Design</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>Processor SDK RTOS ICSS-EMAC-Design</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>Processor SDK RTOS ICSS-EMAC-Design</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;oldid=233605">https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;oldid=233605</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="Category_ICSS-EMAC.html" title="Category:ICSS-EMAC">ICSS-EMAC</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=Processor+SDK+RTOS+ICSS-EMAC-Design" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="Processor_SDK_RTOS_ICSS-EMAC-Design.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Talk:Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="Processor_SDK_RTOS_ICSS-EMAC-Design.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/Processor_SDK_RTOS_ICSS-EMAC-Design.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/Processor_SDK_RTOS_ICSS-EMAC-Design.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;oldid=233605" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=Processor_SDK_RTOS_ICSS-EMAC-Design&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 14 March 2018, at 09:21.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.161","walltime":"0.172","ppvisitednodes":{"value":253,"limit":1000000},"ppgeneratednodes":{"value":295,"limit":1000000},"postexpandincludesize":{"value":604,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    2.346      1 -total"," 69.32%    1.626      4 Template:Prettytable"]},"cachereport":{"timestamp":"20201201065623","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":236});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/Processor_SDK_RTOS_ICSS-EMAC-Design by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 11:53:05 GMT -->
</html>
