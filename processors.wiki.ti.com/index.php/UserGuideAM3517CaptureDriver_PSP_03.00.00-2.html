<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/UserGuideAM3517CaptureDriver_PSP_03.00.00.05 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 06:37:09 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>UserGuideAM3517CaptureDriver PSP 03.00.00.05 - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"UserGuideAM3517CaptureDriver_PSP_03.00.00.05","wgTitle":"UserGuideAM3517CaptureDriver PSP 03.00.00.05","wgCurRevisionId":25625,"wgRevisionId":25625,"wgArticleId":4588,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"UserGuideAM3517CaptureDriver_PSP_03.00.00.05","wgRelevantArticleId":4588,"wgRequestId":"8e76a3287e009222e30caa42","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-UserGuideAM3517CaptureDriver_PSP_03_00_00_05 rootpage-UserGuideAM3517CaptureDriver_PSP_03_00_00_05 skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">UserGuideAM3517CaptureDriver PSP 03.00.00.05</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext"><b>Introduction</b></span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#References"><span class="tocnumber">1.1</span> <span class="toctext"><b>References</b></span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Acronyms_.26_Definitions"><span class="tocnumber">1.2</span> <span class="toctext"><b>Acronyms &amp; Definitions</b></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Features"><span class="tocnumber">2</span> <span class="toctext"><b>Features</b></span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Architecture"><span class="tocnumber">3</span> <span class="toctext"><b>Architecture</b></span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Overview"><span class="tocnumber">3.1</span> <span class="toctext"><b>Overview</b></span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Software_Design_Interfaces"><span class="tocnumber">3.2</span> <span class="toctext"><b>Software Design Interfaces</b></span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="#Opening_and_Closing_of_driver"><span class="tocnumber">3.2.1</span> <span class="toctext"><b>Opening and Closing of driver</b></span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Buffer_Management"><span class="tocnumber">3.2.2</span> <span class="toctext"><b>Buffer Management</b></span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#Query_Capabilities"><span class="tocnumber">3.2.3</span> <span class="toctext"><b>Query Capabilities</b></span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Input_Enumeration"><span class="tocnumber">3.2.4</span> <span class="toctext"><b>Input Enumeration</b></span></a></li>
<li class="toclevel-3 tocsection-12"><a href="#Set_Input"><span class="tocnumber">3.2.5</span> <span class="toctext"><b>Set Input</b></span></a></li>
<li class="toclevel-3 tocsection-13"><a href="#Get_Input"><span class="tocnumber">3.2.6</span> <span class="toctext"><b>Get Input</b></span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Standard_Enumeration"><span class="tocnumber">3.2.7</span> <span class="toctext"><b>Standard Enumeration</b></span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Standard_Detection"><span class="tocnumber">3.2.8</span> <span class="toctext"><b>Standard Detection</b></span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#Set_Standard"><span class="tocnumber">3.2.9</span> <span class="toctext"><b>Set Standard</b></span></a></li>
<li class="toclevel-3 tocsection-17"><a href="#Get_Standard"><span class="tocnumber">3.2.10</span> <span class="toctext"><b>Get Standard</b></span></a></li>
<li class="toclevel-3 tocsection-18"><a href="#Format_Enumeration"><span class="tocnumber">3.2.11</span> <span class="toctext"><b>Format Enumeration</b></span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#Set_Format"><span class="tocnumber">3.2.12</span> <span class="toctext"><b>Set Format</b></span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Get_Format"><span class="tocnumber">3.2.13</span> <span class="toctext"><b>Get Format</b></span></a></li>
<li class="toclevel-3 tocsection-21"><a href="#Try_Format"><span class="tocnumber">3.2.14</span> <span class="toctext"><b>Try Format</b></span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#Query_Control"><span class="tocnumber">3.2.15</span> <span class="toctext"><b>Query Control</b></span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#Set_Control"><span class="tocnumber">3.2.16</span> <span class="toctext"><b>Set Control</b></span></a></li>
<li class="toclevel-3 tocsection-24"><a href="#Get_Control"><span class="tocnumber">3.2.17</span> <span class="toctext"><b>Get Control</b></span></a></li>
<li class="toclevel-3 tocsection-25"><a href="#Queue_Buffer"><span class="tocnumber">3.2.18</span> <span class="toctext"><b>Queue Buffer</b></span></a></li>
<li class="toclevel-3 tocsection-26"><a href="#Dequeue_Buffer"><span class="tocnumber">3.2.19</span> <span class="toctext"><b>Dequeue Buffer</b></span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#Stream_On"><span class="tocnumber">3.2.20</span> <span class="toctext"><b>Stream On</b></span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#Stream_Off"><span class="tocnumber">3.2.21</span> <span class="toctext"><b>Stream Off</b></span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-29"><a href="#Driver_Configuration"><span class="tocnumber">3.3</span> <span class="toctext"><b>Driver Configuration</b></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-30"><a href="#Sample_Applications"><span class="tocnumber">4</span> <span class="toctext"><b>Sample Applications</b></span></a>
<ul>
<li class="toclevel-2 tocsection-31"><a href="#Introduction_2"><span class="tocnumber">4.1</span> <span class="toctext"><b>Introduction</b></span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#Hardware_Setup"><span class="tocnumber">4.2</span> <span class="toctext"><b>Hardware Setup</b></span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Applications_Source"><span class="tocnumber">4.3</span> <span class="toctext"><b>Applications Source</b></span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Introduction"><b>Introduction</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=1" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The Capture Module is a key component for still-image capture applications. The capture module provides the system interface and the processing capability to connect RAW image-sensor modules and video decoders to the AM3517 device.
<br />
</p><p>The capture module consists of the following interfaces:
</p>
<ul><li>One S-video SD input in BT.656 format.</li>
<li>One Composite SD input in BT.656 format.</li></ul>
<p><br />
The following figure shows the top view of physical connection and inputs for TVP5146 decoder.
<br />
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:308px;"><a href="File_Am3517_capture_tvp5146_inputs.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/e/ef/Am3517_capture_tvp5146_inputs.png" width="306" height="400" class="thumbimage" /></a>  <div class="thumbcaption">Capture Physical Input Interface</div></div></div></div>
<p><br />
Both these video inputs are connected to one TVP5146 decoder and the application can select between these two inputs using standard V4L2 interface.
</p><p><br />
<b>NOTE:</b> Only one input can be captured or selected at any given point of time.
<br />
</p><p>The V4L2 Capture driver model is used for capture module. The V4L2 driver model is widely used across many platforms in the Linux community. V4L2 provides good streaming support and support for many buffer formats. It also has its own buffer management mechanism that can be used.
<br />
</p>
<h2><span class="mw-headline" id="References"><b>References</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=2" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li>AM3517 VPSS TRM</li></ul>
<p>Author: Texas Instruments, Inc.
</p>
<ul><li>Video for Linux Two API Specification</li></ul>
<p>Author: Michael H Schimek
Version: 0.23
</p>
<h2><span id="Acronyms_&amp;_Definitions"></span><span class="mw-headline" id="Acronyms_.26_Definitions"><b>Acronyms &amp; Definitions</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=3" title="Edit section: Acronyms &amp; Definitions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<table border="1" cellspacing="0" cellpadding="5" width="40%">
<caption><b>Capture Driver: Acronyms</b>
</caption>
<tbody><tr>
<th align="left">Acronym
</th>
<th align="left">Definition
</th></tr>
<tr>
<td>API
</td>
<td>Application Programming Interface
</td></tr>
<tr>
<td>CCDC
</td>
<td>Input interface block of Capture module
</td></tr>
<tr>
<td>DMA
</td>
<td>Direct Memory Access
</td></tr>
<tr>
<td>I/O
</td>
<td>Input &amp; Output
</td></tr>
<tr>
<td>IOCTL
</td>
<td>Input &amp; Output Control
</td></tr>
<tr>
<td>V4L2
</td>
<td>Video for Linux specification version 2
</td></tr>
<tr>
<td>YUV
</td>
<td>Luminance + 2 Chrominance Difference Signals (Y, Cr, Cb) Color Encoding
</td></tr></tbody></table>
<p><br />
</p>
<h1><span class="mw-headline" id="Features"><b>Features</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=4" title="Edit section: Features">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The Capture Driver provides the following features:
<br />
</p>
<ul><li>Supports one software channel of capture and a corresponding device node (/dev/video0) is created.</li>
<li>Supports single I/O instance and multiple control instances.</li>
<li>Supports buffer access mechanism through memory mapping and user pointers.</li>
<li>Supports dynamic switching among input interfaces with some necessary restrictions wherever applicable.</li>
<li>Supports NTSC and PAL standard on Composite and S-Video interfaces.</li>
<li>Supports 10-bit BT.656 capture in UYVY and YUYV interleaved formats.</li>
<li>Supports standard V4L2 IOCTLs to get/set various contro parameters like brightness, contrast, saturation, hue and auto gain control.</li>
<li>In USERPTR mode of operation both malloced and IO mapped buffers are supported.</li>
<li>Both VPFE Master capture driver and TVP5146 (TVP514x) decoder driver module can be used statically or dynamically (insmod and rmmod supported).</li></ul>
<p><br />
<br />
</p>
<h1><span class="mw-headline" id="Architecture"><b>Architecture</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=5" title="Edit section: Architecture">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p><br />
</p>
<h2><span class="mw-headline" id="Overview"><b>Overview</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=6" title="Edit section: Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following figure shows the basic block diagram of capture interface.
<br />
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:444px;"><a href="File_Am3517_capture_overview.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/0/09/Am3517_capture_overview.png" width="442" height="482" class="thumbimage" /></a>  <div class="thumbcaption">Capture Driver Component Overview</div></div></div></div>
<p><br />
</p><p>The system architecture diagram illustrates the software components that are relevant to the Camera Driver. Some components are outside the scope of this design document. The following is a brief description of each component in the figure.
<br />
</p><p><b>Camera Applications:</b>
<br />
Camera applications refer to any application that accesses the device node that is served by the Camera Driver. These applications are not in the scope of this design. They are here to present the environment in which the Camera Driver is used.
<br />
<b>V4L2 Subsystem:</b>
<br />
The Linux V4L2 subsystem is used as an infrastructure to support the operation of the Camera Driver. Camera applications mainly use the V4L2 API to access the Camera Driver functionality. A Linux 2.6 V4L2 implementation is used in order to support the standard features that are defined in the V4L2 specification.
<br />
<b>Video Buffer Library:</b>
<br />
This library comes with V4L2. It provides helper functions to cleanly manage the video buffers through a video buffer queue object.
<br />
<b>Camera Driver:</b>
<br />
The Camera Driver allows capturing video through an external decoder. It is a V4L2-compliant driver with addition of an AM3517 Capture hardware feature. This driver conforms to the Linux driver model for power management. The camera driver is registered to the V4L2 layer as a master device driver. Any slave decoder driver added to the V4L2 layer will be attached to this driver through the new V4L2 master-slave interface layer. The current implementation supports only one slave device.
<br />
</p><p><b>Decoder Driver:</b>
<br />
The Camera Driver is designed to be AM3517 dependent, but platform and board independent. It is the decoder driver that manages the board connectivity. A decoder driver must implement the new V4L2 master-slave interface. It should register to the V4L2 layer as a slave device. Changing a decoder requires implementation of a new decoder driver; it does not require changing the Camera Driver. Each
decoder driver exports a set of IOCTLs to the master device through function pointers.
<br />
</p><p><b>CCDC library:</b>
<br />
CCDC is a HW block in which acts as a data input port. It receives data from the sensor/decoder through parallel interface. The CCDC library exports API to configure CCDC module. It is configured by the master driver based on the sensor/decoder attached and desired output from the camera driver.
<br />
</p><p><br />
<br />
</p>
<h2><span class="mw-headline" id="Software_Design_Interfaces"><b>Software Design Interfaces</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=7" title="Edit section: Software Design Interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><br />
</p>
<h3><span class="mw-headline" id="Opening_and_Closing_of_driver"><b>Opening and Closing of driver</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=8" title="Edit section: Opening and Closing of driver">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The device can be opened using open call from the application, with the device name and mode of operation as parameters. Application should open the driver in blocking mode. In this mode, DQBUF IOCTL will not return until an empty frame is available.
<br />
</p>
<pre>/* Open a video capture logical channel in blocking mode */
fd = open("/dev/video0", O_RDWR);
if (fd == -1) {
   perror("failed to open Capture device\n");
   return -1;
}
/* closing of channel */
close (fd);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Buffer_Management"><b>Buffer Management</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=9" title="Edit section: Buffer Management">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Capture driver only works with physically contiguous buffers and buffer address should be aligned to 32 bytes boundary. The driver supports both memory usage modes:
<br />
</p>
<ul><li>Memory map buffer mode</li>
<li>User Pointer mode</li></ul>
<p><br />
In Memory map buffer mode, application can request memory from the driver by calling  VIDIOC_REQBUFS IOCTL. In user buffer mode, application needs to allocate memory using some other mechanism in user space like malloc or memalign. In driver buffer mode, maximum number of buffers is limited to  VIDEO_MAX_FRAME (defined in driver header files) and is limited by the available memory in the kernel.
<br />
The main steps that the application must perform for buffer allocation are:
</p>
<ol><li>Allocating Memory</li>
<li>Getting Physical Address</li>
<li>Mapping Kernel Space Address to User Space</li></ol>
<p><br />
<br />
</p>
<ul><li><b>Allocating Memory</b></li></ul>
<p>This IOCTL is used to allocate memory for frame buffers. This is the necessary IOCTL for streaming IO. It has to be called for both driver buffer mode and user buffer mode. Using this IOCTL, driver will know whether driver buffer mode or user buffer mode will be used.
<br />
<i>Ioctl: VIDIOC_REQBUFS</i>
<br />
It takes a pointer to instance of v4l2_requestbuffers structure as an argument. User should specify buffer type as (V4L2_BUF_TYPE_VIDEO_CAPTURE), number of buffers, and memory type  (V4L2_MEMORY_MMAP,
V4L2_MEMORY_USERPTR) at the time of buffer allocation.
</p><p><i>Constraint:</i> This IOCTL can be called only once from the application. This IOCTL is necessary IOCTL.
</p><p><br />
<b>Example:</b>
<br />
</p>
<pre>/* structure to store buffer request parameters */
struct v4l2_requestbuffers reqbuf;
reqbuf.count = numbuffers;
reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
reqbuf.memory = V4L2_MEMORY_MMAP;
ret = ioctl(fd, VIDIOC_REQBUFS, &amp;reqbuf);
if (ret &lt; 0) {
    printf("cannot allocate memory\n");
    close(fd);
    return -1;
}
printf("Number of buffers allocated =&#160;%d\n", reqbuf.count);
</pre>
<p><br />
</p>
<ul><li><b>Getting Physical Address</b></li></ul>
<p>This IOCTL is used to query buffer information like buffer size and buffer physical address. This physical address is used in mmapping the buffers. This IOCTL is necessary for driver buffer mode as it provides the physical address of buffers, which are used to mmap system call the buffers.
<br />
Ioctl: VIDIOC_QUERYBUF
<br />
It takes a pointer to instance of v4l2_buffer structure as an argument. User has to specify buffer type as (V4L2_BUF_TYPE_VIDEO_CAPTURE), buffer index, and memory type  (V4L2_MEMORY_MMAP) at the time of querying.
<br />
Example:
</p>
<pre>/* allocate buffer by VIDIOC_REQBUFS */
/* structure to query the physical address of allocated buffer */
struct v4l2_buffer buffer;
buffer.index = 0; /* buffer index for quering -0 */
buffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
buffer.memory = V4L2_MEMORY_MMAP;
if (ioctl(fd, VIDIOC_QUERYBUF, &amp;buffer) &lt; -1) {
    printf("buffer query error.\n");
    close(fd);
    exit(-1);
}
The buffer.m.offset will contain the physical address returned from driver.
</pre>
<p><br />
</p>
<ul><li><b>Mapping Kernel Space Address to User Space</b></li></ul>
<p>Mapping the kernel buffer to the user space can be done via mmap. This is only required for MMAP buffer mode. User can pass buffer size and physical address of buffer for getting the user space address.
<br />
Example:
</p>
<pre>/* allocate buffer by VIDIOC_REQBUFS */
/* query the buffer using VIDIOC_QUERYBUF */
/* addr hold the user space address */
int addr;
addr = mmap(NULL, buffer.size,PROT_READ | PROT_WRITE, MAP_SHARED, fd, buffer.m.offset);
/* buffer.m.offset is same as returned from VIDIOC_QUERYBUF */
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Query_Capabilities"><b>Query Capabilities</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=10" title="Edit section: Query Capabilities">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to verify kernel devices compatibility with V4L2 specification and to obtain information about individual hardware capabilities. In this case, it will return capabilities provided by capture driver and current decoder driver.
<br />
Ioctl: VIDIOC_QUERYCAP
<br />
Capabilities can be video capture  (V4L2_CAP_VIDEO_CAPTURE) and streaming (V4L2_CAP_STREAMING).
It takes pointer to v4l2_capability structure as an argument. Capabilities can be accessed by capabilities field in the v4l2_capability structure.
<br />
Example:
</p>
<pre>struct v4l2_capability capability;
ret = ioctl(fd, VIDIOC_QUERYCAP, &amp;capability);
if (ret &lt; 0) {
    printf("Cannot do QUERYCAP\n");
    return -1;
}
if (capability.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE) {
    printf("Capture capability is supported\n");
}
if (capability.capabilities &amp; V4L2_CAP_STREAMING) {
    printf("Streaming is supported\n");
}
</pre>
<h3><span class="mw-headline" id="Input_Enumeration"><b>Input Enumeration</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=11" title="Edit section: Input Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enumerate the information of available inputs (analog interface). It includes information like name of input type and supported standards for that input type.
<br />
Ioctl: VIDIOC_ENUMINPUT
<br />
</p><p>It takes pointer to v4l2_input structure. Application provides the index number for which it requires the information, in index member of v4l2_input structure.
<br />
Index with value zero indicates first input type of the decoder. It returns combination of the standards supported on this input in the std member of v4l2_input structure.
</p><p><br />
Example:
</p>
<pre>struct v4l2_input input;
i = 0;
while(1) {
    input.index = i;
    ret = ioctl(fd, VIDIOC_ENUMINPUT, &amp;input);
    if (ret &lt; 0)
        break;
    printf("name =&#160;%s\n", input.name);
    i++;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Set_Input"><b>Set Input</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=12" title="Edit section: Set Input">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set input type (analog interface type).
<br />
Ioctl: VIDIOC_S_INPUT
<br />
This IOCTL takes pointer to integer containing index of the input which has to be set. Application will provide the index number as an argument.
</p><p><br />
</p>
<pre>       <i>0 - Composite input,</i>
       <i>1 - S-Video input.</i>
</pre>
<p><br />
Example:
</p>
<pre>int index = 1; /*To set S-Video input*/
struct v4l2_input input;
ret = ioctl(fd, VIDIOC_S_INPUT, &amp;index);
if (ret &lt; 0) {
    perror("VIDIOC_S_INPUT\n");
    close(fd);
    return -1;
}
input.index = index;
ret = ioctl(fd, VIDIOC_ENUMINPUT, &amp;input);
if (ret &lt; 0) {
perror("VIDIOC_ENUMINPUT\n");
    close(fd);
    return -1;
}
printf("name of the input =&#160;%s\n",input.name);
</pre>
<h3><span class="mw-headline" id="Get_Input"><b>Get Input</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=13" title="Edit section: Get Input">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the current input type (analog interface type).
<br />
Ioctl: VIDIOC_G_INPUT
<br />
This IOCTL takes pointer to integer using which the detected inputs will be returned. It will return the software managed input detected during open system call. Application will provide the index number as an output argument.
<br />
Example:
</p>
<pre>int input;
struct v4l2_input input;
ret = ioctl(fd, VIDIOC_G_INPUT, &amp;input);
if (ret &lt; 0) {
    perror("VIDIOC_G_INPUT\n");
    close(fd);
    return -1;
}
input.index = index;
ret = ioctl(fd, VIDIOC_ENUMINPUT, &amp;input);
if (ret &lt; 0) {
    perror("VIDIOC_ENUMINPUT\n");
    close(fd);
    return -1;
}
printf("name of the input =&#160;%s\n", input.name);
</pre>
<h3><span class="mw-headline" id="Standard_Enumeration"><b>Standard Enumeration</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=14" title="Edit section: Standard Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enumerate the information regarding video standards. This IOCTL is used to enumerate all the standards supported by the registered decoder.
<br />
Ioctl: VIDIOC_ENUMSTD
<br />
This IOCTL takes a pointer to  v4l2_standard structure. Application provides the index of the standard to be enumerated in the index member of this structure. It provides information like standard name, standard ID defined at V4L2 header files (few new standards are included in the respective decoder header files, which were not available in standard V4L2 header files), and numerator and denominator values for frame period and frame lines.
<br />
It takes index as an argument as a part of v4l2_standard structure. Index with value zero provides information for the first standard among all the standards of all the registered decoders. If the index value exceeds the number of supported standards, it returns an error.
<br />
Example:
</p>
<pre>struct v4l2_standard standard;
i = 0;
while(1) {
    standard.index = i;
    ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
    if (ret &lt; 0)
        break;
    printf("name =&#160;%s\n", std.name);
    printf("framelines =&#160;%d\n", std.framelines);
    printf("numerator =&#160;%d\n",
           std.frameperiod.numerator);
    printf("denominator =&#160;%d\n",
           std.frameperiod.denominator);
    i++;
}
</pre>
<h3><span class="mw-headline" id="Standard_Detection"><b>Standard Detection</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=15" title="Edit section: Standard Detection">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to detect the current video standard set in the current decoder.
<br />
Ioctl: VIDIOC_QUERYSTD
<br />
It takes a pointer to  v4l2_std_id instance as an output argument. Driver will call the current decoder's function internally (which has been initialized) to detect the current standard set in hardware. Support of this IOCTL depends on decoder device, whether it can detect a standard or not.
<br />
<b>Note:</b> This IOCTL should be called by the application so that the camera driver can configure Capture module properly with the detected decoder standard.
<br />
Standard IDs are defined in the V4L2 header files
<br />
Example:
</p>
<pre>struct v4l2_std_id std;
struct v4l2_standard standard;
ret = ioctl(fd, VIDIOC_QUERYSTD, &amp;std);
if (ret &lt; 0) {
    perror("VIDIOC_QUERYSTD\n");
    close(fd);
    return -1;
}
while(1) {
    standard.index = i;
    ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
    if (ret &lt; 0)
        break;
    if (standard.std &amp; std) {
        printf("%s standard detected\n",
               standard.name);
        break;
    }
    i++;
}
</pre>
<h3><span class="mw-headline" id="Set_Standard"><b>Set Standard</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=16" title="Edit section: Set Standard">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set the standard in the decoder.
<br />
Ioctl: VIDIOC_S_STD
<br />
It takes a pointer to v4l2_std_id instance as an input argument. If the standard is not supported by the decoder, the driver will return an error Standard IDs are defined in the V4L2 header files (few new standards are included in respective decoder header files, which were not available in standard V4L2 header files).
<br />
<b>Note:</b> Application need not call this IOCTL as the decoder can auto detect the current standard. This is required only when the application needs to set a particular standard. In this case, the decoder driver auto detect function is disabled. Auto detect can be enabled again only by closing and re-opening the driver.
<br />
Example:
</p>
<pre>struct v4l2_std_id std = V4L2_STD_NTSC;
ret = ioctl(fd, VIDIOC_S_STD, &amp;std);
if (ret &lt; 0) {
    perror("S_STD\n");
    close(fd);
    return -1;
}
while(1) {
    standard.index = i;
    ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
    if (ret &lt; 0)
        break;
    if (standard.std &amp; std) {
        printf("%s standard is selected\n");
        break;
    }
    i++;
}
</pre>
<h3><span class="mw-headline" id="Get_Standard"><b>Get Standard</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=17" title="Edit section: Get Standard">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the current standard in the current decoder.
<br />
Ioctl: VIDIOC_G_STD
<br />
It takes a pointer to v4l2_std_id instance as an output argument. Standard IDs are defined in the V4L2 header files
<br />
Example:
</p>
<pre>struct v4l2_std_id std;
ret = ioctl(fd, VIDIOC_G_STD, &amp;std);
if (ret &lt; 0) {
    perror("G_STD\n");
    close(fd);
    return -1;
}
while(1) {
    standard.index = i;
    ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
    if (ret &lt; 0)
        break;
    if (standard.std &amp; std) {
         printf("%s standard is selected\n");
         break;
    }
    i++;
}
</pre>
<h3><span class="mw-headline" id="Format_Enumeration"><b>Format Enumeration</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=18" title="Edit section: Format Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enumerate the information of pixel formats. The driver supports only two pixel form at -8-bit UYVY interleaved and 8-bit YUYV interleaved.
<br />
Ioctl: VIDIOC_ENUM_FMT
<br />
It takes a pointer to instance of v4l2_fmtdesc structure as an output parameter. Application must provide the buffer type in the type argument of v4l2_fmtdesc structure as  V4L2_BUF_TYPE_VIDEO_CAPTURE  and index member of this structure as zero.
<br />
Example:
</p>
<pre>struct v4l2_fmtdesc fmt;
i = 0;
while(1) {
    fmt.index = i;
    ret = ioctl(fd, VIDIOC_ENUM_FMT, &amp;fmt);
    if (ret &lt; 0)
        break;
    printf("description =&#160;%s\n",fmt.description);
    if (fmt.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
        printf("Video capture type\n");
    if (fmt.pixelformat == V4L2_PIX_FMT_YUYV)
        printf("V4L2_PIX_FMT_YUYV\n");
    i++;
}
</pre>
<h3><span class="mw-headline" id="Set_Format"><b>Set Format</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=19" title="Edit section: Set Format">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set the format parameters. The format parameters are line offset, storage format, pixel format, and so on. This IOCTL is one of the necessary IOCTL. If it is not set, it uses the following default values:
<br />
</p>
<ul><li>Default storage format - V4L2_FIELD_INTERLACED</li></ul>
<p><br />
This IOCTL expects proper width and height members of the v4l2_format structure from application as per the standard selected. Please note that, V4L2_FIELD_INTERLACED is the only storage format supported.
<br />
The application can decide the buffer pixel format using pixelformat member of this IOCTL. The current driver supports - 8-bit UYVY interleaved and 8-bit YUYV interleaved formats. The desired pitch of the buffer can be set by using the bytesperline member. The pitch should be at least one line size in bytes. When changing the pitch, the application should also modify the sizeimage member accordingly - sizeimage should be at least pitch * image height. The driver allocates buffer of size sizeimage member of the v4l2_format structure passed through this IOCTL for both mmap buffer and user pointer mode. Driver validates the provided buffer size along with the other members and uses this buffer size for calculating offsets for storing video data.
<br />
This IOCTL is a necessary IOCTL for the user buffer mode because driver will know the buffer size for user buffer mode. If it not called for the user buffer mode, driver assumes the default buffer size and calculates offsets accordingly.
<br />
Ioctl: VIDIOC_S_FMT
<br />
It will take pointer to instance of v4l2_format structure as an input parameter. If the type member is V4L2_BUF_TYPE_VIDEO_CAPTURE, it checks pixel format, pitch value, and image size. It returns an error, if the parameters are invalid.
<br />
Example:
</p>
<pre>struct v4l2_format fmt;
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
/* for  NTSC standard */
fmt.fmt.pix.width = 720;
fmt.fmt.pix.height = 480;
fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;
ret = ioctl(fd, VIDIOC_S_FMT, &amp;fmt);
if (ret &lt; 0) {
    perror("VIDIOC_S_FMT\n");
    close(fd);
    return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Get_Format"><b>Get Format</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=20" title="Edit section: Get Format">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the current format parameters.
<br />
Ioctl: VIDIOC_G_FMT
<br />
It takes a pointer to instance of  v4l2_format structure as an input parameter. Driver provides format parameters in the structure pointer passed as an argument. v4l2_format structure contains parameters like pixel format, image size, bytes per line, and field type.
<br />
For type  V4L2_BUF_TYPE_VIDEO_CAPTURE, the  v4l2_pix_format structure of fmt union is filled.
</p><p><br />
Example:
</p>
<pre>struct v4l2_format fmt;
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ret = ioctl(fd, VIDIOC_G_FMT, &amp;fmt);
if (ret &lt; 0) {
    perror("VIDIOC_G_FMT\n");
    close(fd);
    return -1;
}
if (fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV)
    printf("8-bit UYVY pixel format\n");
printf("Size of the buffer =&#160;%d\n", fmt.fmt.pix.sizeimage);
printf("Line offset =&#160;%d\n", fmt.fmt.pix.bytesperline);
if (fmt.fmt.pix.field == V4L2_FIELD_INTERLACED)
    printf("Storate format is interlaced frame format");
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Try_Format"><b>Try Format</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=21" title="Edit section: Try Format">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to validate the format parameters provided by the application. It checks parameters and returns the correct parameter, if any parameter is incorrect. It returns error only if the parameters passed are ambiguous.
<br />
Ioctl: VIDIOC_TRY_FMT
<br />
It takes a pointer to instance of v4l2_format structure as an input/output parameter. If the type member is V4L2_BUF_TYPE_VIDEO_CAPTURE, it checks pixel format, pitch value, and image size. It returns errors to the application, if the parameters are invalid.
<br />
Example:
</p>
<pre>struct v4l2_format fmt;
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
fmt.fmt.pix.sizeimage = size;
fmt.fmt.pix.bytesperline = pitch;
fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;
ret = ioctl(fd, VIDIOC_TRY_FMT, &amp;fmt);
if (ret &lt; 0) {
    perror("VIDIOC_TRY_FMT\n");
    close(fd);
    return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Query_Control"><b>Query Control</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=22" title="Edit section: Query Control">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the information of controls that is, brightness, contrast, and so on supported by the current decoder.
<br />
Ioctl: VIDIOC_QUERYCTRL
<br />
This IOCTL takes a pointer to the instance of v4l2_queryctrl structure as the argument and returns the control information in the same pointer. Application provides the control ID in the v4l2_queryctrl id member in this structure. This control ID is defined in V4L2 header file, for which information is needed.
<br />
If the control command specified by Id is not supported in current decoder, driver will return an error.
<br />
Example:
</p>
<pre>struct v4l2_queryctrl ctrl;
ctrl.id = V4L2_CID_CONTRAST;
ret = ioctl(fd, VIDIOC_QUERYCTRL, &amp;ctrl);
if (ret &lt; 0) {
    perror("VIDIOC_QUERYCTRL \n");
    close(fd);
    return -1;
}
printf("name =&#160;%s\n", ctrl.name);
printf("min =&#160;%d max =&#160;%d step =&#160;%d default =&#160;%d\n",
       ctrl.minimum, ctrl.maximum, ctrl.step, ctrl.default_value);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Set_Control"><b>Set Control</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=23" title="Edit section: Set Control">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set the value for a particular control in current decoder. To set the control value, this IOCTL can also be called when streaming is on.
<br />
Ioctl: VIDIOC_S_CTRL
<br />
It takes a pointer to instance of  v4l2_control structure as an input parameter. Application provides control ID and control values in the v4l2_control id and value member in this structure. If the control command specified by Id is not supported in the current decoder and if value of the control is out of range, driver returns an error. Otherwise, it sets the control in the registers.
<br />
Example:
</p>
<pre>struct v4l2_control ctrl;
ctrl.id = V4L2_CID_CONTRAST;
ctrl.value = 100;
ret = ioctl(fd, VIDIOC_S_CTRL, &amp;ctrl);
if (ret &lt; 0) {
    perror("VIDIOC_S_CTRL\n");
    close(fd);
    return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Get_Control"><b>Get Control</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=24" title="Edit section: Get Control">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the value for a particular control in the current decoder.
<br />
Ioctl: VIDIOC_G_CTRL
<br />
It takes a pointer to instance of v4l2_control structure as an output parameter. Application provides the control ID of id member in this structure. If the control command specified by Id is not supported  in the current decoder, driver returns an error. Otherwise, it returns the value of the control in the value member of the v4l2_control structure.
<br />
Example:
</p>
<pre>struct v4l2_control ctrl;
ctrl.id = V4L2_CID_CONTRAST;
ret = ioctl(fd, VIDIOC_G_CTRL, &amp;ctrl);
if (ret &lt; 0) {
    perror("VIDIOC_G_CTRL\n");
    close(fd);
    return -1;
}
printf("value =&#160;%x\n", ctrl.value);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Queue_Buffer"><b>Queue Buffer</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=25" title="Edit section: Queue Buffer">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enqueue the buffer in buffer queue. This IOCTL will enqueue an empty buffer in the driver buffer queue. This IOCTL is one of necessary IOCTL for streaming IO. If no buffer is enqueued before starting streaming, driver returns an error as there is no buffer available. So at least one buffer must be enqueued before starting streaming. This IOCTL is also used to enqueue empty buffers after streaming is started.
<br />
Ioctl: VIDIOC_QBUF
<br />
This IOCTL takes a pointer to instance of  v4l2_buffer structure as an argument. Application has to specify the buffer type (V4L2_BUF_TYPE_VIDEO_CAPTURE), buffer index, and memory type (V4L2_MEMORY_MMAP or V4L2_MEMORY_USERPTR) at the time of queuing.
<br />
For the user pointer buffer exchange mechanism, application also has to provide buffer pointer in the m.userptr member of  v4l2_buffer structure. Driver will enqueue buffer in the driver's incoming queue.
It will take pointer to instance of v4l2_ buffer structure as an input parameter.
<br />
Example:
</p>
<pre>struct v4l2_buffer buf;
buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
buf.type = V4L2_MEMORY_MMAP;
buf.index = 0;
ret = ioctl(fd, VIDIOC_QBUF, &amp;buf);
if (ret &lt; 0) {
    perror("VIDIOC_QBUF\n");
    close(fd);
    return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Dequeue_Buffer"><b>Dequeue Buffer</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=26" title="Edit section: Dequeue Buffer">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to dequeue the buffer in the buffer queue. This IOCTL will dequeue the captured buffer from buffer queue of the driver. This IOCTL is one of necessary IOCTL for the streaming IO. This IOCTL can be used only after streaming is started. This IOCTL will block until an empty buffer is available.
<br />
<b>Note:</b> The application can dequeue all buffers from the driver - the driver will not hold the last buffer to itself. In this case, the driver will disable the capture operation and the capture operation resumes when a buffer is queued to the driver again.
<br />
Ioctl: VIDIOC_DQBUF
<br />
It takes a pointer to instance of v4l2_buffer structure as an output parameter. Application has to specify the buffer type (V4L2_BUF_TYPE_VIDEO_CAPTURE)   and memory type (V4L2_MEMORY_MMAP or V4L2_MEMORY_USERPTR) at the time of dequeueing.
<br />
If this IOCTL is called with the file descriptor, with which VIDIOC_REQBUF is not performed, driver will return an error. Driver will enqueue buffer, if the buffer queue is not empty.
<br />
Example:
</p>
<pre>struct v4l2_buffer buf;
buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
buf.type = V4L2_MEMORY_MMAP;
ret = ioctl(fd, VIDIOC_DQBUF, &amp;buf);
if (ret &lt; 0) {
    perror("VIDIOC_DQBUF\n");
    close(fd);
    return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Stream_On"><b>Stream On</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=27" title="Edit section: Stream On">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to start video capture functionality.
<br />
Ioctl: VIDIOC_STREAMON
<br />
If streaming is already started, this IOCTL call returns an error.
<br />
Example:
</p>
<pre>v4l2_buf_type buftype = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ret = ioctl(fd, VIDIOC_STREAMON, &amp;buftype);
if (ret &lt; 0) {
    perror("VIDIOC_STREAMON \n");
    close(fd);
    return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Stream_Off"><b>Stream Off</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=28" title="Edit section: Stream Off">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to stop video capture functionality.
<br />
Ioctl: VIDIOC_STREAMOFF
<br />
If streaming is not started, this IOCTL call returns an error.
<br />
Example:
</p>
<pre>struct v4l2_buf_type buftype = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ret = ioctl(fd, VIDIOC_STREAMOFF, &amp;buftype);
if (ret &lt; 0) {
    perror("VIDIOC_STREAMOFF \n");
    close(fd);
    return -1;
}
</pre>
<p><br />
</p>
<h2><span class="mw-headline" id="Driver_Configuration"><b>Driver Configuration</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=29" title="Edit section: Driver Configuration">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To enable V4L2 capture driver support in the kernel:
<br />
</p><p>Start Linux Kernel Configuration tool.
</p>
<pre>$ make menuconfig ARCH=arm
</pre>
<ul><li>Select Device Drivers from the main menu.</li></ul>
<pre>...
...
Kernel Features  ---&gt;
Boot options  ---&gt;
CPU Power Management  ---&gt;
Floating point emulation  ---&gt;
Userspace binary formats  ---&gt;
Power management options  ---&gt;
[*] Networking support  ---&gt;
<b>Device Drivers  ---&gt;</b>
...
...
</pre>
<ul><li>Select Multimedia support from the menu.</li></ul>
<pre>...
...
Sonics Silicon Backplane  ---&gt;
Multifunction device drivers  ---&gt;
<b>&lt;*&gt; Multimedia support  ---&gt;</b>
Graphics support  ---&gt;
&lt;*&gt; Sound card support  ---&gt;
[*] HID Devices  ---&gt;
[*] USB support  ---&gt;
...
...
</pre>
<ul><li>Select Video For Linux from the menu.</li></ul>
<pre>...
...
*** Multimedia core support ***
<b>&lt;*&gt;   Video For Linux</b>
[*]     Enable Video For Linux API 1 (DEPRECATED)
&lt; &gt;   DVB for Linux
...
...
</pre>
<ul><li>Select Video capture adapters from the same menu.</li></ul>
<pre>...
...
[ ]   Customize analog and hybrid tuner modules to build  ---&gt;
<b>[*]   Video capture adapters  ---&gt;</b>
[*]   Radio Adapters  ---&gt;
[ ]   DAB adapters
...
...
</pre>
<p><br />
</p>
<ul><li>Select TI Media Drivers from the menu. After selecting this option sub-menu will appear.</li></ul>
<pre>...
...
&lt; &gt;   OMAP ISP Resizer
<b>&lt;*&gt;   TI Media Drivers</b>
-*-     VPSS System module driver
...
...
</pre>
<ul><li>Select VPFE Video Capture Driver &amp; DM6446 CCDC HW module from the menu.</li></ul>
<pre>...
...
&lt; &gt;   OMAP ISP Previewer
&lt; &gt;   OMAP ISP Resizer
&lt;*&gt;   TI Media Drivers
<b>&lt;*&gt;     VPFE Video Capture Driver</b>
<b>&lt;*&gt;       DM6446 CCDC HW module</b>
&lt;*&gt;   OMAP2/OMAP3 V4L2-DSS driver
&lt; &gt;   SoC camera support
...
...
</pre>
<ul><li>Selection of TVP5146 Video Decoder driver -</li></ul>
<p>De-select option  Autoselect pertinent encoders/decoders and other helper chips and go inside Encoders/decoders and other helper chips
</p>
<pre>--- Video capture adapters
...
...
[ ]   Autoselect pertinent encoders/decoders and other helper chips
    <b>Encoders/decoders and other helper chips  ---&gt;</b>
&lt; &gt;   Virtual Video Driver
...
...
</pre>
<ul><li>Select TVP5146 Video Decoder driver from the menu.</li></ul>
<pre>*** Audio decoders ***
...
...
&lt; &gt;   Philips SAA7191 video decoder
<b>&lt;*&gt;   Texas Instruments TVP514x video decoder</b>
&lt; &gt;   Texas Instruments TVP5150 video decoder
...
...
</pre>
<p><br />
</p>
<h1><span class="mw-headline" id="Sample_Applications"><b>Sample Applications</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=30" title="Edit section: Sample Applications">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>This chapter describes the sample application provided along with the package. The binary and the source for these sample application can are available in the Examples directory of the Release Package  folder.
</p>
<h2><span class="mw-headline" id="Introduction_2"><b>Introduction</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=31" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Writing a capture application involves the following steps:
<br />
</p>
<ul><li>Opening the capture device.</li>
<li>Set the parameters of the device.</li>
<li>Allocate and initialize capture buffer</li>
<li>Receive video data from the device.</li>
<li>Close the device.</li></ul>
<h2><span class="mw-headline" id="Hardware_Setup"><b>Hardware Setup</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=32" title="Edit section: Hardware Setup">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Following are the steps required to run the capture sample application:
<br />
</p>
<ul><li>Connect the AM3517 User interface card module containing the TVP5146 deocoder to the AM3517 main board.</li>
<li>Make sure that switch settings on UI Card, S11.1 and S11.2 are turned ON.</li>
<li>Connect a DVD player/camera generating a NTSC video signal to the S-Video or Composite jack of the daughter card.</li>
<li>Run the sample application after booting the kernel.</li></ul>
<h2><span class="mw-headline" id="Applications_Source"><b>Applications Source</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;section=33" title="Edit section: Applications Source">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Following are the list of capture sample application provided with the release:
<br />
</p>
<ul><li><b>MMAP Loopback Application (saMmapLoopback.c):</b></li></ul>
<p><br />
This sample application using driver allocated buffers to capture video data from any one of the active inputs and displays the video in the LCD using display driver.
</p><p><br />
</p>
<ul><li><b>USERPTR Loopback Application (saUserPtrLoopback.c):</b></li></ul>
<p><br />
This sample application using User allocated buffers to capture video data from any one of the active inputs and displays the video in the LCD using display driver. The application makes use of V4L2 display driver buffers as a user pointer in capture driver.
</p><p><b>NOTE:</b> sauserPtrLoopback application configures the parameters for NTSC, so User will have to change it for PAL.
</p>
<!-- 
NewPP limit report
Cached time: 20201201035203
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.080 seconds
Real time usage: 0.082 seconds
Preprocessor visited node count: 346/1000000
Preprocessor generated node count: 616/1000000
Postexpand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 7592/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:4588-0!canonical and timestamp 20201201035203 and revision id 25625
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>UserGuideAM3517CaptureDriver PSP 03.00.00.05</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>UserGuideAM3517CaptureDriver PSP 03.00.00.05</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>UserGuideAM3517CaptureDriver PSP 03.00.00.05</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>UserGuideAM3517CaptureDriver PSP 03.00.00.05</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>UserGuideAM3517CaptureDriver PSP 03.00.00.05</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>UserGuideAM3517CaptureDriver PSP 03.00.00.05</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>UserGuideAM3517CaptureDriver PSP 03.00.00.05</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>UserGuideAM3517CaptureDriver PSP 03.00.00.05</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>UserGuideAM3517CaptureDriver PSP 03.00.00.05</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;oldid=25625">https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;oldid=25625</a>"					</div>
				<div id="catlinks" class="catlinks catlinks-allhidden" data-mw="interface"></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=UserGuideAM3517CaptureDriver+PSP+03.00.00.05" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="UserGuideAM3517CaptureDriver_PSP_03.00.00-2.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Talk:UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="UserGuideAM3517CaptureDriver_PSP_03.00.00-2.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/UserGuideAM3517CaptureDriver_PSP_03.00.00-2.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/UserGuideAM3517CaptureDriver_PSP_03.00.00-2.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;oldid=25625" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=UserGuideAM3517CaptureDriver_PSP_03.00.00.05&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 18 March 2010, at 06:00.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.080","walltime":"0.082","ppvisitednodes":{"value":346,"limit":1000000},"ppgeneratednodes":{"value":616,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":7592,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20201201035203","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":295});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/UserGuideAM3517CaptureDriver_PSP_03.00.00.05 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 06:37:11 GMT -->
</html>
