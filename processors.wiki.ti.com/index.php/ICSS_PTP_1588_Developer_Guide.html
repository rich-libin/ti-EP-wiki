<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/ICSS_PTP_1588_Developer_Guide by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 08:44:14 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>ICSS PTP 1588 Developer Guide - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"ICSS_PTP_1588_Developer_Guide","wgTitle":"ICSS PTP 1588 Developer Guide","wgCurRevisionId":229581,"wgRevisionId":229581,"wgArticleId":41500,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages with broken file links"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"ICSS_PTP_1588_Developer_Guide","wgRelevantArticleId":41500,"wgRequestId":"8ae96034ce62a31ed16e3342","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-ICSS_PTP_1588_Developer_Guide rootpage-ICSS_PTP_1588_Developer_Guide skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">ICSS PTP 1588 Developer Guide</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#About_this_Guide"><span class="tocnumber">1</span> <span class="toctext">About this Guide</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Versions"><span class="tocnumber">2</span> <span class="toctext">Versions</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Changes_in_New_Release"><span class="tocnumber">2.1</span> <span class="toctext">Changes in New Release</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Glossary_of_terms"><span class="tocnumber">3</span> <span class="toctext">Glossary of terms</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#About_PTP_on_PRU-ICSS"><span class="tocnumber">4</span> <span class="toctext">About PTP on PRU-ICSS</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Features_.26_Capabilities"><span class="tocnumber">5</span> <span class="toctext">Features &amp; Capabilities</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Mechanism"><span class="tocnumber">6</span> <span class="toctext">Mechanism</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#End_to_End_Transparent_Clock_Operation"><span class="tocnumber">6.1</span> <span class="toctext">End to End Transparent Clock Operation</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Line_Delay_Calculation_.28Delay_Request.2FResponse.29"><span class="tocnumber">6.2</span> <span class="toctext">Line Delay Calculation (Delay Request/Response)</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Clock_Syntonization"><span class="tocnumber">6.3</span> <span class="toctext">Clock Syntonization</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Clock_Synchronization"><span class="tocnumber">6.4</span> <span class="toctext">Clock Synchronization</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Peer_Delay_Calculation_.28P2P_Networks.29"><span class="tocnumber">6.5</span> <span class="toctext">Peer Delay Calculation (P2P Networks)</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Peer_to_Peer_Transparent_Clock_Operation"><span class="tocnumber">6.6</span> <span class="toctext">Peer to Peer Transparent Clock Operation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#Design"><span class="tocnumber">7</span> <span class="toctext">Design</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="#Clock"><span class="tocnumber">7.1</span> <span class="toctext">Clock</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#1_PPS_Output"><span class="tocnumber">7.2</span> <span class="toctext">1 PPS Output</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Timestamping"><span class="tocnumber">7.3</span> <span class="toctext">Timestamping</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#State_Machine"><span class="tocnumber">7.4</span> <span class="toctext">State Machine</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Interrupts"><span class="tocnumber">7.5</span> <span class="toctext">Interrupts</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Synchronization"><span class="tocnumber">7.6</span> <span class="toctext">Synchronization</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Syntonization"><span class="tocnumber">7.7</span> <span class="toctext">Syntonization</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#Determination_of_Sync_Period"><span class="tocnumber">7.8</span> <span class="toctext">Determination of  Sync Period</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Resetting_the_Driver"><span class="tocnumber">7.9</span> <span class="toctext">Resetting the Driver</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-24"><a href="#Memory_Map"><span class="tocnumber">8</span> <span class="toctext">Memory Map</span></a></li>
<li class="toclevel-1 tocsection-25"><a href="#Resource_Usage"><span class="tocnumber">9</span> <span class="toctext">Resource Usage</span></a>
<ul>
<li class="toclevel-2 tocsection-26"><a href="#Interrupts_2"><span class="tocnumber">9.1</span> <span class="toctext">Interrupts</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="#Tasks"><span class="tocnumber">9.2</span> <span class="toctext">Tasks</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="#Semaphore"><span class="tocnumber">9.3</span> <span class="toctext">Semaphore</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="#Timers"><span class="tocnumber">9.4</span> <span class="toctext">Timers</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-30"><a href="#Porting_your_own_PTP_stack"><span class="tocnumber">10</span> <span class="toctext">Porting your own PTP stack</span></a>
<ul>
<li class="toclevel-2 tocsection-31"><a href="#Data_Flow"><span class="tocnumber">10.1</span> <span class="toctext">Data Flow</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#Running_Best_Master_Clock_Algorithm"><span class="tocnumber">10.2</span> <span class="toctext">Running Best Master Clock Algorithm</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Getting_the_current_time"><span class="tocnumber">10.3</span> <span class="toctext">Getting the current time</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Resetting_the_driver_2"><span class="tocnumber">10.4</span> <span class="toctext">Resetting the driver</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#Getting_other_parameters"><span class="tocnumber">10.5</span> <span class="toctext">Getting other parameters</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-36"><a href="#PTPd_Stack_integration_in_the_example"><span class="tocnumber">11</span> <span class="toctext">PTPd Stack integration in the example</span></a></li>
<li class="toclevel-1 tocsection-37"><a href="#Initialization"><span class="tocnumber">12</span> <span class="toctext">Initialization</span></a>
<ul>
<li class="toclevel-2 tocsection-38"><a href="#Memory_Allocation"><span class="tocnumber">12.1</span> <span class="toctext">Memory Allocation</span></a></li>
<li class="toclevel-2 tocsection-39"><a href="#Configuration_and_Interrupt_assignment"><span class="tocnumber">12.2</span> <span class="toctext">Configuration and Interrupt assignment</span></a></li>
<li class="toclevel-2 tocsection-40"><a href="#Callback_registration"><span class="tocnumber">12.3</span> <span class="toctext">Callback registration</span></a></li>
<li class="toclevel-2 tocsection-41"><a href="#PTP_Initialization"><span class="tocnumber">12.4</span> <span class="toctext">PTP Initialization</span></a></li>
<li class="toclevel-2 tocsection-42"><a href="#Stack_Initialization"><span class="tocnumber">12.5</span> <span class="toctext">Stack Initialization</span></a></li>
<li class="toclevel-2 tocsection-43"><a href="#Enabling_PTP"><span class="tocnumber">12.6</span> <span class="toctext">Enabling PTP</span></a></li>
<li class="toclevel-2 tocsection-44"><a href="#IP_assignment"><span class="tocnumber">12.7</span> <span class="toctext">IP assignment</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-45"><a href="#Basic_self_debugging"><span class="tocnumber">13</span> <span class="toctext">Basic self debugging</span></a>
<ul>
<li class="toclevel-2 tocsection-46"><a href="#Advanced_Debug"><span class="tocnumber">13.1</span> <span class="toctext">Advanced Debug</span></a></li>
</ul>
</li>
</ul>
</div>

<h3><span class="mw-headline" id="About_this_Guide">About this Guide</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=1" title="Edit section: About this Guide">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This wiki is meant to aid developers in understanding and using the PTP-1588 implementation on PRU-ICSS that comes as a part of <a rel="nofollow" class="external text" href="http://www.ti.com/tool/sysbiossdk-ind-sitara">Industrial SDK</a> and <a rel="nofollow" class="external text" href="http://www.ti.com/tool/PROCESSOR-SDK-AM335X">Processor SDK</a>.
</p><p><a rel="nofollow" class="external text" href="PRU-ICSS.html">PRU-ICSS</a> is an IP that is available on many TI SoC's, this wiki is about PRU-ICSS on Sitara devices, particularly AM335x, AM437x and AM57x. Developers reading this wiki are expected to familiarize themselves with the <a href="AM335x_SYSBIOS_Industrial_SDK_Getting_Started_Guide.html" title="AM335x SYSBIOS Industrial SDK Getting Started Guide">Industrial SDK</a> and <a href="Processor_SDK_RTOS_ICSS-EMAC-Design.html" title="Processor SDK RTOS ICSS-EMAC-Design">EMAC LLD</a> architecture.  
</p><p><b>Note&#160;:</b> PTP-1588 is also available on all existing Sitara devices on CPSW (The ethernet MAC on a Beaglebone) through a module known as CPTS (Common Platform Time switch) which is a hardware IP. CPSW is a gigabit switch which supports PTP 1588 v2. It's features are documented in all the respective Sitara TRM's. This wiki does not cover that aspect. Please do a comparison of both the IP's based on your requirements.
</p>
<h3><span class="mw-headline" id="Versions">Versions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=2" title="Edit section: Versions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The newer version of PTP-1588 on ICSS is called TimeSync while the older version was called PTP, the basic implementation is PTP-1588 only but the name has been changed to reflect the various annexes and derivatives of PTP that will be supported like 802.1 AS. Going forward when referring to the driver/stack as a component PTP will refer to the older design while TimeSync will refer to the new design.
</p><p>The change was done to accommodate the growing number of 
</p><p>For developers who are using the older PTP library there is a migration guide provided <a href="https://processors.wiki.ti.com/index.php?title=PRU_ICSS_TimeSync_Migration_Guide&amp;action=edit&amp;redlink=1" class="new" title="PRU ICSS TimeSync Migration Guide (page does not exist)">here</a>
</p><p>The older version is archived <a rel="nofollow" class="external text" href="http://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;oldid=223489">here</a>
</p>
<h4><span class="mw-headline" id="Changes_in_New_Release">Changes in New Release</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=3" title="Edit section: Changes in New Release">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">
  
<caption><i>Comparison between PTP and TimeSync modules</i>
</caption>
<tbody><tr>
<th>Changes
</th>
<th>TimeSync
</th>
<th>PTP
</th></tr>
<tr>
<td>TC
</td>
<td>Transparent Clock
</td>
<td>
</td></tr>
<tr>
<td>OC
</td>
<td>Ordinary clock
</td>
<td>
</td></tr>
<tr>
<td>Master
</td>
<td>Master clock
</td>
<td>
</td></tr>
<tr>
<td>Slave
</td>
<td>Ordinary clock as slave
</td>
<td>
</td></tr>
<tr>
<td>EMAC
</td>
<td>Two port EMAC
</td>
<td>
</td></tr>
<tr>
<td>Switch
</td>
<td>Either EtherNet/IP or HSR/PRP
</td>
<td>
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Glossary_of_terms">Glossary of terms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=4" title="Edit section: Glossary of terms">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">
  
<caption><i>Glossary of PTP/1588 terms</i>
</caption>
<tbody><tr>
<th>Terms
</th>
<th>Abbreviation
</th></tr>
<tr>
<td>TC
</td>
<td>Transparent Clock
</td></tr>
<tr>
<td>OC
</td>
<td>Ordinary clock
</td></tr>
<tr>
<td>Master
</td>
<td>Master clock
</td></tr>
<tr>
<td>Slave
</td>
<td>Ordinary clock as slave
</td></tr>
<tr>
<td>EMAC
</td>
<td>Two port EMAC
</td></tr>
<tr>
<td>Switch
</td>
<td>Either EtherNet/IP or HSR/PRP
</td></tr></tbody></table>
<h3><span class="mw-headline" id="About_PTP_on_PRU-ICSS">About PTP on PRU-ICSS</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=5" title="Edit section: About PTP on PRU-ICSS">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>PTP comes in a variety of standards and flavors. Every industry has it’s own set of sub rules and configurations which are defined by Annexes and Profiles. For example the telecom industry uses the telecom profile while power and substation automation requires the power profile. CIP sync requires the Drive profile. HSR + PRP has it’s own set of rules for interoperating with PTP/1588 and then there is the plain vanilla 1588 implementation for EMAC's and switches. All of this however is based on the basic PTP-1588 standard published by IEEE so there are a lot of similarities to the implementation. 
</p><p>Keeping these in mind PTP/1588 implementation on PRU-ICSS serves the following protocols/domains/markets
</p>
<ul><li>EMAC - Not supported right now.</li>
<li>EtherNet/IP CIP Sync - Supported</li>
<li>Smart Grid and Home Automation (HSR/PRP networks) - Supported</li></ul>
<p>For EMAC PTP will add generic time sync capabilities. CIP Sync is geared towards the drives markets while Smart Grid and Home Automation rely on PTP along with other protocols like IEC 61850 and IEC 62439 for reliability and precision.
</p><p><b>PTP on PRU-ICSS comes in three flavors</b>
</p>
<ol><li>Delay Request/Response based TC and OC – Drives Profile for CIP Sync. Annex D</li>
<li>Peer Delay Request/Response based TC and OC for HSR/PRP – Power profile with HSR/PRP. Annex F with modifications for IEC 62439-3</li></ol>
<p>The implementation is firmware specific. Any two implementations will not be supported at the same time. For example EtherNet/IP only has End-to-End (E2E) version of PTP, it will not support Peer-to-Peer (P2P). HSR/PRP implementation supports only P2P and the implementation is unique to HSR/PRP. Standard Peer to Peer networks will not interoperate with this implementation. There are some additional differences imposed by the standards which are applicable.
</p><p>In spite of the differences there are many similarities to the PTP design across all three implementations.
</p><p>The requirements for Delay Request/Response based TC and OC is coming from CIP Sync which requires support for Annex D of PTP/1588 (PTP over UDP) while Peer Delay Request/Response based TC and OC is coming from IEC 61588 and IEC 62439-3 (HSR/PRP) which requires support for Annex F of PTP/1588 (PTP over 802.3).
So the support is provided as such i.e. E2E TC is implemented to be over UDP (Annex D) while P2P TC is over 802.3 (Annex F). Any profile which requires E2E in Annex F and P2P over Annex D is not supported at this point of time. 
Besides these there is an additional section that discusses PTP requirements related to HSR/PRP.
</p><p><b>IEC 62439-3</b>
</p><p>PTP for HSR/PRP requires that HSR header and PRP tag be added to Sync, Follow Up and Announce packets.  Peer Delay Request and Response frames are considered link local and need not have the headers. In addition to this a 1588 implementation need not add or honor redundancy tags in PRP so tags are only applicable with respect to HSR.
The standard is still evolving on this one so the design is subject to change. This design doc follows Ed.2 of the IEC 62439-3 standard.
</p><p><br />
</p>
<h3><span id="Features_&amp;_Capabilities"></span><span class="mw-headline" id="Features_.26_Capabilities">Features &amp; Capabilities</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=6" title="Edit section: Features &amp; Capabilities">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>As mentioned before PTP/1588 on PRU-ICSS supports two flavors (right now)
</p>
<ol><li>Annex D based solution on EtherNet/IP</li>
<li>Annex F (with adaptation for HSR/PRP) on IEC 62439-3 Ed.2</li></ol>
<p><b>Single/Dual Step</b>
The slave implementation is capable of handling both single and two step PTP messages, PRU-ICSS is also capable of generating two step messages, although currently it only generates single step frames.  This feature will be enabled in future.
</p><p>The basic features supported are
</p>
<ol><li>Single step Transparent clock</li>
<li>Single step Ordinary clock</li>
<li>BMCA (Best Master clock algorithm)</li>
<li>Syntonization factor calculation</li>
<li>Simple design for time base (More explanations in design section)</li>
<li>1PPS output for Sync. Configurable time period for sync generation</li>
<li>Statistics for debugging and monitoring</li></ol>
<p><br />
</p>
<h3><span class="mw-headline" id="Mechanism">Mechanism</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=7" title="Edit section: Mechanism">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span class="mw-headline" id="End_to_End_Transparent_Clock_Operation">End to End Transparent Clock Operation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=8" title="Edit section: End to End Transparent Clock Operation">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The End to End TC works by adding the resident bridge delay correction to certain time critical packets, these are.
</p>
<ol><li>Sync</li>
<li>Delay Request</li></ol>
<p><a href="File_E2E_TC.html" class="image" title="459×97px"><img alt="459×97px" src="https://processors.wiki.ti.com/images/c/c0/E2E_TC.jpeg" width="459" height="97" /></a>
</p><p><br />
</p>
<h4><span id="Line_Delay_Calculation_(Delay_Request/Response)"></span><span class="mw-headline" id="Line_Delay_Calculation_.28Delay_Request.2FResponse.29">Line Delay Calculation (Delay Request/Response)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=9" title="Edit section: Line Delay Calculation (Delay Request/Response)">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The calculation of line delay (time distance between two nodes) although not required for doing basic transparent clocking operation is required for finding out other items like clock drift and frequency syntonization factor (rcf).
The mechanism for Line Delay is roughly the same for both Delay Request and Path Delay packets, hence this section will be referenced again for dealing with Path Delay Frames. The basic concept to understand here is that we want to find out the time it takes for a packet to traverse between the nodes. This is done by sending a packet from one node to another (usually from master to slave); this is called a sync packet. The sync packet contains a timestamp that indicates when it left the master. This is present either in the correction field or the timestamp.  If the device is incapable of providing an accurate timestamp in the sync packet, a follow up packet is sent which contains this information.  
Upon receipt of the follow up information the slave sends a Delay Request packet which again is timestamped like the sync packet with the exit timestamp. (Delay Request is actually sent periodically and independent of follow up or Sync). When a delay request is received at the Master, a Delay Response is sent meant only for that slave which issued the Delay Request (Delay Response is tagged with Slave information). The Delay Response contains the time at which Delay Request was received at the Master.
</p><p>The entire process is depicted in the diagram below.
</p><p><a href="File_E2E_delay.html" class="image" title="458×514px"><img alt="458×514px" src="https://processors.wiki.ti.com/images/3/3d/E2E_delay.jpeg" width="458" height="514" /></a>
</p>
<pre>The timestamps are respectively indicated by t1, t2, t3 and t4.
Line delay is calculated as 
Mean Path Delay = (Forward Delay + Reverse Delay) / 2 = ((t2 – t1) + (t4 – t3))/ 2
Since on both slave and master the counters are free counters, it makes more sense to re-arrange the computation like this.
Mean Path Delay = ((t4 - t1) – (t3 – t2))/2
</pre>
<p><br />
</p>
<h4><span class="mw-headline" id="Clock_Syntonization">Clock Syntonization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=10" title="Edit section: Clock Syntonization">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Two clocks need not run at same frequency and minor as well as major changes in PLL should be accounted for, this is done using the syntonization factor (rcf). For example if master clock is running at half the frequency of slave then a 1s delay measured on slave is actually only 0.5s on the master. The RCF in this case would be 0.5.
</p>
<pre>RCF is calculated as:
Here T3 is the sync transmit timestamp from master and T4 is the sync receive timestamp on slave. T3’ is T3 measured again in future (same for T4).
Rcf = (T3’ – T3) / (T4’ – T4)
Mean Path Delay (compensated) = Mean Path Delay * rcf;
</pre>
<h4><span class="mw-headline" id="Clock_Synchronization">Clock Synchronization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=11" title="Edit section: Clock Synchronization">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Clock Synchronization is the task of adjusting the timers to correct for large changes in time base or changing the value of the timer.
</p>
<ol><li>When the first sync packet arrives the seconds and nanoseconds field are copied directly to the corresponding fields in the PTP implementation. This is done by firmware when state machine is in BMCA complete state.</li>
<li>Once the local clock is synchronized IEP counter value and nanoseconds timestamp from master is compared to find the drift. Value calculated in nanoseconds is used to divide the sync interval to find the ECAP Period. An adjustment    value is chosen and programmed into the EDMA</li></ol>
<h4><span id="Peer_Delay_Calculation_(P2P_Networks)"></span><span class="mw-headline" id="Peer_Delay_Calculation_.28P2P_Networks.29">Peer Delay Calculation (P2P Networks)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=12" title="Edit section: Peer Delay Calculation (P2P Networks)">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Peer delay is calculated in a manner somewhat similar to Line delay but the frame types used are different. In this case the packets are
</p>
<ol><li>Peer Delay Request</li>
<li>Peer Delay Response</li>
<li>Peer Delay Response Follow Up</li></ol>
<pre>The nominal value of the &lt;meanPathDelay&gt; is computed as &lt;meanPathDelay&gt; = [(t2 – t1) + (t4 – t3)]/2 = [(t2 –t3) + (t4 – t1)]/2
For a one step clock like ours we return the resident bridge delay (t3-t2) in the correction field of the Pdelay response frame sent out. 
For a 2-step clock the Tx timestamp t3 is sent out in a follow up frame.
</pre>
<p><a href="File_P2P_line_delay.html" class="image" title="411×467px"><img alt="411×467px" src="https://processors.wiki.ti.com/images/1/14/P2P_line_delay.jpeg" width="411" height="467" /></a>
</p><p><br />
</p>
<h4><span class="mw-headline" id="Peer_to_Peer_Transparent_Clock_Operation">Peer to Peer Transparent Clock Operation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=13" title="Edit section: Peer to Peer Transparent Clock Operation">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>In Peer to Peer Transparent clock operation the four big differences compared to End to End TC are:
</p>
<ol><li>Path Delay Request/Response messages are used</li>
<li>Sync packet is not required for delay calculation</li>
<li>The clock adds resident bridge delay + mean path delay to the correction field (instead of just the resident bridge delay)</li>
<li>Delay isn’t necessarily measured between master and slave, it can be between any two devices hence the name peer to peer.</li></ol>
<p>Its operation is shown in the diagram below.
The correction field is updated with the value of CorrectionField where Correction Field = Mean Path Delay (lambda in the diagram) + Bridge Delay (rho in the diagram) + Correction Field of the Packet (to account for earlier delays).
</p><p><a href="File_P2P_Delay.html" class="image" title="455×514px"><img alt="455×514px" src="https://processors.wiki.ti.com/images/0/0b/P2P_Delay.jpeg" width="943" height="204" /></a>
</p><p>Since Peer to Peer Requests are meant for adjacent nodes, it’s important that these packets be dropped and not be forwarded.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Design">Design</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=14" title="Edit section: Design">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The processing load is shared between firmware (PRU) and Host (ARM) with the firmware doing most of the time critical activities. The generic division is as follows
</p>
<ul><li>firmware (PRU)
<ul><li>Timestamping</li>
<li>Packet parsing and storing fragments to memory</li>
<li>Running checks and generating fast interrupts</li></ul></li>
<li>Host (ARM)
<ul><li>BMCA algorithm</li>
<li>Synchronization (clock adjustment using timestamps provided by firmware)</li>
<li>Checks for Sync timeout</li>
<li>Syntonization factor calculation</li>
<li>Line/peer delay calculation (using firmware timestamps)</li>
<li>Sending out delay request frames</li>
<li>Responding to peer delay requests</li>
<li>Management messages</li></ul></li></ul>
<p>The task on Host is further subdivided into Driver and Stack
</p>
<ul><li>Driver - Performs all time critical tasks like packet transmit, delay calculations and synchronization</li>
<li>Stack - Performs all non critical tasks like BMCA and responding to management messages. Additionally the stack checks for Announce timeout.</li></ul>
<h4><span class="mw-headline" id="Clock">Clock</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=15" title="Edit section: Clock">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Every PTP implementation requires the following
</p>
<ol><li>An underlying hardware clock powering the ordinary clock which can be thought of as a wall clock</li>
<li>Ability to time stamp packets on entry and exit</li></ol>
<p>In case of PRU-ICSS this clock is provided by the IEP. IEP stands for Industrial Ethernet Peripheral, it has a 32 bit timer powered by a 200 Mhz derived from the main SoC Crystal-PLL combination. The timer can be programmed to automatically wraparound on a preset value. It also has different compare and capture registers to capture different kinds of events like receive and transmit events.
</p><p>More details on the HW module can be found in the ICSS section of respective TRM's. For further discussion this guide will assume that the user is familiar with IEP.
</p><p>A standard PTP implementation requires two clock values.
</p>
<ol><li>The seconds value&#160;: Corresponding to number of seconds since epoch in Unix, this is a 64 bit (48 bits are used) timer in software and corresponds to the second’s field of PTP origin timestamp. Firmware checks for the CMP0 event and increments this counter on every reset event. The value resides in shared memory. (See Memory Map)</li>
<li>The nanoseconds value&#160;: This is the 32 bit IEP hardware timer. All timestamps are with reference to this. CMP0 event is programmed to 1 second in PTP driver and reset on wraparound event is enabled in CMP_CFG register so this counter wraps around when it reaches 1s value. It can be read directly from the hardware, no adjustment is required.</li></ol>
<p>PTP does not maintain any other timer base other than these. When a query is made to find out the local time then these two values are returned.
</p><p><b>Note&#160;: Since one ICSS has only one IEP, one ICSS can only do one ordinary clock, because of this the two EMAC ports cannot have two independent ordinary clocks.</b>
</p><p><br />
</p>
<h4><span class="mw-headline" id="1_PPS_Output">1 PPS Output</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=16" title="Edit section: 1 PPS Output">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>IEP has an additional hardware to generate a programmable sync output which is tied to the IEP counter. This is called the Sync0 unit. For this signal generation CMP1 is programmed to a value ranging from 1ms to 1 second. PRU0 checks this event in firmware and re-programs it after every hit to ensure that accurate sync pulses are generated. This sync is equivalent to the 1PPS output and should not be confused with PTP Sync frame.
</p><p><br />
</p>
<h4><span class="mw-headline" id="Timestamping">Timestamping</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=17" title="Edit section: Timestamping">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Timestamping policy for different packets is given below
</p>
<ul><li>Sync – Both nanosecond and second Rx timestamps are stored and reported to driver for the purpose of RCF calculations. Tx timestamp is taken and sent out in the Sync frame.</li>
<li>Delay Response – Rx timestamp is stored and used for Delay calculation.</li>
<li>Follow Up – No timestamping record is kept</li>
<li>Announce – No timestamping record is kept</li>
<li>Delay Req – Entry and exit timestamping is done in nanoseconds. Exit timestamp is used in delay calculations while Entry timestamp is used for bridge delay calculation.</li>
<li>Pdelay Req – Rx and Tx timestamping is done in nanoseconds. Tx timestamp is used for delay calculations while Rx timestamp is used to update the correction field.</li>
<li>Pdelay Res – Rx and Tx timestamps are taken in nanoseconds. Rx timestamp is used for delay calculations while Tx timestamp is used to update the correction field.</li>
<li>Pdelay Res Follow Up – No timestamp record is kept.</li></ul>
<p>Timestamps are stored in shared memory and not provided with the packets since other than Announce and Follow Up most packets are not even sent to the Host. The timestamps are consumed by the PTP driver as and when the interrupts are triggered or PTP Task computes peer/line delay.
</p><p><b>Timestamping in Hardware:</b>
IEP module in PRU-ICSS timestamps packets on Receive and Transmit. 
</p>
<ul><li>For receive both Start of Frame (SOF) and Start of Frame Delimiter (SFD) timestamps are available.</li>
<li>For transmit only SOF timestamp is available.</li></ul>
<p>Since PTP-1588 specifies that SFD time stamps are to be used we store the RX SFD time stamp for all frames and add 640ns to the Tx SOF time stamp, the underlying assumption being that the preamble length is 8 bytes. This is ok since PTP-1588 frames are delayed cut-through (i.e. PRU-ICSS inserts it's own preamble and CRC instead of copying the received frames)
</p><p><b>PHY delay correction of timestamps</b>
It's important to compensate of PHY delay and other known delay parameters in timestamps for accurate timing. This is done in the firmware by reading pre-programmed PHY delays written into the shared RAM. The memory offsets in shared RAM for this are. 
</p>
<ul><li><b>MII_RX_CORRECTION</b> - Rx delay in nanoseconds</li>
<li><b>MII_TX_CORRECTION</b> - Tx delay in nanoseconds</li></ul>
<p>The Tx correction value should be the PHY delay + 640ns to accommodate SOF-SFD timestamp conversion.
The driver writes the latency into these locations in the function <i>ptpDramInit()</i> using the pre-defined macros RX_PHY_LATENCY and TX_PHY_LATENCY.
</p><p>For TLK110 the respective values for Rx and Tx PHY delay are 186ns and 86ns. Since for Tx 640ns is added to delay the actual value comes to 726 ns.
</p><p><br />
</p>
<h4><span class="mw-headline" id="State_Machine">State Machine</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=18" title="Edit section: State Machine">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The PTP has the following states
</p>
<ol><li>Initialized.</li>
<li>BMCA has run and master has been determined</li>
<li>Line delay computed</li>
<li>Sync interval computed</li>
<li>Ready for adjustment. This happens once 2 and 3 occur.</li>
<li>Synchronized. Average clock drift has gone below a specified threshold.</li>
<li>Error (Announce timeout, very large adjustment, sync interval too large, missed sync frame) leads to 1.</li></ol>
<p>When the Firmware initializes it goes into Initialized state and it puts all Announce and Management frames in highest priority queue and no sync interrupt is generated, TC still runs. RCF value used is the default 1.0. Once BMCA has determined the master, it’s MAC ID is written into memory; firmware checks against this MAC ID to generate Fast ISR for Sync and other frames. Clock Synchronization starts and RCF is computed along with other values.
</p>
<h4><span class="mw-headline" id="Interrupts">Interrupts</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=19" title="Edit section: Interrupts">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The EMAC-LLD has an Rx interrupt (as discussed in EMAC LLD Design Guide) but it's too slow to handle critical PTP tasks so we use a mixed approach where we dump PTP information in shared memory and issue a specific interrupt to ARM to process the data. We will refer to this as the fast ISR henceforth. 
</p><p>The following fast ISR's will be configured for PTP
</p>
<ol><li>Single interrupt for Sync where time synchronization will be done. Sync ISR</li>
<li>Single interrupt for Delay Response where line delay is be calculated. Delay Response ISR</li>
<li>Two interrupts – One each for Pdelay Request. Pdelay Req ISR</li></ol>
<p>Announce frames and PTP management messages are handled through the regular Rx interrupt on high priority queue from where they are forwarded to PTP stack for further processing.
</p>
<h4><span class="mw-headline" id="Synchronization">Synchronization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=20" title="Edit section: Synchronization">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Synchronization is about making sure that the local clock on both master and slave reflect the same value (after adjustment for path delay). This is done by
</p>
<ol><li>Copying the value of clock directly (seconds and nanoseconds) at first also called the Initial adjustment.</li>
<li>Calculating the drift every time a sync frame comes and then adjusting the local clock to take care of the drift.</li></ol>
<p>Synchronization is done in the Sync ISR context and adjustment must be complete by the time next Sync packet arrives. To calculate the drift the assumption is that second’s field is synchronized and hence only nanoseconds field is compared to find the drift irrespective of the sync interval. Exception is when there is a wraparound and Seconds field is not the same, this can happen when the slave is so far from the master that seconds field increments by the time Sync frame reaches it.
</p>
<h4><span class="mw-headline" id="Syntonization">Syntonization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=21" title="Edit section: Syntonization">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Syntonization is accounting for the frequency difference between Master and Slave. This is done by
</p>
<ol><li>Keeping track of timestamps of two alternate Sync frames (not consecutive)...1st &amp; 3rd, 2nd and 4th.</li>
<li>Taking the difference in arrival timestamp (as recorded on slave), let’s call this “slave time”</li>
<li>Taking the difference in origin timestamp (as recorded on master), let’s call this “master time”</li></ol>
<p>The RCF or syntonization factor is computed as RCF = master time/slave time. Any delay computed on slave is then multiplied by this factor. 
For example if master is running twice as fast as slave then RCF will be 2 and any delay computed on slave will get multiplied by this value to reflect time in terms of master. In reality the RCF rarely goes out of the range 0.99-1.01 and any value outside this should be interpreted as an error.
Timestamps are recorded and Syntonization is done in a PTP task and not inside Sync ISR. The function call for calculating RCF is calcRcfAndSyncInterval()
</p><p><br />
</p>
<h4><span class="mw-headline" id="Determination_of_Sync_Period">Determination of  Sync Period</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=22" title="Edit section: Determination of Sync Period">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ul><li>Sync frame interval is determined in the driver from Sync frames. The driver waits for two sync interrupts to do this.</li>
<li>Driver also checks if there is a large difference in the known Sync Period and the observed value, if it is determined that Sync interval has changed then state machine is initialized to Initializing and PTP syncs all over again.</li>
<li>Driver monitors if the time base has changed significantly (by 1 s or more). This excludes special cases such as leap59 and leap60. Such a condition triggers state machine to go to initializing and PTP synchronization happens all over again.</li>
<li>The sync frame interval is determined in the same function which calculates RCF. calcRcfAndSyncInterval()</li></ul>
<h4><span class="mw-headline" id="Resetting_the_Driver">Resetting the Driver</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=23" title="Edit section: Resetting the Driver">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>A driver reset might be required in the event of link loss or network reconfiguration. The function <i>PTP_reset()</i> performs this but for porting requirements user might need to implement their own version of the reset.
</p><p>The following steps are needed to perform a full reset. 
</p>
<ul><li>Resetting the driver requires resetting certain memory locations in the shared RAM like</li></ul>
<ul><li><ul><li>Seconds counter offset - The current UTC offset</li>
<li><i>PTP_INITIAL_ADJUSTMENT_DONE</i> - Resetting this causes firmware to do first adjustment once again.</li>
<li><i>PTP_MASTER_SRC_MAC_ID</i> - Sync interrupts cease to arrive once this is reset.</li>
<li><i>PTP_CONTROL_FLAGS_P1</i> and <i>PTP_CONTROL_FLAGS_P1</i> - These are internal flags used by PTP</li>
<li>Value of 1024 should be written to <i>PTP_TC_RCF</i></li></ul></li></ul>
<ul><li>The following structures must be reset</li></ul>
<ul><li><ul><li><i>lastSyncParam</i> &amp; <i>syncParam</i> - Contains sync parameters</li>
<li><i>delayParams</i> - Delay request and response TS parameters</li>
<li><i>pDelayParams</i> - Pdelay request and response TS and parameters</li>
<li><i>ptpSyntInfo</i> - Syntonization Info</li>
<li><i>ptpVar</i> - PTP runtime variables</li>
<li>member <i>clockDrift</i> of structure <i>ptpVar</i> should be set to a non-zero value, preferably the default PPM of the crystal.</li>
<li>member <i>rcf</i> of structure <i>ptpSyntInfo</i> should be set to 1.0</li>
<li>members <i>firstOffset</i> and <i>initialOffset</i> of structure <i>ptpSyntInfo</i> should be set to 0.</li></ul></li></ul>
<ul><li>The sync timeout clock needs to be stopped.</li>
<li>and finally the stack must be reset so that BMCA runs once more</li></ul>
<p><br />
</p>
<h3><span class="mw-headline" id="Memory_Map">Memory Map</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=24" title="Edit section: Memory Map">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The offset location is relative to PTP Base in Shared RAM. Currently the base is set to 0x8
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">

<caption><i><b>Common Memory Map</b></i>
</caption>
<tbody><tr>
<th>Name of Offs
</th>
<th>Description
<p>Refer to <i>icss_switch_ptp.h</i>
</p>
</th>
<th>Offset in Shared RAM
</th></tr>
<tr>
<td>PTP_CTRL_VAR
</td>
<td>PTP Start/Stop (1/0) info.
</td>
<td><i>0x0</i>
</td></tr>
<tr>
<td>PTP_CONTROL_FLAGS_P1
</td>
<td>PTP flags (internal to firmware) for Port 1
</td>
<td><i>0x1</i>
</td></tr>
<tr>
<td>PTP_CONTROL_FLAGS_P2
</td>
<td>PTP flags (internal to firmware) for Port 2
</td>
<td><i>0x3</i>
</td></tr>
<tr>
<td>PTP_MASTER_PORT_NUM
</td>
<td>If Master is on Port 1, write 0 else write 1 here
<p>Only used by HSR protocol
</p>
</td>
<td><i>0x5</i>
</td></tr>
<tr>
<td>PTP_RX_TS_P1
</td>
<td>Timestamp in nanoseconds for Port 1. This is a temporary
<p>place holder before this value is copied elsewhere
</p>
</td>
<td><i>0x6</i>
</td></tr>
<tr>
<td>PTP_RX_TS_P2
</td>
<td>Same as above but for Port 2
</td>
<td><i>0xA</i>
</td></tr>
<tr>
<td>PTP_FOLLOW_UP_CORRECTION_FIELD_P1
</td>
<td>Correction field value for Follow Up Frame
<p>for Port 1
</p>
</td>
<td><i>0xE</i>
</td></tr>
<tr>
<td>PTP_RX_TS_SEC_P1
</td>
<td>Timestamp in seconds for Port 1. This is a temporary
<p>place holder before this value is copied elsewhere
</p>
</td>
<td><i>0x16</i>
</td></tr>
<tr>
<td>PTP_RX_TS_SEC_P2
</td>
<td>Same as above but for Port 2
</td>
<td><i>0x1A</i>
</td></tr>
<tr>
<td>PTP_INITIAL_ADJUSTMENT_DONE
</td>
<td>Write 1 here once Initial adjustment has been done
<p>by firmware
</p>
</td>
<td><i>0x22</i>
</td></tr>
<tr>
<td>MII_TX_CORRECTION
</td>
<td>PHY Tx correction value in nanoseconds
</td>
<td><i>0x24</i>
</td></tr>
<tr>
<td>MII_RX_CORRECTION
</td>
<td>PHY Rx correction value in nanoseconds
</td>
<td><i>0x26</i>
</td></tr>
<tr>
<td>PTP_SYNC_CORRECTION_FIELD_P1
</td>
<td>Correction field value for Sync Frame
<p>for Port 1
</p>
</td>
<td><i>0x2A</i>
</td></tr>
<tr>
<td>PTP_SYNC_CORRECTION_FIELD_P2
</td>
<td>Same as above but for Port 2
</td>
<td><i>0x30</i>
</td></tr>
<tr>
<td>PTP_MASTER_SRC_MAC_ID
</td>
<td>BMCA algorithm writes Master MAC ID here
</td>
<td><i>0x36</i>
</td></tr>
<tr>
<td>PTP_SYNC_RX_TS_P1
</td>
<td>Nanoseconds TS for Sync frame ingress on Port1
</td>
<td><i>0x3C</i>
</td></tr>
<tr>
<td>PTP_SYNC_RX_TS_P2
</td>
<td>Same as above but for Port 2
</td>
<td><i>0x40</i>
</td></tr>
<tr>
<td>PTP_FOLLOW_UP_CORRECTION_FIELD_P2
</td>
<td>Correction field value for Follow Up Frame
<p>for Port 1
</p>
</td>
<td><i>0x44</i>
</td></tr>
<tr>
<td>PTP_SYNC_ORIGIN_TIMESTAMP
</td>
<td>TS from PTP Master present on the Sync frame
</td>
<td><i>0x4A</i>
</td></tr>
<tr>
<td>PTP_SYNC_SEQ_ID
</td>
<td>Sequence ID for Sync frame
</td>
<td><i>0x54</i>
</td></tr>
<tr>
<td>PTP_FOLLOW_UP_SEQ_ID
</td>
<td>Sequence ID for Sync frame
</td>
<td><i>0x56</i>
</td></tr>
<tr>
<td>PTP_SYNC_W_FUP
</td>
<td>If it's a two step Sync, write 1 here
</td>
<td><i>0x58</i>
</td></tr>
<tr>
<td>PTP_SYNC_PORT_NUM
</td>
<td>If PTP master is on port 1, firmware writes 1 here
<p>else writes 2. Driver reads this value
</p>
</td>
<td><i>0x59</i>
</td></tr>
<tr>
<td>PTP_CLK_IDENTITY_OFFSET
</td>
<td>Clock identity of the device. Driver initializes this value
</td>
<td><i>0x5A</i>
</td></tr>
<tr>
<td>PTP_SYNC0_WIDTH
</td>
<td>Pulse width of 1PPS signal. Driver initializes this value
</td>
<td><i>0x64</i>
</td></tr>
<tr>
<td>PTP_IEP_VAL_CYCLE_COUNTER
</td>
<td>For Firmware internal usage
</td>
<td><i>0x68</i>
</td></tr>
<tr>
<td>PTP_SYNC0_PERIOD
</td>
<td>For Firmware internal usage
</td>
<td><i>0x6C</i>
</td></tr>
<tr>
<td>PTP_SECONDS_COUNT_OFFSET
</td>
<td>Current UTC offset in seconds.
</td>
<td><i>0x70</i>
</td></tr>
<tr>
<td>PTP_SYNC0_CMP_VALUE
</td>
<td>Time period of Sync pulse is written here. Driver initializes.
</td>
<td><i>0x112</i>
</td></tr>
<tr>
<td>PTP_SYNC_RX_TS_SEC_P1
</td>
<td>Sync ingress TS for Port 1 in seconds
</td>
<td><i>0x116</i>
</td></tr>
<tr>
<td>PTP_SYNC_RX_TS_SEC_P2
</td>
<td>Sync ingress TS for Port 2 in seconds
</td>
<td><i>0x11C</i>
</td></tr></tbody></table>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">

<caption><i><b>E2E specific Memory Map</b></i>
</caption>
<tbody><tr>
<th>Name of Offs
</th>
<th>Description
<p>Refer to <i>icss_switch_ptp.h</i>
</p>
</th>
<th>Offset in Shared RAM
</th></tr>
<tr>
<td>PTP_DLY_REQ_RX_TS_P1
</td>
<td>Delay request Rx timestamp for Port 1
</td>
<td><i>0x78</i>
</td></tr>
<tr>
<td>PTP_DLY_REQ_RX_TS_P2
</td>
<td>Same as above for Port 2
</td>
<td><i>0x7C</i>
</td></tr>
<tr>
<td>PTP_DELAY_RES_RCVD_TIMESTAMP_P1
</td>
<td>Timestamp embedded in delay response rcvd from PTP Master
</td>
<td><i>0x80</i>
</td></tr>
<tr>
<td>PTP_DELAY_RES_RCVD_TIMESTAMP_P2
</td>
<td>Same as above but for Port 2
</td>
<td><i>0x8A</i>
</td></tr>
<tr>
<td>PTP_DEL_RESP_CORRECTION_FIELD_P2
</td>
<td>Correction field embedded in Delay response frame rcvd on Port 2
</td>
<td><i>0x94</i>
</td></tr>
<tr>
<td>PTP_DEL_RESP_CORRECTION_FIELD_P1
</td>
<td>Same as above but for Port 1
</td>
<td><i>0x9A</i>
</td></tr>
<tr>
<td>PTP_DEL_REQ_SEQ_ID
</td>
<td>Delay Request Sequence ID
</td>
<td><i>0xA0</i>
</td></tr>
<tr>
<td>PTP_DELAY_RES_SEQ_ID
</td>
<td>Delay Response Sequence ID
</td>
<td><i>0xA2</i>
</td></tr>
<tr>
<td>PTP_DEL_REQ_TIMESTAMP
</td>
<td>Rx timestamp for delay request frame
</td>
<td><i>0xA4</i>
</td></tr>
<tr>
<td>PTP_PDLY_REQ_RX_TS_P1
</td>
<td>Pdelay request Rx timestamp for Port 1
</td>
<td><i>0xA8</i>
</td></tr>
<tr>
<td>PTP_PDLY_REQ_RX_TS_P2
</td>
<td>Same as above but for Port 2
</td>
<td><i>0xAC</i>
</td></tr>
<tr>
<td>PTP_PDLY_RSP_RX_TS_P1
</td>
<td>Pdelay Response Rx timestamp for Port 1
</td>
<td><i>0xB0</i>
</td></tr>
<tr>
<td>PTP_PDLY_RSP_RX_TS_P2
</td>
<td>Same as above but for Port 2
</td>
<td><i>0xB4</i>
</td></tr>
<tr>
<td>PTP_DELAY_RES_PORT
</td>
<td>Port on which Delay response was received
</td>
<td><i>0xB8</i>
</td></tr></tbody></table>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">

<caption><i><b>P2P specific Memory Map</b></i>
</caption>
<tbody><tr>
<th>Name of Offs
</th>
<th>Description
<p>Refer to <i>icss_switch_ptp.h</i>
</p>
</th>
<th>Offset in Shared RAM
</th></tr>
<tr>
<td>PTP_CALC_LINE_DELAY_OK_P1
</td>
<td>Signal for driver that Pdelay response has been received.
<p>Proceed with delay calculation on Port 1
</p>
</td>
<td><i>0x78</i>
</td></tr>
<tr>
<td>PTP_RESP_WITH_FLWUP_P1
</td>
<td>Write 1 if it's a 2-step Delay Response on Port 1
</td>
<td><i>0x79</i>
</td></tr>
<tr>
<td>PTP_P2P_DELAY_P1
</td>
<td>Peer delay on Port 1 in nanoseconds
</td>
<td><i>0x7A</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_RCPT_TS_P1
</td>
<td>Pdelay Req Rx TS on Port 1
</td>
<td><i>0x7E</i>
</td></tr>
<tr>
<td>PTP_PDELAY_RES_FLW_UP_CORRECTION_FIELD_P1
</td>
<td>Correction field in Pdelay Response Follow Up frame
<p>for Port 1
</p>
</td>
<td><i>0x88</i>
</td></tr>
<tr>
<td>PTP_PDELAY_RES_CORRECTION_FIELD_P1
</td>
<td>Correction field in Pdelay Response frame
<p>for Port 1
</p>
</td>
<td><i>0x8E</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_TX_TS_P1
</td>
<td>Pdelay Request egress TS for Port 1
</td>
<td><i>0x94</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_RX_TS_P1
</td>
<td>Delay Response Sequence ID
</td>
<td><i>0x98</i>
</td></tr>
<tr>
<td>PTP_PDEL_RES_RX_TS_P1
</td>
<td>Pdelay response ingress TS for Port 1
</td>
<td><i>0x9C</i>
</td></tr>
<tr>
<td>PTP_PDEL_RES_ORG_TS_P1
</td>
<td>TS from peer embedded in Pdelay Response
<p>for Port 1
</p>
</td>
<td><i>0xA0</i>
</td></tr>
<tr>
<td>PTP_CALC_LINE_DELAY_OK_P2
</td>
<td>Signal for driver that Pdelay response has been received.
<p>Proceed with delay calculation on Port 2
</p>
</td>
<td><i>0xAA</i>
</td></tr>
<tr>
<td>PTP_RESP_WITH_FLWUP_P2
</td>
<td>Write 1 if it's a 2-step Delay Response on Port 2
</td>
<td><i>0xAB</i>
</td></tr>
<tr>
<td>PTP_P2P_DELAY_P2
</td>
<td>Peer delay on Port 2 in nanoseconds
</td>
<td><i>0xAC</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_RCPT_TS_P2
</td>
<td>Pdelay Req Rx TS on Port 2
</td>
<td><i>0xB0</i>
</td></tr>
<tr>
<td>PTP_PDELAY_RES_FLW_UP_CORRECTION_FIELD_P2
</td>
<td>Correction field in Pdelay Response Follow Up frame
<p>for Port 2
</p>
</td>
<td><i>0xBA</i>
</td></tr>
<tr>
<td>PTP_PDELAY_RES_CORRECTION_FIELD_P2
</td>
<td>Correction field in Pdelay Response frame
<p>for Port 2
</p>
</td>
<td><i>0xC0</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_TX_TS_P2
</td>
<td>Pdelay Request egress TS for Port 2
</td>
<td><i>0xC6</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_RX_TS_P2
</td>
<td>Delay Response Sequence ID
</td>
<td><i>0xCA</i>
</td></tr>
<tr>
<td>PTP_PDEL_RES_RX_TS_P2
</td>
<td>Pdelay response ingress TS for Port 2
</td>
<td><i>0xCE</i>
</td></tr>
<tr>
<td>PTP_PDEL_RES_ORG_TS_P2
</td>
<td>TS from peer embedded in Pdelay Response
<p>for Port 2
</p>
</td>
<td><i>0xD2</i>
</td></tr>
<tr>
<td>PTP_TC_RCF
</td>
<td>Syntonization factor calculated by driver.
</td>
<td><i>0xDC</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_DOMAIN_NUM_P1
</td>
<td>Domain Number as present in Pdelay Req frame for Port 1.
</td>
<td><i>0xE0</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_DOMAIN_NUM_P2
</td>
<td>Same as above but for Port 2
</td>
<td><i>0xE1</i>
</td></tr>
<tr>
<td>PTP_PDEL_RES_SEQ_ID_P1
</td>
<td>Sequence ID in Pdelay Response for Port 1
</td>
<td><i>0xE2</i>
</td></tr>
<tr>
<td>PTP_PDEL_RES_SEQ_ID_P2
</td>
<td>Same as above but for Port 2
</td>
<td><i>0xE4</i>
</td></tr>
<tr>
<td>PTP_PDELAY_REQ_CORRECTION_FIELD_P1
</td>
<td>Correction field in Pdelay Req frame received on Port 1
</td>
<td><i>0xE6</i>
</td></tr>
<tr>
<td>PTP_PDELAY_REQ_CORRECTION_FIELD_P2
</td>
<td>Same as above but for Port 2
</td>
<td><i>0xEC</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_SEQ_ID_P1
</td>
<td>Sequence ID of Pdelay Req frame rcvd on P1
</td>
<td><i>0xF2</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_SEQ_ID_P2
</td>
<td>Same as above but for Port 2
</td>
<td><i>0xF4</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_RX_CLK_IDENTITY_OFFSET_P1
</td>
<td>Clock identity of neighboring node on Port 1
</td>
<td><i>0xFA</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_RX_PORT_ID_P1
</td>
<td>Port ID of neighboring node on Port 1
</td>
<td><i>0x102</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_RX_SEQ_ID_P1
</td>
<td>Sequence ID of Pdelay request rcvd on Port 1
</td>
<td><i>0x104</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_RX_CLK_IDENTITY_OFFSET_P2
</td>
<td>Clock identity of neighboring node on Port 2
</td>
<td><i>0x106</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_RX_PORT_ID_P2
</td>
<td>Port ID of neighboring node on Port 2
</td>
<td><i>0x10E</i>
</td></tr>
<tr>
<td>PTP_PDEL_REQ_RX_SEQ_ID_P2
</td>
<td>Sequence ID of Pdelay request rcvd on Port 2
</td>
<td><i>0x110</i>
</td></tr></tbody></table>
<p><br />
</p>
<h3><span class="mw-headline" id="Resource_Usage">Resource Usage</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=25" title="Edit section: Resource Usage">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span class="mw-headline" id="Interrupts_2">Interrupts</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=26" title="Edit section: Interrupts">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>PTP uses three interrupts events driven by the PRUSS INTC  
</p>
<ul><li>Sync interrupt (common to both E2E and P2P implementations) - It's functions are
<ul><li>Posting <i>syncIntPendSemHandle</i> semaphore upon which Delay Req frame is sent out and Syntonization factor and Sync Interval is calculated</li></ul></li>
<li>Delay response interrupt (E2E) - Functions are
<ul><li>Line delay is calculated in this ISR</li></ul></li>
<li>Pdelay request interrupt on Port 1 (P2P)
<ul><li>Copy the parameters from Delay Request on Port 1 and reply with a PDelay Response</li></ul></li>
<li>Pdelay request interrupt on Port 2 (P2P)
<ul><li>Identical to ISR for Port 1</li></ul></li></ul>
<p>Delay response and Pdelay request interrupts are mutually exclusive so Delay response interrupt and Pdelay request ISR on Port 1 share the same interrupt number and ISR.
</p><p>The table below shows the mapping
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">

<caption><i><b>PTP/1588 Interrupt Usage</b></i>
</caption>
<tbody><tr>
<th>Interrupt Name and ISR
</th>
<th>PRU ICSS INTC number (AM335x)
</th>
<th>Description
</th></tr>
<tr>
<td><i>syncIntNum - ptpSyncIsr()</i>
</td>
<td>PRU_ICSS_EVTOUT3
</td>
<td>Interrupt for Sync frame on any port
</td></tr>
<tr>
<td><i>genericIntNum - ptpGenericIsr()</i>
</td>
<td>PRU_ICSS_EVTOUT4
</td>
<td>Shared interrupt for Delay Response and Pdelay Request on Port 0
</td></tr>
<tr>
<td><i>pDelayRespP1IntNum - ptpDelReqIsrP1()</i>
</td>
<td>PRU_ICSS_EVTOUT5
</td>
<td>Interrupt for Pdelay Request on Port 1
</td></tr>
</tbody></table>
<p>Interrupt mapping is described in the EMAC dev guide <a href="Processor_SDK_RTOS_ICSS-EMAC-Design.html#Interrupts" title="Processor SDK RTOS ICSS-EMAC-Design">here</a>
</p><p><br />
</p>
<h4><span class="mw-headline" id="Tasks">Tasks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=27" title="Edit section: Tasks">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>PTP/1588 driver uses two tasks
</p>
<ul><li><i>ptpGenericTask()</i> - It has different roles in case of E2E and P2P
<ul><li>End 2 End - Pend on semaphore posted by Sync interrupt, prepare a Delay response and send it out on the same port on which Sync was received. Also calculate syntonization factor and sync interval</li>
<li>Peer 2 Peer - Check on each port if Pdelay response has been received and calculate peer delay.</li></ul></li>
<li><i>ptpCalcRCFSyncIntTaskP2P()</i> - This is exclusive to P2P and pends on the Sync semaphore to calculate syntonization factor and sync interval</li></ul>
<p>PTPd stack internally uses timers to implement tasks like 
</p>
<ul><li>Checking for PTP frame arrival</li>
<li>Checking Announce timeouts</li></ul>
<h4><span class="mw-headline" id="Semaphore">Semaphore</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=28" title="Edit section: Semaphore">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>PTP/1588 uses one semaphore <i>syncIntPendSemHandle</i> to indicate that Sync frame has arrived and it's ok to calculate RCF (Syntonization factor) and Sync Interval.
</p>
<h4><span class="mw-headline" id="Timers">Timers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=29" title="Edit section: Timers">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Two timers are used for overall implementation. These can be software timers since the resolution is not very high.
</p>
<ul><li>PTP Driver uses one timer for detecting a Sync timeout and implementing redundant clock functionality. The clock resolution is the minimum sync interval for the system.
<ul><li>The name of clock handle is syncISRClockHandle</li>
<li>The name of ISR is <i>PTP_syncTimeoutIsr()</i></li>
<li>The timer is a manual start timer and is started once sync interval is calculated.</li></ul></li></ul>
<ul><li>PTPd stack uses one timer to detect Announce timeouts.</li></ul>
<p><br />
</p>
<h3><span class="mw-headline" id="Porting_your_own_PTP_stack">Porting your own PTP stack</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=30" title="Edit section: Porting your own PTP stack">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span class="mw-headline" id="Data_Flow">Data Flow</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=31" title="Edit section: Data Flow">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Porting your own PTP/1588 stack is very easy because most of the tasks. esp. time critical tasks are performed by the driver. The stack is only responsible for 
</p>
<ol><li>Running BMCA and finding out the PTP Master.</li>
<li>Checking for Announce timeouts</li>
<li>Handling management messages</li></ol>
<p>Once <i>ptpEnable()</i> API is called from the application, all PTP announce and management messages are sent on the highest priority queue to the Host. 
</p><p>A callback function registered to the highest priority queue then handles these frames. The callback API for PTP/1588 is called <i>processPTPFrame()</i>, it expects the entire packet in a buffer <i>pktBuffer</i>. For E2E(EtherNet/IP) the callback is called inside the EtherNet/IP callback <i>processProtocolFrames()</i> which it shares with DLR. In case of P2P, the callback can be called directly after copying the frame from the queue.
</p><p>Once the frame has been received in <i>pktBuffer</i> the frame type is checked and if it's an Announce or Management message the data is copied to the buffer <i>ptpGeneralFrame</i>. Once the frame has been copied a flag <i>generalFrameFlag</i> is set. Another API called <i>ptpGetGeneralMessage()</i> checks the flag and copies the data from the buffer <i>ptpGeneralFrame</i> to another buffer <i>buff</i> which belongs to the PTP stack. The API <i>ptpGetGeneralMessage()</i> strips the header from the frame based on whether the mode is E2E or P2P and only copies the relevant data to the Stack buffer, this way only the relevant data is sent to stack and stack need not worry whether the mode is E2E or P2P.
</p><p>The stack can call the API <i>ptpGetGeneralMessage()</i> as a callback to the PTP callback or in a loop in a task. In PTPd this is done in a task.
</p><p>The sequence is depicted in the flowchart below
</p><p><a href="File_PTPStackDiagram.html" class="image" title="679×599px"><img alt="679×599px" src="https://processors.wiki.ti.com/images/2/2c/PTPStackDiagram.jpeg" width="862" height="761" /></a>
</p>
<h4><span class="mw-headline" id="Running_Best_Master_Clock_Algorithm">Running Best Master Clock Algorithm</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=32" title="Edit section: Running Best Master Clock Algorithm">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>PTP/1588 firmware compares the Source MAC ID of Sync and Follow Up frames with the value stored at the location <b>PTP_MASTER_SRC_MAC_ID</b> in shared RAM, and if it does not match then a Sync Interrupt is not raised so for synchronization to happen once BMCA is complete and source MAC ID of a master is available. This is done by the API <i>updateParentAddress()</i>.
</p>
<h4><span class="mw-headline" id="Getting_the_current_time">Getting the current time</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=33" title="Edit section: Getting the current time">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>As explained previously in Design section, PTP has a very simple design where the IEP counter acts as the nanoseconds counter and the current UTC offset in seconds is stored in a memory location in the shared RAM. A simple read of the register and memory location gives the current time. This is done by the API <i>ptpGetCurrentTime()</i>. Refer to the API guide for more information.
</p><p><br />
</p>
<h4><span class="mw-headline" id="Resetting_the_driver_2">Resetting the driver</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=34" title="Edit section: Resetting the driver">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>In case of a timeout, link break etc the driver requires a reset. This is done using the API <i>resetPTP()</i>. The API also calls the PTPd stack de-init and init API calls <i>ptpDrvStackDeInit()</i> and <i>ptpDrvStackInit()</i>
</p><p><br />
</p>
<h4><span class="mw-headline" id="Getting_other_parameters">Getting other parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=35" title="Edit section: Getting other parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Most of the information related to PTP is encapsulated in Announce and Management messages however certain information is part of the PTP/1588 driver, the stack may need access to these for it's operation. 
Some of these values are part of the PTP runtime structure <i>ptpRuntimeVar_t</i>.
</p>
<ul><li>Sync Interval - <i>currSyncInterval</i> contains the running average of interval between two sync frames in nanoseconds</li>
<li>Port number on which Master is connected - <i>syncPortNum</i> contains this value. Value of 1 represents PORT 1 and value of 2 represents PORT 2</li>
<li>Peer/Line delay - member array <i>pathDelay</i> contains the calculated delay. First member of the array is the delay for PORT 1 and second member contains delay for PORT 2. For E2E only one delay is calculated and it's available in the first member</li>
<li>Offset from master - <i>avgRunningOffset</i> contains the running average of this value.</li>
<li>Sequence ID - <i>sequenceID</i> contains the sequence ID value populated in the delay request frames sent out</li>
<li>Sequence ID of current sync frame - <i>curSyncSeqId</i> contains this value.</li></ul>
<p><br />
</p>
<h3><span class="mw-headline" id="PTPd_Stack_integration_in_the_example">PTPd Stack integration in the example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=36" title="Edit section: PTPd Stack integration in the example">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h3><span class="mw-headline" id="Initialization">Initialization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=37" title="Edit section: Initialization">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>PTP Initialization requires in the following order
</p>
<ul><li>Memory Allocation</li>
<li>Configuration and Interrupt assignment</li>
<li>Callback registration</li>
<li>PTP initialization</li>
<li>Stack initialization - Once IP has been initialized</li>
<li>Enabling PTP</li>
<li>IP assignment</li></ul>
<h4><span class="mw-headline" id="Memory_Allocation">Memory Allocation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=38" title="Edit section: Memory Allocation">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p><i>ptpObj_t</i> and <i>ptpUserConfig_t</i> structures must be allocated in <i>main.c</i>. Rest of the structures are allocated within PTP driver with the PTP initialization API call <i>ptpAllocMem()</i>.
</p>
<h4><span class="mw-headline" id="Configuration_and_Interrupt_assignment">Configuration and Interrupt assignment</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=39" title="Edit section: Configuration and Interrupt assignment">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>PTP must be configured as either Ordinary Clock or Transparent Clock and as either End 2 End or Peer 2 Peer. Below is an example from EtherNet/IP adapter example
</p>
<pre>   /*Configure PTP*/
   ptpConfig.config = BOTH;
   ptpConfig.type = E2E;
   ptpConfig.protocol = UDP_IPV4;
</pre>
<p>Here PTP/1588 is configured as both OC and TC and in E2E mode.
</p><p><b>Limitation</b>&#160;: Currently there is no way to turn off OC and TC features separately. All PTP implementations are configured as both OC and TC by default.
</p><p>Interrupt assignment depends on how the mapping has been done. Following is the excerpt from EtherNet/IP adapter
</p>
<pre>   ptpConfig.syncIntNum = 23;
   ptpConfig.genericIntNum = 24;
</pre>
<pre>   /*This is unused if E2E mode is used*/
   if(P2P == ptpConfig.type)
   {
       ptpConfig.pDelayRespP1IntNum = 25;
   }
</pre>
<h4><span class="mw-headline" id="Callback_registration">Callback registration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=40" title="Edit section: Callback registration">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>As explained previously a callback needs to be registered to handle PTP frames which go to the highest priority queue. The callback can be exclusively for PTP as is the case for HSR/PRP or it can be mixed with a protocol like DLR like in EtherNet/IP. Here we take the example of a callback registration in HSR
</p>
<pre>   /*Packet processing callback*/
   ((((ICSSEMAC_Object *)
      emachandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;callBack =
          (ICSS_EmacCallBack)processHighPrioPackets;
   ((((ICSSEMAC_Object *)
      emachandle-&gt;object)-&gt;callBackHandle)-&gt;rxRTCallBack)-&gt;userArg = emachandle;
</pre>
<h4><span class="mw-headline" id="PTP_Initialization">PTP Initialization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=41" title="Edit section: PTP Initialization">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>PTP/1588 is initialized with the API call <i>ptpInit()</i>
</p>
<h4><span class="mw-headline" id="Stack_Initialization">Stack Initialization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=42" title="Edit section: Stack Initialization">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This will vary depending on the stack in usage. For PTPd this is done with the call <i>ptpDrvStackInit()</i>
</p>
<h4><span class="mw-headline" id="Enabling_PTP">Enabling PTP</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=43" title="Edit section: Enabling PTP">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>PTP is enabled on firmware with the call <i>ptpEnable()</i>
</p>
<h4><span class="mw-headline" id="IP_assignment">IP assignment</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=44" title="Edit section: IP assignment">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>For E2E + UDP IP must be assigned so it's part of frames being sent out. <i>addIPtoPTP()</i> is called with the IP address once IP address is available.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Basic_self_debugging">Basic self debugging</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=45" title="Edit section: Basic self debugging">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Basic PTP/1588 self-check is built into the UART console of the application. For both HSR/PRP and EtherNet/IP the UART menu option for viewing PTP is the letter "<b>P</b> (case insensitive)". The screenshot for both applications UART menu is shown below.
</p><p><a href="File_HSR_PTP_GUI.html" class="image" title="472×240px"><img alt="472×240px" src="https://processors.wiki.ti.com/images/0/05/HSR_PTP_GUI.png" width="829" height="420" /></a>
</p><p>The menu shows the current offset from master, line/peer delay (for both ports) and current time (UTC offset).
</p><p>If no master is connected then UART prompts with a question <b>"Not receiving any Sync frames, are you sure device is connected to PTP Master&#160;?"</b>.
</p>
<h4><span class="mw-headline" id="Advanced_Debug">Advanced Debug</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;section=46" title="Edit section: Advanced Debug">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>There are two ways of debugging. 
</p>
<ul><li>PTP/1588 stack supports all management messages and getting and setting of standard parameters subject to certain conditions (for example PRU-ICSS PTP/1588 devices are slave only so certain parameters are not applicable). Users can query the parameters and figure out what's going on.</li>
<li>Take a look at the internal variables and structures in CCS while debugging with JTAG</li></ul>
<p>Relevant structures and their members are listed below. Not all members are listed as many of them have no debug value.
</p>
<ul><li><b>ptpRuntimeVar_t ptpVar</b> - PTP Runtime Variable&#160;: It contains all the run time variables required by PTP/1588 application.</li></ul>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">
  
<caption><i>PTP Runtime variables</i>
</caption>
<tbody><tr>
<th>Variable Name
</th>
<th>Debug Value
</th></tr>
<tr>
<td>sequenceID
</td>
<td>Sequence ID encoded into the outgoing delay request
<p>and Pdelay request/response frames
</p>
</td></tr>
<tr>
<td>curSyncSeqId
</td>
<td>sequence ID of current Sync frame
</td></tr>
<tr>
<td>prevSyncSeqId
</td>
<td>sequence ID of previous Sync frame
<p>A difference of more than 1 between current and previous sync indicates a missed frame
</p>
</td></tr>
<tr>
<td>currOffset
</td>
<td>Current value of offset from Master
</td></tr>
<tr>
<td>prevOffset
</td>
<td>Previous value of offset from Master
<p>Difference between current and previous offset indicates jitter
</p>
</td></tr>
<tr>
<td>adjustmentIsStable
</td>
<td>Once jitter/drift goes below certain threshold this gets set to 1
<p>If this isn't set even after settling time, indicates some issue with synchronization
</p>
</td></tr>
<tr>
<td>Switch
</td>
<td>Either EtherNet/IP or HSR/PRP
</td></tr>
<tr>
<td>syncPortNum
</td>
<td>Port number on which sync is being received.
<p>Values 1/2 for Port 1 and Port 2
</p>
</td></tr>
<tr>
<td>syncTimeoutEvt
</td>
<td>Is set to 1 if a sync timeout is detected
</td></tr>
<tr>
<td>pathDelay
</td>
<td>Line delay in case of E2E and Peer delay in case of P2P
<p>Array which contains delay for both ports. 0th index indicates line delay
</p>
</td></tr>
<tr>
<td>meanPathDelay
</td>
<td>Delay on the port connected to master
<p>In case of E2E this and pathDelay[0] are same
</p>
</td></tr>
<tr>
<td>clockDrift
</td>
<td>Jitter or drift of the clock
</td></tr>
<tr>
<td>ltaOffset
</td>
<td>Long Term Offset, is the running offset from master.
<p>Computed using an exponential averaging filter
</p>
</td></tr>
<tr>
<td>avgCorrectionField
</td>
<td>Average value of correction field in Sync frame when it reaches device
</td></tr>
<tr>
<td>currSyncInterval
</td>
<td>Running average of Sync Interval. Sync interval is computed as a running average
<p>This value is used for IEP adjustment.
</p>
</td></tr></tbody></table>
<ul><li><b>ptpSyntInfo_t ptpSyntInfo</b>&#160;: Syntonization variables</li></ul>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">
  
<caption><i>PTP Syntonization variables</i>
</caption>
<tbody><tr>
<th>Variable Name
</th>
<th>Debug Value
</th></tr>
<tr>
<td>rcf
</td>
<td>The RCF or syntonization value in decimals.
<p>Value should be within 0.1% of 1 generally.
</p>
</td></tr>
<tr>
<td>syncIngressTs
</td>
<td>An array of corrected Sync Rx timestamps
<p>Alternate values form a pair for purpose of rcf calculation
</p>
</td></tr>
<tr>
<td>correctedMasterTs
</td>
<td>An array of master origin timestamps (corrected)
<p>A difference of more than 1 between current and previous sync indicates a missed frame
</p>
</td></tr></tbody></table>
<ul><li><b>ptpISRCount_t ptpISRCount&#160;:</b> Interrupt count for different PTP message types. Variable names are self explanatory so not being explained separately</li></ul>
<ul><li><b>ptpStats_t ptpStats&#160;:</b> PTP/1588 Statistics. Records events like reset events etc.</li></ul>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">
  
<caption><i>PTP Stats variables</i>
</caption>
<tbody><tr>
<th>Variable Name
</th>
<th>Debug Value
</th></tr>
<tr>
<td>numOffsetTooLarge
</td>
<td>Number of times the offset from master is above the threshold OFFSET_THRESHOLD_FOR_RESET
<p>Persistent, does not reset with PTP Reset event.
</p>
</td></tr>
<tr>
<td>numSyncIntTooLarge
</td>
<td>Every time sync interval variation is above the threshold SYNC_INTERVAL_PERIOD_CHANGE_THRESHOLD
<p>this is incremented
</p>
</td></tr>
<tr>
<td>numSyncMissed
</td>
<td>Number of missed sync frames.
<p>Difference between current and previous sync frame sequence ID
</p>
</td></tr>
<tr>
<td>numSyncTimeouts
</td>
<td>Number of times sync timeout timer has been triggered.
</td></tr>
<tr>
<td>negativeLineDelay
</td>
<td>Certain conditions can trigger a negative line delay.
<p>This variable records number of such instances
</p>
</td></tr>
<tr>
<td>firstOffset
</td>
<td>Offset calculated as soon the first sync interrupt is received
<p>This happens after first adjustment so this value is equal to crystal PPM
</p>
</td></tr>
<tr>
<td>initialOffset
</td>
<td>It is the offset from master when current offset goes below the threshold STABLE_FILTER_THRESHOLD
<p>It also represents the crystal PPM closely
</p>
</td></tr></tbody></table>

<!-- 
NewPP limit report
Cached time: 20201130115503
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.145 seconds
Real time usage: 0.150 seconds
Preprocessor visited node count: 205/1000000
Preprocessor generated node count: 273/1000000
Post‐expand include size: 1359/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    3.001      1 -total
 54.74%    1.643      9 Template:Prettytable
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:41500-0!canonical and timestamp 20201130115503 and revision id 229581
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>ICSS PTP 1588 Developer Guide</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>ICSS PTP 1588 Developer Guide</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>ICSS PTP 1588 Developer Guide</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>ICSS PTP 1588 Developer Guide</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>ICSS PTP 1588 Developer Guide</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>ICSS PTP 1588 Developer Guide</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>ICSS PTP 1588 Developer Guide</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>ICSS PTP 1588 Developer Guide</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>ICSS PTP 1588 Developer Guide</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;oldid=229581">https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;oldid=229581</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="https://processors.wiki.ti.com/index.php?title=Category:Pages_with_broken_file_links&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages with broken file links (page does not exist)">Pages with broken file links</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=ICSS+PTP+1588+Developer+Guide" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="ICSS_PTP_1588_Developer_Guide.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Talk:ICSS_PTP_1588_Developer_Guide&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="ICSS_PTP_1588_Developer_Guide.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/ICSS_PTP_1588_Developer_Guide.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/ICSS_PTP_1588_Developer_Guide.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;oldid=229581" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=ICSS_PTP_1588_Developer_Guide&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 13 July 2017, at 05:35.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.145","walltime":"0.150","ppvisitednodes":{"value":205,"limit":1000000},"ppgeneratednodes":{"value":273,"limit":1000000},"postexpandincludesize":{"value":1359,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    3.001      1 -total"," 54.74%    1.643      9 Template:Prettytable"]},"cachereport":{"timestamp":"20201130115503","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":243});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/ICSS_PTP_1588_Developer_Guide by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 08:44:22 GMT -->
</html>
