<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/BIOS_MCSDK_2.0_User_Guide by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 04:06:22 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>BIOS MCSDK 2.0 User Guide - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"BIOS_MCSDK_2.0_User_Guide","wgTitle":"BIOS MCSDK 2.0 User Guide","wgCurRevisionId":216114,"wgRevisionId":216114,"wgArticleId":8540,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["C667x","C66x","Keystone","Multicore","SDK","SYSBIOS"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"BIOS_MCSDK_2.0_User_Guide","wgRelevantArticleId":8540,"wgRequestId":"7f5c7737436295e123145b9f","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-BIOS_MCSDK_2_0_User_Guide rootpage-BIOS_MCSDK_2_0_User_Guide skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">BIOS MCSDK 2.0 User Guide</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div style="padding:5px; background: #eeeeee; color: #FF0000">
<p><i><b>Important Note:</b></i><br />
</p><p><i><b>The software found on this site is available for download, but is no longer being actively developed or maintained. C665x and C667x devices are now actively maintained on the Processor-SDK release stream. For Migration guide refer <a href="http://software-dl.ti.com/processor-sdk-linux/esd/docs/04_03_00_05/linux/Release_Specific.html#mcsdk-to-processor-sdk-migration-guide" title="MCSDK to Processor SDK Migration">MCSDK_to_Processor_SDK_Migration</a></b></i>
</p>
</div> <p><br />
</p><p><a href="File_TIBanner.html" class="image"><img alt="TIBanner.png" src="https://processors.wiki.ti.com/images/c/cd/TIBanner.png" width="667" height="87" /></a>
</p><p><br /><font size="6"><b>BIOS Multicore Software Development Kit</b><br /></font><br /><font size="6"><b>Version 2.x</b> <br /></font><br /><font size="6"><b>User's Guide</b></font> <br /><br />
</p><p><i>Last updated: 05/08/2016</i>
</p>
<hr />
<div style="margin: 5px; padding: 2px 10px; background-color: #ecffff; border-left: 5px solid #3399ff;"><b>NOTE</b><br /><br />C665x and C667x devices are now actively maintained on the Processor-SDK release stream. See <a rel="nofollow" class="external free" href="http://www.ti.com/lsds/ti/tools-software/processor_sw.page">http://www.ti.com/lsds/ti/tools-software/processor_sw.page</a> for more information.</div>
<p><br />
</p>
<div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Acronyms_and_Definitions"><span class="tocnumber">1.1</span> <span class="toctext">Acronyms and Definitions</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Supported_Devices.2FPlatforms"><span class="tocnumber">1.2</span> <span class="toctext">Supported Devices/Platforms</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Other_Resources"><span class="tocnumber">2</span> <span class="toctext">Other Resources</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Training"><span class="tocnumber">2.1</span> <span class="toctext">Training</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#White_Papers"><span class="tocnumber">2.2</span> <span class="toctext">White Papers</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Getting_Started_Guides"><span class="tocnumber">2.3</span> <span class="toctext">Getting Started Guides</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#API_and_LLD_User_Guides"><span class="tocnumber">2.4</span> <span class="toctext">API and LLD User Guides</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Tools_Overview"><span class="tocnumber">2.5</span> <span class="toctext">Tools Overview</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Hardware_-_EVM_Overview"><span class="tocnumber">2.6</span> <span class="toctext">Hardware - EVM Overview</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Hardware_-_Processor_Overview"><span class="tocnumber">2.7</span> <span class="toctext">Hardware - Processor Overview</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Related_Software"><span class="tocnumber">2.8</span> <span class="toctext">Related Software</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-13"><a href="#Software_Overview"><span class="tocnumber">3</span> <span class="toctext">Software Overview</span></a>
<ul>
<li class="toclevel-2 tocsection-14"><a href="#Platform_Development_Kit_.28PDK.29"><span class="tocnumber">3.1</span> <span class="toctext">Platform Development Kit (PDK)</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="#Operating_System_Adaptation_Layer_.28OSAL.29"><span class="tocnumber">3.1.1</span> <span class="toctext">Operating System Adaptation Layer (OSAL)</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#Resource_Management"><span class="tocnumber">3.1.2</span> <span class="toctext">Resource Management</span></a>
<ul>
<li class="toclevel-4 tocsection-17"><a href="#Platform_Resource_Manager"><span class="tocnumber">3.1.2.1</span> <span class="toctext">Platform Resource Manager</span></a></li>
<li class="toclevel-4 tocsection-18"><a href="#Resource_Manager_.28RM.29_LLD"><span class="tocnumber">3.1.2.2</span> <span class="toctext">Resource Manager (RM) LLD</span></a>
<ul>
<li class="toclevel-5 tocsection-19"><a href="#Managed_Resources"><span class="tocnumber">3.1.2.2.1</span> <span class="toctext">Managed Resources</span></a></li>
<li class="toclevel-5 tocsection-20"><a href="#RM_Architecture_Overview"><span class="tocnumber">3.1.2.2.2</span> <span class="toctext">RM Architecture Overview</span></a></li>
<li class="toclevel-5 tocsection-21"><a href="#Using_the_RM_LLD"><span class="tocnumber">3.1.2.2.3</span> <span class="toctext">Using the RM LLD</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-3 tocsection-22"><a href="#Chip_Support_Library_.28CSL.29"><span class="tocnumber">3.1.3</span> <span class="toctext">Chip Support Library (CSL)</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#Low_Level_Drivers"><span class="tocnumber">3.1.4</span> <span class="toctext">Low Level Drivers</span></a>
<ul>
<li class="toclevel-4 tocsection-24"><a href="#Resource_Manager_.28RM.29"><span class="tocnumber">3.1.4.1</span> <span class="toctext">Resource Manager (RM)</span></a></li>
<li class="toclevel-4 tocsection-25"><a href="#EDMA3_Low_Level_Driver"><span class="tocnumber">3.1.4.2</span> <span class="toctext">EDMA3 Low Level Driver</span></a></li>
<li class="toclevel-4 tocsection-26"><a href="#Multicore_Navigator"><span class="tocnumber">3.1.4.3</span> <span class="toctext">Multicore Navigator</span></a>
<ul>
<li class="toclevel-5 tocsection-27"><a href="#Packet_DMA_.28CPPI.29"><span class="tocnumber">3.1.4.3.1</span> <span class="toctext">Packet DMA (CPPI)</span></a></li>
<li class="toclevel-5 tocsection-28"><a href="#Queue_Manager_.28QMSS.29"><span class="tocnumber">3.1.4.3.2</span> <span class="toctext">Queue Manager (QMSS)</span></a></li>
</ul>
</li>
<li class="toclevel-4 tocsection-29"><a href="#Network_Co-processor_.28NETCP.29"><span class="tocnumber">3.1.4.4</span> <span class="toctext">Network Co-processor (NETCP)</span></a>
<ul>
<li class="toclevel-5 tocsection-30"><a href="#Security_Accelerator_.28SA.29"><span class="tocnumber">3.1.4.4.1</span> <span class="toctext">Security Accelerator (SA)</span></a></li>
<li class="toclevel-5 tocsection-31"><a href="#Packet_Accelerator_.28PA.29"><span class="tocnumber">3.1.4.4.2</span> <span class="toctext">Packet Accelerator (PA)</span></a></li>
</ul>
</li>
<li class="toclevel-4 tocsection-32"><a href="#I.2FO_and_Buses"><span class="tocnumber">3.1.4.5</span> <span class="toctext">I/O and Buses</span></a>
<ul>
<li class="toclevel-5 tocsection-33"><a href="#Serial_RapidIO_.28SRIO.29"><span class="tocnumber">3.1.4.5.1</span> <span class="toctext">Serial RapidIO (SRIO)</span></a></li>
<li class="toclevel-5 tocsection-34"><a href="#Peripheral_Component_Interconnect_Express_.28PCIe.29"><span class="tocnumber">3.1.4.5.2</span> <span class="toctext">Peripheral Component Interconnect Express (PCIe)</span></a></li>
<li class="toclevel-5 tocsection-35"><a href="#Antenna_Interface_.28AIF2.29"><span class="tocnumber">3.1.4.5.3</span> <span class="toctext">Antenna Interface (AIF2)</span></a></li>
<li class="toclevel-5 tocsection-36"><a href="#TSIP"><span class="tocnumber">3.1.4.5.4</span> <span class="toctext">TSIP</span></a></li>
<li class="toclevel-5 tocsection-37"><a href="#Hyperlink"><span class="tocnumber">3.1.4.5.5</span> <span class="toctext">Hyperlink</span></a></li>
<li class="toclevel-5 tocsection-38"><a href="#Ethernet_Media_Access_Controller_.28EMAC.29"><span class="tocnumber">3.1.4.5.6</span> <span class="toctext">Ethernet Media Access Controller (EMAC)</span></a></li>
</ul>
</li>
<li class="toclevel-4 tocsection-39"><a href="#Co-processors"><span class="tocnumber">3.1.4.6</span> <span class="toctext">Co-processors</span></a>
<ul>
<li class="toclevel-5 tocsection-40"><a href="#Bit-rate_Coprocessor_.28BCP.29"><span class="tocnumber">3.1.4.6.1</span> <span class="toctext">Bit-rate Coprocessor (BCP)</span></a></li>
<li class="toclevel-5 tocsection-41"><a href="#Turbo_Coprocessor_Decoder_.28TCP3d.29"><span class="tocnumber">3.1.4.6.2</span> <span class="toctext">Turbo Coprocessor Decoder (TCP3d)</span></a></li>
<li class="toclevel-5 tocsection-42"><a href="#Turbo_Coprocessor_Encoder_.28TCP3e.29"><span class="tocnumber">3.1.4.6.3</span> <span class="toctext">Turbo Coprocessor Encoder (TCP3e)</span></a></li>
<li class="toclevel-5 tocsection-43"><a href="#FFT_Accelerator_Coprocessor.28FFTC.29"><span class="tocnumber">3.1.4.6.4</span> <span class="toctext">FFT Accelerator Coprocessor(FFTC)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-3 tocsection-44"><a href="#Platform_Library"><span class="tocnumber">3.1.5</span> <span class="toctext">Platform Library</span></a></li>
<li class="toclevel-3 tocsection-45"><a href="#Transport"><span class="tocnumber">3.1.6</span> <span class="toctext">Transport</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-46"><a href="#SYS.2FBIOS_RTOS"><span class="tocnumber">3.2</span> <span class="toctext">SYS/BIOS RTOS</span></a></li>
<li class="toclevel-2 tocsection-47"><a href="#Inter-Processor_Communication_.28IPC.29"><span class="tocnumber">3.3</span> <span class="toctext">Inter-Processor Communication (IPC)</span></a>
<ul>
<li class="toclevel-3 tocsection-48"><a href="#IPC_Transports"><span class="tocnumber">3.3.1</span> <span class="toctext">IPC Transports</span></a>
<ul>
<li class="toclevel-4 tocsection-49"><a href="#QMSS_IPC_Transport"><span class="tocnumber">3.3.1.1</span> <span class="toctext">QMSS IPC Transport</span></a></li>
<li class="toclevel-4 tocsection-50"><a href="#SRIO_IPC_Transport"><span class="tocnumber">3.3.1.2</span> <span class="toctext">SRIO IPC Transport</span></a></li>
<li class="toclevel-4 tocsection-51"><a href="#Rebuilding_the_IPC_Transports"><span class="tocnumber">3.3.1.3</span> <span class="toctext">Rebuilding the IPC Transports</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-52"><a href="#IPC_Flow"><span class="tocnumber">3.3.2</span> <span class="toctext">IPC Flow</span></a>
<ul>
<li class="toclevel-4 tocsection-53"><a href="#IPC_Overview"><span class="tocnumber">3.3.2.1</span> <span class="toctext">IPC Overview</span></a></li>
<li class="toclevel-4 tocsection-54"><a href="#IPC_Startup"><span class="tocnumber">3.3.2.2</span> <span class="toctext">IPC Startup</span></a></li>
<li class="toclevel-4 tocsection-55"><a href="#IPC_Heap_Sharing"><span class="tocnumber">3.3.2.3</span> <span class="toctext">IPC Heap Sharing</span></a></li>
<li class="toclevel-4 tocsection-56"><a href="#IPC_MessageQ_Queue_Sharing"><span class="tocnumber">3.3.2.4</span> <span class="toctext">IPC MessageQ Queue Sharing</span></a></li>
<li class="toclevel-4 tocsection-57"><a href="#IPC_Shared_Memory_Transport_Message_Passing"><span class="tocnumber">3.3.2.5</span> <span class="toctext">IPC Shared Memory Transport Message Passing</span></a></li>
<li class="toclevel-4 tocsection-58"><a href="#IPC_QMSS_Transport_Message_Passing"><span class="tocnumber">3.3.2.6</span> <span class="toctext">IPC QMSS Transport Message Passing</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-59"><a href="#IPC_Module_Usage_for_Different_Transports"><span class="tocnumber">3.3.3</span> <span class="toctext">IPC Module Usage for Different Transports</span></a>
<ul>
<li class="toclevel-4 tocsection-60"><a href="#Shared_Memory_IPC_Transport"><span class="tocnumber">3.3.3.1</span> <span class="toctext">Shared Memory IPC Transport</span></a></li>
<li class="toclevel-4 tocsection-61"><a href="#QMSS.2FNavigator_IPC_Transport"><span class="tocnumber">3.3.3.2</span> <span class="toctext">QMSS/Navigator IPC Transport</span></a></li>
<li class="toclevel-4 tocsection-62"><a href="#SRIO_IPC_Transport_2"><span class="tocnumber">3.3.3.3</span> <span class="toctext">SRIO IPC Transport</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-63"><a href="#IPC_Benchmarks"><span class="tocnumber">3.3.4</span> <span class="toctext">IPC Benchmarks</span></a>
<ul>
<li class="toclevel-4 tocsection-64"><a href="#Latency_Benchmark_Setup"><span class="tocnumber">3.3.4.1</span> <span class="toctext">Latency Benchmark Setup</span></a></li>
<li class="toclevel-4 tocsection-65"><a href="#Benchmark_Results"><span class="tocnumber">3.3.4.2</span> <span class="toctext">Benchmark Results</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-66"><a href="#Network_Development_Kit_.28NDK.29"><span class="tocnumber">3.4</span> <span class="toctext">Network Development Kit (NDK)</span></a>
<ul>
<li class="toclevel-3 tocsection-67"><a href="#Network_Interface_Management_Unit_.28NIMU.29_Driver"><span class="tocnumber">3.4.1</span> <span class="toctext">Network Interface Management Unit (NIMU) Driver</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-68"><a href="#Runtime_Libraries"><span class="tocnumber">3.5</span> <span class="toctext">Runtime Libraries</span></a>
<ul>
<li class="toclevel-3 tocsection-69"><a href="#OpenEM"><span class="tocnumber">3.5.1</span> <span class="toctext">OpenEM</span></a></li>
<li class="toclevel-3 tocsection-70"><a href="#OpenMP"><span class="tocnumber">3.5.2</span> <span class="toctext">OpenMP</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-71"><a href="#Algorithm_Libraries"><span class="tocnumber">3.6</span> <span class="toctext">Algorithm Libraries</span></a>
<ul>
<li class="toclevel-3 tocsection-72"><a href="#DSP_Library_.28DSPLIB.29"><span class="tocnumber">3.6.1</span> <span class="toctext">DSP Library (DSPLIB)</span></a></li>
<li class="toclevel-3 tocsection-73"><a href="#Image_Processing_Library_.28IMGLIB.29"><span class="tocnumber">3.6.2</span> <span class="toctext">Image Processing Library (IMGLIB)</span></a></li>
<li class="toclevel-3 tocsection-74"><a href="#Floating_Point_Math_Library_.28MATHLIB.29"><span class="tocnumber">3.6.3</span> <span class="toctext">Floating Point Math Library (MATHLIB)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-75"><a href="#Demonstration_Software"><span class="tocnumber">3.7</span> <span class="toctext">Demonstration Software</span></a>
<ul>
<li class="toclevel-3 tocsection-76"><a href="#High-Performance_DSP_Utility_Application_.28HUA.29"><span class="tocnumber">3.7.1</span> <span class="toctext">High-Performance DSP Utility Application (HUA)</span></a></li>
<li class="toclevel-3 tocsection-77"><a href="#Image_Processing_Demonstration"><span class="tocnumber">3.7.2</span> <span class="toctext">Image Processing Demonstration</span></a></li>
<li class="toclevel-3 tocsection-78"><a href="#Multicore_Video_Infrastructure_Demonstration"><span class="tocnumber">3.7.3</span> <span class="toctext">Multicore Video Infrastructure Demonstration</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-79"><a href="#Bootloader_and_Boot_Utilities"><span class="tocnumber">3.8</span> <span class="toctext">Bootloader and Boot Utilities</span></a>
<ul>
<li class="toclevel-3 tocsection-80"><a href="#Boot_Utilities"><span class="tocnumber">3.8.1</span> <span class="toctext">Boot Utilities</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-81"><a href="#Multicore_Application_Deployment_.28MAD.29_Utilities"><span class="tocnumber">3.9</span> <span class="toctext">Multicore Application Deployment (MAD) Utilities</span></a></li>
<li class="toclevel-2 tocsection-82"><a href="#Tools"><span class="tocnumber">3.10</span> <span class="toctext">Tools</span></a>
<ul>
<li class="toclevel-3 tocsection-83"><a href="#cToolsLibrary"><span class="tocnumber">3.10.1</span> <span class="toctext">cToolsLibrary</span></a></li>
<li class="toclevel-3 tocsection-84"><a href="#Multicore_System_Analyzer_.28MCSA.29"><span class="tocnumber">3.10.2</span> <span class="toctext">Multicore System Analyzer (MCSA)</span></a></li>
<li class="toclevel-3 tocsection-85"><a href="#Eclipse_RTSC_Tools_.28XDC.29"><span class="tocnumber">3.10.3</span> <span class="toctext">Eclipse RTSC Tools (XDC)</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-86"><a href="#Third_Party_Software_and_Tools"><span class="tocnumber">4</span> <span class="toctext">Third Party Software and Tools</span></a>
<ul>
<li class="toclevel-2 tocsection-87"><a href="#Prism_from_Criticalblue"><span class="tocnumber">4.1</span> <span class="toctext">Prism from Criticalblue</span></a></li>
<li class="toclevel-2 tocsection-88"><a href="#Poly-Platform_from_PolyCore_Software"><span class="tocnumber">4.2</span> <span class="toctext">Poly-Platform from PolyCore Software</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-89"><a href="#Build_and_Example_Guide"><span class="tocnumber">5</span> <span class="toctext">Build and Example Guide</span></a>
<ul>
<li class="toclevel-2 tocsection-90"><a href="#Setting_up_the_Build_Environment"><span class="tocnumber">5.1</span> <span class="toctext">Setting up the Build Environment</span></a></li>
<li class="toclevel-2 tocsection-91"><a href="#Building_the_Software"><span class="tocnumber">5.2</span> <span class="toctext">Building the Software</span></a>
<ul>
<li class="toclevel-3 tocsection-92"><a href="#Build_in_Place_vs._Build_in_Workspace"><span class="tocnumber">5.2.1</span> <span class="toctext">Build in Place vs. Build in Workspace</span></a></li>
<li class="toclevel-3 tocsection-93"><a href="#Modifying_a_Library"><span class="tocnumber">5.2.2</span> <span class="toctext">Modifying a Library</span></a></li>
<li class="toclevel-3 tocsection-94"><a href="#Platform_Library_2"><span class="tocnumber">5.2.3</span> <span class="toctext">Platform Library</span></a></li>
<li class="toclevel-3 tocsection-95"><a href="#Building_CSL_and_the_Low_Level_Device_Drivers"><span class="tocnumber">5.2.4</span> <span class="toctext">Building CSL and the Low Level Device Drivers</span></a>
<ul>
<li class="toclevel-4 tocsection-96"><a href="#Building_the_Device_Drivers_Example_Projects"><span class="tocnumber">5.2.4.1</span> <span class="toctext">Building the Device Drivers Example Projects</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-97"><a href="#Compiling_Big_Endian_MCSDK_Demos_and_Examples"><span class="tocnumber">5.2.5</span> <span class="toctext">Compiling Big Endian MCSDK Demos and Examples</span></a></li>
<li class="toclevel-3 tocsection-98"><a href="#Building_and_running_NDK_client_example_with_simulator"><span class="tocnumber">5.2.6</span> <span class="toctext">Building and running NDK client example with simulator</span></a></li>
<li class="toclevel-3 tocsection-99"><a href="#Building_NDK"><span class="tocnumber">5.2.7</span> <span class="toctext">Building NDK</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-100"><a href="#Examples"><span class="tocnumber">5.3</span> <span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-3 tocsection-101"><a href="#Example_1_-_Building_and_running_a_simple_single_core_application"><span class="tocnumber">5.3.1</span> <span class="toctext">Example 1 - Building and running a simple single core application</span></a></li>
<li class="toclevel-3 tocsection-102"><a href="#Example_2_-_Building_and_running_your_first_tasking_application_using_MCSDK_and_BIOS"><span class="tocnumber">5.3.2</span> <span class="toctext">Example 2 - Building and running your first tasking application using MCSDK and BIOS</span></a></li>
<li class="toclevel-3 tocsection-103"><a href="#Example_3_-_Running_from_external_memory_.28DDR.29"><span class="tocnumber">5.3.3</span> <span class="toctext">Example 3 - Running from external memory (DDR)</span></a>
<ul>
<li class="toclevel-4 tocsection-104"><a href="#.3D.3D_main.c_.3D"><span class="tocnumber">5.3.3.1</span> <span class="toctext">== main.c =</span></a></li>
<li class="toclevel-4 tocsection-105"><a href="#.3D.3D_taskFxn_.3D"><span class="tocnumber">5.3.3.2</span> <span class="toctext">== taskFxn =</span></a></li>
<li class="toclevel-4 tocsection-106"><a href="#.3D.3D_main_.3D"><span class="tocnumber">5.3.3.3</span> <span class="toctext">== main =</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-107"><a href="#Example_4_-_Let.27s_make_it_multi-core"><span class="tocnumber">5.3.4</span> <span class="toctext">Example 4 - Let's make it multi-core</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-108"><a href="#Multi-core_Programming_Models"><span class="tocnumber">6</span> <span class="toctext">Multi-core Programming Models</span></a>
<ul>
<li class="toclevel-2 tocsection-109"><a href="#Explicit_Programming_Model_using_IPC"><span class="tocnumber">6.1</span> <span class="toctext">Explicit Programming Model using IPC</span></a>
<ul>
<li class="toclevel-3 tocsection-110"><a href="#Using_and_Configuring_the_Navigator.2FQMSS_Transport"><span class="tocnumber">6.1.1</span> <span class="toctext">Using and Configuring the Navigator/QMSS Transport</span></a>
<ul>
<li class="toclevel-4 tocsection-111"><a href="#Configure_IPC_to_Use_the_QMSS_Transport"><span class="tocnumber">6.1.1.1</span> <span class="toctext">Configure IPC to Use the QMSS Transport</span></a></li>
<li class="toclevel-4 tocsection-112"><a href="#Changing_the_GEM_Interrupt_Used_by_the_QMSS_Transport_Module_.26_Other_TransportQmssSetup_Parameters"><span class="tocnumber">6.1.1.2</span> <span class="toctext">Changing the GEM Interrupt Used by the QMSS Transport Module &amp; Other TransportQmssSetup Parameters</span></a></li>
<li class="toclevel-4 tocsection-113"><a href="#TransportQmss_Configuration_Options"><span class="tocnumber">6.1.1.3</span> <span class="toctext">TransportQmss Configuration Options</span></a></li>
<li class="toclevel-4 tocsection-114"><a href="#TransportQmss_Queue_Allocation_Notes"><span class="tocnumber">6.1.1.4</span> <span class="toctext">TransportQmss Queue Allocation Notes</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-115"><a href="#Using_and_Configuring_the_sRIO_Transport"><span class="tocnumber">6.1.2</span> <span class="toctext">Using and Configuring the sRIO Transport</span></a>
<ul>
<li class="toclevel-4 tocsection-116"><a href="#Configure_IPC_to_Use_the_sRIO_Transport"><span class="tocnumber">6.1.2.1</span> <span class="toctext">Configure IPC to Use the sRIO Transport</span></a></li>
<li class="toclevel-4 tocsection-117"><a href="#Changing_the_GEM_Interrupt_Used_by_the_sRIO_Transport_Module_.26_Other_TransportSrioSetup_Parameters"><span class="tocnumber">6.1.2.2</span> <span class="toctext">Changing the GEM Interrupt Used by the sRIO Transport Module &amp; Other TransportSrioSetup Parameters</span></a></li>
<li class="toclevel-4 tocsection-118"><a href="#TransportSrio_Configuration_Options"><span class="tocnumber">6.1.2.3</span> <span class="toctext">TransportSrio Configuration Options</span></a></li>
<li class="toclevel-4 tocsection-119"><a href="#TransportSrio_Core_Map_Configuration_and_IPC_Cluster_Parameters"><span class="tocnumber">6.1.2.4</span> <span class="toctext">TransportSrio Core Map Configuration and IPC Cluster Parameters</span></a>
<ul>
<li class="toclevel-5 tocsection-120"><a href="#TransportSrio_Single_Device_Core_Map_and_IPC_Cluster_Configuration"><span class="tocnumber">6.1.2.4.1</span> <span class="toctext">TransportSrio Single Device Core Map and IPC Cluster Configuration</span></a></li>
<li class="toclevel-5 tocsection-121"><a href="#TransportSrio_Multi-Device_Core_Map_and_IPC_Cluster_Configuration"><span class="tocnumber">6.1.2.4.2</span> <span class="toctext">TransportSrio Multi-Device Core Map and IPC Cluster Configuration</span></a>
<ul>
<li class="toclevel-6 tocsection-122"><a href="#Device_One_.28Producer.29_Configuration"><span class="tocnumber">6.1.2.4.2.1</span> <span class="toctext">Device One (Producer) Configuration</span></a></li>
<li class="toclevel-6 tocsection-123"><a href="#Device_Two_.28Consumer.29_Configuration"><span class="tocnumber">6.1.2.4.2.2</span> <span class="toctext">Device Two (Consumer) Configuration</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-4 tocsection-124"><a href="#TransportSrio_Queue_Allocation_Notes"><span class="tocnumber">6.1.2.5</span> <span class="toctext">TransportSrio Queue Allocation Notes</span></a></li>
<li class="toclevel-4 tocsection-125"><a href="#TransportSrio_Application_Configuration_Requirements"><span class="tocnumber">6.1.2.6</span> <span class="toctext">TransportSrio Application Configuration Requirements</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-126"><a href="#Programming_Model_using_OpenMP"><span class="tocnumber">6.2</span> <span class="toctext">Programming Model using OpenMP</span></a>
<ul>
<li class="toclevel-3 tocsection-127"><a href="#Compiling_OpenMP_code_with_the_TI_compiler_using_Makefile"><span class="tocnumber">6.2.1</span> <span class="toctext">Compiling OpenMP code with the TI compiler using Makefile</span></a></li>
<li class="toclevel-3 tocsection-128"><a href="#Using_OpenMP_on_TI_devices"><span class="tocnumber">6.2.2</span> <span class="toctext">Using OpenMP on TI devices</span></a>
<ul>
<li class="toclevel-4 tocsection-129"><a href="#Memory_Coherency"><span class="tocnumber">6.2.2.1</span> <span class="toctext">Memory Coherency</span></a></li>
<li class="toclevel-4 tocsection-130"><a href="#Threadprivate_Memory"><span class="tocnumber">6.2.2.2</span> <span class="toctext">Threadprivate Memory</span></a></li>
<li class="toclevel-4 tocsection-131"><a href="#Known_issues"><span class="tocnumber">6.2.2.3</span> <span class="toctext">Known issues</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-132"><a href="#Examples_2"><span class="tocnumber">6.2.3</span> <span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-4 tocsection-133"><a href="#Multicore_Hello_World_Example"><span class="tocnumber">6.2.3.1</span> <span class="toctext">Multicore Hello World Example</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-134"><a href="#OMP_Integration_for_Advanced_Users"><span class="tocnumber">6.2.4</span> <span class="toctext">OMP Integration for Advanced Users</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-135"><a href="#Multi-core_Application_Image_Creation"><span class="tocnumber">7</span> <span class="toctext">Multi-core Application Image Creation</span></a></li>
<li class="toclevel-1 tocsection-136"><a href="#Booting_and_Flash"><span class="tocnumber">8</span> <span class="toctext">Booting and Flash</span></a>
<ul>
<li class="toclevel-2 tocsection-137"><a href="#Boot_Overview"><span class="tocnumber">8.1</span> <span class="toctext">Boot Overview</span></a></li>
<li class="toclevel-2 tocsection-138"><a href="#Power_On_Self_Test_.28POST.29"><span class="tocnumber">8.2</span> <span class="toctext">Power On Self Test (POST)</span></a></li>
<li class="toclevel-2 tocsection-139"><a href="#Intermediate_Boot_Loader_.28IBL.29_and_Examples"><span class="tocnumber">8.3</span> <span class="toctext">Intermediate Boot Loader (IBL) and Examples</span></a></li>
<li class="toclevel-2 tocsection-140"><a href="#Flash_and_Flash_Utilities"><span class="tocnumber">8.4</span> <span class="toctext">Flash and Flash Utilities</span></a>
<ul>
<li class="toclevel-3 tocsection-141"><a href="#Programming_I2C_EEPROM_.28address_0x51.29_with_IBL_and_boot_configuration_table1"><span class="tocnumber">8.4.1</span> <span class="toctext">Programming I2C EEPROM (address 0x51) with IBL and boot configuration table<sup>1</sup></span></a></li>
<li class="toclevel-3 tocsection-142"><a href="#Programming_I2C_EEPROM_.28address_0x50.29_with_POST_boot1"><span class="tocnumber">8.4.2</span> <span class="toctext">Programming I2C EEPROM (address 0x50) with POST boot<sup>1</sup></span></a></li>
<li class="toclevel-3 tocsection-143"><a href="#Flashing_NOR_FLASH_with_a_user_application_for_NOR_boot_over_I2C"><span class="tocnumber">8.4.3</span> <span class="toctext">Flashing NOR FLASH with a user application for NOR boot over I2C</span></a></li>
<li class="toclevel-3 tocsection-144"><a href="#Flashing_NAND_FLASH_with_a_user_application_for_NAND_boot_over_I2C"><span class="tocnumber">8.4.4</span> <span class="toctext">Flashing NAND FLASH with a user application for NAND boot over I2C</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-145"><a href="#Technical_Support_and_Product_Updates"><span class="tocnumber">9</span> <span class="toctext">Technical Support and Product Updates</span></a>
<ul>
<li class="toclevel-2 tocsection-146"><a href="#Technical_Support_and_Forums"><span class="tocnumber">9.1</span> <span class="toctext">Technical Support and Forums</span></a></li>
<li class="toclevel-2 tocsection-147"><a href="#Product_Updates"><span class="tocnumber">9.2</span> <span class="toctext">Product Updates</span></a>
<ul>
<li class="toclevel-3 tocsection-148"><a href="#MCSDK_Product_Folder"><span class="tocnumber">9.2.1</span> <span class="toctext">MCSDK Product Folder</span></a></li>
<li class="toclevel-3 tocsection-149"><a href="#Eclipse_Update_Manager"><span class="tocnumber">9.2.2</span> <span class="toctext">Eclipse Update Manager</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-150"><a href="#Frequently_Asked_Questions"><span class="tocnumber">10</span> <span class="toctext">Frequently Asked Questions</span></a>
<ul>
<li class="toclevel-2 tocsection-151"><a href="#Q:_How_can_I_get_the_EVM_back_to_factory_default_state.3F"><span class="tocnumber">10.1</span> <span class="toctext">Q: How can I get the EVM back to factory default state?</span></a></li>
<li class="toclevel-2 tocsection-152"><a href="#Q:_I_have_just_updated_my_BIOS_MCSDK_software.2C_how_do_I_load_it_to_my_EVM.3F"><span class="tocnumber">10.2</span> <span class="toctext">Q: I have just updated my BIOS MCSDK software, how do I load it to my EVM?</span></a>
<ul>
<li class="toclevel-3 tocsection-153"><a href="#Using_Program_EVM"><span class="tocnumber">10.2.1</span> <span class="toctext">Using Program EVM</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-154"><a href="#Q:_Can_I_update_the_new_images_individually_instead_of_using_Program_EVM.3F"><span class="tocnumber">10.3</span> <span class="toctext">Q: Can I update the new images individually instead of using Program EVM?</span></a>
<ul>
<li class="toclevel-3 tocsection-155"><a href="#Updating_EEPROM_Images"><span class="tocnumber">10.3.1</span> <span class="toctext">Updating EEPROM Images</span></a>
<ul>
<li class="toclevel-4 tocsection-156"><a href="#IBL"><span class="tocnumber">10.3.1.1</span> <span class="toctext">IBL</span></a></li>
<li class="toclevel-4 tocsection-157"><a href="#POST"><span class="tocnumber">10.3.1.2</span> <span class="toctext">POST</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-158"><a href="#Updating_NOR.2FNAND_Images"><span class="tocnumber">10.3.2</span> <span class="toctext">Updating NOR/NAND Images</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-159"><a href="#Q:_How_do_I_use_JTAG_with_CCS.3F"><span class="tocnumber">10.4</span> <span class="toctext">Q: How do I use JTAG with CCS?</span></a>
<ul>
<li class="toclevel-3 tocsection-160"><a href="#Solving_the_Verify_Init:_warnings_when_executing_Demos.2FNDK_Examples_from_CCS"><span class="tocnumber">10.4.1</span> <span class="toctext">Solving the <b>Verify_Init:</b> warnings when executing Demos/NDK Examples from CCS</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-161"><a href="#Q:_Is_there_a_simple_way_to_access_documents_provided_in_the_release.3F"><span class="tocnumber">10.5</span> <span class="toctext">Q: Is there a simple way to access documents provided in the release?</span></a></li>
<li class="toclevel-2 tocsection-162"><a href="#Q:_How_do_I_uninstall_the_BIOS-MCSDK.3F"><span class="tocnumber">10.6</span> <span class="toctext">Q: How do I uninstall the BIOS-MCSDK?</span></a></li>
<li class="toclevel-2 tocsection-163"><a href="#Q:_Are_there_example_code_for_various_device_peripherals.3F"><span class="tocnumber">10.7</span> <span class="toctext">Q: Are there example code for various device peripherals?</span></a></li>
<li class="toclevel-2 tocsection-164"><a href="#Q:_How_do_I_speed_up_downloading_the_BIOS-MCSDK_installer.3F"><span class="tocnumber">10.8</span> <span class="toctext">Q: How do I speed up downloading the BIOS-MCSDK installer?</span></a></li>
<li class="toclevel-2 tocsection-165"><a href="#Q:_Can_I_use_CCS_5.1_with_BIOS_MCSDK_2.0.3F"><span class="tocnumber">10.9</span> <span class="toctext">Q: Can I use CCS 5.1 with BIOS MCSDK 2.0?</span></a></li>
<li class="toclevel-2 tocsection-166"><a href="#Q:_How_can_I_connect_and_use_two_emulators_of_the_same_type_in_the_same_CCS_instance.3F"><span class="tocnumber">10.10</span> <span class="toctext">Q: How can I connect and use two emulators of the same type in the same CCS instance?</span></a></li>
<li class="toclevel-2 tocsection-167"><a href="#Q:_How_do_I_get_the_latest_GEL_files_for_these_EVMs.3F"><span class="tocnumber">10.11</span> <span class="toctext">Q: How do I get the latest GEL files for these EVMs?</span></a></li>
<li class="toclevel-2 tocsection-168"><a href="#Q:_How_do_I_change_SoC_speed_on_my_EVM.3F"><span class="tocnumber">10.12</span> <span class="toctext">Q: How do I change SoC speed on my EVM?</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Introduction">Introduction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=1" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<div class="floatright"><a href="File_C66x-multicore.html" class="image" title="c66x-multicore.jpg"><img alt="c66x-multicore.jpg" src="https://processors.wiki.ti.com/images/b/bd/C66x-multicore.jpg" width="250" height="200" /></a></div>
<p>The BIOS Multicore Software Development Kit (MCSDK) provides the core foundational building blocks that facilitate application software development on TI's high performance and multicore DSPs. The foundational components include:
</p>
<dl><dd><dl><dd><ul><li>SYS/BIOS which is a light-weight real-time embedded operating system for TI devices</li>
<li>Chip support libraries, drivers, and basic platform utilities</li>
<li>Run-time libraries (OpenMP, OpenEM)</li>
<li>Interprocessor communication for communication across cores and devices</li>
<li>Basic networking stack and protocols</li>
<li>Optimized application-specific and application non-specific algorithm libraries</li>
<li>Debug and instrumentation</li>
<li>Bootloaders and boot utilities</li>
<li>Demonstrations and examples</li></ul></dd></dl></dd></dl>
<p>The purpose of this <i>User's Guide</i> is to provide more detailed information regarding the software elements and infrastructure provided with MCSDK. MCSDK pulls together all the elements into demonstrable multicore applications and examples for supported EVMs. The objective being to demonstrate device, platform, and software capabilities and functionality as well as provide the user with instructive examples. The software provided is intended to be used as a reference when starting their development.<br />
</p>
<table border="1">
<tbody><tr>
<td>
<div class="floatleft"><a href="File_Helpful_tips_image.html" class="image"><img alt="Helpful tips image.jpg" src="https://processors.wiki.ti.com/images/5/5c/Helpful_tips_image.jpg" width="75" height="76" /></a></div> 
<p><span style="color: Red"><b>Useful Tip</b></span>
</p><p>It is expected the user has gone through the <i>EVM Quick Start Guide </i>provided with their EVM and have booted the out-of-box demonstration application flashed on the device. It is also assumed the user has gone through the <a href="BIOS_MCSDK_2.html" title="BIOS MCSDK 2.0 Getting Started Guide">MCSDK Getting Started Guide</a> and have installed both CCS and the MCSDK.
</p>
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Acronyms_and_Definitions">Acronyms and Definitions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=2" title="Edit section: Acronyms and Definitions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following acronyms are used throughout this document.<br />
</p>
<table border="1" style="width: 75%; height: 212px" id="acronymtable">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Acronym</b>
</td>
<td bgcolor="#c0c0c0"><b>Meaning</b>
</td></tr>
<tr>
<td>AMC
</td>
<td>Advanced Mezzanine Card
</td></tr>
<tr>
<td>CCS
</td>
<td>Texas Instruments Code Composer Studio
</td></tr>
<tr>
<td>CSL
</td>
<td>Texas Instruments Chip Support Library
</td></tr>
<tr>
<td>DDR
</td>
<td>Double Data Rate
</td></tr>
<tr>
<td>DHCP
</td>
<td>Dynamic Host Configuration Protocol
</td></tr>
<tr>
<td>DSP
</td>
<td>Digital Signal Processor
</td></tr>
<tr>
<td>DVT
</td>
<td>Texas Instruments Data Analysis and Visualization Technology
</td></tr>
<tr>
<td>EDMA
</td>
<td>Enhanced Direct Memory Access
</td></tr>
<tr>
<td>EEPROM
</td>
<td>Electrically Erasable Programmable Read-Only Memory
</td></tr>
<tr>
<td>EVM
</td>
<td>Evaluation Module, hardware platform containing the Texas Instruments DSP
</td></tr>
<tr>
<td>HUA
</td>
<td>High Performance Digital Signal Processor Utility Application
</td></tr>
<tr>
<td>HTTP
</td>
<td>HyperText Transfer Protocol
</td></tr>
<tr>
<td>IP
</td>
<td>Internet Protocol
</td></tr>
<tr>
<td>IPC
</td>
<td>Texas Instruments Inter-Processor Communication Development Kit
</td></tr>
<tr>
<td>JTAG
</td>
<td>Joint Test Action Group
</td></tr>
<tr>
<td>MCSA
</td>
<td>Texas Instruments Multi-Core System Analyzer
</td></tr>
<tr>
<td>MCSDK
</td>
<td>Texas Instruments Multi-Core Software Development Kit
</td></tr>
<tr>
<td>NDK
</td>
<td>Texas Instruments Network Development Kit (IP Stack)
</td></tr>
<tr>
<td>NIMU
</td>
<td>Network Interface Management Unit
</td></tr>
<tr>
<td>PDK
</td>
<td>Texas Instruments Programmers Development Kit
</td></tr>
<tr>
<td>RAM
</td>
<td>Random Access Memory
</td></tr>
<tr>
<td>RTSC
</td>
<td>Eclipse Real-Time Software Components
</td></tr>
<tr>
<td>SRIO
</td>
<td>Serial Rapid IO
</td></tr>
<tr>
<td>TCP
</td>
<td>Transmission Control Protocol
</td></tr>
<tr>
<td>TI
</td>
<td>Texas Instruments
</td></tr>
<tr>
<td>UART
</td>
<td>Universal Asynchronous Receiver/Transmitter
</td></tr>
<tr>
<td>UDP
</td>
<td>User Datagram Protocol
</td></tr>
<tr>
<td>UIA
</td>
<td>Texas Instruments Unified Instrumentation Architecture
</td></tr>
<tr>
<td>USB
</td>
<td>Universal Serial Bus
</td></tr></tbody></table>
<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  We use the abbreviation TMS when referring to a specific TI device (processor) and the abbreviation TMD when referring to a specific platform that the processor is on. For example, TMS320C6678 refers to the C6678 DSP processor and TMDSEVM6678L refers to the actual hardware EVM that the processor is on. <br />
</p>
<h2><span id="Supported_Devices/Platforms"></span><span class="mw-headline" id="Supported_Devices.2FPlatforms">Supported Devices/Platforms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=3" title="Edit section: Supported Devices/Platforms">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The <a href="#Product_Updates">latest BIOS MCSDK Release</a> supports the following Texas Instrument devices/platforms:
</p>
<table style="width: 534px; height: 98px" cellspacing="1" cellpadding="1" width="534" summary="summary" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Platform Development Kit</b>
</td>
<td bgcolor="#c0c0c0"><b>Supported Devices</b>
</td>
<td bgcolor="#c0c0c0"><b>Supported EVM</b>
</td></tr>
<tr>
<td><a href="https://processors.wiki.ti.com/index.php?title=C6657&amp;action=edit&amp;redlink=1" class="new" title="C6657 (page does not exist)">C6657</a>
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/product/tms320c6657">TMS320C6657</a>
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/tool/tmdxevm6657">TMDXEVM6657L</a>, <a rel="nofollow" class="external text" href="http://www.ti.com/tool/tmdxevm6657">TMDXEVM6657LE</a>
</td></tr>
<tr>
<td><a href="https://processors.wiki.ti.com/index.php?title=C6670&amp;action=edit&amp;redlink=1" class="new" title="C6670 (page does not exist)">C6670</a>
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/product/tms320c6670">TMS320C6670</a>, <a rel="nofollow" class="external text" href="http://www.ti.com/product/tms320tci6618">TMS320TCI6618</a>
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/tool/tmdsevm6670">TMDSEVM6670L</a>, <a rel="nofollow" class="external text" href="http://www.ti.com/tool/tmdsevm6670">TMDSEVM6670LE</a>,<a rel="nofollow" class="external text" href="http://www.ti.com/tool/tmdsevm6670">TMDSEVM6670LXE</a>, TMDSEVM6618LXE
</td></tr>
<tr>
<td><a href="C6678.html" class="mw-redirect" title="C6678">C6678</a>
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/product/tms320c6678">TMS320C6678</a>, <a rel="nofollow" class="external text" href="http://www.ti.com/product/tms320tci6608">TMS320TCI6608</a>
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/tool/tmdsevm6678">TMDSEVM6678L</a>, <a rel="nofollow" class="external text" href="http://www.ti.com/tool/tmdsevm6678">TMDSEVM6678LE</a>, <a rel="nofollow" class="external text" href="http://www.ti.com/tool/tmdsevm6678">TMDSEVM6678LXE</a>
</td></tr></tbody></table>
<p><br />
</p>
<h1><span class="mw-headline" id="Other_Resources">Other Resources</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=4" title="Edit section: Other Resources">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<h2><span class="mw-headline" id="Training">Training</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=5" title="Edit section: Training">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This section provides a collection links to training resources relevant to this release.
</p>
<table style="width: 700px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Link</b>
</td>
<td bgcolor="#c0c0c0"><b>Description</b>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/general/docs/video/Portal.tsp?lang=en&amp;entryid=0_xitw1jig">BIOS-MCSDK Short Video</a>
</td>
<td>This short video describes what the BIOS Multicore Software Development Kit is and how it helps customers get to market faster.
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/docs/training/catalog/events/event.jhtml?sku=OLT110048">MCSDK Overview Online</a>
</td>
<td>This video training module provides an overview of the multicore SoC software for C66x devices. This module introduces the optimized software components that enable the rapid development of multicore applications and accelerate time to market using foundational software in the MCSDK. The MCSDK also enables developers to evaluate the hardware and software capabilities using the C66x evaluation module.
<p>The <b>Mandarin</b> version of this training can be found <a rel="nofollow" class="external text" href="http://learningmedia.ti.com/public/hpmp/KeyStone/01_MCSDK_Intro_Mandarin/Index.html">here</a>.
</p>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="Keystone_Device_Architecture.html">KeyStone Architecture Wiki</a>
</td>
<td>KeyStone Architecture Overview Mediawiki
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/docs/training/catalog/events/event.jhtml?sku=OLT110027">KeyStone Architecture Online</a>
</td>
<td>C66x Multicore SOC Online Training for KeyStone Devices
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://e2e.ti.com/support/processors/f/791/t/840835">SYS/BIOS Online</a>
</td>
<td>SYS/BIOS Online Training
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="SYS/BIOS_1.html">SYS/BIOS 1.5 Day</a>
</td>
<td>SYS/BIOS 1.5-DAY Workshop
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="System_Analyzer_Tutorials_(CCSv5).html">MCSA Online</a>
</td>
<td>Multicore System Analyzer Online Tutorial
</td></tr></tbody></table>
<p><br />
</p>
<h2><span class="mw-headline" id="White_Papers">White Papers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=6" title="Edit section: White Papers">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following lists some relevant white papers. Additional white papers can be found on the device product page (e.g., <a rel="nofollow" class="external text" href="http://www.ti.com/product/tms320c6678">C6678</a>).
</p>
<table style="width: 700px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Description</b>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/wp/spry168a/spry168a.pdf">MCSDK White Paper</a>
</td>
<td>This paper introduces TIs Multicore Software Development Kit (MCSDK) by outlining the various software packages available, along with utilities and tool chains that can aid programmers in development for high-level operating systems such as Linux, and the real time operating system SYS/BIOS.
</td></tr></tbody></table>
<p><br />
</p>
<h2><span class="mw-headline" id="Getting_Started_Guides">Getting Started Guides</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=7" title="Edit section: Getting Started Guides">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The getting started guides walk you through setting up your EVM and running the "Out of Box" Demonstration application. This is where you should start after receiving your EVM.
</p>
<table style="width: 700px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Description</b>
</td></tr>
<tr>
<td>MCSDK Release Notes
</td>
<td>Contains latest information on the release including whats changed, known issues and compatibility information. Each foundational component will have individual release notes as well.
</td></tr>
<tr>
<td><a href="BIOS_MCSDK_2.html" title="BIOS MCSDK 2.0 Getting Started Guide">MCSDK Getting Started Guide</a>
</td>
<td>Discusses how to install the BIOS-MCSDK and access the demonstration application.
</td></tr>
<tr>
<td>TMDSEVM66xxL Quick Setup Guide
</td>
<td rowspan="3">Quick Setup Guides showing how to set up the EVM and run the Out of Box demonstration application from flash. These documents can be found in the links provided below for <i>Hardware - EVM Overview</i>.
</td></tr></tbody></table>
<p><br />
</p>
<h2><span class="mw-headline" id="API_and_LLD_User_Guides">API and LLD User Guides</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=8" title="Edit section: API and LLD User Guides">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>API Reference Manuals and LLD User Guides are provided with the software. You can reference them from the Eclipse Help system in CCS or you can navigate to the components <i>doc</i> directory and view them there.
</p><p><br />
</p>
<h2><span class="mw-headline" id="Tools_Overview">Tools Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=9" title="Edit section: Tools Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following documents provide information on the various development tools available to you.
</p>
<table style="width: 700px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Description</b>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="CCSv5_Getting_Started_Guide.html">CCS v5 Getting Started Guide</a>
</td>
<td>How to get up and running with CCS v5
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="Xds_560.html">XDS560 Emulator Information</a>
</td>
<td>Information on XDS560 emulator
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://software-dl.ti.com/ccs/esd/documents/xdsdebugprobes/emu_xds100.html">XDS100 Emulator&#160;Information</a>
</td>
<td>Information on XDS100 emulator
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/lit/ug/spru187t/spru187t.pdf">TMS320C6000 Optimizing Compiler v 7.3</a>
</td>
<td>Everything you wanted to know about the compiler, assembler, library-build process and C++ name demangler.
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/lit/ug/spru186v/spru186v.pdf">TMS320C6000 Assembly Language Tools v 7.3</a>
</td>
<td>More in-depth information on the assembler, linker command files and other utilities.
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="Multicore_System_Analyzer.html">Multi-core System Analyzer</a>
</td>
<td>How to use and integrate the system analyzer into your code base.
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://rtsc.eclipse.org/docs-tip/Demo_of_the_RTSC_Platform_Wizard_in_CCSv4">Eclipse Platform Wizard</a>
</td>
<td>How to create a platform for RTSC. The demo uses CCSv4 but the platform screens are the same in CCSv5.
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://rtsc.eclipse.org/docs-tip/Runtime_Object_Viewer">Runtime Object Viewer</a>
</td>
<td>How to use the Object Viewer for Eclipse Based Debugging.
</td></tr></tbody></table>
<p><br />
</p>
<h2><span class="mw-headline" id="Hardware_-_EVM_Overview">Hardware - EVM Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=10" title="Edit section: Hardware - EVM Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following resources provide information about the EVM.
</p>
<table style="width: 700px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Description</b>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/general/docs/video/Portal.tsp?entryid=0_55svdeqr&amp;lang=en">Introducing the C66x Lite EVM Video</a>
</td>
<td>Short video on the C66x Lite Evaluation Module, the cost-efficient development tool from Texas Instruments that enables developers to quickly get started working on designs for C66x multicore DSPs based on the KeyStone architecture.
</td></tr>
<tr>
<td>TMDSEVM6657L documentation and support
</td>
<td rowspan="4">Discusses the technical aspects of your EVM including board block diagram, DIP Switch Settings, memory addresses and range, power supply and basic operation.
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://www.advantech.com/Support/TI-EVM/6670le_sd.aspx">TMDSEVM6670L documentation and support</a>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://www.advantech.com/Support/TI-EVM/6678le_sd.aspx">TMDSEVM6678L documentation and support</a>
</td></tr>
<tr>
<td>TMDSEVM6618LXE documentation and support (TBD)
</td></tr></tbody></table>
<p><br />
</p>
<h2><span class="mw-headline" id="Hardware_-_Processor_Overview">Hardware - Processor Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=11" title="Edit section: Hardware - Processor Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following documents provide information about the processor used on the EVM.
</p>
<table style="width: 700px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Description</b>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/ds/symlink/tms320c6657.pdf">TMS320C6657 Data Manual</a>
</td>
<td rowspan="4">Data manual for specific TI DSP
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/lit/ds/symlink/tms320c6670.pdf">TMS320C6670 Data Manual</a>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/lit/ds/symlink/tms320c6678.pdf">TMS320C6678 Data Manual</a>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/gpn/tms320tci6618">TMS320TCI6618 Data Manual</a>
</td></tr></tbody></table>
<p><br />
</p>
<h2><span class="mw-headline" id="Related_Software">Related Software</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=12" title="Edit section: Related Software">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This section provides a collection links to additional software elements that may be of interest.
</p>
<table style="width: 700px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Link</b>
</td>
<td bgcolor="#c0c0c0"><b>Description</b>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://software-dl.ti.com/sdoemb/sdoemb_public_sw/salld/index.html">Security Accelerator LLD</a>
</td>
<td>Download page for Security Accelerator (SA) low level driver
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://www.linux-c6x.org/wiki/index.php/Main_Page">C6x DSP Linux Project</a>
</td>
<td>Community site for C6x DSP Linux project
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/docs/toolsw/folders/print/telecomlib.html">Telecom Libraries</a>
</td>
<td>TI software folder for information and download of Telecom Libraries (Voice, Fax, etc) for TI processors.
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/tool/c66xcodecs">c66x Speech and Video Codecs</a>
</td>
<td>TI software folder for information and download of Speech and Video codecs for c66x.
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/tool/s2meddus">Medical Imaging Software Tool Kits</a>
</td>
<td>TI software folder for information and download of medical imaging software tool kits for TI processors.
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="Software_libraries.html">c6x Software Libraries</a>
</td>
<td>Mediawiki providing an overview of available software libraries for TI's c6x family of DSP processors.
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/tool/demovideo-multicore">Multicore Video Infrastructure Demonstration Application</a>
</td>
<td>TI software folder for information and download of multicore video infrastructure demonstration application using the BIOS-MCSDK.
</td></tr></tbody></table>
<p><br />
</p>
<h1><span class="mw-headline" id="Software_Overview">Software Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=13" title="Edit section: Software Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The MCSDK is comprised of the foundational software infrastructure elements intended to enable development of application software on TI high-performance and multicore DSPs.
</p><p><br /><a href="File_MCSDK200SoftwareStack.html" class="image" title="MCSDK200SoftwareStack.jpg"><img alt="MCSDK200SoftwareStack.jpg" src="https://processors.wiki.ti.com/images/e/e2/MCSDK200SoftwareStack.jpg" width="800" height="489" /></a>
</p><p><br />After installing CCS and MCSDK, the components in the picture above will be located as follows:
</p>
<table style="width: 700px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Software Element</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td colspan="2"><div style="text-align: center"><b>CSL&#160;and Low Level Drivers</b></div>
</td></tr>
<tr>
<td>Chip Support Library
</td>
<td>pdk_&lt;platform&gt;_w_xx_yy_zz/packages/ti/csl/
</td></tr>
<tr>
<td>All LLD (except EDMA3)
</td>
<td>pdk_&lt;platform&gt;_w_xx_yy_zz/packages/ti/drv/ - If the driver is supported for a given platform it will be located in the drv/ directory
</td></tr>
<tr>
<td>EDMA3 LLD
</td>
<td>edma3_lld_ww_xx_yy_zz/
</td></tr>
<tr>
<td colspan="2"><div style="text-align: center"><b>Runtime Libraries</b></div>
</td></tr>
<tr>
<td>OpenEM
</td>
<td>openem_w_x_y_z/
</td></tr>
<tr>
<td>OpenMP
</td>
<td>omp_w_x_y_z/
</td></tr>
<tr>
<td colspan="2"><div style="text-align: center"><b>Algorithm Libraries</b></div>
</td></tr>
<tr>
<td>DSPLIB
</td>
<td>dsplib_&lt;proc_type&gt;_w_x_y_z/
</td></tr>
<tr>
<td>IMGLIB
</td>
<td>imglib_&lt;proc_type&gt;_w_x_y_z/
</td></tr>
<tr>
<td>MATHLIB
</td>
<td>mathlib_&lt;proc_type&gt;_w_x_y_z/
</td></tr>
<tr>
<td colspan="2"><div style="text-align: center"><b>Platform/EVM Software</b></div>
</td></tr>
<tr>
<td>Platform Libary
</td>
<td>pdk_&lt;platform&gt;_w_xx_yy_zz/packages/ti/platform/&lt;device&gt;/platform_lib
</td></tr>
<tr>
<td>Resource Manager
</td>
<td>pdk_&lt;platform&gt;_w_xx_yy_zz/packages/ti/platform/resource_mgr.h (Note:&#160;There is also a RM&#160;LLD provided for resource management)
</td></tr>
<tr>
<td>Platform OSAL
</td>
<td>pdk_&lt;platform&gt;_w_xx_yy_zz/packages/ti/platform/platform.h
</td></tr>
<tr>
<td rowspan="3">Transports
</td>
<td>pdk_&lt;platform&gt;_w_xx_yy_zz/packages/ti/transport/ipc/qmss/ - QMSS IPC Transport
</td></tr>
<tr>
<td>pdk_&lt;platform&gt;_w_xx_yy_zz/packages/ti/transport/ipc/srio/ - SRIO IPC Transport
</td></tr>
<tr>
<td>pdk_&lt;platform&gt;_w_xx_yy_zz/packages/ti/transport/ndk - NDK Transport
</td></tr>
<tr>
<td>POST
</td>
<td>mcsdk_w_xx_yy_zz/tools/post/
</td></tr>
<tr>
<td>Bootloader
</td>
<td>mcsdk_w_xx_yy_zz/tools/boot_loader/
</td></tr>
<tr>
<td colspan="2"><div style="text-align: center"><b>Target Software&#160;Components</b></div>
</td></tr>
<tr>
<td>SYS/BIOS RTOS
</td>
<td>bios_w_xx_yy_zz/
</td></tr>
<tr>
<td>Interprocessor Communication
</td>
<td>ipc_w_xx_yy_zz/
</td></tr>
<tr>
<td>Network Developer's Kit (NDK) Package
</td>
<td>ndk_w_xx_yy_zz/
</td></tr>
<tr>
<td colspan="2"><div style="text-align: center"><b>Demonstration Applications</b></div>
</td></tr>
<tr>
<td>HUA "Out of Box" Demo
</td>
<td>mcsdk_w_xx_yy_zz/demos/hua/
</td></tr>
<tr>
<td>Image Processing
</td>
<td>mcsdk_w_xx_yy_zz/demos/image_processing/
</td></tr></tbody></table>
<p><br />
</p>
<h2><span id="Platform_Development_Kit_(PDK)"></span><span class="mw-headline" id="Platform_Development_Kit_.28PDK.29">Platform Development Kit (PDK)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=14" title="Edit section: Platform Development Kit (PDK)">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The Platform Development Kit (PDK) is a package that provides the foundational drivers and software to enable the device. It contains device-specific software consisting of a Chip Support Library (CSL) and Low Level Drivers (LLD) for various peripherals; both the CSLs and LLDs include example projects and examples within the relevant directories which can be used with CCS. It also contains the transport (NIMU), platform library, platform/EVM specific software, applications, CCS configuration files and other board-specific collaterals.
</p><p><br />
</p>
<h3><span id="Operating_System_Adaptation_Layer_(OSAL)"></span><span class="mw-headline" id="Operating_System_Adaptation_Layer_.28OSAL.29">Operating System Adaptation Layer (OSAL)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=15" title="Edit section: Operating System Adaptation Layer (OSAL)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Various components in the PDK support OSAL callbacks that allow applications to tailor common operations to their specific needs. The implementation of these callbacks is the applications responsibility. Typical callbacks include:
</p>
<ul><li>Memory Management</li>
<li>Critical Sections</li>
<li>Cache Coherency</li></ul>
<p>See the file platform_osal.c in the demos and examples. This file can be used as a basic starting point.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Resource_Management">Resource Management</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=16" title="Edit section: Resource Management">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This section covers the resource management implementations delivered as part of the MCSDK PDK package.
</p>
<h4><span class="mw-headline" id="Platform_Resource_Manager">Platform Resource Manager</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=17" title="Edit section: Platform Resource Manager">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The Resource Manager defines a set of APIs and definitions for managing platform resources (e.g. Interrupts, Hardware semaphores, etc) and provides example code for initializing and using the PA, QMSS and CPPI subsystems.
</p><p>The Resource Manager definitions are present in pdk_C####_#_#_#_#/packages/ti/platform/resource_mgr.h header file. This header file is included by the demos/example, NIMU and platform library.
</p><p>The example implementation is included in the MCSDK demo and example applications in the resourcemgr.c/osal.c source files.
</p><p>The following Linker Sections are used by the reourcemgr.c file and would need to be included in the application linker map or .cfg file.
</p>
<ul><li>.resmgr_memregion = Contains QMSS descriptors region</li>
<li>.resmgr_handles = Contains CPPI/QMSS/PA Handles</li>
<li>.resmgr_pa = Contains PA Memory</li></ul>
<p><br />
</p>
<h4><span id="Resource_Manager_(RM)_LLD"></span><span class="mw-headline" id="Resource_Manager_.28RM.29_LLD">Resource Manager (RM) LLD</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=18" title="Edit section: Resource Manager (RM) LLD">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The Resource Manager (RM) LLD allows a system integrator to specify DSP initialization and usage permissions for device resources. The RM lets the system integrator mark a clear separation between resources available for use by the DSPs and those available for use by Linux running on the ARM. When included in a system the RM LLD allows supported LLDs to callout to the RM LLD for resource permission verification.
</p><p>Currently, RM LLD support is in the following LLDs:
</p>
<ul><li>QMSS</li>
<li>CPPI</li>
<li>PA</li></ul>
<p><br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The API additions to the QMSS, CPPI, and PA LLDs to support the RM LLD are fully backwards compatible. No modifications are required to existing applications integrating the new QMSS, CPPI, and PA LLD versions in order to maintain existing behavior. The QMSS, CPPI, and PA LLDs consider RM callouts disabled by default.
</p>
<h5><span class="mw-headline" id="Managed_Resources">Managed Resources</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=19" title="Edit section: Managed Resources">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The RM allows initialization and usage permissions to be specified for the following resources:
</p><p><b>QMSS</b>
</p>
<ul><li>PDSP Firmware Download</li>
<li>Queues</li>
<li>Memory Regions</li>
<li>Linking RAM Control (RAM0/1 Base address programming)</li>
<li>Linking RAM Indices</li>
<li>Accumulator Channels</li>
<li>QOS Clusters</li>
<li>QOS Queues</li></ul>
<p><b>CPPI</b>
</p>
<ul><li>Transmit Channels</li>
<li>Receive Channels</li>
<li>Receive Flows</li></ul>
<p><b>PA</b>
</p>
<ul><li>Firmware Download</li>
<li>Look-up Tables (The entire table, not individual entries)</li></ul>
<h5><span class="mw-headline" id="RM_Architecture_Overview">RM Architecture Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=20" title="Edit section: RM Architecture Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The following figure provides a graphical representation of how the RM LLD fits into an application.
</p><p><br /><a href="File_Rmm_structure_overview.html" class="image" title="rmm_structure_overview.JPG"><img alt="rmm_structure_overview.JPG" src="https://processors.wiki.ti.com/images/0/06/Rmm_structure_overview.JPG" width="1000" height="513" /></a>
</p><p><br />The Resource Manager LLD sits under the hood of the QMSS, CPPI, and PA LLDs to perform permission checks on the initialization and usage of resources. The RM LLD contains a permission field for each tracked QMSS, CPPI, and PA LLD resource. The permission fields contains an initialization and a usage bit for each DSP in the system. The permission fields are global and are required to be placed in the global address space for the device. Whenever a tracked LLD resource is specified for use by the application through the QMSS, CPPI, or PA LLD APIs the LLD internally sends a resource permission check request to the RM LLD. The RM LLD uses the resource data, a resource identifier and the resource value, to index the internal permission tables. When the resource entry is found the DSP number is used to extract the initialization and usage information for the resource. This information is returned to the requesting LLD. Based on the RM LLD response, resource approved or denied, the LLD either continues normal operation or returns a resource denied failure for the application to act upon.
</p><p>The APIs used by the RM LLD and the QMSS, CPPI, and PA LLDs are internal APIs that are not meant to be used by an application. The application gets a RM handle for each DSP from the RM LLD after it has initialized and started the RM. The RM handle contains RM LLD resource permission internal API information that is shared between the RM and the other LLDs. The application must provide the RM handle to each LLD for each DSP operating in the system. Providing the RM handle to the LLDs effectively registers the RM with the LLD and informs the LLD that it should check initialization and usage permissions for all covered resources.
</p><p>It is the job of the system integrator, or application developer, to set the LLD resource permissions prior to compile time. A resource table must be defined and passed as an argument to the "master" DSP core via the RM initialization function. The RM initialization function will parse the resource table and transfer all defined resource permissions to the internal resource permission tables in global memory. Upon completion of the transfer the "master" core will write to a global synchronization object, signalling to the "slave" DSP cores that the internal permission tables have been populated. Each "slave" core will then invalidate the entire permission table so that no further cache invalidate operations need to be performed when checking resource permissions in the data path. The upfront cache invalidate operation is possible because the RM LLD does not allow dynamic resource permission modifications. The permissions defined by the system integrator and loaded during RM initialization are static throughout the system up-time.
</p>
<h5><span class="mw-headline" id="Using_the_RM_LLD">Using the RM LLD</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=21" title="Edit section: Using the RM LLD">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p><b>Defining the Resource Table</b>
</p><p>The first step in integrating the RM LLD is defining the resource table that specifies the resource permissions for the DSPs. The resource table is an array of resource structures. Each structure specifies a resource type, the start and end range for the resource and the initialization and usage permissions for the resource for each DSP. A default resource table is delivered with the RM LLD under the resource_table/ directory. The default resource table is based on the target PDK device and gives all DSPs full permissions to all supported LLD resources.
</p><p>If some resources are going to be used by another processor on the device, say Linux running on an ARM, there are two ways the system integrator can use to define the resource table. The first method, the system integrator should specify all resources that will be used by the DSPs in the resource table. Any resources that are not specified in the resource table are initialized to deny access to all DSPs by the RM LLD. The second method, the system integrator can specify all resources in the system but must make sure the resources that are used by a non-DSP processor give the DSP no permissions. The first method is preferred, and highlighted in this guide, because it provides a clear picture of the resources given to DSPs. The first method is also easier to modify if the used resources change.
</p><p>A simple example for a resource table is provided below. The resources assigned in the example are not from a larger, validated example. If used to a create an example the resources assigned permissions are not enough for a system to function properly. The below code is meant as a teaching example only.
</p><p>&lt;syntaxhighlight lang="c"&gt;
/* The Rm_Resource structure and the resource identifiers used are defined in resource_table_defs.h */
</p><p>/** @brief RM LLD resource table permissions */
const Rm_Resource simpleResourceTable[] =
{
</p>
<pre>/* Magic Number structure to verify RM can read the resource table */
</pre>
<pre>{
/** DSP QMSS Firmware access */
RM_RESOURCE_MAGIC_NUMBER,
/** No start range */
0u,
/** No end range */
0u,
/** No init permissions */
0u,
/** No use permissions */
0u,
},
</pre>
<pre>/* QMSS Resource Definitions */
</pre>
<pre>{
/** DSP QMSS PDSP Firmware access */
RM_RESOURCE_QMSS_FIRMWARE_PDSP,
/** PDSP start range */
0,
/** PDSP end range */
1,
/** Full permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
/** Full use permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
},
{
/** DSP QMSS queue access */
RM_RESOURCE_QMSS_QUEUE,
/** Queue start range*/
2000,
/** Queue end range */
3000,
/** Full permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
/** Full use permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
},
{
/** DSP QMSS accumulator channels */
RM_RESOURCE_QMSS_ACCUMULATOR_CH,
/** Accumulator channel start range*/
0,
/** Accumulator channel end range */
7,
/** Full permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
/** Full use permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
},
{
/** DSP CPPI QMSS tx channels */
RM_RESOURCE_CPPI_QMSS_TX_CH,
/** CPPI QMSS tx channel start range*/
0,
/** CPPI QMSS tx channel end range */
2,
/** Full permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
/** Full use permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
},
{
/** DSP CPPI QMSS rx channels */
RM_RESOURCE_CPPI_QMSS_RX_CH,
/** CPPI QMSS rx channel start range*/
0,
/** CPPI QMSS rx channel end range */
2,
/** Full permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
/** Full use permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
},
{
/** DSP CPPI QMSS rx flows */
RM_RESOURCE_CPPI_QMSS_FLOW,
/** CPPI QMSS rx flow start range*/
0,
/** CPPI QMSS rx flow end range */
2,
/** Full permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
/** Full use permissions for all DSPs */
RM_RESOURCE_ALL_DSPS_FULL_PERMS,
},
</pre>
<pre>/* Final entry structure for RM to find the last entry of resource table */
</pre>
<pre>{
/** Final entry */
RM_RESOURCE_FINAL_ENTRY,
/** No start range*/
0u,
/** No end range */
0u,
/** No init permissions */
0u,
/** No use permissions */
0u,
}
</pre>
<p>};
&lt;/syntaxhighlight&gt;
</p>
<ul><li>RM_RESOURCE_MAGIC_NUMBER - The magic number entry should <b>ALWAYS</b> be the first entry in the resource table. This value is used by the RM to validate the resource table prior to using it to populate the internal permission tables.</li>
<li>RM_RESOURCE_QMSS_FIRMWARE_PDSP - This entry gives all DSPs permission download the firmware for QMSS PDSP0 and PDSP1.</li>
<li>RM_RESOURCE_QMSS_QUEUE - This entry gives all DSPs permission to initialize and use QMSS queues 2000 through 3000.</li>
<li>RM_RESOURCE_QMSS_ACCUMULATOR_CH - This entry gives all DSPs permission to initialize and use QM Accumulator channels 0 through 7.</li>
<li>RM_RESOURCE_CPPI_QMSS_TX_CH - This entry gives all DSPs permission to initialize and use CPPI QM transmit channels 0 through 2.</li>
<li>RM_RESOURCE_CPPI_QMSS_RX_CH - This entry gives all DSPs permission to initialize and use CPPI QM receive channels 0 through 2.</li>
<li>RM_RESOURCE_CPPI_QMSS_FLOW - This entry gives all DSPs permission to initialize and use CPPI QM flows 0 through 2.</li>
<li>RM_RESOURCE_FINAL_ENTRY - The final entry should <b>ALWAYS</b> be the last entry in the resource table. This value is used by the RM to stop parsing the resource table.</li></ul>
<p>The RM LLD will read this resource table and transfer the permissions specified to the internal permission tables. All resources that have been left unspecified will be assigned deny permissions for all DSPs.
</p><p><b>Placing the RM LLD Permission Tables</b>
</p><p>The RM LLD internal permission tables contain the permissions for all DSP cores. Therefore, the tables are global and placed into the ".rm" memory section. Similar to the QMSS ".qmss", and CPPI ".cppi" sections, this memory section <b>MUST</b> be manually placed in shared memory (MSMC or DDR) via the linker command file.
</p><p><b>Initializing the RM LLD</b>
</p><p>The RM LLD has two initialization APIs that are used based on the context in which the application runs. The Rm_init API is the primary initialization routine and should be called on the "master" DSP core. The Rm_start routine should be called on all other "slave" DSP cores. Both APIs should be called prior to any other LLD init/start routines. The Rm_init function should be passed a pointer to the resource table. The Rm_init function will validate and parse the resource table, using it to populate the internal permission tables. When the RM completes populating the internal permissions table the Rm_init will write to a global synchronization object to sync with all slave DSP cores who have invoked the Rm_start API. The slave cores that have invoked Rm_start will stop spinning once the global synchronization has been written. At this time Rm_start will invalidate all internal permission tables so that no further cache invalidate operations need to be performed when checking resource permissions in the data path. The upfront cache invalidate operation is possible because the RM LLD does not allow dynamic resource permission modifications. The permissions defined by the system integrator and loaded during RM initialization are static throughout the system up-time.
</p><p><b>Registering RM with LLDs</b>
</p><p>The RM must be registered with a LLD in order for the LLD to perform resource permission checks. If the RM is not registered with a LLD the LLD will operate as if the RM LLD is not there. This maintains full backwards compatibility with existing applications not using the RM LLD. In order to register the RM LLD with LLDs the following steps should be taken
</p>
<ul><li>Get a Rm_Handle via the Rm_getHandle API on each DSP that uses the RM LLD.</li>
<li>Register the RM LLD with other LLDs by passing the Rm_Handle to the LLD's _startCfg API. Again, this should be performed on all DSP cores using the RM LLD. <img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The master core for the QMSS LLD should have the Rm_Handle registered via the Qmss_init API. This is done by passing the Rm_Handle inside the Qmss_GlobalConfigParams structure.</li></ul>
<p>When a LLD has registered with the RM the LLD will invoke permission check callouts to the RM whenever supported resources are initialized or requested. A permission denied or approved response will be given back to the invoking LLD based on the permissions stored in the RM LLD for the resource.
</p><p><b>RM LLD Initialization Example</b>
</p><p>The following code snippet shows how to initialize the RM LLD and register it with other LLDs on "master" and "slave" DSP cores.
</p><p>&lt;syntaxhighlight lang="c"&gt;
/* DSP Master is Core 0 */
</p>
<ol><li>define DSP_MASTER_CORE 0</li></ol>
<p>/* Global PA instance */
Pa_Handle paInst;
</p><p>/* Externally defined resource table */
extern Rm_Resource simpleResourceTable[];
</p><p>Void main (Void)
{
</p>
<pre>Rm_Handle rmHandle;
Qmss_StartCfg qmssStartCfg;
Cppi_StartCfg cppiStartCfg;
Pa_StartCfg paStartCfg;
</pre>
<pre>paSizeInfo_t paSize;
paConfig_t paCfg;
int sizes[pa_N_BUFS];
int aligns[pa_N_BUFS];
void* bases[pa_N_BUFS];
</pre>
<pre>if (DNUM == DSP_MASTER_CORE)
{
 /* Master DSP Core */
</pre>
<pre> /* Initialize RM and provide the resource table */
 Rm_init(rmTestResourceTable);
</pre>
<pre> /* Get the Rm_Handle to register with LLDs */
 rmHandle = Rm_getHandle();
</pre>
<pre> /* Configure Qmss_InitCfg and Qmss_GlobalConfigParams values */
</pre>
<pre> /* Add the Rm_Handle to the Qmss_GlobalConfigParams structure */
 qmssGblCfgParams.qmRmHandle = rmHandle;
</pre>
<pre> /* Initialize QMSS and register RM */
 Qmss_init(&amp;qmssInitConfig, &amp;qmssGblCfgParams);
</pre>
<pre> /* Initialize CPPI */
 Cppi_init (&amp;cppiGblCfgParams);
</pre>
<pre> /* Register RM with CPPI */
 cppiStartCfg.rmHandle = rmHandle;
 Cppi_startCfg (&amp;cppiStartCfg);
}
else
{
 /* Slave DSP Core */
</pre>
<pre> /* Wait for master core to complete RM initialization */
 Rm_start();
</pre>
<pre> /* Get the Rm_Handle to register with LLDs */
 rmHandle = Rm_getHandle();
</pre>
<pre> /* Start QMSS and register RM */
 qmssStartCfg.rmHandle = rmHandle;
 Qmss_startCfg (&amp;qmssStartCfg);
</pre>
<pre> /* Register RM with CPPI */
 cppiStartCfg.rmHandle = rmHandle;
 Cppi_startCfg (&amp;cppiStartCfg);
</pre>
<pre>}
</pre>
<pre>/* Initialize PA, done from each core */
</pre>
<pre>/* Get a PA buffer */
Pa_getBufferReq(&amp;paSize, sizes, aligns);
</pre>
<pre>/* Create a PA instance */
Pa_create (&amp;paCfg, bases, &amp;paInst);
</pre>
<pre>/* Register RM with PA */
paStartCfg.rmHandle = rmHandle;
Pa_startCfg (paInst, &amp;paStartCfg);
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p><p>For a working example please see the rm_testproject under the test/ directory of the RM LLD.
</p>
<h3><span id="Chip_Support_Library_(CSL)"></span><span class="mw-headline" id="Chip_Support_Library_.28CSL.29">Chip Support Library (CSL)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=22" title="Edit section: Chip Support Library (CSL)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div><div style="float: left; width: 4in">
<p>The Chip Support Library constitutes a set of well-defined APIs that abstract low-level details of the underlying SoC device so that a user can configure, control (start/stop, etc.) and have read/write access to peripherals without having to worry about register bit-field details. The CSL services are implemented as distinct modules that correspond with the underlying SoC device modules themselves. By design, CSL APIs follow a consistent style uniformly across Processor Instruction Set Architecture and are independent of the OS. This helps in improving portability of code written using the CSL.
</p><p>CSL is realized as twin-layer  a basic register-layer and a more abstracted functional-layer. The lower register layer comprises of a very basic set of macros and type definitions. The upper functional layer comprises of C functions that provide an increased degree of abstraction, but intended to provide directed control of underlying hardware.
</p><p>It is important to note that CSL does not manage data movement over underlying h/w devices. Such functionality is considered a prerogative of a device driver and serious effort is made to not blur the boundary between device driver and CSL services in this regard.
</p><p>CSL does not model the device state machine. However, should there exist a mandatory (hardware-dictated) sequence (possibly atomically executed) of register reads/writes to setup the device in chosen operating modes as per the device data sheet, then CSL does indeed support services for such operations.
</p><p>The CSL services are decomposed into modules, each following the twin layer of abstraction described above. The APIs of each such module are completely orthogonal (the API of one module does not internally call API of another module) and do not allocate memory dynamically from within. This is key to keeping CSL scalable to fit the specific usage scenarios and ease the effort to ROM a CSL-based application.
</p><p>The source code of the CSL is located under $(TI_PDK_C66##_INSTALL_DIR)\packages\ti\csl directory.<br />
</p><p><b>Note</b>: The CSL is built with LLD using same script. Please refer the LLD build section for details.
</p>
</div><div style="padding-left: 10px; float: left">
<table cellpadding="2" width="50%" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>Chip Support Library Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>PDK
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>pdk_c6678x_&lt;version&gt;\packages\ti\csl <br />pdk_c6670x_&lt;version&gt;\packages\ti\csl <br />pdk_c6657x_&lt;version&gt;\packages\ti\csl
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little &amp; Big
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\csl <br />$(TI_PDK_C6670_INSTALL_DIR)\packages\ti\csl <br />$(TI_PDK_C6657_INSTALL_DIR)\packages\ti\csl
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>.vecs , .switch, .args, .cio
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>L2 Cache
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\csl <br />$(TI_PDK_C6670_INSTALL_DIR)\packages\ti\csl <br />$(TI_PDK_C6657_INSTALL_DIR)\packages\ti\csl
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td><a rel="nofollow" class="external text" href="Chip_support_library.html">Chip support library</a>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Product Updates</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
</div></div><div style="clear: both"></div>
<p><br />
</p>
<h3><span class="mw-headline" id="Low_Level_Drivers">Low Level Drivers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=23" title="Edit section: Low Level Drivers">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div><div style="padding-left: 10px; float: left; width: 4in">
<p>The Low Level Drivers (LLDs) provide interfaces to the various peripherals on your SoC Device.
</p><p>The source code for the LLDs is located under $(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv directory.
</p><p>The following table shows PDK LLD vs. SoC availability.
</p>
<table cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Driver</b>
</td>
<td bgcolor="#c0c0c0"><b>C6678</b>
</td>
<td bgcolor="#c0c0c0">
<p><b>C6670/</b><br /><b>TCI6618</b>
</p>
</td>
<td bgcolor="#c0c0c0"><b>C6657</b>
</td></tr>
<tr>
<td>CSL
</td>
<td>X
</td>
<td>X
</td>
<td>X
</td></tr>
<tr>
<td>RM
</td>
<td>X
</td>
<td>X
</td>
<td>X
</td></tr>
<tr>
<td>QMSS
</td>
<td>X
</td>
<td>X
</td>
<td>X
</td></tr>
<tr>
<td>PKTDMA (CPPI)
</td>
<td>X
</td>
<td>X
</td>
<td>X
</td></tr>
<tr>
<td>PA
</td>
<td>X
</td>
<td>X
</td>
<td>&#160;
</td></tr>
<tr>
<td>SA
</td>
<td>X
</td>
<td>X
</td>
<td>&#160;
</td></tr>
<tr>
<td>SRIO
</td>
<td>X
</td>
<td>X
</td>
<td>X
</td></tr>
<tr>
<td>PCIe
</td>
<td>X
</td>
<td>X
</td>
<td>X
</td></tr>
<tr>
<td>Hyperlink
</td>
<td>X
</td>
<td>X
</td>
<td>X
</td></tr>
<tr>
<td>TSIP
</td>
<td>X
</td>
<td>&#160;&#160;
</td>
<td>&#160;
</td></tr>
<tr>
<td>EDMA3
</td>
<td>X
</td>
<td>X
</td>
<td>X
</td></tr>
<tr>
<td>FFTC
</td>
<td>&#160;
</td>
<td>X
</td>
<td>&#160;
</td></tr>
<tr>
<td>TCP3d
</td>
<td>&#160;
</td>
<td>X
</td>
<td>X
</td></tr>
<tr>
<td>TCP3e
</td>
<td>&#160;
</td>
<td>X
</td>
<td>&#160;
</td></tr>
<tr>
<td>BCP
</td>
<td>&#160;&#160;
</td>
<td>X
</td>
<td>&#160;
</td></tr>
<tr>
<td>AIF2
</td>
<td>&#160;
</td>
<td>X
</td>
<td>&#160;
</td></tr>
<tr>
<td>EMAC
</td>
<td>&#160;
</td>
<td>&#160;
</td>
<td>X
</td></tr></tbody></table>
<p><br />
</p>
</div><div style="padding-left: 10px; float: left">
<table cellpadding="2" width="50%" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>Driver Library Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>PDK
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>pdk_c6678x_&lt;version&gt;\packages\ti\drv <br />pdk_c6670x_&lt;version&gt;\packages\ti\drv <br />pdk_c6657x_&lt;version&gt;\packages\ti\drv
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little &amp; Big
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\drv <br />$(TI_PDK_C6670_INSTALL_DIR)\packages\ti\drv <br />$(TI_PDK_C6657_INSTALL_DIR)\packages\ti\drv
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\drv <br />$(TI_PDK_C6670_INSTALL_DIR)\packages\ti\drv <br />$(TI_PDK_C6657_INSTALL_DIR)\packages\ti\drv
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td><a rel="nofollow" class="external text" href="Chip_support_library.html">Chip support library</a>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Product Updates</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
</div></div><div style="clear: both"></div>
<p><br />
</p><p><br />
</p>
<h4><span id="Resource_Manager_(RM)"></span><span class="mw-headline" id="Resource_Manager_.28RM.29">Resource Manager (RM)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=24" title="Edit section: Resource Manager (RM)">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The RM low level driver provides the integrator a mechanism for assigning DSP initialization and usage permissions to various device resources. For more information on how to utilize the RM and which resources are covered by the RM please see the <a href="BIOS_MCSDK_2-2.html#Resource_Manager_.28RM.29_LLD" title="BIOS MCSDK 2.0 User Guide">Resource Manager (RM) LLD</a> section.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\rm\docs\rmlldDocs.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\docs\ReleaseNotes_RM_LLD.pdf
</td></tr></tbody></table>
<p><br /><br />
</p>
<h4><span class="mw-headline" id="EDMA3_Low_Level_Driver">EDMA3 Low Level Driver</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=25" title="Edit section: EDMA3 Low Level Driver">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div><div style="padding-left: 10px; float: left; width: 4in">
<p>EDMA3 Low Level Driver is targeted to users (device drivers and applications) for submitting and synchronizing EDMA3-based DMA transfers.
</p><p>EDMA3 is a peripheral that supports data transfers between two memory-mapped devices. It supports EDMA as well as QDMA channels for data transfer. This peripheral IP is re-used in different SoCs with only a few configuration changes like number of DMA and QDMA channels supported, number of PARAM sets available, number of event queues and transfer controllers, etc. The EDMA3 peripheral is used by other peripherals for their DMA needs. Thus, the EDMA3 Driver needs to cater to the device driver requirements of these peripherals as well as other application software that may need to use DMA services.
</p><p>The EDMA3 LLD consists of an EDMA3 Driver and EDMA3 Resource Manager. The <b>EDMA3 Driver</b> provides functionality that allows device drivers and applications for submitting and synchronizing with EDMA3-based DMA transfers. In order to simplify the usage, this component internally uses the services of the <b>EDMA3 Resource Manager</b> and provides one consistent interface for applications or device drivers.
</p>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>EDMA3 Driver Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>EDMA3 Low level drivers
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>&lt;root_install_dir&gt;/edma3_lld_02_11_01_02
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little and Big
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>edma3_lld_drv.ae66 (little endian) and edma3_lld_drv.ae66e (big endian)
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under install directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td><a rel="nofollow" class="external text" href="Programming_the_EDMA3_using_the_Low-Level_Driver_(LLD).html">Programming the EDMA3 using the Low-Level Driver (LLD)</a>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Product Updates</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
</div>
<p><br />
</p>
<h4><span class="mw-headline" id="Multicore_Navigator">Multicore Navigator</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=26" title="Edit section: Multicore Navigator">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Multicore Navigator provides multicore-safe communication while reducing load on DSPs in order to improve overall system performance.
</p>
<h5><span id="Packet_DMA_(CPPI)"></span><span class="mw-headline" id="Packet_DMA_.28CPPI.29">Packet DMA (CPPI)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=27" title="Edit section: Packet DMA (CPPI)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The CPPI low level driver can be used to configure the CPPI block in CPDMA for the Packet Accelerator (PA). The LLD provides resource management for descriptors, receive/transmit channels and receive flows.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/sprugr9d/sprugr9d.pdf">User Guide</a>
</td></tr>
<tr>
<td>LLD Users Guide
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\cppi\docs\ CPPI_QMSS_LLD_SDS.pdf
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\cppi\docs\cppilldDocs.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\docs\ReleaseNotes_CPPI_LLD.pdf
</td></tr></tbody></table>
<p><br />
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  As of BIOS-MCSDK 2.0.8 applications that configure the CPPI OSAL to allocate memory from an IPC SharedRegion heap may need to change. Changes are required only if the Cppi_init() function executes prior to the Ipc_attach() function. If the latter case occurs the Cppi_init() will attempt to allocate a block of memory from the SharedRegion heap located in shared memory. However, because Ipc_attach() has not executed yet the SharedRegion will not be configured. This will cause a default to allocate from a local heap in L2. The block pointer returned by this local heap will at some point be used by a remote core, expecting the CPPI heap to be shared. This will corrupt anything located in the remote core's memory located at the value of the block pointer.
</p><p>Applications which suffer from the latter issue must create a static heap at compile time for use by CPPI. The heap can be provided to the CPPI LLD via new APIs. In the application source code at the following:
</p><p>&lt;syntaxhighlight lang="c"&gt;
</p>
<ol><li>define SIZE_CPPI_HEAP 1024 /* Should be sized large enough to fit all shared</li></ol>
<pre>* CPPI channel and flow objects */
</pre>
<p>/* Statically created shared heap for CPPI since IPC does create a
</p>
<pre>* shared heap for SharedRegion prior to Ipc_attach */
</pre>
<ol><li>pragma DATA_SECTION (cppiHeap, ".cppi_heap");</li>
<li>pragma DATA_ALIGN (cppiHeap, 128)</li></ol>
<p>UInt8 cppiHeap[SIZE_CPPI_HEAP];
</p><p>Int32 systemInit (Void)
{
</p>
<pre>Cppi_InitCfg cppiHeapInit; /* Static CPPI heap */
</pre>
<pre>...
</pre>
<pre>/* Configure Cppi_init() parameters to configure static heap */
cppiHeapInit.heapParams.staticHeapBase = &amp;cppiHeap[0];
cppiHeapInit.heapParams.staticHeapSize = SIZE_CPPI_HEAP;
cppiHeapInit.heapParams.heapAlignPow2 = 7; /* Power of 7 (128 byte) */
cppiHeapInit.heapParams.dynamicHeapBlockSize = -1; /* Shut off malloc if block runs out */
result = Cppi_initCfg (&amp;cppiGblCfgParams, &amp;cppiHeapInit);
if (result&#160;!= CPPI_SOK)
{
Error...
}
</pre>
<pre>...
</pre>
<p>}
</p><p>Int main(Int argc, Char* argv[])
{
</p>
<pre>Int32 result = 0;
</pre>
<pre>selfId = CSL_chipReadReg (CSL_CHIP_DNUM);
</pre>
<pre>/* System initializations for each core. */
if (selfId == 0)
{
/* SRIO, QMSS, and CPPI system wide initializations are run on
* this core */
result = systemInit();
}
</pre>
<pre>...
</pre>
<p>}
</p><p>&lt;/syntaxhighlight&gt;
</p><p>In the application linker command file or XDC configuration place the static CPPI heap into shared memory.
</p><p>If using XDC .cfg file to add sections to the linker command file: &lt;syntaxhighlight lang="c"&gt;
Program.sectMap[".cppi_heap"] = new Program.SectionSpec();
Program.sectMap[".cppi_heap"] = "MSMCSRAM";
&lt;/syntaxhighlight&gt;
</p><p>If explicitly placing the heap in the application linker command file: &lt;syntaxhighlight lang="c"&gt;
.cppi_heap: load &gt;&gt; MSMCSRAM
&lt;/syntaxhighlight&gt;
</p><p><br />
</p>
<h5><span id="Queue_Manager_(QMSS)"></span><span class="mw-headline" id="Queue_Manager_.28QMSS.29">Queue Manager (QMSS)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=28" title="Edit section: Queue Manager (QMSS)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The QMSS low level driver provides the interface to Queue Manager Subsystem hardware which is part of the Multicore Navigator functional unit for a KeyStone device. QMSS provides a hardware-assisted queue system and implements fundamental operations such as en-queue and de-queue, descriptor management, accumulator functionality and configuration of infrastructure DMA mode. The LLD provides APIs to get full entitlement of supported hardware functionality.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/pdf/sprugr9">User Guide</a>
</td></tr>
<tr>
<td>LLD Users Guide
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\qmss\docs\ CPPI_QMSS_LLD_SDS.pdf
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\qmss\docs\qmsslldDocs.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\docs\ReleaseNotes_QMSS_LLD.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h4><span id="Network_Co-processor_(NETCP)"></span><span class="mw-headline" id="Network_Co-processor_.28NETCP.29">Network Co-processor (NETCP)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=29" title="Edit section: Network Co-processor (NETCP)">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>NETCP provides hardware accelerator functionality for processing Ethernet packets.
</p>
<h5><span id="Security_Accelerator_(SA)"></span><span class="mw-headline" id="Security_Accelerator_.28SA.29">Security Accelerator (SA)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=30" title="Edit section: Security Accelerator (SA)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The SA, also known as cp_ace (Adaptive Cryptographic Engine), is designed to provide packet security for IPsec, SRTP and 3GPP industry standards. The SA LLD provides APIs to abstract configuration and control between application and the SA. Similar to the PA LLD, it does not provide a transport layer. The Multicore Navigator is used to exchange control packets between the application and the SA firmware.
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Due to export control restrictions the SA driver is a separate download from the rest of the MCSDK. See download link in the <a rel="nofollow" class="external text" href="BIOS_MCSDK_2-2.html#Related_Software">Related Software</a> link above.
</p><p><br />Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/sprugy6">User Guide</a>
</td></tr>
<tr>
<td>LLD Users Guide
</td>
<td>$(TI_SA_LLD_&lt;ver&gt;_INSTALL_DIR)\sasetup\docs\UserGuide_SA_LLD.pdf
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_SA_LLD_&lt;ver&gt;_INSTALL_DIR)\sasetup\packages\ti\drv\sa\docs\doxygen\sa_lld_docs.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_SA_LLD_&lt;ver&gt;_INSTALL_DIR)\sasetup\packages\ti\drv\sa\docs\ReleaseNotes_SA_LLD.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h5><span id="Packet_Accelerator_(PA)"></span><span class="mw-headline" id="Packet_Accelerator_.28PA.29">Packet Accelerator (PA)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=31" title="Edit section: Packet Accelerator (PA)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The PA LLD is used to configure the hardware PA and provides an abstraction layer between an application and the PA firmware. This does not include a transport layer. Commands and data are exchanged between the PA and an application via the Mutlicore Navigator.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/sprugs4/sprugs4.pdf">User Guide</a>
</td></tr>
<tr>
<td>LLD Users Guide
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\pa\docs\pa_sds.pdf
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\pa\docs\paDocs.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\docs\ReleaseNotes_PA_LLD.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h4><span id="I/O_and_Buses"></span><span class="mw-headline" id="I.2FO_and_Buses">I/O and Buses</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=32" title="Edit section: I/O and Buses">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<h5><span id="Serial_RapidIO_(SRIO)"></span><span class="mw-headline" id="Serial_RapidIO_.28SRIO.29">Serial RapidIO (SRIO)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=33" title="Edit section: Serial RapidIO (SRIO)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The SRIO Low Level Driver provides a well defined standard interface which allows application to send and receive messages via the SRIO peripheral.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/sprugw1">User Guide</a>
</td></tr>
<tr>
<td>LLD Users Guide
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\docs\SRIO_SDS.pdf
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\srio\docs\api_ref.html
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\docs\ReleaseNotes_SRIODriver.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h5><span id="Peripheral_Component_Interconnect_Express_(PCIe)"></span><span class="mw-headline" id="Peripheral_Component_Interconnect_Express_.28PCIe.29">Peripheral Component Interconnect Express (PCIe)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=34" title="Edit section: Peripheral Component Interconnect Express (PCIe)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The PCIe module supports dual operation mode: End Point (EP or Type0) or Root Complex (RC or Type1). This driver focuses on EP mode but it also provides access to some basic RC configuration/functionality. The PCIe subsystem has two address spaces. The first (Address Space 0) is dedicated for local application registers, local configuration accesses and remote configuration accesses. The second (Address Space 1) is dedicated for data transfer. This PCIe driver focuses on the registers for Address Space 0.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/sprugs6a">User Guide</a>
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\pcie\docs\pcieDocs.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\docs\ReleaseNotes_PCIE_LLD.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h5><span id="Antenna_Interface_(AIF2)"></span><span class="mw-headline" id="Antenna_Interface_.28AIF2.29">Antenna Interface (AIF2)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=35" title="Edit section: Antenna Interface (AIF2)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>This AIF2 low level driver aims at generalizing the configuration of AIF2 for different modes (CPRI/OBSAI/ABTLib/Generic packet, WCDMA/LTE/Dual mode). The AIF2 LLD makes use of Chip Support Library and CPPI/QMSS Low Level Drivers (LLDs). This driver is only supported in C6670.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/sprugv7b/sprugv7b.pdf">User Guide</a>
</td></tr>
<tr>
<td>LLD Users Guide
</td>
<td>$(TI_PDK_C6670_INSTALL_DIR)\packages\ti\drv\aif2\docs\AIF2-c6670_usersguide.pdf
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C6670_INSTALL_DIR)\packages\ti\drv\aif2\docs\AIF2-c6670_apireferenceguide.html
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C6670_INSTALL_DIR)\docs\ReleaseNotes_AIF2_LLD.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h5><span class="mw-headline" id="TSIP">TSIP</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=36" title="Edit section: TSIP">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The TSIP is multi-link serial interface consisting of a maximum of eight transmit data signals (or links), eight receive data signals (or links), two frame-sync input signals, and two serial clock inputs. Internally, the TSIP offers multiple channels of time-slot data management and multi-channel DMA capability that allow individual time-slots to be selectively processed. The LLD provides a well-defined standard interface which allows application to configure the peripheral.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/sprugy4">User Guide</a>
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\tsip\docs\tsipDocs.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\docs\ReleaseNotes_TSIP_LLD.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h5><span class="mw-headline" id="Hyperlink">Hyperlink</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=37" title="Edit section: Hyperlink">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The Hyperlink peripheral provides a high-speed, low-latency, and low-power point-to-point link between two Keystone (SoC) devices. The peripheral is also known as vUSR and MCM. Some chip-specific definitions in CSL and documentation may have references to the old names. The LLD provides a well defined standard interface which allows application to configure this peripheral.
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Hyperlink is a point-to-point peripheral, so can only support communication between two devices.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/sprugw8">User Guide</a>
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\hyplnk\docs\hyplnkDocs.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\docs\ReleaseNotes_HYPLNK_LLD.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h5><span id="Ethernet_Media_Access_Controller_(EMAC)"></span><span class="mw-headline" id="Ethernet_Media_Access_Controller_.28EMAC.29">Ethernet Media Access Controller (EMAC)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=38" title="Edit section: Ethernet Media Access Controller (EMAC)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The device driver exposes a set of well defined API which is used by the application layer to send and receive data packets via the EMAC peripheral, and configure and monitor PHY via the MDIO peripheral. The driver also exposes a set of well defined OS abstraction API which is used to ensure that the driver is OS independent and portable. The EMAC driver uses the CSL EMAC functional layer for all EMAC MMR accesses.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td>User Guide
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\emac\docs\doxygen\emac.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\docs\ReleaseNotes_EMAC_LLD.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h4><span class="mw-headline" id="Co-processors">Co-processors</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=39" title="Edit section: Co-processors">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<h5><span id="Bit-rate_Coprocessor_(BCP)"></span><span class="mw-headline" id="Bit-rate_Coprocessor_.28BCP.29">Bit-rate Coprocessor (BCP)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=40" title="Edit section: Bit-rate Coprocessor (BCP)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The BCP driver is divided into 2 layers: Low Level Driver APIs and High Level APIs. The Low Level Driver APIs provide BCP MMR access by exporting register read/write APIs and also provides some useful helper APIs in putting together BCP global and sub-module headers required by the hardware. The BCP Higher Layer provides APIs useful in submitting BCP requests and retrieving their results from the BCP engine.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/sprugz1">User Guide</a>
</td></tr>
<tr>
<td>LLD Users Guide
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\bcp\docs\BCP_SDS.pdf
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\bcp\docs\bcpDocs.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\bcp\docs\ReleaseNotes_BCPDriver.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h5><span id="Turbo_Coprocessor_Decoder_(TCP3d)"></span><span class="mw-headline" id="Turbo_Coprocessor_Decoder_.28TCP3d.29">Turbo Coprocessor Decoder (TCP3d)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=41" title="Edit section: Turbo Coprocessor Decoder (TCP3d)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The TCP3 decoder driver provides a well-defined standard interface which allows the application to send code blocks for decoding and receive hard decision and status via EDMA3 transfers.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/sprugs0">User Guide</a>
</td></tr>
<tr>
<td>LLD Users Guide
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\tcp3d\docs\TCP3D_DriverSDS.pdf
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\tcp3d\docs\TCP3D_DRV_APIIF.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\tcp3d\docs\ReleaseNotes_TCP3DDriver.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h5><span id="Turbo_Coprocessor_Encoder_(TCP3e)"></span><span class="mw-headline" id="Turbo_Coprocessor_Encoder_.28TCP3e.29">Turbo Coprocessor Encoder (TCP3e)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=42" title="Edit section: Turbo Coprocessor Encoder (TCP3e)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The TCP3 Encoder driver provides a well-defined standard interface which allows the application to send code blocks for encoding and receive encoded bits via EDMA3 transfers.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/sprugs1">User Guide</a>
</td></tr>
<tr>
<td>LLD Users Guide
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\tcp3e\docs\TCP3E_DriverSDS.pdf
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\tcp3e\docs\TCP3E_DRV_APIIF.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\tcp3e\docs\ReleaseNotes_TCP3EDriver.pdf
</td></tr></tbody></table>
<p><br />
</p>
<h5><span id="FFT_Accelerator_Coprocessor(FFTC)"></span><span class="mw-headline" id="FFT_Accelerator_Coprocessor.28FFTC.29">FFT Accelerator Coprocessor(FFTC)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=43" title="Edit section: FFT Accelerator Coprocessor(FFTC)">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The FFTC driver is divided into 2 layers: Low Level Driver APIs and High Level APIs. The Low Level Driver APIs provide FFTC MMR access by exporting register read/write APIs and also provides some useful helper APIs in putting together FFTC control header, DFT size list, etc. as required by the hardware. The FFTC Higher Layer provides APIs useful in submitting FFT requests and retrieving their results from the FFTC engine without having to know all the details of the Multicore Navigator.
</p><p>Additional documentation can be found in:
</p>
<table style="width: 720px" cellpadding="2" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Document</b>
</td>
<td bgcolor="#c0c0c0"><b>Location</b>
</td></tr>
<tr>
<td>Hardware Peripheral Users Guide
</td>
<td><a rel="nofollow" class="external text" href="http://www.ti.com/lit/ug/sprugs2c/sprugs2c.pdf">User Guide</a>
</td></tr>
<tr>
<td>LLD Users Guide
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\fftc\docs\FFTC_SDS.pdf
</td></tr>
<tr>
<td>API Reference Manual
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\fftc\docs\fftcDocs.chm
</td></tr>
<tr>
<td>Release Notes
</td>
<td>$(TI_PDK_C66##_INSTALL_DIR)\packages\ti\drv\fftc\docs\ReleaseNotes_FFTCDriver.pdf
</td></tr></tbody></table>
<p><br /><br />
</p>
<h3><span class="mw-headline" id="Platform_Library">Platform Library</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=44" title="Edit section: Platform Library">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div style="padding-left: 10px; float: left; width: 4in">
<p>The platform library defines a standard interface for platform utilities and functionality and provides sample implementations for the EVM platform. These include things such as reading and writing to EEPROM, FLASH, UART, etc. Platform library supports three libraries:
</p>
<ol><li>debug library (e.g., ti.platform.evm6678l.ae66) - located under \platform_lib\lib\debug, needed only when a debug is needed on the platform library since the source is compiled with full source debugging.</li>
<li>release library (e.g., ti.platform.evm6678l.ae66) - located under \platform_lib\lib\release, should be used normally for the best performance of the cycles since the code is compiled with the full optimization.</li>
<li>lite library (e.g., ti.platform.evm6678l.lite.lib) - \platform_lib\lib\debug, not needed for regular platform development - this is used to link for the Power On Self Test (POST) application.</li></ol>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>Platform Library Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>PDK for C66X
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>pdk_c6657_&lt;version&gt;\packages\ti\platform\evm6657l\platform_lib
<p>pdk_c6670_&lt;version&gt;\packages\ti\platform\evm6670l\platform_lib pdk_c6678_&lt;version&gt;\packages\ti\platform\evm6678l\platform_lib
</p>
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="CCSv5_Getting_Started_Guide.html">CCS</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>Select for the C6678L EVM <br />
<p>ti.platform.evm6678l.ae66 (little)
</p>
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\platform\evmc6678l\platform_lib\lib\debug - for debug version <br />$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\platform\evmc6678l\platform_lib\lib\release - for release version
<p><br />(similar paths for C6670, C6657)
</p>
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>platform_lib
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>none
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\platform <br />
<p><br />(similar paths for C6670, C6657) platform.h defines the interface
</p>
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td><a rel="nofollow" class="external text" href="http://processors.wiki.ti.com/">Texas Instruments Embedded Processors Wiki</a>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Product Updates</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p><b>Platform Library Migration Information</b>
</p><p>The below table provides the migration information for the <i>platform library</i> for maintenance updates to the BIOS-MCSDK 2.0.0 production release:
</p><p><br />
</p>
<table style="width: 786px; height: 103px" cellspacing="1" cellpadding="1" width="786" border="1">

<tbody><tr>
<th scope="col">Release
</th>
<th scope="col">API&#160;Change
</th>
<th scope="col">Migration Notes
</th></tr>
<tr>
<td rowspan="3">BIOS-MCSDK&#160;2.0.2<br />&#160;<br />&#160;
</td>
<td>Added Platform_STATUS platform_get_emac_info(uint32_t port_num, PLATFORM_EMAC_EXT_info * emac_info)
</td>
<td>&#160;
</td></tr>
<tr>
<td>Deprecated the efuse_mac_address[6], eeprom_mac_address[6] fields in EMAC_info structure as MAC address is now defined in the new data structure PLATFORM_EMAC_EXT_info
</td>
<td>Use PLATFORM_EMAC_EXT_info structure for MAC&#160;address
</td></tr>
<tr>
<td>Added Platform_STATUS platform_get_macaddr(PLATFORM_MAC_TYPE type, uint8_t * mac_address);
</td>
<td>&#160;
</td></tr>
<tr>
<td>BIOS-MCSDK&#160;2.0.5<br />&#160;<br />&#160;
</td>
<td>No Platform library API change
</td>
<td>Updated the main PLL, DDR3 PLL and PA PLL sequences. Please refer to <i>\platform_lib\src\evm667#.c</i> file for the updates.
</td></tr>
<tr>
<td>
</td>
<td>
</td>
<td>
</td></tr></tbody></table>
<p><br />
</p>
<h3><span class="mw-headline" id="Transport">Transport</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=45" title="Edit section: Transport">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Transports are intermediate drivers that sit between either the NDK or IPC sub-systems and interface them to the appropriate EVM peripherals. The transports supported by MCSDK are:
</p>
<ul><li>NDK transport - Network Interface Management Unit (NIMU) Driver</li>
<li>QMSS IPC transport - IPC MessageQ transport utilizing QMSS</li>
<li>SRIO IPC transport - IPC MessageQ transport utilizing SRIO</li></ul>
<p>More information on these can be found in the NDK or IPC sections of this guide.
</p><p><br />
</p>
<h2><span id="SYS/BIOS_RTOS"></span><span class="mw-headline" id="SYS.2FBIOS_RTOS">SYS/BIOS RTOS</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=46" title="Edit section: SYS/BIOS RTOS">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div style="padding-left: 10px; float: left; width: 4in">
<p>SYS/BIOS is a scalable real-time kernel. It is designed to be used by applications that require real-time scheduling and synchronization or real-time instrumentation. SYS/BIOS provides preemptive multi-threading, hardware abstraction, real-time analysis, and configuration tools. SYS/BIOS is designed to minimize memory and CPU requirements on the target.
</p>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>SYS/BIOS Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Libraries
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>SYS/BIOS
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>bios_6_&lt;version&gt;\
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little and Big
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>The appropriate libraries are selected for your device and platform as set in the RTSC build properties for your project and based on the use module statements in your configuration.
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>The appropriate path is selected to the libraries for your device and platform as set in the RTSC build properties for your project.
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>
<p>BIOS_CG_ROOT is set automatically by CCS based on the version of BIOS you have checked to build with. <br />${BIOS_CG_ROOT}\packages\ti\bios\include
</p>
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td><a rel="nofollow" class="external text" href="https://e2e.ti.com/support/processors/f/791/t/840835">SYS/BIOS Online Training</a><br /><a rel="nofollow" class="external text" href="SYS/BIOS_1.html">SYS/BIOS 1.5-DAY Workshop</a><br /><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC Home</a>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td>
<p><a rel="nofollow" class="external text" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/bios/index.html">SYS/BIOS Downloads</a>
</p>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p><br />
</p>
<h2><span id="Inter-Processor_Communication_(IPC)"></span><span class="mw-headline" id="Inter-Processor_Communication_.28IPC.29">Inter-Processor Communication (IPC)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=47" title="Edit section: Inter-Processor Communication (IPC)">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div style="padding-left: 10px; float: left; width: 4in">
<p>Inter-Processor Communication (IPC) provides communication between processors in a multi-processor environment, communication to other threads on same processor, and communication to peripherals. It includes message passing, streams, and linked lists.
</p><p>IPC can be used to communicate with the following:
</p>
<ul><li>Other threads on the same processor</li>
<li>Threads on other processors running SYS/BIOS</li>
<li>Threads on GPP processors running SysLink (e.g., Linux)</li></ul>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>IPC Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Libraries
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>IPC
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>ipc_&lt;version&gt;\
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little and Big
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>The appropriate libraries are selected for your device and platform as set in the RTSC build properties for your project and based on the use module statements in your configuration.
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>The appropriate path is selected to the libraries for your device and platform as set in the RTSC build properties for your project.
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC Home</a>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a rel="nofollow" class="external text" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ipc/index.html">IPC Downloads</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p><br />
</p>
<h3><span class="mw-headline" id="IPC_Transports">IPC Transports</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=48" title="Edit section: IPC Transports">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<h4><span class="mw-headline" id="QMSS_IPC_Transport">QMSS IPC Transport</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=49" title="Edit section: QMSS IPC Transport">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div style="padding-left: 10px; float: left; width: 4in">
<p>The QMSS transport is an additional transport for IPC. The QMSS transport can be used by MessageQ to send data between tasks and cores via the QMSS IP block. This package has a QMSS transport unit test/benchmark example for all supported platforms.
</p><p><br />
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  This module is only intended to be used with IPC MessageQ. As such, users should not tie up to its API directly.
</p>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>QMSS IPC Transport Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>PDK_C6678_INSTALL_DIR
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>mcsdk_&lt;version&gt;\packages\ti\transport\ipc\qmss
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little, Big
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>ti.transport.ipc.qmss.transports.ae66 (little) <br />ti.transport.ipc.qmss.transports.ae66e (big)
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\transport\ipc\qmss\transports\lib\whole_program_debug
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>None
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td>The QMSS IPC Transport benchmark example is available in <br />$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\transport\ipc\examples\qmssIpcBenchmark
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a rel="nofollow" class="external free" href="http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html">http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p><br />
</p><p>The MessageQ communication architecture utilizing the QMSS IPC transport is shown below. <br /><a href="File_QMSS_Transport.html" class="image" title="QMSS_Transport.JPG"><img alt="QMSS_Transport.JPG" src="https://processors.wiki.ti.com/images/c/c6/QMSS_Transport.JPG" width="700" height="365" /></a>
</p><p><br />
</p>
<h4><span class="mw-headline" id="SRIO_IPC_Transport">SRIO IPC Transport</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=50" title="Edit section: SRIO IPC Transport">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div style="padding-left: 10px; float: left; width: 4in">
<p>The SRIO transport is an additional transport for IPC. The SRIO transport can be used by MessageQ to send data between tasks, cores, and chips via the SRIO IP block. This package has SRIO transport unit test and benchmark examples for all supported platforms.
</p><p><br />
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  This module is only intended to be used with IPC MessageQ. As such, users should not tie up to its API directly.
</p>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>SRIO IPC Transport Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>PDK_C6678_INSTALL_DIR
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>mcsdk_&lt;version&gt;\packages\ti\transport\ipc\srio
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little, Big
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>ti.transport.ipc.srio.transports.ae66 (little) <br />ti.transport.ipc.srio.transports.ae66e (big)
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\transport\ipc\srio\transports\lib\whole_program_debug<br />
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>None
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td>The SRIO IPC Transport benchmark example is available in <br />$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\transport\ipc\examples\srioIpcBenchmark <br />The SRIO IPC Transport Chip to Chip example is available in <br />$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\transport\ipc\examples\srioIpcChipToChipExample
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a rel="nofollow" class="external free" href="http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html">http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p><br />
</p><p>The MessageQ communication architecture utilizing the SRIO IPC transport is shown below. <a href="File_SRIOtransport.html" class="image" title="SRIOtransport.PNG"><img alt="SRIOtransport.PNG" src="https://processors.wiki.ti.com/images/2/29/SRIOtransport.PNG" width="700" height="443" /></a>
</p><p><br />
</p>
<h4><span class="mw-headline" id="Rebuilding_the_IPC_Transports">Rebuilding the IPC Transports</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=51" title="Edit section: Rebuilding the IPC Transports">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>For experimentation and debug the QMSS and SRIO transports can be rebuilt following the below instructions.
</p>
<ol><li>[Optional - Required for debug single stepping] Modify the transports config.bld file C66LE/BE.ccOpts.prefix to remove optimization and add symbolic debug <br /> From: "-mo <b>-o3</b> -q -k -eo.o" <br /> To: "-mo <b>-g</b> -q -k -eo.o"</li>
<li>From a command prompt navigate to the pdk\packages\ti\transport\ipc\(qmss or srio) directory</li>
<li>Configure the XDCPATH environment variable with the BIOS and IPC install locations: <br /> <b>set XDCPATH=c:\ti\bios_w_xx_yy_zz\packages\</b> <br /> <b>set XDCPATH=%XDCPATH%;c:\ti\ipc_w_xx_yy_zz\packages\</b></li>
<li>Configure the XDCCGROOT environment variable with the compiler install path (Using CGT 7.2.4 installed as part of CCS as an example) <br /> <b>set XDCCGROOT=c:\ti\ccsv5\tools\compiler\c6000_7.2.4</b></li>
<li>Add the XDC Tools to your system PATH <br /> <b>set PATH=%PATH%;c:\ti\xdctools_w_xx_yy_zz\</b></li>
<li>Clean the transport <br /> &gt;<b>xdc clean -PR .</b></li>
<li>Build the transport <br /> &gt;<b>xdc -PR .</b></li></ol>
<p>The transport example projects can now be rebuilt via CCS with the debug profile.  The example code as well as the transport code can be single stepped after rebuilding the transport with symbolic debug.
</p><p><b>Note:</b> To allow single-step debug of the IPC and BIOS source rebuild the example projects with the following command added to the example's .cfg file <br /> <b>BIOS.libType = BIOS.LibType_Debug;</b>
</p>
<h3><span class="mw-headline" id="IPC_Flow">IPC Flow</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=52" title="Edit section: IPC Flow">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This section provides ladders diagrams showing the execution flow that takes place when multiple cores access shared resources or exchange data using IPC. Not all function calls and input parameters are described in the ladder diagram. However, enough detail is provided to show how different cores share resources without stepping on one another.
</p>
<h4><span class="mw-headline" id="IPC_Overview">IPC Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=53" title="Edit section: IPC Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>A high-level ladder diagram showing how two cores would share a heap, MessageQ queues, and exchange a message using IPC <a href="File_Ipc_overview_ladder.html" class="image" title="ipc_overview_ladder.JPG"><img alt="ipc_overview_ladder.JPG" src="https://processors.wiki.ti.com/images/5/5e/Ipc_overview_ladder.JPG" width="700" height="526" /></a>
</p><p><br />
</p>
<h4><span class="mw-headline" id="IPC_Startup">IPC Startup</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=54" title="Edit section: IPC Startup">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This ladder diagram shows how two cores initialize and attach to one another via IPC: <a href="File_Ipc_startup_ladder.html" class="image" title="ipc_startup_ladder.JPG"><img alt="ipc_startup_ladder.JPG" src="https://processors.wiki.ti.com/images/c/c6/Ipc_startup_ladder.JPG" width="700" height="527" /></a>
</p><p><br />
</p>
<h4><span class="mw-headline" id="IPC_Heap_Sharing">IPC Heap Sharing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=55" title="Edit section: IPC Heap Sharing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This ladder diagram shows how two cores initialize and share a global heap for allocating and freeing messages: <a href="File_Ipc_heap_ladder.html" class="image" title="ipc_heap_ladder.JPG"><img alt="ipc_heap_ladder.JPG" src="https://processors.wiki.ti.com/images/a/a1/Ipc_heap_ladder.JPG" width="700" height="526" /></a>
</p><p><br />
</p>
<h4><span class="mw-headline" id="IPC_MessageQ_Queue_Sharing">IPC MessageQ Queue Sharing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=56" title="Edit section: IPC MessageQ Queue Sharing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This ladder diagram shows how two cores search for, and find MessageQ queues located on remote cores: <a href="File_Ipc_messageq_ladder.html" class="image" title="ipc_messageq_ladder.JPG"><img alt="ipc_messageq_ladder.JPG" src="https://processors.wiki.ti.com/images/d/d7/Ipc_messageq_ladder.JPG" width="700" height="526" /></a>
</p><p><br />
</p>
<h4><span class="mw-headline" id="IPC_Shared_Memory_Transport_Message_Passing">IPC Shared Memory Transport Message Passing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=57" title="Edit section: IPC Shared Memory Transport Message Passing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This ladder diagram shows how two cores allocate, send, receive, and free MessageQ messages over the Shared Memory transport: <a href="File_Ipc_shared_mem_ladder.html" class="image" title="ipc_shared_mem_ladder.JPG"><img alt="ipc_shared_mem_ladder.JPG" src="https://processors.wiki.ti.com/images/b/b3/Ipc_shared_mem_ladder.JPG" width="700" height="526" /></a>
</p><p><br />
</p>
<h4><span class="mw-headline" id="IPC_QMSS_Transport_Message_Passing">IPC QMSS Transport Message Passing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=58" title="Edit section: IPC QMSS Transport Message Passing">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This ladder diagram shows how two cores allocate, send, receive, and free MessageQ messages over the QMSS transport: <a href="File_Ipc_qmss_ladder.html" class="image" title="ipc_qmss_ladder.JPG"><img alt="ipc_qmss_ladder.JPG" src="https://processors.wiki.ti.com/images/6/6e/Ipc_qmss_ladder.JPG" width="700" height="527" /></a>
</p><p><br />
</p>
<h3><span class="mw-headline" id="IPC_Module_Usage_for_Different_Transports">IPC Module Usage for Different Transports</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=59" title="Edit section: IPC Module Usage for Different Transports">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>When different IPC transports are used by an application some IPC modules may cease to function due to the system architecture. The system architecture dictates the IPC transport used. For example, chip to chip data transfer over MessageQ would be handled by the SRIO transport since SRIO established a transport path between two chips. This is something the Shared Memory and QMSS/Navigator transports are incapable of. The following describes which modules delivered in the IPC component are functional for each IPC transport.
</p>
<h4><span class="mw-headline" id="Shared_Memory_IPC_Transport">Shared Memory IPC Transport</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=60" title="Edit section: Shared Memory IPC Transport">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The Shared Memory transport is delivered with the IPC component package. The Shared Memory transport is the default IPC transport. As such, all modules delivered in IPC are functional and useable with the Shared Memory transport within the context of a single chip. The Shared Memory transport is delivered with IPC and used by default since it fits the generality module of IPC. It is the only transport that can be used when the architecture of the chip is not known.
</p><p><br />
</p>
<table cellspacing="0" cellpadding="5" align="center" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0" colspan="3"><b>Useable IPC Modules</b>
</td></tr>
<tr>
<td bgcolor="#c0c0c0"><b>IPC Component</b>
</td>
<td bgcolor="#c0c0c0"><b>Supported?</b>
</td>
<td bgcolor="#c0c0c0"><b>Comments</b>
</td></tr>
<tr>
<td>IPC
</td>
<td><b>YES</b>
</td>
<td>Required to start IPC regardless of transport
</td></tr>
<tr>
<td>MessageQ
</td>
<td><b>YES</b>
</td>
<td>Can use Shared Memory transport to send messages between threads on the same core and cores on the same chip
</td></tr>
<tr>
<td>Heap*MP
</td>
<td><b>YES</b>
</td>
<td>Messages allocated from shared memory on a source thread/core using a Heap*MP then sent over the Shared Memory transport can be freed on the destination thread/core
</td></tr>
<tr>
<td>GateMP
</td>
<td><b>YES</b>
</td>
<td>Can be used to synchronize threads/cores communicating over the Shared Memory transport
</td></tr>
<tr>
<td>Notify
</td>
<td><b>YES</b>
</td>
<td>Used to generate interrupt on destination core signalling there is a message available for it to receive on over the Shared Memory transport
</td></tr>
<tr>
<td>SharedRegion
</td>
<td><b>YES</b>
</td>
<td>Specifies the IPC Shared Region from which Heaps, MessageQ queues, and Shared Memory transport FIFOs should be allocated
</td></tr>
<tr>
<td>MultiProc
</td>
<td><b>YES</b>
</td>
<td>Specifies the cores within the system that the Shared Memory transport can transport messages between
</td></tr>
<tr>
<td>NameServer
</td>
<td><b>YES</b>
</td>
<td>Used to service MessageQ, Heap, and Gate _open requests between cores which intend to communicate over the Shared Memory transport
</td></tr></tbody></table>
<p><br />
</p>
<h4><span id="QMSS/Navigator_IPC_Transport"></span><span class="mw-headline" id="QMSS.2FNavigator_IPC_Transport">QMSS/Navigator IPC Transport</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=61" title="Edit section: QMSS/Navigator IPC Transport">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The QMSS/Navigator transport is delivered with the PDK component packages. The QMSS/Navigator transport is a platform specific IPC transport that uses QMSS resources on the PDK platform. The QMSS/Navigator transport allows communication between threads on the same core and cores on the same chip. This is similar to the Shared Memory transport except the Navigator QMSS queues are used to move the message instead of shared memory. As such, all modules delivered in IPC are functional and useable with the QMSS/Navigator transport within the context of a single chip.
</p><p><br />
</p>
<table cellspacing="0" cellpadding="5" align="center" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0" colspan="3"><b>Useable IPC Modules</b>
</td></tr>
<tr>
<td bgcolor="#c0c0c0"><b>IPC Component</b>
</td>
<td bgcolor="#c0c0c0"><b>Supported?</b>
</td>
<td bgcolor="#c0c0c0"><b>Comments</b>
</td></tr>
<tr>
<td>IPC
</td>
<td><b>YES</b>
</td>
<td>Required to start IPC regardless of transport
</td></tr>
<tr>
<td>MessageQ
</td>
<td><b>YES</b>
</td>
<td>Can use QMSS/Navigator transport to send messages between threads on the same core and cores on the same chip
</td></tr>
<tr>
<td>Heap*MP
</td>
<td><b>YES</b>
</td>
<td>Messages allocated from shared memory on a source thread/core using a Heap*MP then sent over the QMSS/Navigator transport can be freed on the destination thread/core
</td></tr>
<tr>
<td>GateMP
</td>
<td><b>YES</b>
</td>
<td>Can be used to synchronize threads/cores communicating over the QMSS/Navigator transport
</td></tr>
<tr>
<td>Notify
</td>
<td><b>YES but...</b>
</td>
<td>Is not directly used by the QMSS/Navigator transport which generates an interrupt on the destination core via QMSS queue interrupt mechanisms. However, since the QMSS/Navigator transport works within the context of a single chip the Notify module can still be used to generate interrupts, out-of-band from the QMSS/Navigator transport, to different cores on the chip
</td></tr>
<tr>
<td>SharedRegion
</td>
<td><b>YES</b>
</td>
<td>Specifies the IPC Shared Region from which Heaps, and MessageQ queues should be allocated
</td></tr>
<tr>
<td>MultiProc
</td>
<td><b>YES</b>
</td>
<td>Specifies the cores within the system that the QMSS/Navigator transport can transport messages between
</td></tr>
<tr>
<td>NameServer
</td>
<td><b>YES</b>
</td>
<td>Used to service MessageQ, Heap, and Gate _open requests between cores which intend to communicate over the QMSS/Navigator transport
</td></tr></tbody></table>
<p><br />
</p>
<h4><span class="mw-headline" id="SRIO_IPC_Transport_2">SRIO IPC Transport</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=62" title="Edit section: SRIO IPC Transport">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The SRIO transport is delivered with the PDK component packages. The SRIO transport is a platform specific IPC transport that uses SRIO and QMSS resources on the PDK platform. The SRIO transport allows communication between threads on the same core, cores on the same chip, and cores on different chips. When the SRIO transport is used to transport messages between entities within the same chip all IPC modules are useable, similar to the Shared Memory and QMSS/Navigator transports. However, when the SRIO transport is used to transport messages between entities on two separate chips only a subset of the IPC modules are useable. This is due to the assumption that there are no shared resources, such as hardware semaphores or shared memory, between two chips. The only thing connecting the chips are the SRIO lanes.
</p><p><br />
</p>
<table cellspacing="0" cellpadding="5" align="center" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0" colspan="3"><b>Useable IPC Modules When Communicating Between Cores on Different Chips</b>
</td></tr>
<tr>
<td bgcolor="#c0c0c0"><b>IPC Component</b>
</td>
<td bgcolor="#c0c0c0"><b>Supported?</b>
</td>
<td bgcolor="#c0c0c0"><b>Comments</b>
</td></tr>
<tr>
<td>IPC
</td>
<td><b>YES</b>
</td>
<td>Required to start IPC regardless of transport
</td></tr>
<tr>
<td>MessageQ
</td>
<td><b>YES</b>
</td>
<td>Can use SRIO transport to send messages between cores on different chips
</td></tr>
<tr>
<td>Heap*MP
</td>
<td><b>NO</b>
</td>
<td>Any heaps opened would only be useable for cores on the chip which the Heap*MP was opened. There is no sense of a Heap*MP instance that would be shared between cores on different chips. IPC assumes there is no shared memory between chips
</td></tr>
<tr>
<td>GateMP
</td>
<td><b>NO</b>
</td>
<td>Any gates used would only be synchronize cores on the chip which the Gate was opened. There is no sense of a Gate instance that would be shared between cores on different chips. IPC assumes there are no shared hardware semaphores between chips
</td></tr>
<tr>
<td>Notify
</td>
<td><b>NO</b>
</td>
<td>IPC assumes there is no hardware or software interrupt mechanism between cores on different chips
</td></tr>
<tr>
<td>SharedRegion
</td>
<td><b>NO</b>
</td>
<td>Any SharedRegion created would only be useable by cores on the chip which the SharedRegion was defined. There is no sense of a SharedRegion between cores on different chips. IPC assumes there is no shared memory between chips for the SharedRegion to exist
</td></tr>
<tr>
<td>MultiProc
</td>
<td><b>YES</b>
</td>
<td>Specifies the cores within the system, all chips, that the SRIO transport can transport messages between
</td></tr>
<tr>
<td>NameServer
</td>
<td><b>YES</b>
</td>
<td>Used to service MessageQ_open requests between cores on different chips which intend to communicate over the SRIO transport. The SRIO transport itself is used to pass the NameServer request/response messages between the cores
</td></tr></tbody></table>
<p><br />
</p>
<h3><span class="mw-headline" id="IPC_Benchmarks">IPC Benchmarks</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=63" title="Edit section: IPC Benchmarks">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>IPC performance is measured in terms of the time (in cycles) to send a message from one core to another core and includes all cache coherency operations to ensure the message is ready for use by the receiving core. The one way latency is measured for shared memory, QMSS/Navigator, and SRIO transports.
</p>
<h4><span class="mw-headline" id="Latency_Benchmark_Setup">Latency Benchmark Setup</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=64" title="Edit section: Latency Benchmark Setup">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>To measure the 1-way latency a message is ping-ponged between two cores. Core 0 starts the test by sending a message to Core 1. Core 1 relays the message back to Core 0 who then sends it back to Core 1. The message ping-pongs between the two cores for a configured amount of iterations. Each time Core 0 receives the message it stores the round-trip time, in cycles, representing the total time for the message to go from Core 0 to Core 1 then back to Core 0. This measured time is divided by two to get the one-way latency. The one-way latency measurements are then averaged over all iterations to yield the average 1-way latency.
</p><p>The QMSS/Navigator transport results are presented for both QPEND and Accumulator options. See <a href="BIOS_MCSDK_2-2.html#IPC_Transports" title="BIOS MCSDK 2.0 User Guide">IPC Transports</a> for more information on the QPEND and Accumulator implementations.
</p><p>For the SRIO transport a four 1x port and 3.125 Gbps link rate was used. Loopback mode was disabled so all packets were transferred over the SRIO lanes and not looped back in the SRIO hardware.
</p>
<h4><span class="mw-headline" id="Benchmark_Results">Benchmark Results</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=65" title="Edit section: Benchmark Results">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<table cellspacing="0" cellpadding="5" align="center" border="1">

<tbody><tr>
<td bgcolor="#c0c0c0">
</td>
<td bgcolor="#c0c0c0"><b>Shared Memory Transport</b>
</td>
<td bgcolor="#c0c0c0"><b>QMSS Transport (QPEND)</b>
</td>
<td bgcolor="#c0c0c0"><b>QMSS Transport (Accumulator - 1 Descriptor per Interrupt)</b>
</td>
<td bgcolor="#c0c0c0"><b>QMSS Transport (Accumulator - 10 Descriptors per Interrupt)</b>
</td>
<td bgcolor="#c0c0c0"><b>SRIO Transport (Type 11 - 1 packet per Interrupt)</b>
</td>
<td bgcolor="#c0c0c0"><b>SRIO Transport (Type 11 - 10 packets per Interrupt)</b>
</td></tr>
<tr>
<td>Avg 1-way Latency (Cycles)
</td>
<td>2,402
</td>
<td>1,673
</td>
<td>4,522
</td>
<td>4,606
</td>
<td>9,056
</td>
<td>9,104
</td></tr></tbody></table>
<p><u>Notes:</u>
</p>
<ul><li>-o3 compiler option</li>
<li>All debug and assert options disabled</li></ul>
<p><u>Benchmark Comments:</u>
</p>
<ul><li>The Shared Memory transport is the default IPC transport offering good out-of-the box performance.</li>
<li>Applications which require the very best in latency performance should use the QPEND implementation of the QMSS/Navigator transport. These queues, when pushed descriptors, interrupt the DSP directly through the INTC module. The QMSS/Navigator transport is delivered as part of PDK. For information on how to configure the QMSS/Navigator transport to use QPEND queues please see <a href="BIOS_MCSDK_2-2.html#Using_and_Configuring_the_Navigator.2FQMSS_Transport" title="BIOS MCSDK 2.0 User Guide">Using and Configuring the Navigator/QMSS Transport</a>.</li>
<li>The QMSS/Navigator transport should be configured to use the Accumulator implementation if interrupt pacing is desired. The Accumulator configuration has a higher latency than its transport counterpart but offers the ability to interrupt the DSP after a number of descriptors have been pushed to an accumulator queue or after a certain amount of time has passed. For information on how to configure the QMSS/Navigator transport to use Accumulator queues, as well as configure the pacing and timeout values, please see <a href="BIOS_MCSDK_2-2.html#Using_and_Configuring_the_Navigator.2FQMSS_Transport" title="BIOS MCSDK 2.0 User Guide">Using and Configuring the Navigator/QMSS Transport</a>.</li>
<li>The SRIO transport, despite a high latency, offers the ability to transfer messages between cores on different chips. This is something that is not possible with the Shared Memory or QMSS/Navigator transports. The SRIO transport is delivered as part of PDK. For information on how to configure the SRIO transport please see <a href="BIOS_MCSDK_2-2.html#Using_and_Configuring_the_sRIO_Transport" title="BIOS MCSDK 2.0 User Guide">Using and Configuring the SRIO Transport</a>.</li></ul>
<p><br /><b>The benchmark applications used to find the latency measurements are included in PDK under $(TI_PDK_C667x_INSTALL_DIR)\packages\ti\transport\ipc\examples. READMEs describing how to build and run the benchmarks are contained within the individual benchmark directories. See <a href="BIOS_MCSDK_2-2.html#Explicit_Programming_Model_using_IPC" title="BIOS MCSDK 2.0 User Guide">Explicit Programming Module Using IPC</a> for guidance on modifying transport configuration options when rerunning the benchmark applications.</b>
</p><p><br />
</p>
<h2><span id="Network_Development_Kit_(NDK)"></span><span class="mw-headline" id="Network_Development_Kit_.28NDK.29">Network Development Kit (NDK)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=66" title="Edit section: Network Development Kit (NDK)">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div style="padding-left: 10px; float: left; width: 4in">
<p>The NDK is a platform for development and demonstration of network-enabled applications on DSP devices and includes demonstration software showcasing DSP capabilities across a range of network-enabled applications. The NDK serves as a rapid prototype platform for the development of network and packet-processing applications, or to add network connectivity to existing DSP applications for communications, configuration, and control. Using the components provided in the NDK, developers can quickly move from development concepts to working implementations attached to the network.
</p><p>The NDK provides an IPv6 and IPv4 compliant TCP/IP stack working with the SYS/BIOS real-time operating system. Its primary focus is on providing the core Layer 3 and Layer 4 stack services along with additional higher-level network applications such as HTTP server and DHCP.
</p><p>The NDK itself does not include any platform or device-specific software. The NDK interfaces through well-defined interfaces to the PDK and platform software elements needed for operation.
</p>
The functional architecure for NDK is shown below. <br /><div class="floatleft"><a href="File_Ndkarch.html" class="image" title="Ndkarch.png"><img alt="Ndkarch.png" src="https://processors.wiki.ti.com/images/5/5f/Ndkarch.png" width="300" height="249" /></a></div>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>Network Development Kit Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Libraries
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>NDK
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>ndk_&lt;version&gt;\
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little and Big
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>
<p>binsrc.lib or binsrce.lib <br />and <br />cgi.lib or cgie.lib <br />and <br />console.lib or consolee.lib <br />and <br />hdlc.lib or hdlce.lib <br />and <br />miniPrintf.lib or miniPrintfe.lib <br />and <br />netctrl.lib or netctrle.lib <br />and <br />nettool.lib or nettoole.lib <br />and <br />os.lib or ose.lib <br />and <br />servers.lib or serverse.lib <br />and <br />stack.lib or stacke.lib
</p>
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>$(NDK_INSTALL_DIR)\packages\ti\ndk\lib\&lt;arch&gt;
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>.far:NDK_OBJMEM, .far:NDK_PACKETMEM
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>L2 Cache
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>NDK_INSTALL_DIR is set automatically by CCS based on the version of NDK you have checked to build with. <br />
<p>${NDK_INSTALL_DIR}\packages\ti\ndk\inc <br />${NDK_INSTALL_DIR}\packages\ti\ndk\inc\tools
</p>
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td>The NDK unit test examples are available in <br />$(TI_MCSDK_INSTALL_DIR)\packages\ti\platform\nimu\test\evm####
</td></tr>
<tr>
<td><b>Extended Support</b>
</td>
<td>
<p><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC Home</a> <br /><a rel="nofollow" class="external text" href="http://www-s.ti.com/sc/techlit/spru523.pdf">NDK User's Guide</a> <br /><a rel="nofollow" class="external text" href="http://www-s.ti.com/sc/techlit/spru524.pdf">NDK Programmer's Reference Guide</a> <br /><a rel="nofollow" class="external text" href="http://www-s.ti.com/sc/techlit/sprufp2.pdf">NDK Support Package Ethernet Driver Design Guide</a> <br /><a rel="nofollow" class="external text" href="Network_Developers_Kit_FAQ.html">NDK_FAQ</a> <br /><a rel="nofollow" class="external text" href="https://e2e.ti.com/support/processors/f/791/t/947275">Rebuilding NDK Core</a> <br />
</p>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a rel="nofollow" class="external text" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ndk/index.html">NDK Downloads</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p><br />
</p>
<h4><span id="Network_Interface_Management_Unit_(NIMU)_Driver"></span><span class="mw-headline" id="Network_Interface_Management_Unit_.28NIMU.29_Driver">Network Interface Management Unit (NIMU) Driver</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=67" title="Edit section: Network Interface Management Unit (NIMU) Driver">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<div style="padding-left: 10px; float: left; width: 4in">
<p>NIMU sits between NDK common software and the C6678 SoC and provides a common interface for NDK communication. This package contains NDK unit test examples for all supported platforms.
</p><p><br />
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  This module is only intended to be used with NDK. As such, users should not tie up to its API directly.
</p><p><br />
</p>
The functional architecture for NIMU (taking the C6678 platform as an example) is shown below. A similar architecture is also applicable for the C6670 platform. <br /><div class="center"><div class="floatnone"><a href="File_Ndkarch.html" class="image" title="Ndkarch.png"><img alt="Ndkarch.png" src="https://processors.wiki.ti.com/images/5/5f/Ndkarch.png" width="300" height="249" /></a></div></div>
<p><br />
</p>
Note: The below model is applicable for C6657 platform. <div class="center"><div class="floatnone"><a href="File_Ndkarch-6657.html" class="image" title="Ndkarch-6657.png"><img alt="Ndkarch-6657.png" src="https://processors.wiki.ti.com/images/a/a9/Ndkarch-6657.png" width="300" height="248" /></a></div></div>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>NIMU Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>PDK_C6678_INSTALL_DIR
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>mcsdk_&lt;version&gt;\packages\ti\transport\ndk\nimu
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>ti.transport.ndk.nimu.ae66 (little)
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\transport\ndk\nimu\lib\debug for debug version <br />$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\transport\ndk\nimu\lib\release for release version
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>nimu_eth_ll2
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>L2SRAM
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>$(TI_PDK_C6678_INSTALL_DIR)\packages\ti\transport\ndk\nimu\include
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>None
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td>The NDK unit test examples are available in <br />$(TI_MCSDK_INSTALL_DIR)\examples\ndk\evm####
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a rel="nofollow" class="external free" href="http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html">http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p><br /><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p><p><br />
</p>
<h2><span class="mw-headline" id="Runtime_Libraries">Runtime Libraries</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=68" title="Edit section: Runtime Libraries">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="OpenEM">OpenEM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=69" title="Edit section: OpenEM">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div style="padding-left: 10px; float: left; width: 4in;">
<p>The Open Event Machine (OpenEM) is a multi-core runtime for KeyStone devices. TIs implementation extensively leverages KeyStones multicore infrastructure and especially the Multicore Navigator.  The main missions of OpenEM are to enable efficient scheduling, dispatching and load balancing of work across the cores of a KeyStone device.
</p><p>In addition, OpenEM facilitate easy porting of multi-core applications from one KeyStone device to another.  It is able to transfer data between global shared and local private memories and optionally manages cache coherency.  Finally, it integrates well with many interfaces and accelerators as well as with different Operating Systems.
</p>
</div>
<table cellpadding="2" border="5" style="font-size: 13px; background-color: rgb(255, 255, 255); width: 675px;">

<tbody><tr>
<td align="center" colspan="2" style="background-color: rgb(232, 232, 232); background-position: initial initial; background-repeat: initial initial;"><b>OMP Library Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>OPENEM
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>openem_&lt;version&gt;\
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td>Eclipse RTSC
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>The appropriate path is selected to the libraries for your device and platform as set in the RTSC build properties for your project.
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>$(OEM_INSTALL_DIR)\packages
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html">BIOS-MCSDK</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p><br />
</p><p><br />
</p>
<h3><span class="mw-headline" id="OpenMP">OpenMP</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=70" title="Edit section: OpenMP">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div style="padding-left: 10px; float: left; width: 4in;">
<p>OMP is an implementation of an openMP run-time library for SYS/BIOS supporting KeyStone multicore DSP devices. The library implements support for thread management, shared memory, and synchronization as required for openMP.
</p><p>Combined with the TI compiler (version 7.4 or greater) a user can create OpenMP programs for TI's multicore DSPs.
</p>
</div>
<table cellpadding="2" border="5" style="font-size: 13px; background-color: rgb(255, 255, 255); width: 675px;">

<tbody><tr>
<td align="center" colspan="2" style="background-color: rgb(232, 232, 232); background-position: initial initial; background-repeat: initial initial;"><b>OMP Library Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>OMP
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>omp_&lt;version&gt;\
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td>Eclipse RTSC
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>The appropriate path is selected to the libraries for your device and platform as set in the RTSC build properties for your project.
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>$(OMP_INSTALL_DIR)\packages
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td>PDK
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html">BIOS-MCSDK</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>&#160;and&#160;<a rel="nofollow" class="external text" href="http://www.gnu.org/licenses/gcc-exception.html">GPL-3.0-with-GCC-exception</a>
</td></tr></tbody></table>
<p><br />
</p><p><br />
</p>
<h2><span class="mw-headline" id="Algorithm_Libraries">Algorithm Libraries</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=71" title="Edit section: Algorithm Libraries">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>TI provides several algorithm libraries, each specific to a particular arena. Each library provides a collection of C-callable low-level functions (kernels), each tailored for optimal performance on a specific TI processing device (or devices). The libraries are typically used in computationally intensive real-time applications where execution speed is a critical factor. Their use generally accelerates execution speeds well beyond that achieved by equivalent code written in standard ANSI C. Additionally, use of these libraries can significantly reduce application development time. Source code is provided in all cases to facilitate kernel modification when needed.
</p><p>See <a rel="nofollow" class="external text" href="Software_libraries.html">c6x Software Library mediawiki</a> for a comprehensive overview of the various software libraries available for TI's c6x family of processors.
</p><p><br />
</p>
<h3><span id="DSP_Library_(DSPLIB)"></span><span class="mw-headline" id="DSP_Library_.28DSPLIB.29">DSP Library (DSPLIB)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=72" title="Edit section: DSP Library (DSPLIB)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div style="padding-left: 10px; float: left; width: 4in">
<p>DSPLIB is an optimized DSP Function Library and includes many C-callable, optimized, general-purpose signal-processing routines including:
</p>
<ul><li>Adaptive Filtering</li>
<li>Correlation</li>
<li>Fast Fourier Transform</li>
<li>Filtering and convolution</li>
<li>Matrix</li></ul>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>DSPLIB Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>DSPLIB
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>dsplib_c66x_&lt;version&gt;\
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="CCSv5_Getting_Started_Guide.html">CCS</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Big and Little
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>dsplib.a66 (COFF, little-endian) <br />dsplib.a66e (COFF, big-endian) <br />dsplib.ae66 (ELF, little-endian) <br />dsplib.ae66e (ELF, big-endian)
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>&lt;root_install_dir&gt;\lib\
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>&lt;root_install_dir&gt;\inc\ <br />&lt;root_install_dir&gt;\packages\
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS E2e Forum</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td><a rel="nofollow" class="external text" href="Software_libraries.html">c6x Software Library mediawiki</a>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a rel="nofollow" class="external text" href="http://software-dl.ti.com/sdoemb/sdoemb_public_sw/dsplib/latest/index_FDS.html">DSPLIB Downloads</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p><br />
</p>
<h3><span id="Image_Processing_Library_(IMGLIB)"></span><span class="mw-headline" id="Image_Processing_Library_.28IMGLIB.29">Image Processing Library (IMGLIB)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=73" title="Edit section: Image Processing Library (IMGLIB)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div style="padding-left: 10px; float: left; width: 4in">
<p>IMGLIB is an optimized image/video processing library with kernels in the following functional categories:
</p>
<ul><li>Compression &amp; Decompression</li>
<li>Image Analysis</li>
<li>Image Filtering and Conversion</li></ul>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>IMGLIB Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>IMGLIB
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>imglib_c66x_&lt;version&gt;\
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="CCSv5_Getting_Started_Guide.html">CCS</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>imglib.ae66 (ELF, little-endian)
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>&lt;root_install_dir&gt;\lib\
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>&lt;root_install_dir&gt;\inc\ <br />&lt;root_install_dir&gt;\packages\
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS E2e Forum</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td><a rel="nofollow" class="external text" href="Software_libraries.html">c6x Software Library mediawiki</a>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a rel="nofollow" class="external text" href="http://software-dl.ti.com/sdoemb/sdoemb_public_sw/imglib/latest/index_FDS.html">IMGLIB Downloads</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p><br />
</p>
<h3><span id="Floating_Point_Math_Library_(MATHLIB)"></span><span class="mw-headline" id="Floating_Point_Math_Library_.28MATHLIB.29">Floating Point Math Library (MATHLIB)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=74" title="Edit section: Floating Point Math Library (MATHLIB)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div style="padding-left: 10px; float: left; width: 4in">
<p>MATHLIB contains optimized versions of most commonly used floating point math routines contained in the RTS library. Kernels are offered in two variations:
</p>
<ul><li>Double-precision floating point</li>
<li>Single-precision floating point</li></ul>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>MATHLIB Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>MATHLIB
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>mathlib_c66x_&lt;version&gt;\
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="CCSv5_Getting_Started_Guide.html">CCS</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Big and Little
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>mathlib.a66 (COFF, little-endian) <br />mathlib.a66e (COFF, big-endian) <br />mathlib.ae66 (ELF, little-endian) <br />mathlib.ae66e (ELF, big-endian)
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>&lt;root_install_dir&gt;\lib\
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>&lt;root_install_dir&gt;\inc\ <br />&lt;root_install_dir&gt;\packages\
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS E2e Forum</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td><a rel="nofollow" class="external text" href="Software_libraries.html">c6x Software Library mediawiki</a>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a rel="nofollow" class="external text" href="http://focus.ti.com/docs/toolsw/folders/print/mathlib.html">MATHLIB Downloads</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p><br />
</p>
<h2><span class="mw-headline" id="Demonstration_Software">Demonstration Software</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=75" title="Edit section: Demonstration Software">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The MCSDK consist of demonstration software to illustrate device and software capabilities, benchmarks, and usage.<br />
</p>
<h3><span id="High-Performance_DSP_Utility_Application_(HUA)"></span><span class="mw-headline" id="High-Performance_DSP_Utility_Application_.28HUA.29">High-Performance DSP Utility Application (HUA)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=76" title="Edit section: High-Performance DSP Utility Application (HUA)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>HUA is the MCSDK out-of-box demonstration/utility application which includes a web server and has pages to query information about the platform and software versions, network statistics, network throughput benchmark, board diagnostics, flash read and write, and EEPROM read and write functions. This is a basic utility application which demonstrates basic platform functionality and how to integrate some of the basic software infrastructure (e.g., SYS/BIOS, NDK, Platform Library). The Utility is accessed from a web browser by browsing the platforms IP address (which can be assigned either as a static IP or through DHCP.) Pages available in the utility are Information, Statistics, Benchmarks, Flash, Diagnostics, and EEPROM.
</p><p>See the <a href="MCSDK_HUA_Demonstration_Guide.html" title="MCSDK HUA Demonstration Guide">HUA Demonstration Guide</a> for more information.
</p>
<h3><span class="mw-headline" id="Image_Processing_Demonstration">Image Processing Demonstration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=77" title="Edit section: Image Processing Demonstration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The Image Processing Demonstration illustrates the integration of key components in the MCSDK. The purpose of the demonstration is to provide a multicore software development framework on an evaluation module (EVM).
</p>
<ol><li>Demonstrates the transfer of image data from/to DDR and internal memory. Typically, images are large and need to be stored in external memory.</li>
<li>Operates on different segments of the same image in different DSP cores.</li>
<li>Operates across multiple cores executing different algorithms on the same image data.</li>
<li>Transfers input/output image to external systems (e.g., a PC).</li></ol>
<p>See the <a href="MCSDK_Image_Processing_Demonstration_Guide.html" title="MCSDK Image Processing Demonstration Guide">Image Processing Demo Guide</a> for more information. <br />
</p>
<h3><span class="mw-headline" id="Multicore_Video_Infrastructure_Demonstration">Multicore Video Infrastructure Demonstration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=78" title="Edit section: Multicore Video Infrastructure Demonstration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The multicore video infrastructure demonstration includes a set of demonstration applications targeted to demonstrate the use of MCSDK for real-time multicore video processing applications. The applications include Ethernet packet-to-packet processing of video streams (transcoding, encoding, decoding) for a various common video standards, resolutions, and use cases. There are two demonstrations included:
</p>
<ol><li>Multichannel high-density operation with low resolution</li>
<li>Multicore processing of high resolution video codecs</li></ol>
<p>See the <a href="MCSDK_VIDEO_2.html" title="MCSDK VIDEO 2.0 Demo Guide">MCSDK Video Demonstration Guide</a> for more information.
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The multicore video infrastructure demo is not provided as part of the MCSDK, but is provided as a separate package available <a rel="nofollow" class="external text" href="http://www.ti.com/tool/demovideo-multicore">here</a>.<br />
</p>
<h2><span class="mw-headline" id="Bootloader_and_Boot_Utilities">Bootloader and Boot Utilities</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=79" title="Edit section: Bootloader and Boot Utilities">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The platform package includes POST (Power On Self Test), bootloader software and utilities to write images to the EEPROM, NOR and NAND Flash.<br />
</p>
<h3><span class="mw-headline" id="Boot_Utilities">Boot Utilities</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=80" title="Edit section: Boot Utilities">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Boot Utilities include a set of tools to configure and boot the board. These include:
</p>
<ul><li><b>Intermediate Boot Loader (IBL):</b> Resides on EEPROM that supports customizing configuration for boot modes. See <a rel="nofollow" class="external text" href="http://linux-c6x.org/wiki/index.php/IBL_version_1.0.0.11">IBL user guide</a> for details.</li>
<li>Examples of booting/loading images for NAND, NOR, and Ethernet</li>
<li>Write utilities for NAND, NOR, and EEPROM</li></ul>
<p>The boot utilities are discussed further in the section on Booting and Flash.
</p>
<h2><span id="Multicore_Application_Deployment_(MAD)_Utilities"></span><span class="mw-headline" id="Multicore_Application_Deployment_.28MAD.29_Utilities">Multicore Application Deployment (MAD) Utilities</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=81" title="Edit section: Multicore Application Deployment (MAD) Utilities">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The Multicore Application Deployment (MAD) is a collection of tools allows you to create a bootable image that can support multiple images and multiple cores. The premise behind MAD is to allow you to:
</p>
<ul><li>Deploy multiple applications on multiple cores.</li>
<li>Conserve memory by sharing common code.</li>
<li>Deploy an application dynamically on a core, if needed.</li></ul>
<p>See <a rel="nofollow" class="external text" href="MAD_Utils_User_Guide.html">MAD Utils User Guide</a> for more details.
</p><p>An example of an MCSDK application that uses MAD is the <a href="MCSDK_Image_Processing_Demonstration_Guide.html" title="MCSDK Image Processing Demonstration Guide">Image Processing Demo Guide</a>.
</p><p><br /><br />
</p>
<h2><span class="mw-headline" id="Tools">Tools</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=82" title="Edit section: Tools">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span class="mw-headline" id="cToolsLibrary">cToolsLibrary</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=83" title="Edit section: cToolsLibrary">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div style="padding-left: 10px; width: 4in; float: left">
<p>The cTools library provides APIs for using the individual instrumentation libraries for advanced users and also few use case based libraries that are built on top of the individual instrumentation libraries.
</p><p>As shown in the figure below, the <i>ctoolslib_sdk</i> module provided in the package is intended to provide the glue between the use case based libraries, individual instrumentation libraries and application:
</p>
<div class="thumb tleft"><div class="thumbinner" style="width:352px;"><a href="File_Ctoolslib_uclib_bitmap.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/5/52/Ctoolslib_uclib_bitmap.png" width="350" height="188" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Ctoolslib_uclib_bitmap.html" class="internal" title="Enlarge"></a></div>cToolsLibrary SW architecture</div></div></div>
<p>The <i>ctoolslib_sdk</i> is a collection of libraries for Advanced Event Triggering(AET), Common Platform Tracers(CPT), Ctools use case library(Ctools_UC), DSPTrace, Embedded Trace Buffer(ETB) and System Trace Module(STM) - located under \aet\lib, \CPTLib\lib, \Ctools_UCLib\lib, \DSPTraceLib\lib, \ETBLib\lib and \STMLib\lib
</p>
</div>
<table style="width: 50%" border="5" cellpadding="2">

<tbody><tr>
<td style="background: #e8e8e8" colspan="2" align="center"><b>Ctools Library Package Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Library
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>CtoolsLibrary for C6670, C6678 and C6657
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>ctoolslib_&lt;version&gt; <br />
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="CCSv5_Getting_Started_Guide.html">CCS</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little &amp; Big
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>Select for the C6670, C6678 or C6657 EVM <br />
<p>Please see <i>GettingStarted.htm</i> for details
</p>
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>$(TI_CTOOLSLIB_INSTALL_DIR)\packages\ti\LIBRARY_NAME\lib - for release/debug version, where LIBRARY_NAME = aet, CPTLib, Ctools_UCLib, DSPTraceLib, ETBLib and STMLib.
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>none
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>none
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>$(TI_CTOOLSLIB_INSTALL_DIR)\packages\ti\LIBRARY_NAME\include\*.h<br />
<p>and ti\ctoolslib_sdk\evmc66xx\package.xdc define the interface for c66xx use case library support
</p>
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See doc\*html*\index.html file under respective libraries for details <br />
<p>and <a rel="nofollow" class="external text" href="CToolsLib.html">CtoolsLib</a>
</p>
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td><a rel="nofollow" class="external text" href="http://processors.wiki.ti.com/">Texas Instruments Embedded Processors Wiki</a>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Product Updates</a>
</td></tr>
<tr>
<td><b>License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr></tbody></table>
<p>Portions of cToolsLib is implemented in the Image Processing Demonstration; please refer to the <a rel="nofollow" class="external text" href="MCSDK_Image_Processing_Demonstration_Guide.html">Demonstration Guide</a> for more information. Additionally, please refer to <a rel="nofollow" class="external text" href="CToolsLib.html#Examples">CCSv5 CtoolsLib Examples</a> for more information and to download other supported Ctools library examples. The downloaded Examples.zip should be extracted into [&lt;CTOOLSLIB INSTALL&gt;\packages\ti\] location. All the examples are CCSv5 compatible.
</p>
<h3><span id="Multicore_System_Analyzer_(MCSA)"></span><span class="mw-headline" id="Multicore_System_Analyzer_.28MCSA.29">Multicore System Analyzer (MCSA)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=84" title="Edit section: Multicore System Analyzer (MCSA)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div style="padding-left: 10px; float: left; width: 4in">
<p>Multicore System Analyzer (MCSA) is a suite of tools that provide real-time visibility into the performance and behavior of your code, and allow you to analyze information that is collected from software and hardware instrumentation in a number of different ways.
</p><p>Advanced tooling features of the MCSA include the following:
</p>
<ul><li>Real-time event monitoring</li>
<li>Multicore event correlation</li>
<li>Correlation of software events, hardware events and CPU trace</li>
<li>Real-time profiling and benchmarking</li>
<li>Real-time debugging</li></ul>
<p>The MCSA includes two key components:
</p>
<ul><li>DVT: Various features of Data Analysis and Visualization Technology (DVT) provide the user interface for System Analyzer within Code Composer Studio (CCS).</li>
<li>UIA: The Unified Instrumentation Architecture (UIA) target package defines APIs and transports that allow embedded software to log instrumentation data for use within CCS.</li></ul>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>MCSA Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Libraries
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>UIA + DVT
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>ccsv5/uia_&lt;version&gt;, ccsv5/eclipse, ccsv5/ccs_base_5.0.0.*/dvt\
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>The appropriate libraries are selected for your device and platform as set in the RTSC build properties for your project and based on the use module statements in your configuration.
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>The appropriate path is selected to the libraries for your device and platform as set in the RTSC build properties for your project.
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td><a rel="nofollow" class="external text" href="Multicore_System_Analyzer.html">Multicore System Analyzer</a>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td>Installed as a part of BIOS MCSDK installation
</td></tr>
<tr>
<td><b>UIA License</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.opensource.org/licenses/bsd-license.php">BSD</a>
</td></tr>
<tr>
<td><b>DVT License</b>
</td>
<td>TI Technology and Software Publicly Available (TSPA). See DVT Manifest in the install directory.
</td></tr></tbody></table>
<p><br />
</p>
<h3><span id="Eclipse_RTSC_Tools_(XDC)"></span><span class="mw-headline" id="Eclipse_RTSC_Tools_.28XDC.29">Eclipse RTSC Tools (XDC)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=85" title="Edit section: Eclipse RTSC Tools (XDC)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div style="padding-left: 10px; float: left; width: 4in">
<p>RTSC is a C-based programming model for developing, delivering, and deploying Real-Time Software Components targeted for embedded platforms. The XDCtools product includes tooling and runtime elements for component-based programming using RTSC.
</p>
</div>
<table style="width: 50%" cellpadding="2" border="5">

<tbody><tr>
<td style="background: #e8e8e8" align="center" colspan="2"><b>XDC Summary</b>
</td></tr>
<tr>
<td><b>Component Type</b>
</td>
<td>Tools
</td></tr>
<tr>
<td><b>Install Package</b>
</td>
<td>XDC
</td></tr>
<tr>
<td><b>Install Directory</b>
</td>
<td>xdctools_&lt;version&gt;\
</td></tr>
<tr>
<td><b>Project Type</b>
</td>
<td><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC</a>
</td></tr>
<tr>
<td><b>Endian Support</b>
</td>
<td>Little and Big
</td></tr>
<tr>
<td><b>Library Name</b>
</td>
<td>The appropriate libraries are selected for your device and platform as set in the RTSC build properties for your project and based on the use module statements in your configuration.
</td></tr>
<tr>
<td><b>Linker Path</b>
</td>
<td>The appropriate path is selected to the libraries for your device and platform as set in the RTSC build properties for your project.
</td></tr>
<tr>
<td><b>Linker Sections</b>
</td>
<td>systemHeap
</td></tr>
<tr>
<td><b>Section Preference</b>
</td>
<td>none
</td></tr>
<tr>
<td><b>Include Paths</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>Reference Guides</b>
</td>
<td>See docs under Install Directory
</td></tr>
<tr>
<td><b>Support</b>
</td>
<td><a href="#Technical_Support_and_Product_Updates">Technical Support</a>
</td></tr>
<tr>
<td><b>Additional Resources</b>
</td>
<td>
<p><a rel="nofollow" class="external text" href="http://www.eclipse.org/rtsc/">Eclipse RTSC Home</a> <br /><a rel="nofollow" class="external text" href="http://rtsc.eclipse.org/docs-tip/Main_Page">Users Guide and Reference Manual</a>
</p>
</td></tr>
<tr>
<td><b>Downloads</b>
</td>
<td>N/A
</td></tr>
<tr>
<td><b>License</b>
</td>
<td>See XDC Manifest in the install directory
</td></tr></tbody></table>
<p><br />
</p>
<h1><span class="mw-headline" id="Third_Party_Software_and_Tools">Third Party Software and Tools</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=86" title="Edit section: Third Party Software and Tools">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<h2><span class="mw-headline" id="Prism_from_Criticalblue">Prism from Criticalblue</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=87" title="Edit section: Prism from Criticalblue">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Prism is a multicore analysis tool provided by <a rel="nofollow" class="external text" href="http://www.criticalblue.com/">Critical Blue</a> as an Eclipse plug-in which is intended to allow developers to evaluate parallelization strategies of existing sequential code upfront without implementing any code changes. This is accomplished by the developer taking their existing serial code and running it through a standard simulator (in this case our TI C66x simulator). The results from the simulator are fed into Prism, which displays the execution profile and, more importantly, uses the simulation data to allow the developers to perform what-if analysis without changing a line of code. This includes looking at data parallelization strategies and task parallelization strategies. The obvious motivation is to allow a developer to investigate various parallelization strategies without having to go through the entire process of implementation and debug which can be time consuming and requires significant effort. This enables a kind of ROI assessment for multicore prior to investment in implementation. In the end, this represents at least a good start for someone beginning to look at migration of existing applications to a multicore device.
</p><p>Please see <a rel="nofollow" class="external text" href="http://www.criticalblue.com/prism/ti/">http://www.criticalblue.com/prism/ti/</a> for more detailed information on Prism and to get started.
</p><p>Please see <a rel="nofollow" class="external text" href="MCSDK_Image_Processing_Demonstration_Guide.html#Image_Processing_Demo_Analysis_with_Prism">Image Processing Demo Analysis with Prism</a> for notes on running Prism with the image processing demo application.
</p>
<h2><span class="mw-headline" id="Poly-Platform_from_PolyCore_Software">Poly-Platform from PolyCore Software</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=88" title="Edit section: Poly-Platform from PolyCore Software">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Poly-Platform by <a rel="nofollow" class="external text" href="http://www.polycoresoftware.com/">PolyCore Software</a>, is a development framework, consisting of tools and runtime software, providing a programming model for the application to scale from one to many cores in homogenous and heterogeneous multicore environments. The tools are Eclipse plug-ins and are integrated with CCSv5 for a seamless development environment and, provide rapid development for MCAPI programming and topology configuration. Poly-Messenger, the runtime engine which is integrated with DSP BIOS, transparently handles the communications between cores and between processors across multiple transports. Applications readily move from one core to multicore to many cores using the same source code base.
</p><p>Please see <a rel="nofollow" class="external text" href="http://www.polycoresoftware.com/products.php">http://www.polycoresoftware.com/products.php</a> for more information.
</p><p><br />
</p>
<h1><span class="mw-headline" id="Build_and_Example_Guide">Build and Example Guide</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=89" title="Edit section: Build and Example Guide">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The Build and Example Guide talks about setting up your build environment for MCSDK, how to build the various components, and then walks you through a set of example programs that are designed to teach you how to start writing programs using the software development kit.
</p><p><br />
</p>
<h2><span class="mw-headline" id="Setting_up_the_Build_Environment">Setting up the Build Environment</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=90" title="Edit section: Setting up the Build Environment">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To set up the build environment, you need to complete the following:
</p>
<ul><li>Install Code Composer Studio</li>
<li>Install the MCSDK software</li>
<li>Create a Target Configuration File that allows communication with the EVM over JTAG</li></ul>
<p>The <a rel="nofollow" class="external text" href="BIOS_MCSDK_2.html">Getting Started Guide</a> talks about how to do this.
</p><p>Once CCS and MCSDK are installed, they provide both Debug and Release versions of the demonstrations, examples and components. In addition, many of the components provide pre-built big endian versions as well. To rebuild the demos and examples and components that do not provide pre-built Big Endian, see the section on re-building for Big Endian in this guide.
</p><p><br />
</p>
<h2><span class="mw-headline" id="Building_the_Software">Building the Software</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=91" title="Edit section: Building the Software">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><br />
</p>
<h3><span class="mw-headline" id="Build_in_Place_vs._Build_in_Workspace">Build in Place vs. Build in Workspace</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=92" title="Edit section: Build in Place vs. Build in Workspace">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The MCSDK uses a "Build in Place" philosophy. This means projects should not be import into the workspace. You can, but if you do, the projects may not re-build automatically and you may need to edit paths and other project settings to get them to build.
</p><p>Note: It can be challenging to write a project that supports both build in place and build in workspace when the project is fairly rich and uses common source files (shared with other projects), etc.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Modifying_a_Library">Modifying a Library</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=93" title="Edit section: Modifying a Library">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>If you want to modify and rebuild a library, it is best not to copy it into your workspace. We suggest building it "in place". When you build in place, you do not need to change build macros and so forth. You also not have to edit the example projects as they already have the correct paths to the library.</li></ul>
<ul><li>If you want to experiment with a library routine, debug it or try some new functionality, add the file to your project and use it there. Once you are done with it, if it is a change you need to add, then you can rebuild it in the library.</li></ul>
<ul><li>You may want to make a backup copy of any library before you begin modifying it. This will allow you to get to the original more easily should you need to do so.</li></ul>
<p><br />
</p>
<h3><span class="mw-headline" id="Platform_Library_2">Platform Library</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=94" title="Edit section: Platform Library">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>We will be building library in place which will allow other dependent application to pick up the library from usual place.
</p><p>The following procedure assumes the MCSDK is installed in <i>C:\Program Files\Texas Instruments</i>.
</p>
<ul><li>Open CCS (preferably with a new workspace)</li>
<li>Goto <i>Project-&gt;Import Existing CCS/CCE Eclipse project</i></li>
<li>In the <i>Select search-directory:</i> enter <i>C:\Program Files\Texas Instruments\pdk_C667##_#_#_#_##\packages\ti\platform\evmc667#l\platform_lib</i> and hit <i>Browse</i>. See <a href="File_Importplatformlibproject.html" title="File:Importplatformlibproject.jpg">Import Project Settings</a>. This will import platform_lib_evmc667## into the workspace.</li></ul>
<div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="File_Importplatformlibproject.html" class="image"><img alt="Importplatformlibproject.jpg" src="https://processors.wiki.ti.com/images/1/10/Importplatformlibproject.jpg" width="200" height="128" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Importplatformlibproject.html" class="internal" title="Enlarge"></a></div></div></div></div>
<ul><li>Make sure the <i>Copy projects into workspace</i> is not checked. Then hit <i>Finish</i>.</li>
<li>Import the platform library project under interest to CCS. For example, for building C6678 platform library import the project <i>platform_lib_evmc6678l</i> into the CCS.</li>
<li>Now <i>Project-&gt;Rebuild All</i> should rebuild the project and library is created in <i>C:\Program Files\Texas Instruments\pdk_C66##_#_#_#_##\packages\ti\platform\evmc667#l\platform_lib\lib</i> for a selected profile. <a href="File_Setprofileplatformlibproject.html" title="File:Setprofileplatformlibproject.jpg">Setting Profile for Project Settings</a>. This will set the desired profile for platform_lib_evmc667## into the workspace.</li></ul>
<div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="File_Setprofileplatformlibproject.html" class="image"><img alt="Setprofileplatformlibproject.jpg" src="https://processors.wiki.ti.com/images/9/94/Setprofileplatformlibproject.jpg" width="200" height="177" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Setprofileplatformlibproject.html" class="internal" title="Enlarge"></a></div></div></div></div>
<p><br />
</p>
<table border="1" cellpadding="5" cellspacing="0" align="center">

<tbody><tr>
<td bgcolor="#c0c0c0"><b>Profile</b>
</td>
<td bgcolor="#c0c0c0"><b>Little endian Library name</b>
</td>
<td bgcolor="#c0c0c0"><b>Big Endian Library Name</b>
</td>
<td bgcolor="#c0c0c0"><b>Comment</b>
</td></tr>
<tr>
<td>Debug
</td>
<td>/lib/debug/ti.platform.evm6678l.ae66
</td>
<td>/lib/debug/ti.platform.evm6678l.ae66e
</td>
<td>Full Symbol Debug Platform library
</td></tr>
<tr>
<td>Release
</td>
<td>/lib/release/ti.platform.evm6678l.ae66
</td>
<td>/lib/release/ti.platform.evm6678l.ae66e
</td>
<td>Optimized Full Platform library
</td></tr>
<tr>
<td>Lite
</td>
<td>/lib/debug/ti.platform.evm6678l.lite.lib
</td>
<td>lib/debug/ti.platform.evm6678l.lite.libe
</td>
<td>Platform library intended only for Power On Self Test (POST) executable
</td></tr></tbody></table>
<p><br />
</p><p>See <i>platform_library_user_guide</i> located under <i>C:\Program Files\Texas Instruments\pdk_C667#_#_#_#_##\packages\ti\platform\docs\platform</i> for more information on platform APIs.
</p><p><b>Note</b>: The library name provided above is provided as an example for the C6678 platform. Similar naming conventions for the library can be applied for the C6657 and C6670 platforms.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Building_CSL_and_the_Low_Level_Device_Drivers">Building CSL and the Low Level Device Drivers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=95" title="Edit section: Building CSL and the Low Level Device Drivers">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Follow the instructions below to build CSL and LLDs.
</p>
<ul><li>Open a command window inside of the $(TI_PDK_C66##_INSTALL_DIR)\packages directory.</li>
<li>Set the environment by running the batch file and follow the instructions as per the batch file output.</li></ul>
<p>&lt;syntaxhighlight lang="dos"&gt;
.\ti\drv\pdksetupenv.bat
&lt;/syntaxhighlight&gt;
</p>
<ul><li>After configuring the environment successfully, the following message appears.</li></ul>
<p>&lt;syntaxhighlight lang="text"&gt;
</p>
<ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li class="mw-empty-elt"></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
<p>...
...
...
PDK BUILD ENVIRONMENT CONFIGURED
</p>
<ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li><ul><li class="mw-empty-elt"></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul>
<p>&lt;/syntaxhighlight&gt;
</p>
<ul><li>To build the drivers run the below batch file.</li></ul>
<p>&lt;syntaxhighlight lang="dos"&gt;
.\ti\drv\pdkbuilder.bat
&lt;/syntaxhighlight&gt;
</p>
<h4><span class="mw-headline" id="Building_the_Device_Drivers_Example_Projects">Building the Device Drivers Example Projects</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=96" title="Edit section: Building the Device Drivers Example Projects">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The device drivers have example projects which can be verified after they are built with CCSv5. Follow the steps below to build the CCS projects for the example projects.
</p>
<ul><li>Check Prerequisites</li></ul>
<p>Ensure that all dependent/pre-requisite packages are installed before proceeding with the examples and/or unit test.
</p>
<ul><li>Configure CCS Environment</li></ul>
<p>The CCS environment configuration step needs to be done only once for a workspace as these settings are saved in the workspace preferences. These settings only need to be modified if:<br />
</p>
<ul><li><ul><li>New workspace is selected</li>
<li>Newer version of the component is being used. In that case, modify the paths of the upgraded component to the newer directory.</li></ul></li></ul>
<p>The procedure mentioned in this section is provided using &lt;Managed Build Macro&gt; option in CCS. The steps are as follows:
</p>
<ul><li>Create a macro file if not available from the PDK release. For the PDK release file: &lt;PDK_INSTALL_DIR&gt;\packages\ti\drv\macros.ini can be used, where &lt;PDK_INSTALL_DIR&gt; refers to the location where PDK is installed.</li></ul>
<p>The following environment would need to be available in the macros.ini file &lt;syntaxhighlight lang="bash"&gt;
PDK_INSTALL_PATH  = &lt;PDK_INSTALL_DIR&gt;\packages
CSL_INSTALL_PATH  = &lt;PDK_INSTALL_DIR&gt;\packages
CPPI_INSTALL_PATH = &lt;PDK_INSTALL_DIR&gt;\packages
QMSS_INSTALL_PATH = &lt;PDK_INSTALL_DIR&gt;\packages
PASS_INSTALL_PATH = &lt;PDK_INSTALL_DIR&gt;\packages
SA_INSTALL_PATH   = &lt;PDK_INSTALL_DIR&gt;\packages
MAS_INSTALL_PATH  = &lt;PDK_INSTALL_DIR&gt;\packages
SRIO_INSTALL_PATH = &lt;PDK_INSTALL_DIR&gt;\packages
&lt;/syntaxhighlight&gt;
</p>
<ul><li>Import macros.ini located under \pdk_C####_1_0_0_XX\packages\ti\drv
<ul><li>This can be done as Click on CCS File menu option-&gt;Import-&gt;CCS-&gt;Managed Build Macros</li>
<li>Click on Next and Browse to open the macros.ini located in the above mentioned path</li>
<li>Click Finish</li></ul></li>
<li>Import the desired example project and build it under CCS to continue the test.</li></ul>
<p><br />
</p>
<h3><span class="mw-headline" id="Compiling_Big_Endian_MCSDK_Demos_and_Examples">Compiling Big Endian MCSDK Demos and Examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=97" title="Edit section: Compiling Big Endian MCSDK Demos and Examples">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The pre-compiled platform libraries, NIMU drivers, NDK examples, and HUA demos provided in the package are Little Endian only. If Big Endian binaries are needed, they need to be rebuilt by changing the CCS build options. This section covers how to build and run the NDK Network Client example, NDK Network HelloWorld example, and HUA demo in Big Endian.
</p><p><br />
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The following images describing the steps to build the Big Endian libraries portray c6678l projects. The same instructions can be used for c6670l projects.
</p><p><br />
</p><p><span style="position: relative; top: -2px;"><img alt="Warning" src="https://processors.wiki.ti.com/images/c/cb/Warning.png" title="Warning" width="18" height="15" /></span> <b>Warning</b>:  Make sure to execute the EVM initialization GEL on the core the examples will be run on. The GEL's Global_Default_Setup function should be executed prior to loading and running any of the clients and examples. The GEL can be found under "CCSv5 installation path"\ccsv5\ccs_base_w.x.y.zzzzz\emulation\boards\evmc66xxl\gel\evmc66xxl.gel.
</p><p><br />
</p><p><b>Recompile Big Endian NDK NIMU Driver</b>
</p>
<ul><li>The NIMU driver is required for all NDK examples and the HUA demo. This must be recompiled in Big Endian prior to recompiling any example or demo in Big Endian.</li></ul>
<dl><dd><dl><dd>1. <b>Open the CCSv5 Project Import Wizard:</b> In CCSv5, click on File -&gt; Import... to open the Project Import Wizard. Subsequently, select "Existing CCS/CCE Eclipse Projects" and click on the "Next" button as shown:</dd></dl></dd></dl>
<dl><dd><dl><dd><a href="File_Import_Project.html" class="image" title="Import Project.JPG"><img alt="Import Project.JPG" src="https://processors.wiki.ti.com/images/1/17/Import_Project.JPG" width="600" height="507" /></a></dd></dl></dd></dl>
<p><br />
</p>
<dl><dd><dl><dd>2. <b>Select and Import the NIMU Project:</b> Click the browse button to open a directory browser. Navigate to the PDK transport directory and select the NIMU transport project. Click "Finish" to import the nimu_eth_evmc66xxl project into CCS.</dd></dl></dd></dl>
<dl><dd><dl><dd><a href="File_Import_NIMU.html" class="image" title="Import NIMU.JPG"><img alt="Import NIMU.JPG" src="https://processors.wiki.ti.com/images/1/1c/Import_NIMU.JPG" width="400" height="468" /></a></dd></dl></dd></dl>
<p><br />
</p>
<dl><dd><dl><dd>3. <b>Change the NIMU project active build configuration to Big Endian (Debug or Release):</b> In the C/C++ Projects window, right-click on the nimu_eth_evmc66xxl RTSC project folder, click on Build Configurations -&gt; Set Active -&gt; Debug_BE (or Release_BE for release).</dd></dl></dd></dl>
<dl><dd><dl><dd><a href="File_NIMU_debug_be_set_active.html" class="image" title="NIMU debug be set active.JPG"><img alt="NIMU debug be set active.JPG" src="https://processors.wiki.ti.com/images/1/18/NIMU_debug_be_set_active.JPG" width="600" height="598" /></a></dd></dl></dd></dl>
<p><br />
</p>
<dl><dd><dl><dd>4. <b>Clean and Build the NIMU driver:</b> The NIMU driver will be rebuilt in Big Endian format and can now be linked by rebuilt Big Endian NDK examples and the HUA demo.</dd></dl></dd></dl>
<p><br />
</p><p><b>Recompile Big Endian Platform Library</b>
</p>
<dl><dd><dl><dd>5. <b>Import the Platform library project:</b> Repeat steps 1. and 2. from above to import the platform_lib_evmc66xxl project. This project should be located within the PDK installation directory, under ti\platform\evmc66xxl\platform_lib.</dd></dl></dd></dl>
<dl><dd><dl><dd>6. <b>Change the Platform project active build configuration to Big Endian (Debug or Release):</b> Repeat step 3. from above to set the big endian build configuration.</dd></dl></dd></dl>
<dl><dd><dl><dd>7. <b>Clean and Build the Platform library:</b> The Platform library will be rebuilt in Big Endian format and can now be linked by rebuilt Big Endian NDK examples and the HUA demo.</dd></dl></dd></dl>
<p><br />
</p><p><b>Recompile Big Endian NDK Client Example</b>
</p>
<dl><dd><dl><dd>8. <b>Import the NDK Client example project:</b> Repeat steps 1. and 2. from above to import the client_evmc66xxl project. This project should be located within the MCSDK installation directory, under examples\ndk\client\evmc66xxl.</dd></dl></dd></dl>
<dl><dd><dl><dd>9. <b>Reconfigure the Client example for Big Endian:</b> With the client_evmc66xxl project selected, click on Project -&gt; Properties and then select the "CCS Build" pane. In the "General" tab set "Device Endianness" to "big". Click "Apply".</dd></dl></dd></dl>
<dl><dd><dl><dd><a href="File_Client_big_endian.html" class="image" title="Client big endian.JPG"><img alt="Client big endian.JPG" src="https://processors.wiki.ti.com/images/a/af/Client_big_endian.JPG" width="800" height="444" /></a></dd></dl></dd></dl>
<p><br />
</p>
<dl><dd><dl><dd>In addition, click on the "RTSC" tab and configure the following and click "Apply" when finished:
<dl><dd><dl><dd><b>RTSC Target:</b> ti.targets.elf.C66_big_endian</dd>
<dd><b>RTSC Platform:</b> ti.platforms.evm66xx</dd></dl></dd></dl></dd></dl></dd></dl>
<dl><dd><dl><dd><a href="File_Client_big_endian_RTSC.html" class="image" title="Client big endian RTSC.JPG"><img alt="Client big endian RTSC.JPG" src="https://processors.wiki.ti.com/images/b/b3/Client_big_endian_RTSC.JPG" width="800" height="652" /></a></dd></dl></dd></dl>
<p><br />
</p>
<dl><dd><dl><dd>10. <b>Clean and build the Client example:</b> Clean and rebuild the Client example project from the project context menu.</dd></dl></dd></dl>
<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  When the client example is executed the IP address negotiated with DHCP will be displayed backwards. As shown below the IP address reported is 148.112.218.10. The correct IP address is 10.218.112.148.
</p>
<dl><dd><dl><dd><a href="File_Client_running.html" class="image" title="Client running.JPG"><img alt="Client running.JPG" src="https://processors.wiki.ti.com/images/f/fb/Client_running.JPG" width="700" height="618" /></a></dd></dl></dd></dl>
<p><br />
</p><p><b>Recompile Big Endian NDK HelloWorld Example and HUA Demo</b>
</p>
<dl><dd><dl><dd>11. <b>Reconfigure NDK HelloWorld Example and HUA Demo as Big Endian and rebuild:</b> Follow step 8. through 10. to rebuild the NDK HelloWorld Example and HUA Demo in Big Endian.</dd></dl></dd></dl>
<p><br />
</p>
<h3><span class="mw-headline" id="Building_and_running_NDK_client_example_with_simulator">Building and running NDK client example with simulator</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=98" title="Edit section: Building and running NDK client example with simulator">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<dl><dt>Setup RGMII/EMAC Adaptor in the CCS EMAC simulator</dt></dl>
<ul><li>Open the target Configuration file located under CCS simulation directory (simulation_csp_ny). For example, if CCSv5 is installed to its default directory, i.e., C:\Program Files\Texas Instruments\ccsv5, then the configuration file can be found at C:\Program Files\Texas Instruments\ccsv5\ccs_base_5.x.x.xxxxxx\simulation_csp_ny\bin\configurations with name tisim_c####_pv.cfg</li>
<li>Pick a NIC on the PC running simulation that you'd like to use to run the example. This will be the interface using which the packets will be sent/received by the example.</li>
<li>Under "EMAC_ADAPTOR" section look for USER_INPUTS sub-section, locate the following line of code,</li></ul>
<p><br />
</p>
<pre>INPUT2	ADAPTOR, OFF;
</pre>
<p>Modify the above line of code to:
</p>
<pre>INPUT2	ADAPTOR, ON;
</pre>
<p>This will turn on the EMAC adapter in simulator so as to send/receive packets.
</p><p><br />
</p>
<ul><li>Under the same section, locate and modify the following line of code as follows:</li></ul>
<pre>INPUT4  NETWORK_ADAPTOR, Broadcom;
</pre>
<p>Modify the above line of code to include the name of the NIC card you are using, for example if the interface you are using for the test on your PC is a "Realtek" card, modify the above line to:
</p>
<pre>INPUT4  NETWORK_ADAPTOR, Realtek;
</pre>
<ul><li>If the following lines are uncommented, please comment them:</li></ul>
<pre>CONNECT11       System.C66XX_S.SHARED_SYSTEM.SWITCHSS.switchss_sgmii0_tx_data_gen_opin, System.C66XX_S.SHARED_SYSTEM.SWITCHSS.switchss_sgmii1_rx_data_gen_ipin;
CONNECT12       System.C66XX_S.SHARED_SYSTEM.SWITCHSS.switchss_sgmii0_rx_data_gen_ipin, System.C66XX_S.SHARED_SYSTEM.SWITCHSS.switchss_sgmii1_tx_data_gen_opin;
</pre>
<p><br />
as follows:
</p>
<pre>//CONNECT11       System.C66XX_S.SHARED_SYSTEM.SWITCHSS.switchss_sgmii0_tx_data_gen_opin, System.C66XX_S.SHARED_SYSTEM.SWITCHSS.switchss_sgmii1_rx_data_gen_ipin;
//CONNECT12       System.C66XX_S.SHARED_SYSTEM.SWITCHSS.switchss_sgmii0_rx_data_gen_ipin, System.C66XX_S.SHARED_SYSTEM.SWITCHSS.switchss_sgmii1_tx_data_gen_opin;
</pre>
<p><br />
This disables loopback at EMAC adapter level (PHY simulation) in the simulator.
</p>
<ul><li>Finally, configure the switch MAC configured in the example, i.e., 0x10-0x11-0x12-0x13-0x14-0x15 on the EMAC adaptor so that the simulator can pass all packets matching the switch MAC up to the application.</li></ul>
<p>example:
</p>
<pre> INPUT5  MAC_ADDRESS_PORT0, 10-11-12-13-14-15;   // configure the Port0 MAC to be the switch MAC
INPUT6  MAC_ADDRESS_PORT1, 00-01-02-03-04-05;
</pre>
<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Note: For details see C:\Program Files\Texas Instruments\ccsv5\ccs_base_5.x.x.xxxxxx\simulation_csp_ny\docs\pdf\TCI6616-C6670-TCI6608-C6678_Device_Simulator_EMAC_Model_IO_user_guide.pdf
</p>
<dl><dt>Re-compile NIMU library with simulator support</dt></dl>
<ul><li>Start CCS and import project from C:\Program Files\Texas Instruments\pdk_C66##_#_#_#_##\packages\ti\transport\ndk\nimu directory</li>
<li>Open Project-&gt;Properties-&gt;C/C++ Build-&gt;Settings-&gt;Predefined symbols, add variable <i>SIMULATOR_SUPPORT</i>, OK to close the project</li>
<li>Re-compile the project Project-&gt;Clean, Project-&gt;Compile</li></ul>
<dl><dt>Update NDK client example and run it on simulator</dt></dl>
<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b> The PC running simulator needs to be set with static IP address <i>192.168.2.101</i> for this example program, see figure for <a href="File_Wirednwconnection.html" title="File:Wirednwconnection.png">Static IP Setup</a>
</p>
<ul><li>Import project from C:\Program Files\Texas Instruments\mcsdk_#_##_##_##\examples\ndk\client\evmC####</li></ul>
<ul><li>Open client.cfg file in CCS text editor from the project client_evm####l and change the line</li></ul>
<p>from &lt;syntaxhighlight lang="javascript"&gt;
var PlatformLib  = xdc.loadPackage('ti.platform.evmc####l');
&lt;/syntaxhighlight&gt; to &lt;syntaxhighlight lang="javascript"&gt;
var PlatformLib  = xdc.loadPackage('ti.platform.simc####');
&lt;/syntaxhighlight&gt;
</p>
<ul><li>Open file client.c, then change clientMACAddress string to match your PC mac address, make sure the format needs to be as follows</li></ul>
<p>&lt;syntaxhighlight lang="c"&gt;
Uint8 clientMACAddress [6] = {0x00,0x18,0x8B,0x10,0x17,0xBF};
&lt;/syntaxhighlight&gt;
</p>
<ul><li>Re-compile the project Project-&gt;Clean, Project-&gt;Build</li></ul>
<ul><li>Load functional simulator target on CCS</li></ul>
<ul><li>Load the client image created above on the simulator and hit run to run the application</li></ul>
<h3><span class="mw-headline" id="Building_NDK">Building NDK</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=99" title="Edit section: Building NDK">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The following instructions how how to re-build the NDK libraries and enable debug versions if you need them.
</p><p><br />
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The NDK build re-builds everything in the library and its quite large so re-building may take some time on slower machines.
</p><p><br />
</p>
<ul><li>Before you start building its a good idea to make a backup copy of the library.</li></ul>
<ul><li>Open a Windows cmd window (dos box) in your NDK install directory. You can do this by selecting the NDK top directory and then right clicking and selecting run cmd here (in windows XP).</li></ul>
<p><a href="File_Ndkdosbox.html" class="image" title="ndkdosbox.jpg"><img alt="ndkdosbox.jpg" src="https://processors.wiki.ti.com/images/3/33/Ndkdosbox.jpg" width="500" height="156" /></a>
</p>
<ul><li>Change directory to packages\ti\ndk</li></ul>
<p><a href="File_Ndkdosboxbuild.html" class="image" title="Ndkdosboxbuild.jpg"><img alt="Ndkdosboxbuild.jpg" src="https://processors.wiki.ti.com/images/1/12/Ndkdosboxbuild.jpg" width="500" height="169" /></a>
</p>
<ul><li>You will see a file called config.bld.default. You will need to edit this file.</li></ul>
<ul><li>Make a *copy* of the file and call it config.bld.</li></ul>
<ul><li>You will need to edit some settings in config.bld as discussed below. Note: These are the paths I am using. Yours may be different depending on where you installed CCS and/or MCSDK.</li></ul>
<p>&lt;syntaxhighlight lang="text"&gt;
</p><p>Change the BIOS 6  path to where you have BIOS installed:
var bios6path = "C:/Program Files/Texas Instruments/bios_6_32_01_38/packages";
</p><p>Change the location for the Code Generation tools:
var rootDir = "C:/Program\ Files/Texas\ Instruments/ccsv5/tools/compiler/c6000"
</p><p>You can remove the ARM path if you are not building NDK for ARM or did not
install ARM support. If you need ARM libraries built then make sure  this has
the right path:
var rootDirArm = "C:/Program\ Files/Texas\ Instruments/ccsv4/tools/compiler/tms470"
</p><p>Remove tragets you do not need built. You should see our C66 targets. The others
for ARM or C64 can removed if you do not need to build for them.
Build.targets =	[
</p>
<pre>   elfTargets.C66,
   elfTargets.C66_big_endian,
</pre>
<p>];
</p><p>Compile for Debug if you need debug by Changing the compiler options line
C6xSuffix and adding a -g to it as below.
var c6xSuffix = "-mi10 -mo -pdr -pden -pds=238 -pds=880 -pds1110 -g ";
</p><p>&lt;/syntaxhighlight&gt;
</p>
<ul><li>Save the file with your changes.</li></ul>
<ul><li>Type xdc at the command line to build. Note that the xdc command must be run in the same directory as the config.bld.</li></ul>
<p><a href="File_Ndkdosboxbuilding.html" class="image" title="ndkdosboxbuilding.jpg"><img alt="ndkdosboxbuilding.jpg" src="https://processors.wiki.ti.com/images/8/82/Ndkdosboxbuilding.jpg" width="500" height="169" /></a>
</p><p><br />
</p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=100" title="Edit section: Examples">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The example programs are designed to take you from writing a simple "hello world" type program to progressively more complicated applications. At each step, various methodologies and ways of working with the MCSDK are introduced. It is highly recommended that you do them.
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b> The following examples assume you installed MCSDK in <i>C:\Program Files\Texas Instruments</i>. If you did not, then you will need to alter the paths used in this example to the location of where you installed it.
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The example programs make use of components contained in the PDK so you will need to specify the processor number and substitute it into the various paths and names as needed. As shown below, the #### refers to processor type (6678 for TMS320C6678 OR TMS320TCI6608; 6670 for TMS320C6670 OR TMS320TCI6618; 6657 for TMS320C6657) and the xx refers to a version number.
</p><p>For example, a typical path might be:
</p>
<pre>"C:\Program Files\Texas Instruments\pdk_C####_1_0_0_xx\packages"
</pre>
<p>To specify that for the 6670 on the 2.0.0.11 release you would do:
</p>
<pre>"C:\Program Files\Texas Instruments\pdk_C6670_1_0_0_11\packages"
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Example_1_-_Building_and_running_a_simple_single_core_application">Example 1 - Building and running a simple single core application</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=101" title="Edit section: Example 1 - Building and running a simple single core application">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This is the first example program. It's purpose is to get you used to creating projects in CCS, building an executable and then running it on your EVM. The application executes out of shared memory on the EVM and does not use the external DDR.
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Please note that the simple platform library application code is assuming that everything is running from shared memory (MSMCRAM) - so no GEL file is needed. It is preferred to run the respective CCS GEL file for that platform before loading and running any application.
</p><p>1. The first step is to create a project in CCS for this example. To do so follow the steps below.
</p>
<ul><li>Open CCS (preferably with a new workspace).</li>
<li>Open <i>File-&gt;New-&gt;CCS Project</i> and in the project name field enter <i>led_play", then hit </i>Next<i>.</i></li>
<li>In the CCS project window, select <i>Project Type</i>: as <i>C6000</i> and hit <i>Next</i> and hit <i>Next</i> again to skip the next page for <i>Additional Project Settings</i>.</li>
<li>In the <i>New CCS Project</i>, select <i>Device Variant</i>: as <i>Generic C66xx Device</i> and hit <i>Next</i>. See <a href="File_Projectsettingshelloworld.html" title="File:Projectsettingshelloworld.jpg">Project Settings</a>.</li></ul>
<div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="File_Projectsettingshelloworld.html" class="image"><img alt="Projectsettingshelloworld.jpg" src="https://processors.wiki.ti.com/images/f/f8/Projectsettingshelloworld.jpg" width="200" height="154" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Projectsettingshelloworld.html" class="internal" title="Enlarge"></a></div></div></div></div>
<ul><li>In the <i>Project Templets</i> window select <i>Empty Project</i> and hit <i>Next</i>.</li>
<li>It should open an empty project with name <i>led_play</i>.</li></ul>
<p><br /> 2. Now that we have a project, we are going to create a source file that will use the MCSDK Platform Library to a.) initialize our EVM at start-up, b.) write a simple string to the UART (console port) and c.) will blink the EVM LED's.
</p>
<ul><li>Select <i>File-&gt;New-&gt;Source File</i>, enter <i>Source File</i> name as <i>led_play.c</i>, then hit <i>Finish</i>.</li>
<li>It should open <i>led_play.c</i> empty file in the eclipse editor. Paste following source code in the editor</li></ul>
<p>&lt;syntaxhighlight lang="c"&gt;
</p>
<ol><li>include &lt;cerrno&gt;</li>
<li>include &lt;stdio.h&gt;</li>
<li>include &lt;stdlib.h&gt;</li>
<li>include &lt;string.h&gt;</li>
<li>include "ti\platform\platform.h"</li>
<li>include "ti\platform\resource_mgr.h"</li></ol>
<p>/* OSAL functions for Platform Library */
uint8_t *Osal_platformMalloc (uint32_t num_bytes, uint32_t alignment)
{
</p>
<pre>   return malloc(num_bytes);
</pre>
<p>}
</p><p>void Osal_platformFree (uint8_t *dataPtr, uint32_t num_bytes)
{
</p>
<pre>   /* Free up the memory */
   if (dataPtr)
   {
       free(dataPtr);
   }
</pre>
<p>}
</p><p>void Osal_platformSpiCsEnter(void)
{
</p>
<pre>   /* Get the hardware semaphore.
    *
    * Acquire Multi core CPPI synchronization lock
    */
   while ((CSL_semAcquireDirect (PLATFORM_SPI_HW_SEM)) == 0);
</pre>
<pre>   return;
</pre>
<p>}
</p><p>void Osal_platformSpiCsExit (void)
{
</p>
<pre>   /* Release the hardware semaphore
    *
    * Release multi-core lock.
    */
   CSL_semReleaseSemaphore (PLATFORM_SPI_HW_SEM);
</pre>
<pre>   return;
</pre>
<p>}
</p><p>void main(void) {
</p>
<pre>   platform_init_flags init_flags;
   platform_init_config init_config;
   platform_info p_info;
   uint32_t led_no = 0;
   char message[] = "\r\nHello World.....\r\n";
   uint32_t length = strlen((char *)message);
   uint32_t i;
</pre>
<pre>   /* Initialize platform with default values */
   memset(&amp;init_flags, 0x01, sizeof(platform_init_flags));
   memset(&amp;init_config, 0, sizeof(platform_init_config));
   if (platform_init(&amp;init_flags, &amp;init_config)&#160;!= Platform_EOK) {
       return;
   }
</pre>
<pre>   platform_uart_init();
   platform_uart_set_baudrate(115200);
</pre>
<pre>   platform_get_info(&amp;p_info);
</pre>
<pre>   /* Write to the UART */
   for (i = 0; i &lt; length; i++) {
       if (platform_uart_write(message[i])&#160;!= Platform_EOK) {
           return;
       }
   }
</pre>
<pre>   /* Play forever */
   while(1) {
       platform_led(led_no, PLATFORM_LED_ON, PLATFORM_USER_LED_CLASS);
       platform_delay(30000);
       platform_led(led_no, PLATFORM_LED_OFF, PLATFORM_USER_LED_CLASS);
       led_no = (++led_no)&#160;% p_info.led[PLATFORM_USER_LED_CLASS].count;
   }
</pre>
<p>}
</p><p>&lt;/syntaxhighlight&gt;
</p><p>3. Our project now needs a linker command script. The linker command script defines the memory map for the platform (where internal, shared and external memory start, etc.) and where we want our code and data sections to be placed. We are going to put them in the shared memory region on the processor.
</p>
<ul><li>Select <i>File-&gt;New-&gt;File from Template</i>, enter <i>File Name</i> as <i>led_play.cmd</i> and hit <i>Finish</i>.</li>
<li>It would open <i>led_play.cmd</i> file in the editor, paste following linker command file in the editor</li></ul>
<p>&lt;syntaxhighlight lang="asm"&gt;
-c
-heap  0x41000
-stack 0xa000
</p><p>/* Memory Map */
MEMORY
{
</p>
<pre>   L1PSRAM (RWX) &#160;: org = 0x0E00000, len = 0x7FFF
   L1DSRAM (RWX) &#160;: org = 0x0F00000, len = 0x7FFF
   L2SRAM (RWX)  &#160;: org = 0x0800000, len = 0x080000
   MSMCSRAM (RWX)&#160;: org = 0xc000000, len = 0x200000
   DDR3 (RWX)    &#160;: org = 0x80000000,len = 0x10000000
</pre>
<p>}
</p><p>SECTIONS
{
</p>
<pre>   .csl_vect    &gt;       MSMCSRAM
   .text        &gt;       MSMCSRAM
   GROUP (NEAR_DP)
   {
       .neardata
       .rodata
       .bss
   } load       &gt;      MSMCSRAM
   .stack       &gt;      MSMCSRAM
   .cinit       &gt;      MSMCSRAM
   .cio         &gt;      MSMCSRAM
   .const       &gt;      MSMCSRAM
   .data        &gt;      MSMCSRAM
   .switch      &gt;      MSMCSRAM
   .sysmem      &gt;      MSMCSRAM
   .far         &gt;      MSMCSRAM
   .testMem     &gt;      MSMCSRAM
   .fardata     &gt;      MSMCSRAM
   platform_lib &gt; 	MSMCSRAM
</pre>
<p>}
</p><p>&lt;/syntaxhighlight&gt;
</p><p>4. Were almost done. We have some code to execute and a memory map. Now we need to build the executable we will load and run. Before we build though, we will need to define a few include paths and specify the library for the Platform Library.
</p>
<ul><li>Select <i>Project-&gt;Properties</i>, it should open Properties window for led_play project, select <i>C/C++ Build</i> from the left pane.</li>
<li>Select <i>Settings</i> in the left pane after opening the <i>C/C++ Build</i> sub menu.</li>
<li>In the <i>Tool Settings</i> tab, select <i>Include Options</i>, add following items in the <i>Add dir to #include search path...</i></li></ul>
<p>&lt;syntaxhighlight lang="text"&gt;
"C:\Program Files\Texas Instruments\pdk_C####_1_0_0_xx\packages"
&lt;/syntaxhighlight&gt;
</p><p>See <a href="File_Includepathhelloworld.html" title="File:Includepathhelloworld.jpg">Include Path</a>
</p>
<div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="File_Includepathhelloworld.html" class="image"><img alt="Includepathhelloworld.jpg" src="https://processors.wiki.ti.com/images/e/e2/Includepathhelloworld.jpg" width="200" height="154" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Includepathhelloworld.html" class="internal" title="Enlarge"></a></div></div></div></div>
<ul><li>Select <i>File Search Path</i> from <i>C6000 Linker</i> section. Add following items in <i>Include library...</i> section</li></ul>
<p>&lt;syntaxhighlight lang="text"&gt;
ti.platform.evm####l.ae66
&lt;/syntaxhighlight&gt; <img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Please note that the above library is the little endian debug version library of the platform library. This is needed for the application built for Little Endian. Please refer to the above table for including the appropriate library for the particular platform library application.
</p><p>And add following items in <i>Add &lt;dir&gt; to library...</i> section
</p><p>&lt;syntaxhighlight lang="text"&gt;
"C:\Program Files\Texas Instruments\pdk_C####_1_0_0_xx\packages\ti\platform\evmc####l\platform_lib\lib\debug"
&lt;/syntaxhighlight&gt;
</p><p>
See <a href="File_Linkerinputhelloworld.html" title="File:Linkerinputhelloworld.jpg">Linker Input</a>. </p><div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="File_Linkerinputhelloworld.html" class="image"><img alt="Linkerinputhelloworld.jpg" src="https://processors.wiki.ti.com/images/0/00/Linkerinputhelloworld.jpg" width="200" height="153" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Linkerinputhelloworld.html" class="internal" title="Enlarge"></a></div></div></div></div>
<ul><li>Select <i>OK</i> to close the properties dialog box.</li>
<li>Select <i>Project-&gt;Build Project</i> to build the project.</li></ul>
<p>5. We should have an executable. Likely it was built as Debug since that is the default option to build unless it was changed. You can now follow the steps below to load and run your first example.
</p>
<ul><li>Select <i>View-&gt;Target Configurations</i> to open target configuration tab in the left pane (this step assumes you have followed Getting Started Guide to create target configuration for your setup).</li>
<li>Right click on the configurations file (######.ccxml) and select <i>Launch Selected Configuration</i>.</li>
<li>It should change the CCS prospective to <i>Debug</i> and load the configuration.</li>
<li>After loading is complete select <i>Device</i> for core 0 (e.g. <i>C66XX_0</i>).</li>
<li>Select <i>Target-&gt;Connect Target</i> to connect to the core.</li>
<li>After core 0 is connected, select <i>Run-&gt;Load-&gt;Load Program</i>, then hit <i>Browse Project...</i>.</li>
<li>It should open <i>Select program to load</i> dialog, then select <i>led_play.out [....]</i> and hit <i>OK</i> and another <i>OK</i> to load the program to core 0.</li>
<li>After loading completes, select <i>Target-&gt;Run</i> to run the application.</li>
<li>The application should print <i>Hello World</i> if UART is connected to the board at 115200 baud rate and should flash LEDs.</li></ul>
<p><br />
</p>
<h3><span class="mw-headline" id="Example_2_-_Building_and_running_your_first_tasking_application_using_MCSDK_and_BIOS">Example 2 - Building and running your first tasking application using MCSDK and BIOS</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=102" title="Edit section: Example 2 - Building and running your first tasking application using MCSDK and BIOS">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This example essentially re-does the first example and takes the LED code and puts it into a task. Note that while the steps may look similar there is a significant leap being made with BIOS and Eclipse RTSC being introduced.
</p><p>1. The first step is to create an Eclipse RTSC project. To do that:
</p>
<ul><li>Open CCS (preferably with a new workspace).</li>
<li>Open <i>File-&gt;New-&gt;CCS Project</i> and in the project name field enter <i>led_play</i>
<ul><li>In the CCS project window, select <i>Device Family</i>: as <i>C6000</i></li>
<li>select <i>Device Variant</i>: as <i>Generic C66xx Device</i></li>
<li>In the <i>Project Templates</i> screen, select an <i>Empty RTSC Project</i> and hit <i>Next</i>.</li></ul></li>
<li>In the <i>RTSC Configuration Settings</i> screen, check the <i>Products and Repositories</i> (i.e. components) you want to use. All of them will be checked by default. Select only Sys/BIOS and the appropriate PDK for your EVM.
<ul><li>In the <i>RTSC Target</i> field enter <i>ti.targets.elf.C66</i>.</li>
<li>Select the <i>RTSC Platform</i> you are using. Select the <i>ti.platforms.evm66##</i> from the list box (note it will be empty, but just click on it and values will be filled in to select from).</li>
<li>Select <i>Build-profile</i> to debug</li></ul></li>
<li>Hit <i>Finish</i></li></ul>
<p>Note: The eclipse plugin discovery tool registers the project templates from the individual components with CCSv5. After the discovery tool registers XDCtools 3.22.01 version provided with BIOS MCSDK 2.0.1 release, the option <i>Empty RTSC Project</i> does not appear in the <i>Project Templates</i> screen because XDCtools 3.22.01 does not have the <i>Empty RTSC Project</i> template. Please follow this <a href="Empty_RTSC_Project_Workaround.html" title="Empty RTSC Project Workaround">link</a> to work around this problem.<br />
</p><p><br />
2. Now we have an Eclipse RTSC project but nothing in it. Our next step is to create a <i>.cfg</i> file and the source file we want to use. The <i>.cfg</i> is essential to this project and serves many purposes: 1.) It replaces the <i>linker.cmd</i> file 2.) Allows you to include the various modules from BIOS and other Components you wish to use and 3.) allows you to configure default settings within them.
</p><p>
If you followed along in Example one you should know how to add files to a project. Add a C source file called <i>led_play.c</i>. Now we need to add the configuration file called <i>led_play.cfg</i> to the project. Do <i>File-&gt;New-&gt;RTSC Configuration File</i> and then name is <i>led_play.cfg</i>. You should now have both files as shown in the figure to the right called BIOS LED Example Project. </p><div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="File_LedRtscProject.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/3/30/LedRtscProject.JPG" width="200" height="199" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_LedRtscProject.html" class="internal" title="Enlarge"></a></div>LedRtscProject.JPG</div></div></div>
<p>Note: Do not select a regular text file or a BIOS 5 configuration file when creating the .cfg.
</p><p><br />
</p><p>3. Lets add the code we need to the <i>led_play.c</i> file:
</p><p>&lt;syntaxhighlight lang="c"&gt;
</p>
<ol><li>include &lt;cerrno&gt;</li>
<li>include &lt;stdio.h&gt;</li>
<li>include &lt;stdlib.h&gt;</li>
<li>include &lt;string.h&gt;</li>
<li>include &lt;ti/sysbios/BIOS.h&gt;</li>
<li>include &lt;ti/sysbios/hal/Hwi.h&gt;</li>
<li>include &lt;ti/bios/include/swi.h&gt;</li>
<li>include "ti\platform\platform.h"</li>
<li>include "ti\platform\resource_mgr.h"</li></ol>
<p>/* OSAL functions for Platform Library */
uint8_t *Osal_platformMalloc (uint32_t num_bytes, uint32_t alignment)
{
</p>
<pre>   return malloc(num_bytes);
</pre>
<p>}
</p><p>void Osal_platformFree (uint8_t *dataPtr, uint32_t num_bytes)
{
</p>
<pre>   /* Free up the memory */
   if (dataPtr)
   {
       free(dataPtr);
   }
</pre>
<p>}
</p><p>void Osal_platformSpiCsEnter(void)
{
</p>
<pre>   /* Get the hardware semaphore.
    *
    * Acquire Multi core CPPI synchronization lock
    */
   while ((CSL_semAcquireDirect (PLATFORM_SPI_HW_SEM)) == 0);
</pre>
<pre>   return;
</pre>
<p>}
</p><p>void Osal_platformSpiCsExit (void)
{
</p>
<pre>   /* Release the hardware semaphore
    *
    * Release multi-core lock.
    */
   CSL_semReleaseSemaphore (PLATFORM_SPI_HW_SEM);
</pre>
<pre>   return;
</pre>
<p>}
</p><p><br />
/*************************************************************************
</p>
<pre>* main()
* Entry point for the application.
************************************************************************/
</pre>
<p>int main()
{
</p>
<pre>   /* Start the BIOS 6 Scheduler - it will kick off our main thread ledPlayTask() */
   platform_write("Start BIOS 6\n");
</pre>
<pre>   BIOS_start();
</pre>
<p>}
</p><p>/*************************************************************************
</p>
<pre>* EVM_init()
* Initializes the platform hardware. This routine is configured to start in
* the evm.cfg configuration file. It is the first routine that BIOS
* calls and is executed before Main is called. If you are debugging within
* CCS the default option in your target configuration file may be to execute
* all code up until Main as the image loads. To debug this you should disable
* that option.
************************************************************************/
</pre>
<p>void EVM_init()
{
</p>
<pre>   platform_init_flags sFlags;
   platform_init_config sConfig;
   int32_t pform_status;
</pre>
<p><br />
</p>
<pre>   /* Initialize the UART */
   platform_uart_init();
   platform_uart_set_baudrate(115200);
   (void) platform_write_configure(PLATFORM_WRITE_ALL);
</pre>
<pre>   /*
    * You can choose what to initialize on the platform by setting the following
    * flags. Things like the DDR, PLL, etc should have been set by the boot loader.
    */
   memset( (void *) &amp;sFlags, 0, sizeof(platform_init_flags));
   memset( (void *) &amp;sConfig, 0, sizeof(platform_init_config));
</pre>
<pre>   sFlags.pll = 0; /* PLLs for clocking */
   sFlags.ddr = 0; /* External memory */
   sFlags.tcsl = 1; /* Time stamp counter */
   sFlags.phy = 0; /* Ethernet */
   sFlags.ecc = 0; /* Memory ECC */
   sConfig.pllm = 0; /* Use libraries default clock divisor */
</pre>
<pre>   pform_status = platform_init(&amp;sFlags, &amp;sConfig);
</pre>
<pre>   /* If we initialized the platform okay */
   if (pform_status&#160;!= Platform_EOK) {
       /* Initialization of the platform failed... die */
       platform_write("Platform failed to initialize. Error code&#160;%d \n", pform_status);
       platform_write("We will die in an infinite loop... \n");
       while (1) {
           (void) platform_led(1, PLATFORM_LED_ON, PLATFORM_USER_LED_CLASS);
           (void) platform_delay(50000);
           (void) platform_led(1, PLATFORM_LED_OFF, PLATFORM_USER_LED_CLASS);
           (void) platform_delay(50000);
       }
   }
</pre>
<pre>   return;
</pre>
<p>}
</p><p><br />
/*************************************************************************
</p>
<pre>* ledPlayTask()
*
* This is the main task for the example. It will write send text
* messages to both the console and the UART using platform_write and then
* twinkle the LEDs. This task is configured to start in led_play.cfg
* configuration file and it is called from BIOS.
*
************************************************************************/
</pre>
<p>int ledPlayTask (void) {
</p>
<pre>   platform_info p_info;
   uint32_t led_no = 0;
</pre>
<pre>   /* Get information about the platform */
   platform_get_info(&amp;p_info);
</pre>
<pre>   platform_write("Lets twinkle some LED's\n");
</pre>
<pre>   /* Play forever */
   while(1) {
       platform_led(led_no, PLATFORM_LED_ON, PLATFORM_USER_LED_CLASS);
       platform_delay(30000);
       platform_led(led_no, PLATFORM_LED_OFF, PLATFORM_USER_LED_CLASS);
       led_no = (++led_no)&#160;% p_info.led[PLATFORM_USER_LED_CLASS].count;
   }
</pre>
<p>}
</p><p>&lt;/syntaxhighlight&gt;
</p><p><br />
</p><p>4. Add the code to the cfg file <i>led_play.cfg</i> by opening it with a text editor. Note that if you double click it, it opens a tool you can use to edit the file but editing it via a text editor will be simpler.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
</p><p>/*
</p>
<pre>* led_play.cfg
*
* Memory Map and Program initialization for the BIOS
* LED example program.
*/
</pre>
<p>/* Include the various Modules we want to use */
var Memory  = xdc.useModule('xdc.runtime.Memory');
var Startup = xdc.useModule('xdc.runtime.Startup');
var BIOS = xdc.useModule('ti.sysbios.BIOS');
var Task = xdc.useModule('ti.sysbios.knl.Task');
</p><p>/* Configure the Modules */
BIOS.taskEnabled = true; /* Enable BIOS Task Scheduler */
</p><p>/* Create our memory map - i.e. this is equivalent to linker.cmd */
Program.sectMap[".const"] = "MSMCSRAM";
Program.sectMap[".text"] = "MSMCSRAM";
Program.sectMap[".code"] = "MSMCSRAM";
Program.sectMap[".data"] = "MSMCSRAM";
Program.sectMap[".sysmem"] = "MSMCSRAM";
Program.sectMap["platform_lib"] = "MSMCSRAM";
</p><p>/* Lets register any hooks, tasks, etc that we want BIOS to handle */
</p><p>/*
</p>
<ul><li><ul><li>Register an EVM Init handler with BIOS. This will initialize the hardware.</li>
<li>BIOS calls before it starts.</li></ul></li>
<li>/</li></ul>
<p>Startup.firstFxns.$add('&amp;EVM_init');
</p><p>/*
</p>
<ul><li><ul><li>Create the Main Thread Task for our application.</li></ul></li>
<li>/</li></ul>
<p>var tskNdkMainThread = Task.create("&amp;ledPlayTask");
tskNdkMainThread.stackSize = 0x2000;
tskNdkMainThread.priority = 0x5;
tskNdkMainThread.instance.name = "ledPlayTask";
&lt;/syntaxhighlight&gt;
</p><p><br />
</p><p>5. Now we need to configure a few project settings for the Platform Library (just like we did in the previous example).
</p>
<ul><li>In the '<i>Build&gt;C6000 Compiler&gt;Include Options</i>, add following items in the Add dir to #include search path...</li></ul>
<p>&lt;syntaxhighlight lang="text"&gt;
"C:\ti\pdk_C66xx_x_x_x_x\packages"
&lt;/syntaxhighlight&gt;
</p><p><br />
</p>
<ul><li>Select <i>File Search Path</i> from <i>C6000 Linker</i> section. Add following items in <i>Include library...</i> section</li></ul>
<p>&lt;syntaxhighlight lang="javascript"&gt;
ti.platform.evm####l.ae66
&lt;/syntaxhighlight&gt; <img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Please note that the above library is the little endian debug version library of the platform library. This is needed for the application built for Little Endian. Please refer to the above table for including the appropriate library for the particular platform library application.
</p><p>And add following items in <i>Add &lt;dir&gt; to library...</i> section &lt;syntaxhighlight lang="text"&gt;
"C:\ti\pdk_C66xx_x_x_x_x\packages\ti\platform\evmc66xxl\platform_lib\lib\debug"
&lt;/syntaxhighlight&gt;
</p><p><br />
</p>
<ul><li>Select <i>OK</i> to close the properties dialog box.</li>
<li>Select <i>Project-&gt;Build Project</i> to build the project.</li></ul>
<p>You maybe wondering why we do not need include/library paths or library names for BIOS? Any RTSC enabled component in the MCSDK, provides its libraries and paths automatically during the build process. The appropriate libraries (big or little) and the paths are determined by the version of the component you selected in the CCS or RTSC Settings Screen. If you need to change any RTSC settings for an existing project, you can do so by highlighting the project name in CCS, then right clicking and selecting Properties and then selecting CCS from the menu.
</p><p><br />
</p><p>6. Build the project.
</p><p><br />
</p><p>7. Connect to your EVM with your Target Configuration file, then load and run the program on core 0!
</p><p><br /><br />
</p>
<h3><span id="Example_3_-_Running_from_external_memory_(DDR)"></span><span class="mw-headline" id="Example_3_-_Running_from_external_memory_.28DDR.29">Example 3 - Running from external memory (DDR)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=103" title="Edit section: Example 3 - Running from external memory (DDR)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This example essentially re-does the second example and takes the LED example code and puts it into DDR3 external memory. This example is created using CCS version 5.1.1. Please note that steps used to create the LED example using CCS version 5.0 and version 5.1 are very similar.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="File_LedPlayEx3.html" class="image"><img alt="LedPlayEx3.JPG" src="https://processors.wiki.ti.com/images/4/41/LedPlayEx3.JPG" width="200" height="252" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_LedPlayEx3.html" class="internal" title="Enlarge"></a></div></div></div></div>
<p>1. The first step is to create an Eclipse RTSC project as follows:
</p>
<ul><li>Open CCS (preferably with a new workspace).</li>
<li>Open File-&gt;New-&gt;CCS Project and in the project name field enter led_play_ddr3.</li>
<li>Select device family as C6000</li>
<li>Leave Device Variant as select or type filter text and select Generic C66xx Device on the next drop down list.</li>
<li>In the Project Templates screen (see image to the right), select Empty Project then hit Finish</li></ul>
<p><br /> 2. The second step is to create RTSC configuration file as follows:
</p>
<ul><li>Right click on led_play_ddr3 project-&gt;New-&gt;Other-&gt;RTSC-&gt;RTSC configuration File, then hit Next</li>
<li>Enter RTSC configuration file name as led_play_ddr3.cfg and hit Finish.</li></ul>
<p>3. Now we have an Eclipse RTSC project and its configuration file. Our next step is to overwrite .cfg file and the source file with test code and configuration that we want to use. The .cfg is essential to this project and serves many purposes: 1.) It replaces the linker.cmd file 2.) Allows you to include the various modules from BIOS and other components you wish to use and 3.) It allows you to configure default settings within them.
</p><p>4. Lets add the code we need to the led_play_ddr3 main.c file.
</p><p>&lt;syntaxhighlight lang="c"&gt;
</p><p>/*
</p>
<h6><span id="==_main.c_="></span><span class="mw-headline" id=".3D.3D_main.c_.3D">== main.c =</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=104" title="Edit section: == main.c =">edit</a><span class="mw-editsection-bracket">]</span></span></h6>
<ul><li>/</li></ul>
<ol><li>include &lt;xdc/std.h&gt;</li>
<li>include &lt;xdc/runtime/Error.h&gt;</li>
<li>include &lt;xdc/runtime/System.h&gt;</li>
<li>include &lt;ti/sysbios/BIOS.h&gt;</li>
<li>include &lt;ti/sysbios/knl/Task.h&gt;</li>
<li>include &lt;cerrno&gt;</li>
<li>include &lt;stdio.h&gt;</li>
<li>include &lt;stdlib.h&gt;</li>
<li>include &lt;string.h&gt;</li>
<li>include &lt;ti/sysbios/BIOS.h&gt;</li>
<li>include &lt;ti/sysbios/hal/Hwi.h&gt;</li>
<li>include &lt;ti/bios/include/swi.h&gt;</li>
<li>include "ti\platform\platform.h"</li>
<li>include "ti\platform\resource_mgr.h"</li></ol>
<p><br />
</p><p><br />
/* OSAL functions for Platform Library */
uint8_t *Osal_platformMalloc (uint32_t num_bytes, uint32_t alignment)
{
</p>
<pre>   return malloc(num_bytes);
</pre>
<p>}
</p><p>void Osal_platformFree (uint8_t *dataPtr, uint32_t num_bytes)
{
</p>
<pre>   /* Free up the memory */
   if (dataPtr)
   {
       free(dataPtr);
   }
</pre>
<p>}
</p><p>void Osal_platformSpiCsEnter(void)
{
</p>
<pre>   /* Get the hardware semaphore.
    *
    * Acquire Multi core CPPI synchronization lock
    */
   while ((CSL_semAcquireDirect (PLATFORM_SPI_HW_SEM)) == 0);
</pre>
<pre>   return;
</pre>
<p>}
</p><p>void Osal_platformSpiCsExit (void)
{
</p>
<pre>   /* Release the hardware semaphore
    *
    * Release multi-core lock.
    */
   CSL_semReleaseSemaphore (PLATFORM_SPI_HW_SEM);
</pre>
<pre>   return;
</pre>
<p>}
</p><p><br />
</p><p>/*************************************************************************
</p>
<pre>* EVM_init()
* Initializes the platform hardware. This routine is configured to start in
* the evm.cfg configuration file. It is the first routine that BIOS
* calls and is executed before Main is called. If you are debugging within
* CCS the default option in your target configuration file may be to execute
* all code up until Main as the image loads. To debug this you should disable
* that option.
************************************************************************/
</pre>
<p>void EVM_init()
{
</p>
<pre>   platform_init_flags sFlags;
   platform_init_config sConfig;
   int32_t pform_status;
</pre>
<pre>   /* Initialize the UART */
   platform_uart_init();
   platform_uart_set_baudrate(115200);
   (void) platform_write_configure(PLATFORM_WRITE_ALL);
</pre>
<pre>   /*
    * You can choose what to initialize on the platform by setting the following
    * flags. Things like the DDR, PLL, etc should have been set by the boot loader.
    */
   memset( (void *) &amp;sFlags, 0, sizeof(platform_init_flags));
   memset( (void *) &amp;sConfig, 0, sizeof(platform_init_config));
</pre>
<pre>   sFlags.pll = 0; /* PLLs for clocking */
   sFlags.ddr = 0; /* External memory */
   sFlags.tcsl = 1; /* Time stamp counter */
   sFlags.phy = 0; /* Ethernet */
   sFlags.ecc = 0; /* Memory ECC */
   sConfig.pllm = 0; /* Use libraries default clock divisor */
</pre>
<pre>   pform_status = platform_init(&amp;sFlags, &amp;sConfig);
</pre>
<pre>   /* If we initialized the platform okay */
   if (pform_status&#160;!= Platform_EOK) {
       /* Initialization of the platform failed... die */
       platform_write("Platform failed to initialize. Error code&#160;%d \n", pform_status);
       platform_write("We will die in an infinite loop... \n");
       while (1) {
           (void) platform_led(1, PLATFORM_LED_ON, PLATFORM_USER_LED_CLASS);
           (void) platform_delay(50000);
           (void) platform_led(1, PLATFORM_LED_OFF, PLATFORM_USER_LED_CLASS);
           (void) platform_delay(50000);
       }
   }
</pre>
<pre>   return;
</pre>
<p>}
</p><p><br />
</p><p>/*
</p>
<h6><span id="==_taskFxn_="></span><span class="mw-headline" id=".3D.3D_taskFxn_.3D">== taskFxn =</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=105" title="Edit section: == taskFxn =">edit</a><span class="mw-editsection-bracket">]</span></span></h6>
<ul><li>/</li></ul>
<p>Void taskFxn(UArg a0, UArg a1)
{
	platform_info p_info;
	uint32_t led_no = 0;
</p><p>	 /* Get information about the platform */
	platform_get_info(&amp;p_info);
</p><p>	platform_write("Lets twinkle some LED's\n");
</p><p>	    /* Play forever */
	    while(1) {
	        platform_led(led_no, PLATFORM_LED_ON, PLATFORM_USER_LED_CLASS);
	        platform_delay(30000);
	        platform_led(led_no, PLATFORM_LED_OFF, PLATFORM_USER_LED_CLASS);
	        led_no = (++led_no)&#160;% p_info.led[PLATFORM_USER_LED_CLASS].count;
	    }
</p><p>}
</p><p>/*
</p>
<h6><span id="==_main_="></span><span class="mw-headline" id=".3D.3D_main_.3D">== main =</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=106" title="Edit section: == main =">edit</a><span class="mw-editsection-bracket">]</span></span></h6>
<ul><li>/</li></ul>
<p>Void main()
{
</p>
<pre>   Task_Handle task;
   Error_Block eb;
</pre>
<pre>   System_printf("enter main()\n");
</pre>
<pre>   Error_init(&amp;eb);
   task = Task_create(taskFxn, NULL, &amp;eb);
   if (task == NULL) {
       System_printf("Task_create() failed!\n");
       BIOS_exit(0);
   }
</pre>
<pre>   BIOS_start();     /* enable interrupts and start SYS/BIOS */
</pre>
<p>}
</p><p>&lt;/syntaxhighlight&gt;
</p><p>4. Add the code to the cfg file led_play_ddr3.cfg by opening .cfg file with XDCscript editor. Right click on configuration file-&gt;open with-&gt;XDCscript editor. Copy and paste the following code to .cfg file.
</p><p>&lt;syntaxhighlight lang="c"&gt;
</p><p>/*
</p>
<pre>* led_play_ddr3.cfg
*
* Memory Map and Program initialization for the BIOS
* LED example program.
*/
</pre>
<p>/* Include the various Modules we want to use */
var Memory  = xdc.useModule('xdc.runtime.Memory');
var Startup = xdc.useModule('xdc.runtime.Startup');
var Task = xdc.useModule('ti.sysbios.knl.Task');
var BIOS = xdc.useModule('ti.sysbios.BIOS');
</p><p>/* Configure the Modules */
BIOS.taskEnabled = true;
</p><p>/* Create our memory map - i.e. this is equivalent to linker.cmd */
Program.sectMap[".const"] = "DDR3";
Program.sectMap[".text"] = "DDR3";
Program.sectMap[".code"] = "DDR3";
Program.sectMap[".data"] = "DDR3";
Program.sectMap[".sysmem"] = "DDR3";
Program.sectMap["platform_lib"] = "DDR3";
</p><p><br />
/* Lets register any hooks, tasks, etc that we want BIOS to handle
</p>
<pre>** Register an EVM Init handler with BIOS. This will initialize the   ** hardware.
</pre>
<ul><li><ul><li>BIOS calls before it starts.</li></ul></li>
<li>/</li></ul>
<p>Startup.firstFxns.$add('&amp;EVM_init');
</p><p>&lt;/syntaxhighlight&gt;
</p><p><br /> 5. Now we need to configure a few project settings for the Platform Library (just like we did in the previous example).
</p>
<ul><li>Select Project-&gt;Properties, it should open Properties window for led_play_ddr3 project, select Build-&gt;C6000 linker-&gt;File Search Path from the left pane.</li>
<li>On File Search Path window, add library file name ti.platform.evm6678l.ae66 and add dir to library file search path "c:\Program Files\Texas Instruments\ pdk_C####_1_0_0_xx \packages\ti\platform\evmc6678l\platform_lib\lib\debug"</li></ul>
<p>Note: Please note that the above library is the Little Endian debug version library of the platform library. This is needed for the application built for Little Endian. Please refer to the above table for including the appropriate library for the particular platform library application. You may be wondering why we do not need include/library paths or library names for BIOS? Any RTSC enabled component in the MCSDK, provides its libraries and paths automatically during the build process. The appropriate libraries (big or little) and the paths are determined by the version of the component you selected in the CCS or RTSC Settings Screen. If you need to change any RTSC settings for an existing project, you can do so by highlighting the project name in CCS, then right clicking and selecting Properties and then selecting CCS from the menu.
</p><p>6. Now select appropriate RSTC components by right click on project name-&gt;properties-&gt;Resource-&gt;General-&gt;RTSC (select PDK and BIOS versions and etc.), and then select appropriate target platform.
</p><p><br /> 7. Build the project.
</p><p>8. Connect to your EVM with your Target Configuration file, then load and run the program. You should now see all LEDs blinking.
</p><p><br />
</p>
<h3><span id="Example_4_-_Let's_make_it_multi-core"></span><span class="mw-headline" id="Example_4_-_Let.27s_make_it_multi-core">Example 4 - Let's make it multi-core</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=107" title="Edit section: Example 4 - Let&#039;s make it multi-core">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This example enhances the LED example code to run on multicore and puts it into DDR3 external memory. Similar to example 3, this example uses CCS version 5.1.1 to create its project. Please note that steps used to create this LED example with CCS version 5.0 and version 5.1 are very similar.
</p>
<div class="thumb tright"><div class="thumbinner" style="width:202px;"><a href="File_LedPlayEx4.html" class="image"><img alt="LedPlayEx4.jpg" src="https://processors.wiki.ti.com/images/2/2d/LedPlayEx4.jpg" width="200" height="252" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_LedPlayEx4.html" class="internal" title="Enlarge"></a></div></div></div></div>
<p>1. The first step is to create an Eclipse RTSC project as follows:
</p>
<ul><li>Open CCS (preferably with a new workspace).</li>
<li>Open File-&gt;New-&gt;CCS Project and in the project name field enter led_play_ddr3.</li>
<li>Select device family as C6000</li>
<li>Leave Device Variant as select or type filter text and select Generic C66xx Device on the next drop down list.</li>
<li>In the Project Templates screen, select Empty Project then hit Finish</li></ul>
<p>2. The second step is to create RTSC configuration file as follows:
</p>
<ul><li>Right click on led_play_ddr3 project-&gt;New-&gt;Other-&gt;RTSC-&gt;RTSC configuration File, then hit Next</li>
<li>Enter RTSC configuration file name as led_play_ddr3.cfg and hit Finish.</li></ul>
<p>3. Now we have an Eclipse RTSC project and its configuration file. Our next step is to overwrite .cfg file and the source file with test code and configuration that we want to use. The .cfg is essential to this project and serves many purposes: 1.) It replaces the linker.cmd file 2.) Allows you to include the various modules from BIOS and other ponents you wish to use and 3.) It allows you to configure default settings within them.
</p><p>4. Lets add the code we need to the led_play_ddr3.c file:
</p><p>&lt;syntaxhighlight lang="c"&gt;
</p><p>/*
</p>
<pre>* led_play.c
*
*  Created on: Feb 6, 2012
*
*/
</pre>
<ol><li>include &lt;cerrno&gt;</li>
<li>include &lt;stdio.h&gt;</li>
<li>include &lt;stdlib.h&gt;</li>
<li>include &lt;string.h&gt;</li>
<li>include &lt;ti/sysbios/BIOS.h&gt;</li>
<li>include &lt;ti/sysbios/hal/Hwi.h&gt;</li>
<li>include &lt;ti/bios/include/swi.h&gt;</li>
<li>include "ti\platform\platform.h"</li>
<li>include "ti\platform\resource_mgr.h"</li></ol>
<p><br />
</p>
<ol><li>pragma DATA_SECTION(next, ".sharedVar")</li>
<li>pragma DATA_ALIGN (next, 128)</li></ol>
<p>typedef union {
	uint32_t core;
	uint8_t padding[128];
}n;
</p><p>n next;
</p><p>uint32_t maxFlashes = 50;
</p><p>/* OSAL functions for Platform Library */
uint8_t *Osal_platformMalloc (uint32_t num_bytes, uint32_t alignment)
{
</p>
<pre>   return malloc(num_bytes);
</pre>
<p>}
</p><p>void Osal_platformFree (uint8_t *dataPtr, uint32_t num_bytes)
{
</p>
<pre>   /* Free up the memory */
   if (dataPtr)
   {
       free(dataPtr);
   }
</pre>
<p>}
</p><p>void Osal_platformSpiCsEnter(void)
{
</p>
<pre>   /* Get the hardware semaphore.
    *
    * Acquire Multi core CPPI synchronization lock
    */
   while ((CSL_semAcquireDirect (PLATFORM_SPI_HW_SEM)) == 0);
</pre>
<pre>   return;
</pre>
<p>}
</p><p>void Osal_platformSpiCsExit (void)
{
</p>
<pre>   /* Release the hardware semaphore
    *
    * Release multi-core lock.
    */
   CSL_semReleaseSemaphore (PLATFORM_SPI_HW_SEM);
</pre>
<pre>   return;
</pre>
<p>}
</p><p>/*****************************************************************************
</p>
<pre>*
* Function: Converts a core local L2 address to a global L2 address
*   Input addr:  L2 address to be converted to global.
*   return:  uint32_t   Global L2 address
*
*****************************************************************************/
</pre>
<p>uint32_t convert_CoreLocal2GlobalAddr (uint32_t  addr)
{
</p>
<pre> uint32_t coreNum;
</pre>
<pre> /* Get the core number. */
 coreNum = CSL_chipReadReg(CSL_CHIP_DNUM);
</pre>
<pre> /* Compute the global address. */
 return ((1 &lt;&lt; 28) | (coreNum &lt;&lt; 24) | (addr &amp; 0x00ffffff));
</pre>
<p>}
</p><p>/*************************************************************************
</p>
<pre>* main()
* Entry point for the application.
************************************************************************/
</pre>
<p>int main()
{
</p>
<pre>   /* Start the BIOS 6 Scheduler - it will kick off our main thread ledPlayTask() */
   platform_write("Start BIOS 6\n");
</pre>
<pre>   BIOS_start();
</pre>
<p>}
</p><p>/*************************************************************************
</p>
<pre>* EVM_init()
* Initializes the platform hardware. This routine is configured to start in
* the evm.cfg configuration file. It is the first routine that BIOS
* calls and is executed before Main is called. If you are debugging within
* CCS the default option in your target configuration file may be to execute
* all code up until Main as the image loads. To debug this you should disable
* that option.
************************************************************************/
</pre>
<p>void EVM_init()
{
</p>
<pre>   platform_init_flags sFlags;
   platform_init_config sConfig;
   int32_t pform_status;
</pre>
<pre>   /* Initialize the UART */
   platform_uart_init();
   platform_uart_set_baudrate(115200);
   (void) platform_write_configure(PLATFORM_WRITE_ALL);
</pre>
<pre>   /*
    * You can choose what to initialize on the platform by setting the following
    * flags. Things like the DDR, PLL, etc should have been set by the boot loader.
    */
   memset( (void *) &amp;sFlags, 0, sizeof(platform_init_flags));
   memset( (void *) &amp;sConfig, 0, sizeof(platform_init_config));
</pre>
<pre>   sFlags.pll = 0; /* PLLs for clocking */
   sFlags.ddr = 0; /* External memory */
   sFlags.tcsl = 1; /* Time stamp counter */
   sFlags.phy = 0; /* Ethernet */
   sFlags.ecc = 0; /* Memory ECC */
   sConfig.pllm = 0; /* Use libraries default clock divisor */
</pre>
<pre>   pform_status = platform_init(&amp;sFlags, &amp;sConfig);
</pre>
<pre>   /* If we initialized the platform okay */
   if (pform_status&#160;!= Platform_EOK) {
       /* Initialization of the platform failed... die */
       platform_write("Platform failed to initialize. Error code&#160;%d \n", pform_status);
       platform_write("We will die in an infinite loop... \n");
       while (1) {
           (void) platform_led(1, PLATFORM_LED_ON, PLATFORM_USER_LED_CLASS);
           (void) platform_delay(50000);
           (void) platform_led(1, PLATFORM_LED_OFF, PLATFORM_USER_LED_CLASS);
           (void) platform_delay(50000);
       }
   }
</pre>
<pre>   return;
</pre>
<p>}
</p><p><br />
/*************************************************************************
</p>
<pre>* ledPlayTask()
*
* This is the main task for the example. It will write send text
* messages to both the console and the UART using platform_write and then
* each core (0-3) sequentially twinkles its LEDs. This task is configured to start in led_play.cfg
* configuration file and it is called from BIOS.
*
************************************************************************/
</pre>
<p>void ledPlayTask (void) {
</p>
<pre>   platform_info p_info;
   uint32_t led_no = 0;
   uint32_t coreId, i;
</pre>
<pre>   /* determine the core number. */
   coreId = CSL_chipReadReg (CSL_CHIP_DNUM);
</pre>
<pre>   /* Get information about the platform */
   platform_get_info(&amp;p_info);
</pre>
<pre>   /* determine which core to twinkle LED	*/
   if(coreId&#160;!= 0){
   	while(1){
   		/* lets delay a bit before reading shared variable 	*/
   		platform_delay(30000);
   		CACHE_invL1d (&amp;next, 4, CACHE_FENCE_WAIT);
   		if(next.core == coreId)
   			break;
   	}
   }
</pre>
<pre>   /* lets delay a bit before twinkling the next LED	*/
   platform_delay(30000);
   i = 0;
   led_no = coreId;
   platform_write("core =&#160;%d starts twinkling its LED\n", coreId);
</pre>
<pre>   /* twinkle the LED based on core id and LED id, respectively	*/
   while(1) {
       platform_led(led_no, PLATFORM_LED_ON, PLATFORM_USER_LED_CLASS);
</pre>
<pre>       platform_delay(300000);
       platform_led(led_no, PLATFORM_LED_OFF, PLATFORM_USER_LED_CLASS);
</pre>
<pre>       platform_delay(300000);
</pre>
<pre>       i++;
       if ( i == maxFlashes){
       	break;
       }
   }
</pre>
<pre>   /* let next core twinkles its LED	*/
   next.core = coreId + 1;
   CACHE_wbL1d ((void *) &amp;next, 4, CACHE_WAIT);
   platform_write("core&#160;%d is done.\n", coreId);
</pre>
<p>}
</p><p>&lt;/syntaxhighlight&gt;
</p><p><br /> 5. Add the code to the cfg file led_play_ddr3.cfg by opening it with XDCscript editor by right click on configuration file-&gt;open with-&gt;XDCscript editor
</p><p>&lt;syntaxhighlight lang="c"&gt;
var Startup = xdc.useModule('xdc.runtime.Startup');
</p><p>var Defaults = xdc.useModule('xdc.runtime.Defaults');
var Diags = xdc.useModule('xdc.runtime.Diags');
var Error = xdc.useModule('xdc.runtime.Error');
var Log = xdc.useModule('xdc.runtime.Log');
var LoggerBuf = xdc.useModule('xdc.runtime.LoggerBuf');
var Main = xdc.useModule('xdc.runtime.Main');
var Memory = xdc.useModule('xdc.runtime.Memory')
var SysMin = xdc.useModule('xdc.runtime.SysMin');
var System = xdc.useModule('xdc.runtime.System');
var Text = xdc.useModule('xdc.runtime.Text');
</p><p>var Csl = xdc.loadPackage('ti.csl');
</p><p>var BIOS = xdc.useModule('ti.sysbios.BIOS');
var Clock = xdc.useModule('ti.sysbios.knl.Clock');
var Swi = xdc.useModule('ti.sysbios.knl.Swi');
var Task = xdc.useModule('ti.sysbios.knl.Task');
var Semaphore = xdc.useModule('ti.sysbios.knl.Semaphore');
var Hwi = xdc.useModule('ti.sysbios.hal.Hwi');
</p><p>/*
</p>
<pre>* Program.argSize sets the size of the .args section.
* The examples don't use command line args so argSize is set to 0.
*/
</pre>
<p>Program.argSize = 0x0;
</p><p>/*
</p>
<pre>* Uncomment this line to globally disable Asserts.
* All modules inherit the default from the 'Defaults' module.  You
* can override these defaults on a per-module basis using Module.common$.
* Disabling Asserts will save code space and improve runtime performance.
</pre>
<p>Defaults.common$.diags_ASSERT = Diags.ALWAYS_OFF;
</p>
<pre>*/
</pre>
<p>/*
</p>
<pre>* Uncomment this line to keep module names from being loaded on the target.
* The module name strings are placed in the .const section. Setting this
* parameter to false will save space in the .const section.  Error and
* Assert messages will contain an "unknown module" prefix instead
* of the actual module name.
</pre>
<p>Defaults.common$.namedModule = false;
</p>
<pre>*/
</pre>
<p>/*
</p>
<pre>* Minimize exit handler array in System.  The System module includes
* an array of functions that are registered with System_atexit() to be
* called by System_exit().
*/
</pre>
<p>System.maxAtexitHandlers = 4;
</p><p>/*
</p>
<pre>* Uncomment this line to disable the Error print function.
* We lose error information when this is disabled since the errors are
* not printed.  Disabling the raiseHook will save some code space if
* your app is not using System_printf() since the Error_print() function
* calls System_printf().
</pre>
<p>Error.raiseHook = null;
</p>
<pre>*/
</pre>
<p>/*
</p>
<pre>* Uncomment this line to keep Error, Assert, and Log strings from being
* loaded on the target.  These strings are placed in the .const section.
* Setting this parameter to false will save space in the .const section.
* Error, Assert and Log message will print raw ids and args instead of
* a formatted message.
</pre>
<p>Text.isLoaded = false;
</p>
<pre>*/
</pre>
<p>/*
</p>
<pre>* Uncomment this line to disable the output of characters by SysMin
* when the program exits.  SysMin writes characters to a circular buffer.
* This buffer can be viewed using the SysMin Output view in ROV.
</pre>
<p>SysMin.flushAtExit = false;
</p>
<pre>*/
</pre>
<p>/*
</p>
<pre>* The BIOS module will create the default heap for the system.
* Specify the size of this default heap.
*/
</pre>
<p>BIOS.heapSize = 0x1000;
</p><p>/* System stack size (used by ISRs and Swis) */
Program.stack = 0x2000;
</p><p>/* Circular buffer size for System_printf() */
SysMin.bufSize = 0x200;
</p><p>/*
</p>
<pre>* Create and install logger for the whole system
*/
</pre>
<p>var loggerBufParams = new LoggerBuf.Params();
loggerBufParams.numEntries = 16;
var logger0 = LoggerBuf.create(loggerBufParams);
Defaults.common$.logger = logger0;
Main.common$.diags_INFO = Diags.ALWAYS_ON;
</p><p>System.SupportProxy = SysMin;
</p><p>/* Example 3 Create our memory map - i.e. this is equivalent to linker.cmd */
Program.sectMap[".const"] = "DDR3";
Program.sectMap[".text"] = "DDR3";
Program.sectMap[".code"] = "DDR3";
Program.sectMap[".data"] = "DDR3";
Program.sectMap[".sysmem"] = "DDR3";
Program.sectMap[".sharedVar"] = "DDR3";
Program.sectMap["platform_lib"] = "DDR3";
</p><p><br />
</p><p>/* Lets register any hooks, tasks, etc that we want BIOS to handle */
/*
</p>
<ul><li><ul><li>Register an EVM Init handler with BIOS. This will initialize the hardware.</li>
<li>BIOS calls before it starts.</li></ul></li>
<li>/</li></ul>
<p>Startup.firstFxns.$add('&amp;EVM_init');
</p><p>/*
</p>
<ul><li><ul><li>Create the Main Thread Task for our application.</li></ul></li>
<li>/</li></ul>
<p>var tskNdkMainThread = Task.create("&amp;ledPlayTask");
tskNdkMainThread.stackSize = 0x2000;
tskNdkMainThread.priority = 0x5;
tskNdkMainThread.instance.name = "ledPlayTask";
</p><p>&lt;/syntaxhighlight&gt;
</p><p>6. Now we need to configure a few project settings for the Platform Library (just like we did in the previous example).
</p>
<ul><li>Select Project-&gt;Properties, it should open Properties window for led_play_ddr3 project, select Build-&gt;C6000 linker-&gt;File Search Path from the left pane.</li>
<li>On File Search Path window, add library file name ti.platform.evm6678l.ae66 and add dir to library file search path "c:\Program Files\Texas Instruments\ pdk_C####_1_0_0_xx \packages\ti\platform\evmc6678l\platform_lib\lib\debug"</li></ul>
<p><br />
</p>
<pre>Note: Please note that the above library is the little endian debug version library of the platform library. This is needed for the application built for Little Endian. Please refer to the above table for including the appropriate library for the particular platform library application.
</pre>
<p>You may be wondering why we do not need include/library paths or library names for BIOS? Any RTSC enabled component in the MCSDK, provides its libraries and paths automatically during the build process. The appropriate libraries (big or little) and the paths are determined by the version of the component you selected in the CCS or RTSC Settings Screen. If you need to change any RTSC settings for an existing project, you can do so by highlighting the project name in CCS, then right clicking and selecting Properties and then selecting CCS from the menu.
</p><p>7. Now select appropriate RSTC components by right click on project name-&gt;properties-&gt;Resource-&gt;General-&gt;RTSC (select PDK and BIOS versions and etc.), and then select appropriate target platform.
</p><p>8. Build the project.
</p><p>9. Connect to your EVM with your Target Configuration file, then load and run the program on first 4 cores. You should now see LEDs (0-3) blinking one after another.
</p><p><br /> <br />
</p>
<h1><span class="mw-headline" id="Multi-core_Programming_Models">Multi-core Programming Models</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=108" title="Edit section: Multi-core Programming Models">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<h2><span class="mw-headline" id="Explicit_Programming_Model_using_IPC">Explicit Programming Model using IPC</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=109" title="Edit section: Explicit Programming Model using IPC">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The MCSDK provides the foundations to support an explicit programming model based on Inter-Processor Communication (IPC). An explicit programming model is one in which the developer analyzes their application and manually partition tasks and processing elements across the cores and devices. In this model the developer is responsible for creating and managing processing tasks, communication between tasks, and data management.
</p><p>
The figures below illustrate the concept in different scenarios including both Linux and BIOS Operating systems. </p><div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:602px;"><a href="File_IPC_comm_features.html" class="image"><img alt="IPC comm features.JPG" src="https://processors.wiki.ti.com/images/2/27/IPC_comm_features.JPG" width="600" height="228" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_IPC_comm_features.html" class="internal" title="Enlarge"></a></div></div></div></div></div>
<p><br />
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:602px;"><a href="File_IPC_Linux_comm.html" class="image"><img alt="IPC Linux comm.JPG" src="https://processors.wiki.ti.com/images/c/c2/IPC_Linux_comm.JPG" width="600" height="207" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_IPC_Linux_comm.html" class="internal" title="Enlarge"></a></div></div></div></div></div>
<p>The IPC provides a processor agnostic API which can be used for communication between processes on the same processing core (inter-process), processes on different cores (inter-core), and processes on different devices (interdevice). For inter-core communication, the transport can be shared memory or leverage the hardware queuing in the KeyStone architecture. And across devices multiple transports can be supported (e.g., SRIO). For all cases, the API is maintained so as to ease the task of migrating tasks and processes across cores and processors as part of designing and tuning an implementation.
</p><p><a href="File_IPC_transport_types.html" class="image" title="IPC transport types.JPG"><img alt="IPC transport types.JPG" src="https://processors.wiki.ti.com/images/0/06/IPC_transport_types.JPG" width="1012" height="663" /></a>
</p><p><sup>1</sup> <a href="MCSDK_Image_Processing_Demonstration_Guide.html" title="MCSDK Image Processing Demonstration Guide">Image Processing Demo Guide</a>.
</p>
<h3><span id="Using_and_Configuring_the_Navigator/QMSS_Transport"></span><span class="mw-headline" id="Using_and_Configuring_the_Navigator.2FQMSS_Transport">Using and Configuring the Navigator/QMSS Transport</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=110" title="Edit section: Using and Configuring the Navigator/QMSS Transport">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The QMSS Transport can be used in place of the shared memory transports delivered as part of the IPC module. This section will describe how to enable the use of and configure the QMSS transport.
</p><p>Following, snippets from the qmssIpcBenchmark example project's RTSC configuration file, bench_qmss.cfg, included as part of MCSDK will be used to show how an application can utilize and configure the QMSS transport for use in IPC. The qmssIpcBenchmark example is found in pdk_C667#_w_x_y_z\packages\ti\transport\ipc\examples\qmssIpcBenchmark.
</p>
<h4><span class="mw-headline" id="Configure_IPC_to_Use_the_QMSS_Transport">Configure IPC to Use the QMSS Transport</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=111" title="Edit section: Configure IPC to Use the QMSS Transport">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>&lt;syntaxhighlight lang="javascript"&gt;
/* Load and use the CPPI and QMSS packages */
var Cppi = xdc.loadPackage('ti.drv.cppi');
var Qmss = xdc.loadPackage('ti.drv.qmss');
</p><p>Program.sectMap[".qmss"] = new Program.SectionSpec();
Program.sectMap[".qmss"] = "MSMCSRAM";
</p><p>Program.sectMap[".cppi"] = new Program.SectionSpec();
Program.sectMap[".cppi"] = "MSMCSRAM";
</p><p>var MessageQ = xdc.useModule('ti.sdo.ipc.MessageQ');
var TransportQmssSetup = xdc.useModule('ti.transport.ipc.qmss.transports.TransportQmssSetup');
</p><p>MessageQ.SetupTransportProxy = xdc.useModule(Settings.getMessageQSetupDelegate());
MessageQ.SetupTransportProxy = TransportQmssSetup;
&lt;/syntaxhighlight&gt;
</p><p>The code includes the CPPI and QMSS modules, allocates their global objects in MSMC, and then assigns the use of the QMSS Transport module (TransportQMSS) at the transport layer. Interrupts are tied to queue push actions at the transport layer so the Notify later is not required.
</p>
<h4><span id="Changing_the_GEM_Interrupt_Used_by_the_QMSS_Transport_Module_&amp;_Other_TransportQmssSetup_Parameters"></span><span class="mw-headline" id="Changing_the_GEM_Interrupt_Used_by_the_QMSS_Transport_Module_.26_Other_TransportQmssSetup_Parameters">Changing the GEM Interrupt Used by the QMSS Transport Module &amp; Other TransportQmssSetup Parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=112" title="Edit section: Changing the GEM Interrupt Used by the QMSS Transport Module &amp; Other TransportQmssSetup Parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>&lt;syntaxhighlight lang="javascript"&gt;
TransportQmssSetup.dspIntVectId = 8  /* Desired GEM interrupt */
&lt;/syntaxhighlight&gt;
</p><p>Adding the latter line to the .cfg file after creating the TransportQmssSetup variable allows the application developer to specify which GEM interrupt is used by the QMSS Transport module.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportQmssSetup.descMemRegion = 0;
&lt;/syntaxhighlight&gt;
</p><p>Adding the latter line to the .cfg file after creating the TransportQmssSetup variable allows the application developer to specify the memory region in which the descriptors were allocated.
</p>
<h4><span class="mw-headline" id="TransportQmss_Configuration_Options">TransportQmss Configuration Options</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=113" title="Edit section: TransportQmss Configuration Options">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>&lt;syntaxhighlight lang="javascript"&gt;
var TransportQmss = xdc.useModule('ti.transport.ipc.qmss.transports.TransportQmss');
&lt;/syntaxhighlight&gt;
</p><p>The latter defines a TransportQmss variable in order to access and change the QMSS transport configurations. Use of the TransportQmssSetup module automatically includes the use of the TransportQmss module but this variable must be created in order to access all the TransportQmss transport configuration options.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportQmss.numDescriptors = 1024;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the total number of descriptors to be used by <b>all</b> cores. This value should match the number of descriptors inserted in the memory region by the application.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportQmss.descriptorIsInSharedMem = true;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines whether the descriptors are placed into shared memory, such as MSMCSRAM or DDR3, or into local L2 memory. If the descriptors are in L2 memory task-to-task communication, within the same core, will only work.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportQmss.descriptorSize = 128;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the descriptor size in bytes. It is recommended this value be equivalent to the cache line size of 128 bytes.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportQmss.useAccumulatorLogic = false;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines whether the QMSS transport uses the Accumulator or QPEND queues. If this value is set to false the QPEND queues will be used. If true, the Accumulator queues and logic will be used. As of now, the QPEND queue configuration offers higher throughput and lower latency.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportQmss.pacingEnabled = false;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines whether the accumulator accumulation logic is enabled. If this value is set to true the accumulator will interrupt the DSP as soon as intThreshold (next parameter discussed) number of descriptors have been received. Enabling pacing will increase end-to-end delay.
</p><p><b>This option is only valid when useAccumulatorLogic is true </b>
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportQmss.intThreshold = 100;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the number of descriptors that should be received by the accumulator prior to interrupting the DSP when accumulator pacing is enabled. If pacing is disabled this value should be left at its default of 1.
</p><p><b>This option is only valid when useAccumulatorLogic is true </b>
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportQmss.timerLoadCount = 0;        // timer ticks. This value only has effect when the pacingEnabled is true.
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the time the accumulator should wait prior to interrupting the DSP. If the accumulator has not received a number of descriptors equal to intThreshold within the timeout period the accumulator will interrupt the DSP.
</p><p><b>This option is only valid when useAccumulatorLogic is true </b>
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportQmss.accuHiPriListSize = 204;  // this number should be &gt;= (2*intThreshold)+2
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the accumulator list size. The list is a ping pong buffer so the accumulator list should be sized as greater than or equal to twice the intThreshold+2. The +2 is for the words included at the start of the ping and pong buffers storing the number of entries in each buffer.
</p><p><b>This option is only valid when useAccumulatorLogic is true </b>
</p>
<h4><span class="mw-headline" id="TransportQmss_Queue_Allocation_Notes">TransportQmss Queue Allocation Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=114" title="Edit section: TransportQmss Queue Allocation Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The QMSS Transport does not hard code which high priority accumulator, or QPEND, queues it uses. The transport initialization code queries the QMSS LLD for the next available high priority, or QPEND, queue. When the queue number is returned by the QMSS LLD the DSP GEM Event to be tied to the specified GEM Interrupt is chosen based on the interrupt map tables in the SPRUGR9 - Keystone Architecture Multicore Navigator document. The tables of interest are in Section 5.3-Interrupt Maps. For the accumulator queues, Table 5-3 is for C6670 devices and Table 5-4 is for C6678 devices. For the QPEND queues, Table 5-6 is for C6670 devices and Table 5-7 is for C6678 devices.
</p>
<h3><span class="mw-headline" id="Using_and_Configuring_the_sRIO_Transport">Using and Configuring the sRIO Transport</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=115" title="Edit section: Using and Configuring the sRIO Transport">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The sRIO Transport can be used in place of the shared memory transports delivered as part of the IPC module. This section will describe how to enable the use of and configure the sRIO transport.
</p><p>Following, snippets from the srioIpcBenchmark example project's RTSC configuration file, bench_srio.cfg, included as part of MCSDK will be used to show how an application can utilize and configure the sRIO transport for use in IPC. The srioIpcBenchmark example is found in pdk_C667#_w_x_y_z\packages\ti\transport\ipc\examples\srioIpcBenchmark.
</p>
<h4><span class="mw-headline" id="Configure_IPC_to_Use_the_sRIO_Transport">Configure IPC to Use the sRIO Transport</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=116" title="Edit section: Configure IPC to Use the sRIO Transport">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>&lt;syntaxhighlight lang="javascript"&gt;
/* Load and use the CPPI, QMSS, and SRIO packages */
var Cppi = xdc.loadPackage('ti.drv.cppi');
var Qmss = xdc.loadPackage('ti.drv.qmss');
var Srio = xdc.loadPackage('ti.drv.srio');
</p><p>Program.sectMap[".qmss"] = new Program.SectionSpec();
Program.sectMap[".qmss"] = "MSMCSRAM";
</p><p>Program.sectMap[".cppi"] = new Program.SectionSpec();
Program.sectMap[".cppi"] = "MSMCSRAM";
</p><p>Program.sectMap[".srioSharedMem"] = new Program.SectionSpec();
Program.sectMap[".srioSharedMem"] = "MSMCSRAM";
</p><p>var MessageQ                = xdc.module('ti.sdo.ipc.MessageQ');
MessageQ.SetupTransportProxy = xdc.useModule(Settings.getMessageQSetupDelegate());
</p><p>var TransportSrioSetup = xdc.useModule('ti.transport.ipc.srio.transports.TransportSrioSetup');
MessageQ.SetupTransportProxy = TransportSrioSetup;
&lt;/syntaxhighlight&gt;
</p><p>The latter code includes the CPPI, QMSS, and sRIO modules, allocates their global objects in MSMCSRAM, and then assigns the use of the sRIO Transport module (TransportSrio) at the transport layer. The Notify layer is not required since sRIO can interrupt the remote core directly via QMSS queue interrupt.
</p>
<h4><span id="Changing_the_GEM_Interrupt_Used_by_the_sRIO_Transport_Module_&amp;_Other_TransportSrioSetup_Parameters"></span><span class="mw-headline" id="Changing_the_GEM_Interrupt_Used_by_the_sRIO_Transport_Module_.26_Other_TransportSrioSetup_Parameters">Changing the GEM Interrupt Used by the sRIO Transport Module &amp; Other TransportSrioSetup Parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=117" title="Edit section: Changing the GEM Interrupt Used by the sRIO Transport Module &amp; Other TransportSrioSetup Parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrioSetup.dspIntVectId = 8  /* Desired GEM interrupt */
&lt;/syntaxhighlight&gt;
</p><p>Adding the latter line to the .cfg file after creating the TransportSrioSetup variable allows the application developer to specify which GEM interrupt is used by the sRIO Transport module.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrioSetup.descMemRegion = 0;
&lt;/syntaxhighlight&gt;
</p><p>Adding the latter line to the .cfg file after creating the TransportSrioSetup variable allows the application developer to specify the memory region in which the descriptors were allocated.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrioSetup.numRxDescBuffs = 256;
&lt;/syntaxhighlight&gt;
</p><p>Adding the latter line to the .cfg file after creating the TransportSrioSetup variable allows the application developer to specify the number of descriptor buffers that can be tied to sRIO receive-side descriptors. The number of receive buffers must be at least the number of receive descriptors (TransportSrio.srioNumRxDescriptors) times the number of cores on the local chip. There should be enough buffers such that buffers are still available for tying to receive descriptors while other buffers are being processed by the application.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrioSetup.messageQHeapId = 0;
&lt;/syntaxhighlight&gt;
</p><p>Adding the latter line to the .cfg file after creating the TransportSrioSetup variable allows the application developer to specify the heap ID of the heap from which MessageQ is to allocate the receive-side buffers.
</p><p><b>This head ID should not be used by any other module within the system. It is meant solely for the receive-side descriptor buffers. </b>
</p>
<h4><span class="mw-headline" id="TransportSrio_Configuration_Options">TransportSrio Configuration Options</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=118" title="Edit section: TransportSrio Configuration Options">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>&lt;syntaxhighlight lang="javascript"&gt;
var TransportSrio = xdc.useModule('ti.transport.ipc.srio.transports.TransportSrio');
&lt;/syntaxhighlight&gt;
</p><p>The latter defines a TransportSrio variable in order to access and change the sRIO transport configurations. Use of the TransportSrioSetup module automatically includes the use of the TransportSrio module but this variable must be created in order to access all the sRIO transport configuration options.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioNumTxDescriptors = 4;
TransportSrio.srioNumRxDescriptors = 4;
&lt;/syntaxhighlight&gt;
</p><p>The latter options define the number of transmit and receive descriptors to be used by each core. For example, if there are two cores in the system each core would be assigned 4 transmit and 4 receive descriptors. The number of descriptors inserted in the memory region by the application should be greater than or equal to ((srioNumTxDescriptors + srioNumRxDescriptors) * number of cores used on chip).
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.descriptorSize = 128;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the descriptor size in bytes. It is recommended this value be equivalent to the cache line size of 128 bytes.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.pacingEnabled = true;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines whether the accumulator accumulation logic is enabled. If this value is set to true the accumulator will interrupt the DSP as soon as intThreshold (next parameter discussed) number of descriptors have been received. Enabling pacing will increase end-to-end delay.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.intThreshold = 100;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the number of descriptors that should be received by the accumulator prior to interrupting the DSP when accumulator pacing is enabled. If pacing is disabled this value should be left at its default of 1.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.timerLoadCount = 0;        // timer ticks. This value only has effect when the pacingEnabled is true.
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the time the accumulator should wait prior to interrupting the DSP. If the accumulator has not received a number of descriptors equal to intThreshold within the timeout period the accumulator will interrupt the DSP.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.accuHiPriListSize = 204;  // this number should be &gt;= (2*intThreshold)+2
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the accumulator list size. The list is a ping pong buffer so the accumulator list should be sized as greater than or equal to twice the intThreshold+2. The +2 is for the words included at the start of the ping and pong buffers storing the number of entries in each buffer.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioMaxMtuSizeBytes = 256;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the maximum transmissible unit by sRIO in bytes. The maximum value that can be specified is 256 bytes.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.numTxDescToCleanUp = 1;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the number of descriptors to cleanup each time TransportSrio_put is called. After sRIO sends out data associated with a descriptor provided by the TransportSrio_put function, sRIO will put the descriptor into a transmit completion queue. The next time TransportSrio_put is invoked it will check the transmit completion queue for descriptors, and their associated buffers, to clean up. If the number of descriptors in the transmit completion queue equals this setting it will cleanup the the defined number of descriptors and buffers.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioGarbageQ = "defined SRIO garbage queue value";
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the sRIO garbage queue for which the SRIO transport should check for descriptors to cleanup. The sRIO hardware can be assigned up to six separate QMSS queues which are used as repositories for descriptors which failed to send because of different errors. The sRIO transport has the ability to check one of these queues for descriptors, and their associated buffers, to clean up. The application can specify six separate queues for each sRIO failure type or can tie one or more failure types to a single garbage queue. This allows the SRIO transport to clean up anywhere from one to all six failure types. The cleanup process occurs every TransportSrio_put operation.
</p>
<h4><span class="mw-headline" id="TransportSrio_Core_Map_Configuration_and_IPC_Cluster_Parameters">TransportSrio Core Map Configuration and IPC Cluster Parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=119" title="Edit section: TransportSrio Core Map Configuration and IPC Cluster Parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The sRIO transport is a multi-chip transport, allowing communication between two or more cores on separate chips. This attribute means that each chip running the sRIO transport must contain a copy of the core address array configurations. This copy must be exactly the same across all chips. The multi-chip capabilities of the sRIO transport are facilitated by the IPC cluster support. The IPC cluster support allows the core map to remain the same across all chips. Based on the IPC cluster base defined for each chip the sRIO core map is indexed in the transport to find the proper address for the destination core.
</p>
<h5><span class="mw-headline" id="TransportSrio_Single_Device_Core_Map_and_IPC_Cluster_Configuration">TransportSrio Single Device Core Map and IPC Cluster Configuration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=120" title="Edit section: TransportSrio Single Device Core Map and IPC Cluster Configuration">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>This section covers the sRIO transport core map and IPC cluster configuration for a system that contains two cores within the same device communicating with one another. This scenario is illustrated by the srioIpcBenchmark example project and the code covered below is taken directly from the bench_srio.cfg file.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
Program.global.Srio8BitDeviceId1 = 0xAB;
&lt;/syntaxhighlight&gt;
</p><p>The latter operation defines the only valid device ID for data routed through the sRIO IP block. This value or any other device IDs must match with any device IDs used to set the sRIO TLM Base Routing Pattern Match information. In the srioIpcBenchmark example the pattern match information is set in the SrioDevice_init function in device_srio.c.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioMaxNumSystemCores = 2;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the total number of cores across all chips contained in the system. For this case, there is only one chip with only two cores on the chip being utilized.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioCoreTT.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreTT[0] = 0;
TransportSrio.srioCoreTT[1] = 0;
&lt;/syntaxhighlight&gt;
</p><p>The srioCoreTT array specifies whether each core's socket uses 16 or 8-bit identifiers (deviceIDs as named in this example). The srioCoreTT array should have as many entries as there are cores in the system. The srioCoreTT array is sized to the maximum number of system cores prior to assigning a value to each entry in the array. For information on valid srioCoreTT settings please refer to pdk_C667#_w_x_y_z\packages\ti\transport\ipc\srio\transports\TransportSrio.xdc.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioCoreDeviceId.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreDeviceId[0] = Program.global.Srio8BitDeviceId1;
TransportSrio.srioCoreDeviceId[1] = Program.global.Srio8BitDeviceId1;
&lt;/syntaxhighlight&gt;
</p><p>The srioCoreDeviceId array specifies the deviceID assigned to each core's sRIO socket. The srioCoreDeviceId array should have as many entries as there are cores in the system. The srioCoreDeviceId array is sized to the maximum number of system cores prior to assigning a value to each entry in the array. For information on valid srioCoreDeviceId settings please refer to pdk_C667#_w_x_y_z\packages\ti\transport\ipc\srio\transports\TransportSrio.xdc.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioCoreMailbox.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreMailbox[0] = 0;
TransportSrio.srioCoreMailbox[1] = 0;
&lt;/syntaxhighlight&gt;
</p><p>The srioCoreMailbox array specifies the mailbox number assigned to each core's sRIO socket. The srioCoreMailbox array should have as many entries as there are cores in the system. The srioCoreMailbox array is sized to the maximum number of system cores prior to assigning a value to each entry in the array. For information on valid srioCoreMailbox settings please refer to pdk_C667#_w_x_y_z\packages\ti\transport\ipc\srio\transports\TransportSrio.xdc.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioCoreLetter.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreLetter[0] = 0;
TransportSrio.srioCoreLetter[1] = 1;
&lt;/syntaxhighlight&gt;
</p><p>The srioCoreLetter array specifies the letter number assigned to each core's sRIO socket. The srioCoreLetter array should have as many entries as there are cores in the system. The srioCoreLetter array is sized to the maximum number of system cores prior to assigning a value to each entry in the array. For information on valid srioCoreLetter settings please refer to pdk_C667#_w_x_y_z\packages\ti\transport\ipc\srio\transports\TransportSrio.xdc.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioCoreSegMap.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreSegMap[0] = 0;
TransportSrio.srioCoreSegMap[1] = 0;
&lt;/syntaxhighlight&gt;
</p><p>The srioCoreSegMap array specifies the segmentation mapping for core's sRIO socket. The srioCoreSegMap array should have as many entries as there are cores in the system. The srioCoreSegMap array is sized to the maximum number of system cores prior to assigning a value to each entry in the array. For information on valid srioCoreSegMap settings please refer to pdk_C667#_w_x_y_z\packages\ti\transport\ipc\srio\transports\TransportSrio.xdc.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
var procName = null;
&lt;/syntaxhighlight&gt;
</p><p>This option can be used to define the MultiProc ID for cores prior to runtime. Typically, this option is set to null and the MultiProc ID for each core is set at runtime.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
var procNameList = [];
procNameList = ["CORE0", "CORE1"];
&lt;/syntaxhighlight&gt;
</p><p>This option defines the number of cores on this chip that will be used.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
var MultiProc = xdc.useModule('ti.sdo.utils.MultiProc');
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines a MultiProc variable for use in setting the cluster configurations.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
MultiProc.numProcessors = TransportSrio.srioMaxNumSystemCores;
&lt;/syntaxhighlight&gt;
</p><p>The latter option sets the number of processors in the entire system, across all chips. For this case the number of cores is 2, or srioMaxNumSystemCores.
</p><p><b>baseIdOfCluster and numProcessors must be set BEFORE setConfig is run</b>
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
MultiProc.baseIdOfCluster = 0;
&lt;/syntaxhighlight&gt;
</p><p>The latter option sets the base cluster ID for this chip. In this case, there is only one chip with two cores. The base ID is zero.
</p><p><b>baseIdOfCluster and numProcessors must be set BEFORE setConfig is run</b>
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
MultiProc.setConfig(procName, procNameList);
&lt;/syntaxhighlight&gt;
</p><p>The latter function sets up the MultiProc module using the specified processor and cluster information.
</p>
<h5><span class="mw-headline" id="TransportSrio_Multi-Device_Core_Map_and_IPC_Cluster_Configuration">TransportSrio Multi-Device Core Map and IPC Cluster Configuration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=121" title="Edit section: TransportSrio Multi-Device Core Map and IPC Cluster Configuration">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>This section covers the sRIO transport core map and IPC cluster configuration for a system that contains two devices with two cores each, for a total four cores, communicating with one another. This scenario is illustrated by the srioIpcChipToChipExample project.
</p>
<h6><span id="Device_One_(Producer)_Configuration"></span><span class="mw-headline" id="Device_One_.28Producer.29_Configuration">Device One (Producer) Configuration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=122" title="Edit section: Device One (Producer) Configuration">edit</a><span class="mw-editsection-bracket">]</span></span></h6>
<p>This section covers the core map and IPC cluster configuration settings for the first, producer device within the system. As previously noted, each device .cfg file must map every core within the system. This scenario is illustrated by the SrioIpcChipToChipExample\producer example project and the code covered below is taken directly from the producer_srio.cfg file.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
Program.global.Srio8BitDeviceId1 = 0xAB
Program.global.Srio8BitDeviceId2 = 0xCD
&lt;/syntaxhighlight&gt;
</p><p>The latter operations define the only valid device IDs for data routed through the sRIO IP block. These values or any other device IDs must match with any device IDs used to set the sRIO TLM Base Routing Pattern Match information. In the srioIpcBenchmark example the pattern match information is set in the SrioDevice_init function in device_srio.c.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioMaxNumSystemCores = 4;
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines the total number of cores across all chips contained in the system. There are two cores on device one and two cores on device two, for a total of four cores being utilized.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioCoreTT.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreTT[0] = 0;
TransportSrio.srioCoreTT[1] = 0;
TransportSrio.srioCoreTT[2] = 0;
TransportSrio.srioCoreTT[3] = 0;
&lt;/syntaxhighlight&gt;
</p><p>The srioCoreTT array specifies whether each core's socket uses 16 or 8-bit identifiers (deviceIDs, as named in this example). The srioCoreTT array should have as many entries as there are cores in the system. The srioCoreTT array is sized to the maximum number of system cores prior to assigning a value to each entry in the array. For information on valid srioCoreTT settings please refer to pdk_C667#_w_x_y_z\packages\ti\transport\ipc\srio\transports\TransportSrio.xdc.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioCoreDeviceId.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreDeviceId[0] = Program.global.Srio8BitDeviceId1;
TransportSrio.srioCoreDeviceId[1] = Program.global.Srio8BitDeviceId1;
TransportSrio.srioCoreDeviceId[2] = Program.global.Srio8BitDeviceId2;
TransportSrio.srioCoreDeviceId[3] = Program.global.Srio8BitDeviceId2;
&lt;/syntaxhighlight&gt;
</p><p>The srioCoreDeviceId array specifies the deviceID assigned to each core's sRIO socket. The srioCoreDeviceId array should have as many entries as there are cores in the system. The srioCoreDeviceId array is sized to the maximum number of system cores prior to assigning a value to each entry in the array. For information on valid srioCoreDeviceId settings please refer to pdk_C667#_w_x_y_z\packages\ti\transport\ipc\srio\transports\TransportSrio.xdc.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioCoreMailbox.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreMailbox[0] = 0;
TransportSrio.srioCoreMailbox[1] = 0;
TransportSrio.srioCoreMailbox[2] = 0;
TransportSrio.srioCoreMailbox[3] = 0;
&lt;/syntaxhighlight&gt;
</p><p>The srioCoreMailbox array specifies the mailbox number assigned to each core's sRIO socket. The srioCoreMailbox array should have as many entries as there are cores in the system. The srioCoreMailbox array is sized to the maximum number of system cores prior to assigning a value to each entry in the array. For information on valid srioCoreMailbox settings please refer to pdk_C667#_w_x_y_z\packages\ti\transport\ipc\srio\transports\TransportSrio.xdc.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioCoreLetter.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreLetter[0] = 0;
TransportSrio.srioCoreLetter[1] = 1;
TransportSrio.srioCoreLetter[2] = 0;
TransportSrio.srioCoreLetter[3] = 1;
&lt;/syntaxhighlight&gt;
</p><p>The srioCoreLetter array specifies the letter number assigned to each core's sRIO socket. The srioCoreLetter array should have as many entries as there are cores in the system. The srioCoreLetter array is sized to the maximum number of system cores prior to assigning a value to each entry in the array. For information on valid srioCoreLetter settings please refer to pdk_C667#_w_x_y_z\packages\ti\transport\ipc\srio\transports\TransportSrio.xdc.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
TransportSrio.srioCoreSegMap.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreSegMap[0] = 0;
TransportSrio.srioCoreSegMap[1] = 0;
TransportSrio.srioCoreSegMap[2] = 0;
TransportSrio.srioCoreSegMap[3] = 0;
&lt;/syntaxhighlight&gt;
</p><p>The srioCoreSegMap array specifies the segmentation mapping for core's sRIO socket. The srioCoreSegMap array should have as many entries as there are cores in the system. The srioCoreSegMap array is sized to the maximum number of system cores prior to assigning a value to each entry in the array. For information on valid srioCoreSegMap settings please refer to pdk_C667#_w_x_y_z\packages\ti\transport\ipc\srio\transports\TransportSrio.xdc.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
var procName = null;
&lt;/syntaxhighlight&gt;
</p><p>This option can be used to define the MultiProc ID for cores prior to runtime. Typically, this option is set to null and the MultiProc ID for each core is set at runtime.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
var procNameList = [];
procNameList = ["CORE0", "CORE1"];
&lt;/syntaxhighlight&gt;
</p><p>This option defines the number of cores on this chip that will be used.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
var MultiProc = xdc.useModule('ti.sdo.utils.MultiProc');
&lt;/syntaxhighlight&gt;
</p><p>The latter option defines a MultiProc variable for use in setting the cluster configurations.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
MultiProc.numProcessors = TransportSrio.srioMaxNumSystemCores;
&lt;/syntaxhighlight&gt;
</p><p>The latter option sets the number of processors in the entire system, across all chips. For this case the number of cores is 2, or srioMaxNumSystemCores.
</p><p><b>baseIdOfCluster and numProcessors must be set BEFORE setConfig is run</b>
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
MultiProc.baseIdOfCluster = 0;
&lt;/syntaxhighlight&gt;
</p><p>The latter option sets the base cluster ID for this chip. In this case, the Producer chip contains the first two cores in the system. Therefore, the cluster base ID for this chip is 0.
</p><p><b>baseIdOfCluster and numProcessors must be set BEFORE setConfig is run</b>
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
MultiProc.setConfig(procName, procNameList);
&lt;/syntaxhighlight&gt;
</p><p>The latter function sets up the MultiProc module using the specified processor and cluster information.
</p>
<h6><span id="Device_Two_(Consumer)_Configuration"></span><span class="mw-headline" id="Device_Two_.28Consumer.29_Configuration">Device Two (Consumer) Configuration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=123" title="Edit section: Device Two (Consumer) Configuration">edit</a><span class="mw-editsection-bracket">]</span></span></h6>
<p>This section covers the core map and IPC cluster configuration settings for the second, consumer device within the system. As previously noted, each device .cfg file must map every core within the system. This scenario is illustrated by the SrioIpcChipToChipExample\consumer example project and the code covered below is taken directly from the consumer_srio.cfg file.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
Program.global.Srio8BitDeviceId1 = 0xAB
Program.global.Srio8BitDeviceId2 = 0xCD
</p><p>TransportSrio.srioMaxNumSystemCores = 4;
</p><p>TransportSrio.srioCoreTT.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreTT[0] = 0;
TransportSrio.srioCoreTT[1] = 0;
TransportSrio.srioCoreTT[2] = 0;
TransportSrio.srioCoreTT[3] = 0;
</p><p>TransportSrio.srioCoreDeviceId.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreDeviceId[0] = Program.global.Srio8BitDeviceId1;
TransportSrio.srioCoreDeviceId[1] = Program.global.Srio8BitDeviceId1;
TransportSrio.srioCoreDeviceId[2] = Program.global.Srio8BitDeviceId2;
TransportSrio.srioCoreDeviceId[3] = Program.global.Srio8BitDeviceId2;
</p><p>TransportSrio.srioCoreMailbox.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreMailbox[0] = 0;
TransportSrio.srioCoreMailbox[1] = 0;
TransportSrio.srioCoreMailbox[2] = 0;
TransportSrio.srioCoreMailbox[3] = 0;
</p><p>TransportSrio.srioCoreLetter.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreLetter[0] = 0;
TransportSrio.srioCoreLetter[1] = 1;
TransportSrio.srioCoreLetter[2] = 0;
TransportSrio.srioCoreLetter[3] = 1;
</p><p>TransportSrio.srioCoreSegMap.length = TransportSrio.srioMaxNumSystemCores;
TransportSrio.srioCoreSegMap[0] = 0;
TransportSrio.srioCoreSegMap[1] = 0;
TransportSrio.srioCoreSegMap[2] = 0;
TransportSrio.srioCoreSegMap[3] = 0;
&lt;/syntaxhighlight&gt;
</p><p>All the latter commands match exactly with what was defined for the producer device. For the sRIO transport to work all device's must have the same knowledge of the global core map. As a result, all the latter information must not change between device .cfg files.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
var procName = null;
var procNameList = [];
</p><p>procNameList = ["CORE0", "CORE1"];
</p><p>var MultiProc = xdc.useModule('ti.sdo.utils.MultiProc');
MultiProc.numProcessors = TransportSrio.srioMaxNumSystemCores;
MultiProc.baseIdOfCluster = 2;
MultiProc.setConfig(procName, procNameList);
&lt;/syntaxhighlight&gt;
</p><p>The latter options configure MultiProc for the Consumer chip. For this case, the Consumer chip contains the last two cores in the system. Therefore, the cluster base ID for this chip is 2.
</p><p><b>baseIdOfCluster and numProcessors must be set BEFORE setConfig is run</b>
</p>
<h4><span class="mw-headline" id="TransportSrio_Queue_Allocation_Notes">TransportSrio Queue Allocation Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=124" title="Edit section: TransportSrio Queue Allocation Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The sRIO transport does not hardcode which general purpose, sRIO, or high priority accumulator queues it uses. The transport initialization code queries the QMSS LLD for the next available queues. When the queue number is returned for the high priority accumulator queues by the QMSS LLD the DSP GEM Event to be tied to the specified GEM Interrupt is chosen based on the interrupt map tables in the SPRUGR9 - Keystone Architecture Multicore Navigator document. The tables of interest are in Section 5.3-Interrupt Maps. Table 5-3 is for C6670 devices and Table 5-4 is for C6678 devices.
</p>
<h4><span class="mw-headline" id="TransportSrio_Application_Configuration_Requirements">TransportSrio Application Configuration Requirements</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=125" title="Edit section: TransportSrio Application Configuration Requirements">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>In order to use the sRIO IPC transport to communicate with a core off-chip a couple rules must be followed when settings up the transport in the application.
</p><p>1. A core to be used to communicate with an off-chip core must attach to at least one local core prior to communicating off-chip. The first invocation of Ipc_attach for a core will result in the sRIO transport starting up and configuring itself for send/receive. The IPC cluster mechanism does not enable attaching to core's off-chip. Those connection are setup manually. Therefore, at least one local IPC attach is required in order to setup and configure the sRIO transport. This local attach must be done in the context of main prior to BIOS_start enabling interrupts.
</p><p>2. A core's connections to off-chip cores must be registered manually. Manual registration must be done after the local Ipc_attach is performed and before BIOS_start runs, enabling interrupts. A connection must be registered for each off-chip core that is to be communicated with. The following code gives an example of how to manually register an off-chip core connection:
</p><p>&lt;syntaxhighlight lang="c"&gt;
/* NameServerMessageQ and SRIO Transport handles are global so they can be deleted
</p>
<pre>* in task context when execution completes. */
</pre>
<p>NameServerMessageQ_Handle nsHandle = NULL;
TransportSrio_Handle srioHandle = NULL;
</p><p>Int main(Int argc, Char* argv[])
{
</p>
<pre> Error_Block eb;
</pre>
<pre> ...
</pre>
<pre> Attach_to_local_cores();
</pre>
<pre> ...
</pre>
<pre> /* Create messageQ to remote proc .  This will use srioTransport to send/receive nameserver
  * messages to/from remote chip.  A MessageQ heap must be registered prior to calling
  * NameServerMessageQ_create()*/
 Error_init(&amp;eb);
 nsHandle = NameServerMessageQ_create(off_chip_core_multiProc_id, NULL, &amp;eb);
 if (nsHandle == NULL)
 {
   System_abort("NameServerMessageQ_create() failed");
 }
 /* Register a transport for messages received from off-chip cores */
 Error_init(&amp;eb);
 srioHandle = TransportSrio_create(off_chip_core_multiProc_id, NULL, &amp;eb);
</pre>
<pre> ...
</pre>
<pre> /* Start BIOS and all defined tasks.  Function will not return since it acts as the scheduler. */
 BIOS_start();
</pre>
<pre> /* should not reach here */
 return (0);
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p><p>3. Attempts to open a MessageQ located on an off-core chip must be done after the manual connection to the off-chip core has been created and after BIOS_start() has enabled interrupts. When a core attempts to open an MessageQ located on an off-chip core, the NameServerMesssageQ uses the sRIO transport to send a NameServer request message to the off-chip core. In order to service the request and send a response back the remote off-chip core must have the sRIO transport up and running and have a manual connection to the requesting core created. If a requesting core tries to make a NameServer request to an off-chip core that is not ready yet, the NameServerMessageQ request functionality will timeout. At that point the application can wait then try to open the MessageQ at a later time. The timeout period to wait for a NameServer response can be configured in the .cfg file with the following commands. The resolution of the timeout value is microseconds.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
var NameServerMessageQ = xdc.useModule('ti.sdo.ipc.nsremote.NameServerMessageQ');
NameServerMessageQ.timeoutInMicroSecs = 1000000; /* 1 sec */
&lt;/syntaxhighlight&gt;
</p><p>For a working example of how to use the multi-chip IPC and the sRIO transport for device to device communication please examine the producer and consumer RTSC projects in the directory pdk_C667#_w_x_y_z\packages\ti\transport\ipc\examples\srioIpcChipToChipExample. The project .cfg and .c files have been highlighted in the latter sections but contain more in-line comments regarding the use of the sRIO transport.
</p><p><br />
</p><p><br />
</p><p><br />
</p>
<h2><span class="mw-headline" id="Programming_Model_using_OpenMP">Programming Model using OpenMP</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=126" title="Edit section: Programming Model using OpenMP">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>OpenMP is the industry standard for shared memory parallel programming in C, C++, or Fortran. It provides portable high-level programming constructs that enable users to easily expose a program's task and loop level parallelism in an incremental fashion. With OpenMP, users specify the parallelization strategy for a program at a high level by annotating the program code with compiler directives that specify how a region of code is executed by a team of threads. The compiler works out the detailed mapping of the computation to the machine. The OpenMP programming API enables the programmer to perform the following:
</p>
<ul><li>Create and manage threads</li>
<li>Assign and distribute work (tasks) to threads</li>
<li>Specify which data is shared among threads and which data is private</li>
<li>Coordinate thread access to shared data</li></ul>
<p>As shown in the following figure, OpenMP is a thread-based programming language. The master thread executes the sequential parts of a program. When the master thread encounters a parallel region, it forks a team of worker threads that along with the master thread execute in parallel.
</p>
<div class="center"><div class="floatnone"><a href="File_Threading_model.html" class="image" title="Threading model.jpg"><img alt="Threading model.jpg" src="https://processors.wiki.ti.com/images/c/cd/Threading_model.jpg" width="700" height="230" /></a></div></div>
<p>There is a fairly easy migration for existing code base - C/C++ based directives (#pragma) - used to express parallelism. OpenMP directives specify that a well-structured region of code is executed by a collection of threads that share in the work. Worksharing directives are provided to effect a distribution of work among the participating threads. The programmer incrementally adds OpenMP pragmas to an existing sequential application allowing them to quickly port code to a multicore platform.
</p><p>The following figure is an example of data-parallelism. A parallel-for loop where each thread executes a chunk of the loop and their intermediate results are reduced to a final result. A single copy of x[] and c[] is shared by all the threads.
</p>
<div class="center"><div class="floatnone"><a href="File_Parallel_for_with_reduction.html" class="image" title="Parallel for with reduction.jpg"><img alt="Parallel for with reduction.jpg" src="https://processors.wiki.ti.com/images/b/b2/Parallel_for_with_reduction.jpg" width="700" height="333" /></a></div></div>
<p>The following figure shows the OpenMP solution stack. The OpenMP API is made up of directives(#pragmas), function calls, and environment variables. The compiler translates the OpenMP API into multi-threaded code with calls to a custom runtime library that implements support for thread management, shared memory and synchronization.
</p><p>The OpenMP run-time for SYS/BIOS (OMP) library implements the bottom two layers of the OpenMP solution stack. Currently, OpenMP is supported on TI DSPs only for SYS/BIOS operating system. All OpenMP programs must be linked with the OMP run-time library.
</p>
<div class="center"><div class="floatnone"><a href="File_OpenMP_Solution_Stack.html" class="image" title="OpenMP Solution Stack.jpg"><img alt="OpenMP Solution Stack.jpg" src="https://processors.wiki.ti.com/images/1/10/OpenMP_Solution_Stack.jpg" width="400" height="446" /></a></div></div>
<p><br />See also:
</p>
<ul><li><a rel="nofollow" class="external free" href="http://openmp.org/wp/www.openMP.org">http://openmp.org/wp/www.openMP.org</a> for more tutorials, references, online tutorials for OpenMP programming</li></ul>
<p><br />
</p>
<h4><span class="mw-headline" id="Compiling_OpenMP_code_with_the_TI_compiler_using_Makefile">Compiling OpenMP code with the TI compiler using Makefile</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=127" title="Edit section: Compiling OpenMP code with the TI compiler using Makefile">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The TI compiler (version 7.4 or higher) includes support for OpenMP 3.0.
</p><p>To enable support for OpenMP in the compiler you will need to use the --openmp command line option.
</p><p>The number of threads available to an OpenMP program is determined by the configuration of the OMP run-time.
</p><p>Hello World example OpenMP program:
</p><p>&lt;syntaxhighlight lang="c"&gt;/* omp-hello.c */
</p>
<ol><li>include &lt;stdlib.h&gt;</li>
<li>include &lt;stdio.h&gt;</li>
<li>include &lt;ti/omp/omp.h&gt;</li>
<li>include &lt;ti/omp/libgomp_g.h&gt;</li></ol>
<p>int main (int argc, char *argv[]) {
</p>
<pre>int nthreads, tid;
</pre>
<pre>/* Fork a team of threads giving them their own copies of variables */
</pre>
<ol><li>pragma omp parallel private(nthreads, tid)</li></ol>
<pre>{
</pre>
<pre>/* Obtain thread number */
tid = omp_get_thread_num();
printf("Hello World from thread =&#160;%d\n", tid);
</pre>
<pre>/* Only master thread does this */
if (tid == 0)
{
nthreads = omp_get_num_threads();
printf("Number of threads =&#160;%d\n", nthreads);
}
</pre>
<pre>} /* All threads join master thread and disband */
</pre>
<pre>return 0;
</pre>
<p>}&lt;/syntaxhighlight&gt;
</p><p>You may generate prebuilt C libraries against which an OpenMP application can be compiled and linked. A typical build flow involves building the prebuilt library once for a given device (i.e. evm6678) and for a specific RTSC configuration.
</p><p>The files needed to generate the prebuilt libraries can be found in [OMP_INSTALL_DIR]\preconfig directory.
</p><p>1) Edit&#160;<b>ompdefault.cfg</b>&#160;as needed to match your desired RTSC configuration.
</p><p>2) Edit the&#160;<b>makeomplibs</b>&#160;file as needed:
</p><p>a. Point to your BIOS, IPC, PDK, XDCTools and OMP products
</p><p>b. Change the build profile as needed
</p><p>c. Change the build platform as needed
</p><p>3) Build the prebuilt libraries
</p><p>&lt;syntaxhighlight lang="bash"&gt;$ make -f makeomplibs omp-evm6678&lt;/syntaxhighlight&gt;
</p><p>4) Edit&#160;<b>Makefile</b>&#160;as follows:
</p><p>a. Edit the path to the C6x OpenMP-aware codegen tools
</p><p>b. Add application build goals to the Makefile using the example for omp_hello provided as a guideline.
</p><p>5) Build the application:&#160;&lt;syntaxhighlight lang="bash"&gt;$ make omp_hello.xe66&lt;/syntaxhighlight&gt;
</p><p>The above procedure would produce a hello.out core executable which needs to be loaded and run on CORE0 only.
</p>
<h4><span class="mw-headline" id="Using_OpenMP_on_TI_devices">Using OpenMP on TI devices</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=128" title="Edit section: Using OpenMP on TI devices">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<h5><span class="mw-headline" id="Memory_Coherency">Memory Coherency</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=129" title="Edit section: Memory Coherency">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>OpenMP has shared and private variables. Each thread has its own copy of a private variable that the other threads cannot access. OpenMP specifies a relaxed consistency shared memory model. Threads executing in parallel have a temporary view of shared memory until they reach memory synchronization or flush points in the execution flow.
</p>
<ul><li>It is currently the programmers responsibility to maintain the consistency of shared variables that are allocated to cachable memory. Something like:</li></ul>
<p>&lt;syntaxhighlight lang="c"&gt;/* process elements of shared_array in parallel*/
</p>
<ol><li>pragma omp parallel for</li></ol>
<pre>for (i=0; i&lt;N; i++)
shared_array[i] = do_stuff(shared_array[i]);
</pre>
<pre>/* write-back invalidate each thread/core's cache */
</pre>
<ol><li>pragma omp parallel</li></ol>
<pre>{
Cache_wbInvAll();
_mfence();
}&lt;/syntaxhighlight&gt;
</pre>
<ul><li>All global and static variables are shared. All dynamically allocated memory is shared.</li>
<li>Stacks must also be placed in shared memory since a stack variable can be shared.</li>
<li>If a variable is smaller than a cache line it is possible for two cores to cache the line that contains the variable. In this case, the last core to write the cache line will over-write in shared memory the other core's version of the variable.</li></ul>
<h5><span class="mw-headline" id="Threadprivate_Memory">Threadprivate Memory</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=130" title="Edit section: Threadprivate Memory">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<ul><li>The compiler allocates threadprivate variables into the .threadprivate section. The execution model assumes that the .threadprivate section is allocated by the linker into the L2 private memory.</li>
<li>The above restriction will be removed once the compiler tools implement support for thread local storage.</li>
<li>When using threadprivate, only one thread can be assigned to each core.</li></ul>
<h5><span class="mw-headline" id="Known_issues">Known issues</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=131" title="Edit section: Known issues">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<ul><li>The collapse clause is not supported</li>
<li>Error messages are sparse</li>
<li>Goto in/out of a parallel region is not flagged as an error</li></ul>
<p><br />
</p>
<h3><span class="mw-headline" id="Examples_2">Examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=132" title="Edit section: Examples">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The example programs are designed to familiarize you with the various steps required to create, compile, and run and OpenMP program. Besides these examples are are additional examples included under the OMP (e.g.,<i>\OMP_xx_xx_xx\packages\examples</i>).&#160;<br />
</p>
<h4><span class="mw-headline" id="Multicore_Hello_World_Example">Multicore Hello World Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=133" title="Edit section: Multicore Hello World Example">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This is the first example OpenMP program. It's purpose is to get you used to creating projects in CCS, building an executable and then running it on your EVM.
</p><p>1. The first step is to create a project in CCS for this example. To do so follow the steps below.
</p>
<ul><li>Open CCS (preferably with a new workspace).</li>
<li>Open&#160;<i>File-&gt;New-&gt;CCS Project</i>&#160;and in the project name field enter&#160;<i>HelloWorld_example</i>.</li>
<li>In the CCS project window, select&#160;<i>Project Type</i>: as&#160;<i>C6000</i>.</li>
<li>In the&#160;<i>New CCS Project</i>, select&#160;<i>Device Variant</i>: as&#160;<i>Generic C66xx Device</i>.</li>
<li>In the&#160;<i>Project Templates</i>&#160;window select&#160;<i>Empty RTSC Project</i>&#160;and hit&#160;<i>Next</i>. See figure below.</li>
<li>Configure your RTSC settings. The packages that need to be selected, are as per the snapshot in instruction #2 below.</li>
<li>It should open an empty project with name&#160;<i>HelloWorld_example</i>.</li></ul>
<p><br />
</p>
<dl><dd><dl><dd><a href="File_Import_OpenMPEx1Project.html" class="image" title="Import OpenMPEx1Project.JPG"><img alt="Import OpenMPEx1Project.JPG" src="https://processors.wiki.ti.com/images/e/ef/Import_OpenMPEx1Project.JPG" width="400" height="512" /></a></dd></dl></dd></dl>
<p><br />2. Configure your RTSC settings. The following packages needs to be selected as shown in the snapshot below: BIOS, IPC, OpenMP, PDK, and MCSDK:
</p>
<dl><dd><dl><dd><a href="File_MCSDK_components.html" class="image"><img alt="MCSDK components.JPG" src="https://processors.wiki.ti.com/images/c/cd/MCSDK_components.JPG" width="456" height="801" /></a><br /></dd></dl></dd></dl>
<p>3. Now that we have a project, we are going to create a source file for the project.
</p>
<ul><li>Select&#160;<i>File-&gt;New-&gt;Source File</i>, enter&#160;<i>Source File</i>&#160;name as&#160;<i>helloworld.c</i>, then hit&#160;<i>Finish</i>.</li>
<li>It should open&#160;<i>helloworld.c</i>&#160;empty file in the eclipse editor. Paste following source code in the editor</li></ul>
<p>&lt;syntaxhighlight lang="c"&gt;/******************************************************************************
</p>
<pre>* FILE: omp_hello.c
* DESCRIPTION:
* OpenMP Example - Hello World - C/C++ Version
* In this simple example, the master thread forks a parallel region.
* All threads in the team obtain their unique thread number and print it.
* The master thread only prints the total number of threads. Two OpenMP
* library routines are used to obtain the number of threads and each
* thread's number.
* AUTHOR: Blaise Barney 5/99
* LAST REVISED: 04/06/05
* UPDATED: For BIOS MCSDK
******************************************************************************/
</pre>
<ol><li>include &lt;ti/omp/omp.h&gt;</li></ol>
<ol><li>include &lt;string.h&gt;</li>
<li>include &lt;assert.h&gt;</li>
<li>include &lt;stdio.h&gt;</li>
<li>include &lt;time.h&gt;</li>
<li>include "ti/platform/platform.h"</li>
<li>include "ti/platform/resource_mgr.h"</li></ol>
<ol><li>define NTHREADS 8</li></ol>
<p>void main()
{
</p>
<pre>int nthreads, tid;
</pre>
<pre>nthreads = NTHREADS;
</pre>
<pre>omp_set_num_threads(NTHREADS);
</pre>
<pre>/* Fork a team of threads giving them their own copies of variables */
</pre>
<ol><li>pragma omp parallel private(nthreads, tid)</li></ol>
<pre>{
</pre>
<pre>/* Obtain thread number */
tid = omp_get_thread_num();
printf("Hello World from thread =&#160;%d\n", tid);
</pre>
<pre>/* Only master thread does this */
if (tid == 0)
{
nthreads = omp_get_num_threads();
printf("Number of threads =&#160;%d\n", nthreads);
}
</pre>
<pre>} /* All threads join master thread and disband */
</pre>
<p>}&lt;/syntaxhighlight&gt;<br />
</p><p><br />4. Create a new .cfg File by right clicking your project and selecting&#160;<i>New --&gt; File</i>. Name this file helloworld.cfg and copy the source code:
</p><p>&lt;syntaxhighlight lang="javascript"&gt;/*
</p>
<pre>* Copyright 2012 by Texas Instruments Incorporated.
*
*/
</pre>
<p>var OpenMP = xdc.useModule('ti.omp.utils.OpenMP');
var System = xdc.useModule("xdc.runtime.System");
var SysMin = xdc.useModule("xdc.runtime.SysMin");
System.SupportProxy = SysMin;
SysMin.bufSize = 0x8000;
</p><p>/* Increase local heap size */
var BIOS = xdc.useModule('ti.sysbios.BIOS');
BIOS.heapSize = 0x20000;
</p><p>/* Use more efficient Notify driver */
var Notify = xdc.module('ti.sdo.ipc.Notify');
Notify.SetupProxy = xdc.module('ti.sdo.ipc.family.c647x.NotifyCircSetup');
</p><p>/* Use more efficient MessageQ transport */
var MessageQ = xdc.module('ti.sdo.ipc.MessageQ');
MessageQ.SetupTransportProxy = xdc.useModule('ti.sdo.ipc.transports.TransportShmNotifySetup');
</p><p>var System = xdc.useModule('xdc.runtime.System');
System.extendedFormats = "%f";
</p><p>OpenMP.setNumProcessors(8);
</p><p>/* Create HeapOMP for shared heap */
var SharedRegion = xdc.useModule('ti.sdo.ipc.SharedRegion');
var HeapOMP = xdc.useModule('ti.omp.utils.HeapOMP');
HeapOMP.sharedRegionId = 2;
HeapOMP.localHeapSize  = 0x20000;
HeapOMP.sharedHeapSize = 0x1000000;
// Specify the Shared Region
SharedRegion.setEntryMeta( HeapOMP.sharedRegionId,
</p>
<pre>                          {   base: 0x90000000,
                              len:  HeapOMP.sharedHeapSize,
                              ownerProcId: 0,
                              createHeap: true,
                              isValid: true,
                              name: "HeapOMP",
                          }
                         );
</pre>
<p>var Cache        = xdc.useModule('ti.sysbios.family.c66.Cache');
Cache.setMarMeta(0x90000000, 0x10000000, Cache.PC | Cache.WTE );&lt;/syntaxhighlight&gt;
</p><p>5. Enable OpenMP compile option by right clicking your project and selecting Properties. Navigate to:&#160;<i>Build --&gt; C6000 Compiler --&gt; Advanced Options --&gt; Advanced Optimizations</i>. Tick the checkbox that says "Enable support for OpenMP 3.0 (--openmp, --omp)".
</p>
<dl><dd><dl><dd><a href="File_OpenMPEx1Project_EnableOMPCompile.html" class="image" title="OpenMPEx1Project EnableOMPCompile.JPG"><img alt="OpenMPEx1Project EnableOMPCompile.JPG" src="https://processors.wiki.ti.com/images/f/ff/OpenMPEx1Project_EnableOMPCompile.JPG" width="400" height="304" /></a></dd></dl></dd></dl>
<p>6. Build your project by right clicking your project and select&#160;<i>Build Project</i>.
</p><p>7. Connect and power your device. Launch your configuration file and connect to core0. For more information on connecting your device with CCS, refer to the 2.0.x User Guide.
</p><p>8. Load your helloworld program: select the core 0 and select&#160;<i>Run --&gt; Load --&gt; Load program</i>. Browse and select the .out program you compiled in step 6.
</p><p>9. Press run (the green triangle). You should see the following output:
</p>
<dl><dd><dl><dd><a href="File_OpenMPEx1Project_Output.html" class="image" title="OpenMPEx1Project Output.JPG"><img alt="OpenMPEx1Project Output.JPG" src="https://processors.wiki.ti.com/images/a/ac/OpenMPEx1Project_Output.JPG" width="400" height="224" /></a></dd></dl></dd></dl>
<p>Notes:
</p>
<ul><li>The number of cores available available to an OpenMP program is determined by the configuration of the OpenMP run-time using&#160;<i>OpenMP.setNumProcessors</i>. As an example, you can change&#160;<i>OpenMP.setNumProcessors</i>&#160;to a lower value and try running the Hello World again and see the number of print out change.</li></ul>
<h3><span class="mw-headline" id="OMP_Integration_for_Advanced_Users">OMP Integration for Advanced Users</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=134" title="Edit section: OMP Integration for Advanced Users">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If you are already familiar with OpenMP and TI BIOS MCSDK software, then please see&#160;<a href="OpenMP_Integration_in_existing_applications.html" title="OpenMP Integration in existing applications">OpenMP Integration in existing applications</a>&#160;for more information.
</p><p><br />
</p><p><br />
</p>
<h1><span class="mw-headline" id="Multi-core_Application_Image_Creation">Multi-core Application Image Creation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=135" title="Edit section: Multi-core Application Image Creation">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The standard TI compiler and linker create 'single' *.out files which can be loaded independently and run synchronously on the various cores through CCS or bootloaders. This can be cumbersome when attempting to load a multicore application through CCS and requires additional support infrastructure to boot the complete application.
</p><p>Packaged with the MCSDK is a collection of tools, called Multi-core Application Deployment (MAD) utilities, that allows a user to create a single loadable/bootable multicore application image from one or more standard *.out files generated by the compiler and linker. The generated multicore image can be loaded and run using CCS. In addition, the IBL provided as part of the MCSDK supports loading of MAD generated multicore application images hence provides a complete infrastructure for booting multicore applications.
</p><p>MAD is a collection of utilities intended to support a broad range of multicore use cases. More details can be found here in the <a rel="nofollow" class="external text" href="MAD_Utils_User_Guide.html">MAD Utils User Guide</a>.
</p><p>See also:
</p><p>An example of an MCSDK application that uses MAD is the <a href="MCSDK_Image_Processing_Demonstration_Guide.html" title="MCSDK Image Processing Demonstration Guide">Image Processing Demo Guide</a>.
</p>
<h1><span class="mw-headline" id="Booting_and_Flash">Booting and Flash</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=136" title="Edit section: Booting and Flash">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<h2><span class="mw-headline" id="Boot_Overview">Boot Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=137" title="Edit section: Boot Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The MCSDK includes a Tools Package which provides POST,&#160;boot loader&#160;and boot utilities for use with the TI EVMs and are intended to serve as example/reference for customers.
</p><p><br />The MCSDK tools package is located in the C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools directory and includes:
</p>
<ul><li><b>POST</b>: Power on Self Test application.</li>
<li><b>IBL</b>: 1st stage and 2nd stage Bootloader for booting an application from the NOR/NAND flash or Ethernet over I2C EEPROM.</li>
<li><b>MAD</b>: Multicore application deployment tool to support multicore booting.</li>
<li><b>Boot Examples</b>: Example projects demonstrating the booting of an user application using the boot loader.</li>
<li><b>Writer Utilities</b>: Utilities to program an application image to flash or EEPROM.</li>
<li><b>Other Utilities</b>: Utilities to do file format conversion that are required by the boot examples.&#160;</li></ul>
<h2><span id="Power_On_Self_Test_(POST)"></span><span class="mw-headline" id="Power_On_Self_Test_.28POST.29">Power On Self Test (POST)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=138" title="Edit section: Power On Self Test (POST)">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The Power-On Self Test (POST) boot is designed to execute a series of platform/EVM factory tests on reset and indicate a PASS/FAIL condition using the LEDs and write test result to UART. A PASS result indicates that the EVM can be booted. The POST application resides on the EEPROM of the EVM, therefore the size of the image has to be less than 64 KB.
</p><p>POST will perform the following functional tests:
</p>
<ul><li>External memory read/write test</li>
<li>NAND read test</li>
<li>NOR read test</li>
<li>EEPROM read test</li>
<li>UART write test</li>
<li>Ethernet loopback test</li>
<li>LED test</li></ul>
<p>Additionally, POST provides the following useful information:
</p>
<ul><li>FPGA version</li>
<li>Board serial number</li>
<li>EFUSE MAC ID</li>
<li>Indication of whether SA is available on SOC</li>
<li>PLL Reset Type status register</li></ul>
<div class="block-note"><span class="block-contents"><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b> POST is not intended to perform functional tests of the DSP.</span></div>
<p>At power on, the DSP starts execution with bootrom which transfers execution to the POST boot program from EEPROM using the I2C slave bus address as 0x50. The POST will then run through a sequence of platform tests. Upon power on, all the 4 FPGA debug LEDs will be on by default, remain ON for approximately 10 sec, then turn OFF if all the tests complete successfully. If any of the tests fails, the LED(s) will blink.
</p><p>Below is the LED status table showing the test status/result:
</p>
<table width="445" cellpadding="1" border="5" style="width: 445px; height: 489px">

<tbody><tr>
<th scope="col">Test Result
</th>
<th width="40" scope="col">LED1
</th>
<th scope="col">LED2
</th>
<th scope="col">LED3
</th>
<th scope="col">LED4
</th></tr>
<tr>
<td>Test in progress
</td>
<td>on
</td>
<td>on
</td>
<td>on
</td>
<td>on
</td></tr>
<tr>
<td>All tests passed
</td>
<td>off
</td>
<td>off
</td>
<td>off
</td>
<td>off
</td></tr>
<tr>
<td>External memory test failed
</td>
<td>blink
</td>
<td>off
</td>
<td>off
</td>
<td>off
</td></tr>
<tr>
<td>I2C EEPROM read failed
</td>
<td>off
</td>
<td>blink
</td>
<td>off
</td>
<td>off
</td></tr>
<tr>
<td>EMIF16 NAND read failed
</td>
<td>off
</td>
<td>off
</td>
<td>blink
</td>
<td>off
</td></tr>
<tr>
<td>SPI NOR read failed
</td>
<td>off
</td>
<td>off
</td>
<td>off
</td>
<td>blink
</td></tr>
<tr>
<td>UART write failed
</td>
<td>blink
</td>
<td>blink
</td>
<td>off
</td>
<td>off
</td></tr>
<tr>
<td>EMAC loopback failed
</td>
<td>off
</td>
<td>blink
</td>
<td>blink
</td>
<td>off
</td></tr>
<tr>
<td>PLL initialization failed
</td>
<td>off
</td>
<td>off
</td>
<td>blink
</td>
<td>blink
</td></tr>
<tr>
<td>NAND initialization failed
</td>
<td>blink
</td>
<td>blink
</td>
<td>blink
</td>
<td>off
</td></tr>
<tr>
<td>NOR initialization failed
</td>
<td>off
</td>
<td>blink
</td>
<td>blink
</td>
<td>blink
</td></tr>
<tr>
<td>EMAC loopback failed
</td>
<td>on
</td>
<td>blink
</td>
<td>blink
</td>
<td>blink
</td></tr>
<tr>
<td>Other failures
</td>
<td>blink
</td>
<td>blink
</td>
<td>blink
</td>
<td>blink
</td></tr></tbody></table>
<p><br />
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  POST should only be programmed to EEPROM I2C bus address 0x50 (please refer to C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\post\docs\README.txt on how to build POST and program POST to EEPROM), to execute the POST you must ensure the boot DIP switches for your platform are properly configured to boot from I2C master mode, bus address 0x50 (please refer to the C667x EVM technical reference manual and C667x device data sheet for the boot mode configurations). The POST will put board information and test result on the UART console.
</p><p><a href="File_Post.html" class="image" title="post.jpg"><img alt="post.jpg" src="https://processors.wiki.ti.com/images/7/73/Post.jpg" width="300" height="288" /></a>
</p><p><br />
</p>
<h2><span id="Intermediate_Boot_Loader_(IBL)_and_Examples"></span><span class="mw-headline" id="Intermediate_Boot_Loader_.28IBL.29_and_Examples">Intermediate Boot Loader (IBL) and Examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=139" title="Edit section: Intermediate Boot Loader (IBL) and Examples">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Below is the table showing the boot modes supported by the C66x EVMs:
</p><p><br />
</p>
<table width="50%" cellpadding="2" border="5">

<tbody><tr>
<th scope="col">Boot Mode
</th>
<th scope="col">TMDSEVM6678
</th>
<th scope="col">TMDSEVM6670
</th>
<th scope="col">TMDSEVM6618
</th>
<th scope="col">TMDXEVM6657
</th></tr>
<tr>
<td>NOR boot via IBL over I2C<sup>1</sup>
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>NAND boot via IBL over I2C<sup>1</sup>
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>TFTP boot via IBL over I2C<sup>1</sup>
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>I2C POST boot<sup>2</sup>
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>Ethernet boot
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>SRIO boot
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>PCIe boot
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td></tr></tbody></table>
<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b> 
</p>
<ol><li>Support boot over I2C bus address 0x51</li>
<li>Support POST boot over I2C bus address&#160;0x50</li>
<li>Only&#160;ELF and BBLOB images are supported for booting</li>
<li>IBL is using the first 128KB L2 local memory, any application booting from IBL should NOT use the first 128KB L2 memory, OR should only use the first 128KB L2 memory for uninitialized data section</li></ol>
<p><br />
</p>
<p><br /><b>NAND Boot</b></p><div class="thumb tright"><div class="thumbinner" style="width:502px;"><a href="File_Nandboot.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/0/05/Nandboot.jpg" width="500" height="226" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Nandboot.html" class="internal" title="Enlarge"></a></div>Nandboot.jpg</div></div></div>
<p>NAND boot is a multi-stage process which is designed to boot an application from NAND flash after reset. Figure below illustrates the elements of the NAND boot process.
</p><p>On reset the DSP starts execution with the bootrom which transfers execution to the secondary bootloader from EEPROM using the I2C slave bus address&#160;0x51. The secondary bootloader loads the application program from NAND flash then transfers control to the application. To execute the NAND bootloader you must ensure the DIP switches for your platform are properly configured for I2C Master Boot and address&#160;0x51, AND the&#160;boot parameter&#160;index dip switch should be set to 2 or 3.
</p><p>NAND boot supports multiple images booting<sup>1</sup>. Depending on the boot parameter index dip switch, maximum&#160;2 boot images can be supported. By default NAND boot only supports a BBLOB image format, if the customer wants to boot an ELF image,&#160; the IBL configuration table needs to be modified and re-programmed to EEPROM.
</p><p>Please refer to C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\boot_loader\examples\i2c\nand\docs\README.txt on how to build an Hello World example application and program it to NAND, and boot the Hello World image from the NAND flash.
</p>
<p><br /><b>NOR Boot</b> </p><div class="thumb tright"><div class="thumbinner" style="width:502px;"><a href="File_Norboot.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/0/0a/Norboot.jpg" width="500" height="177" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Norboot.html" class="internal" title="Enlarge"></a></div>Norboot.jpg</div></div></div>
<p>NOR boot is a multi-stage process which is designed to boot an application from NOR flash after reset. Figure below illustrates the elements of the NOR boot process.
</p><p>On reset the DSP starts execution with the bootrom which transfers execution to the secondary bootloader from EEPROM using the I2C slave address 0x51. The secondary bootloader loads the application program from NOR flash then transfers control to the application. To execute the NOR bootloader you must ensure the DIP switches for your platform are properly configured for I2C Master Boot and address&#160;0x51, AND the boot parameter index switch should be set to 0 or 1.
</p><p>NOR boot supports multiple images booting<sup>1</sup>. Depending on the boot parameter index dip switch, maximum&#160;2 boot images can be supported.
</p><p>Please refer to C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\boot_loader\examples\i2c\nor\docs\README.txt on how to build an Hello World example application and program it to NOR, and boot the Hello World image from the NOR flash.
</p><p><br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b> 
</p>
<ol><li>Not supported in Beta-1 release<br /></li></ol>
<p><b>TFTP Boot </b></p><b><div class="thumb tright"><div class="thumbinner" style="width:502px;"><a href="File_Emacboot.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/4/43/Emacboot.jpg" width="500" height="177" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Emacboot.html" class="internal" title="Enlarge"></a></div>Emacboot.jpg</div></div></div></b>
<p>EMAC boot is a multi-stage process which is designed to boot an application from TFTP server after reset. Figure below illustrates the elements of the EMAC boot process.
</p><p>On reset the DSP starts execution with the bootrom which transfers execution to the secondary bootloader from EEPROM using the I2C slave address&#160;0x51. The secondary bootloader loads the application program from a remote TFTP server then transfers control to the application. To execute the EMAC bootloader you must ensure the DIP switches for your platform are properly configured for I2C Master Boot and address&#160;0x51, AND&#160;the boot parameter index switch should be set to&#160;4. By default EMAC boot only supports a BBLOB image format, if the customer wants to boot an ELF image, the IBL configuration table needs to be modified and re-programmed to EEPROM.
</p><p>Please refer to C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\boot_loader\examples\i2c\emac\docs\README.txt on how to build an Hello World example application and boot the Hello World image from a remote TFTP server.
</p><p><br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b> 
</p><p>Please refer to the boot mode dip switch settings for different boot mode on <a rel="nofollow" class="external text" href="http://software-dl.ti.com/processor-sdk-rtos/esd/docs/latest/rtos/index_how_to_guides.html#tmdxevm6678l-evm-hardware-setup-guide#Boot_Mode_Dip_Switch_Settings">TMDSEVM6678L_EVM </a>, <a rel="nofollow" class="external text" href="TMDXEVM6670L_EVM_Hardware_Setup.html#Boot_Mode_Dip_Switch_Settings">TMDSEVM6670L_EVM </a>, and <a rel="nofollow" class="external text" href="TMDXEVM6657L_EVM_Hardware_Setup.html#Boot_Mode_Dip_Switch_Settings">TMDSEVM6657L_EVM </a> that IBL supports.<br />
</p><p><br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b> 
</p><p>IBL is flashed into I2C EEPROM bus address 0x51. IBL provides a workaround for the PLL lockup issue (please refer to C6678 errata document, February 2011, advisory 8 for details on the PLL lockup issue). For ROM boot modes (EMAC,SRIO,PCIe,Hyperlink etc) and I2C boot mode with bus address 0x50, DSP will initially boot from I2C EEPROM bus address 0x51 which does the PLL reset workaround, updates the DEVSTAT for appropriate values based on the DIP switch settings (SW3 through SW6 settings) and then re enters the ROM to accomplish the desired boot mode. Please note that the re entry is done for all boot modes except for PCIe boot mode and I2C boot mode with bus address 0x51.
</p><p>Below are the steps done in the IBL:<br />
</p>
<ol><li>FPGA samples the bootmode pins</li>
<li>FPGA forces the DSP to boot via I2C bus address 0x51</li>
<li>PLL is initialized correctly by the IBL on the I2C.</li>
<li>IBL reads the sampled bootmode from an FPGA register.</li>
<li>IBL checks the bootmode, if it is not I2C boot or it is I2C boot but with bus address 0x50, IBL writes bootmode into the DEVSTAT register</li>
<li>IBL then checks if the bootmode is PCIE boot or not. If it is, it executes some PCIE workaround to configure the PCIE registers (mainly to accept spread spectrum clock) and stays inside IBL waiting for PCIe boot.</li>
<li>If it is not PCIE boot mode, IBL writes the Boot ROM entry address into the DSP Program Counter, DSP executes the desired internal ROM boot mode or boot from I2C bus address 0x50 as normal.</li></ol>
<p><br />
</p><p><b>Updating the IBL Ethernet Configurations</b>
</p><p>As of MCSDK 2.0.5.17, there are two ways to update the IBL ethernet configurations for ethernet boot.
</p><p><i>Using CCS</i> <br /> Please follow the steps as mentioned under section <a rel="nofollow" class="external text" href="BIOS_MCSDK_2-2.html#IBL">IBL</a>and follow steps 10 through 14. Please note that the i2cConfig.gel file can be modified via a text editor before loading and running the script in CCS. Please note that this gel file contains configuration settings for multiple devices and multiple boot modes.
</p><p><i>Using iblConfig Utility Program</i><br /> The second way to update the IBL ethernet configurations is to use iblConfig.out. This utility program is located under mcsdk_2_00_xx_xx\tools\boot_loader\ibl\src\util\iblConfig\build. In command line, use the "make" program with the given Makefile to generate iblConfig.out and input.txt. Please be sure to fill in the parameters for input.txt before running iblConfig.out; below is an example of input.txt:
</p>
<pre>file_name = ibl.bin
device = 6
offset = 0x500
ethBoot-doBootp = TRUE
ethBoot-bootFormat = ibl_BOOT_FORMAT_ELF
ethBoot-ipAddr = 192.168.1.3
ethBoot-serverIp = 192.168.1.2
ethBoot-gatewayIp = 192.168.1.1
ethBoot-netmask = 255.255.255.0
ethBoot-fileName =
</pre>
<p>The first 3 parameters must be filled in for iblConfig.out to work:
</p>
<ul><li>file_name refers to the IBL binary file to update. This file must be in the same directory as iblConfig.out.</li>
<li>device refers to the device being used. Please enter <b>6 for C6678, 7 for C6670, and 8 for C6657</b>.</li>
<li>offset refers to an offset space in the IBL. The value is 0x500 for C6678, C6670, and C6657</li></ul>
<p>The ethernet parameters (the entries beginning with ethBoot) refer to specific ethernet configurations. If they are not specified, they will be defaulted to the values in the mcsdk_2_00_xx_xx\tools\boot_loader\ibl\src\util\iblConfig\src\device.h file. In the example above, the ethernet boot file name will be defaulted to c6678-le.bin when iblConfig.out is run.
</p><p>After running iblConfig.out and updating the IBL binary, you must flash the modified IBL binary to your EVM. You can do this as part of program_evm (refer to section <a rel="nofollow" class="external text" href="BIOS_MCSDK_2-2.html#Using_Program_EVM">Using Program Evm</a>) or you can flash it individually using eepromwriter (refer to section <a rel="nofollow" class="external text" href="BIOS_MCSDK_2-2.html#IBL">IBL</a>). <br /> <img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  If you updated the IBL with iblConfig and flashed it with eepromwriter, you should <b>NOT</b> use i2cparam_0x51_c667#_le_0x500.out and iblConfig.gel - this would overwrite the changes you made to the IBL.
</p>
<h2><span class="mw-headline" id="Flash_and_Flash_Utilities">Flash and Flash Utilities</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=140" title="Edit section: Flash and Flash Utilities">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following boot utilities for loading code into the EEPROM, NOR and NAND are provided as part of the Tools Package with the MCSDK. All source code is provided along with documentation so that customers can port to other environments as necessary or to make modifications and enhancements.
</p>
<ul><li><b>romparse</b>: Utility which converts either the IBL or POST out files into an image format that can be writtent to the EEPROM using the EEPROM writer utility. This utility is specific to Microsoft Windows and generates an image format that MUST be loaded into CCS memory. Romparse utility is located under C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\boot_loader\ibl\src\util\romparse directory.</li>
<li><b>i2cConfig</b>: Utility for writing the IBL boot parameter configuration tables to the I2C EEPROM. The configuration table configures the IBL to boot the image from NOR, NAND or EMAC based on the boot priority. This utility executes on the EVM using CCS and JTAG. i2cConfig utility is located under C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\boot_loader\ibl\src\util\i2cConfig directory.</li>
<li><b>EEPROM Writer</b>: Utility for writing to the EEPROM. This utility executes on the EVM using CCS and JTAG and it is located under C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\writer\eeprom\evmc6678l\bin directory.</li>
<li><b>NOR Writer</b>: Utility for writing to the NOR flash. This utility executes on the EVM using CCS and JTAG and it is located under C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\writer\nor\evmc6678l\bin directory.</li>
<li><b>NAND Writer</b>: Utility for writing to the NAND flash. This utility executes on the EVM using CCS and JTAG and it is located under C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\writer\nand\evmc6678l\bin directory.</li></ul>
<table border="1">
<tbody><tr>
<td>
<div class="floatleft"><a href="File_Helpful_tips_image.html" class="image"><img alt="Helpful tips image.jpg" src="https://processors.wiki.ti.com/images/5/5c/Helpful_tips_image.jpg" width="75" height="76" /></a></div> 
<p><span style="color: Red"><b>Useful Tip</b></span>
</p><p>Starting in BIOS-MCSDK 2.1.1, the program_evm utility provides the ability to format the NAND (i.e., permanently erase the entire NAND device). Please refer to program_evm_userguide.pdf (located in the mcsdk_2_00_xx_xx\tools\program_evm\ directory) for more information.
</p>
</td></tr></tbody></table>
<p><br />
</p>
<h3><span id="Programming_I2C_EEPROM_(address_0x51)_with_IBL_and_boot_configuration_table1"></span><span class="mw-headline" id="Programming_I2C_EEPROM_.28address_0x51.29_with_IBL_and_boot_configuration_table1">Programming I2C EEPROM (address 0x51) with IBL and boot configuration table<sup>1</sup></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=141" title="Edit section: Programming I2C EEPROM (address 0x51) with IBL and boot configuration table1">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Please refer to C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\boot_loader\ibl\doc\README.txt on how to build IBL and program IBL and boot parameter configuration table to EEPROM bus address 0x51.
</p>
<h3><span id="Programming_I2C_EEPROM_(address_0x50)_with_POST_boot1"></span><span class="mw-headline" id="Programming_I2C_EEPROM_.28address_0x50.29_with_POST_boot1"><br />Programming I2C EEPROM (address 0x50) with POST boot<sup>1</sup></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=142" title="Edit section: Programming I2C EEPROM (address 0x50) with POST boot1">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Please refer to C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\post\docs\README.txt on how to build POST and program POST to EEPROM bus address 0x50.<br />
</p>
<h3><span class="mw-headline" id="Flashing_NOR_FLASH_with_a_user_application_for_NOR_boot_over_I2C">Flashing NOR FLASH with a user application for NOR boot over I2C</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=143" title="Edit section: Flashing NOR FLASH with a user application for NOR boot over I2C">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Please refer to C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\writer\nor\docs\README.txt on how to program a user application to NOR.<br />
</p>
<h3><span class="mw-headline" id="Flashing_NAND_FLASH_with_a_user_application_for_NAND_boot_over_I2C">Flashing NAND FLASH with a user application for NAND boot over I2C</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=144" title="Edit section: Flashing NAND FLASH with a user application for NAND boot over I2C">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Please refer to C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\writer\nand\docs\README.txt on how to program a user application to NAND.
</p><p><br />
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b> 
</p>
<ol><li>If the customer wants to user their own EEPROM writer to write a raw binary file to the EEPROM, they can use the C:\Program Files\Texas Instruments\mcsdk_2_00_00_xx\tools\boot_loader\ibl\src\util\btoccs\ccs2bin utility to convert the .dat to .bin either with byte swapping or without swapping depending on the data format their EEPROM writer uses.</li></ol>
<p><br />
</p>
<h1><span class="mw-headline" id="Technical_Support_and_Product_Updates">Technical Support and Product Updates</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=145" title="Edit section: Technical Support and Product Updates">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<h2><span class="mw-headline" id="Technical_Support_and_Forums">Technical Support and Forums</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=146" title="Edit section: Technical Support and Forums">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>For technical discussions and issues, please visit
</p>
<ul><li><b>KeyStone Multicore forum</b>: <a rel="nofollow" class="external free" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/f/639.aspx">http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/f/639.aspx</a></li>
<li><b>TI-RTOS forum</b>: <a rel="nofollow" class="external free" href="http://e2e.ti.com/support/embedded/f/355.aspx">http://e2e.ti.com/support/embedded/f/355.aspx</a></li>
<li><b>Code Composer Studio forum</b>: <a rel="nofollow" class="external free" href="http://e2e.ti.com/support/development_tools/code_composer_studio/f/81/t/3131.aspx">http://e2e.ti.com/support/development_tools/code_composer_studio/f/81/t/3131.aspx</a></li>
<li><b>TI C/C++ Compiler forum</b>: <a rel="nofollow" class="external free" href="http://e2e.ti.com/support/development_tools/compiler/f/343/t/34317.aspx">http://e2e.ti.com/support/development_tools/compiler/f/343/t/34317.aspx</a></li>
<li><b>Embedded Processors wiki</b>: <a href="Main_Page.html" title="Main Page">http://processors.wiki.ti.com</a></li></ul>
<p>For local support in China, please visit
</p>
<ul><li><b>China Support forum</b>: <a rel="nofollow" class="external free" href="http://www.deyisupport.com/">http://www.deyisupport.com</a></li></ul>
<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b> When asking for help in the forum you should tag your posts in the Subject with MCSDK, the part number (e.g. C6678) and additionally the component (e.g. NDK). 
</p>
<table border="1">
<tbody><tr>
<td>
<div class="floatleft"><a href="File_Helpful_tips_image.html" class="image"><img alt="Helpful tips image.jpg" src="https://processors.wiki.ti.com/images/5/5c/Helpful_tips_image.jpg" width="75" height="76" /></a></div> 
<p><span style="color: Red"><b>Useful Tip</b></span>
</p><p>You can always get the most recent version of this document on the Texas Instruments Embedded Processors Wiki.  See the page titled <a class="mw-selflink selflink">BIOS MCSDK 2.0 User Guide</a> for the most up to date revision.
</p>
</td></tr></tbody></table>
<p><br />
</p>
<h2><span class="mw-headline" id="Product_Updates">Product Updates</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=147" title="Edit section: Product Updates">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>There are various ways to receive updates for MCSDK. They are oulined in the following sections.
</p>
<h3><span class="mw-headline" id="MCSDK_Product_Folder">MCSDK Product Folder</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=148" title="Edit section: MCSDK Product Folder">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<ul><li>Visit <b>Multicore Software Development Kits</b>: <a rel="nofollow" class="external free" href="http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html">http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html</a></li>
<li>Use the <b>CCS/Eclipse Update Manager</b></li></ul>
<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The EVM comes with disks containing the MCSDK software and CCS. You can start with these or go to the MCSDK software download site listed above to check for the latest updates and version. The BIOS-MCSDK release download will also have pointers to applicable CCS and compiler release versions as well. Please review the release notes and software manifest before downloading and/or installing the software.
</p>
<h3><span class="mw-headline" id="Eclipse_Update_Manager">Eclipse Update Manager</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=149" title="Edit section: Eclipse Update Manager">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The BIOS MCSDK utilizes Eclipse Update Manager in CCS to detect, download, and install updates in an automated fashion. Eclipse provides various controls for this process -- from manually checking for updates to periodically checking for updates. In the event you can not update via Eclipse using the Eclipse Update Manager, please visit the Texas Instruments software download site for MCSDK: <a rel="nofollow" class="external free" href="http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html">http://focus.ti.com/docs/toolsw/folders/print/bioslinuxmcsdk.html</a>
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  If you are running CCS on Linux, make sure you have write permissions to CCS folders before doing Eclipse updates. If you installed CCS with root permission, please launch CCS with root permission before updating. Incompatible write permissions will prevent CCS's update plugin to update your files correctly.
</p><p><b>Eclipse Update (Automatic)</b>
</p>
<ol><li>Please make sure the <b>MCSDK 2x</b> box is checked in the <i>available software sites</i> of CCS, before clicking <i>check for updates</i> using the CCS help menu.</li>
<li>After CCS re-starts it should recognize MCSDK and can check its update site using the Eclipse Update Manager</li>
<li>When the Update Manager connects you will have the option to download the updated release of BIOS MCSDK</li>
<li>After downloading, CCS will shut down and run the updated BIOS MCSDK installer</li>
<li>After installation, CCS will be re-started and updated BIOS MCSDK content will be installed</li></ol>
<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  For the Eclipse update to work you must have Eclipse Updates enabled. You may also have it set to check on a periodic basis. If so, you may need to run the Update Manager to get the update immediately from "Help/Check for Update" as shown in the picture below:
</p><p><a href="File_CCSHelp_CheckForUpdates.html" class="image" title="Figure 3: Check for Updates in CCS Help Menu"><img alt="Figure 3: Check for Updates in CCS Help Menu" src="https://processors.wiki.ti.com/images/8/8a/CCSHelp_CheckForUpdates.jpg" width="300" height="241" /></a>
</p><p><b>Eclipse Update (Manual)</b>
</p><p>If automatic update does not work, or you wish to just search for an update to MCSDK, do the following, after installing MCSDK.
</p>
<ol><li>Start CCS, and select Window-&gt;Preferences</li>
<li>In the left pane select and expand Install/Update, then select Available Software Sites</li></ol>
<p><a href="File_CCSWin_InstallUpdate.html" class="image" title="Figure 4: Install/Updates in CCS Preferences Menu"><img alt="Figure 4: Install/Updates in CCS Preferences Menu" src="https://processors.wiki.ti.com/images/2/2d/CCSWin_InstallUpdate.jpg" width="300" height="199" /></a>
</p>
<ol><li>It will open a list of avilable software sites</li>
<li>In the list find and check URL <a rel="nofollow" class="external free" href="http://software-dl.ti.com/sdoemb/sdoemb_public_sw/bios_mcsdk/eclipse/mcsdk2x/">http://software-dl.ti.com/sdoemb/sdoemb_public_sw/bios_mcsdk/eclipse/mcsdk2x/</a>, the Enabled column should change to Enabled. You can also enter a name for the site but its not required.</li></ol>
<p><a href="File_CCSWin_AvailableSw.html" class="image" title="Figure 5: Available Software updates in CCS Preferences Menu"><img alt="Figure 5: Available Software updates in CCS Preferences Menu" src="https://processors.wiki.ti.com/images/9/92/CCSWin_AvailableSw.jpg" width="300" height="199" /></a>
</p>
<ol><li>Select OK to close the window</li>
<li>Then select Help-&gt;Install New Software , In the Work with: select the above URL from the drop down menu</li></ol>
<p><a href="File_CCSInst_AvailableSw.html" class="image" title="Figure 6: Available Software Installation in CCS"><img alt="Figure 6: Available Software Installation in CCS" src="https://processors.wiki.ti.com/images/6/63/CCSInst_AvailableSw.jpg" width="400" height="314" /></a>
</p>
<ol><li>Check the URL in Name and select Finish</li>
<li>The CCS should discover new MCSDK release to install</li></ol>
<h1><span class="mw-headline" id="Frequently_Asked_Questions">Frequently Asked Questions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=150" title="Edit section: Frequently Asked Questions">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<h2><span id="Q:_How_can_I_get_the_EVM_back_to_factory_default_state?"></span><span class="mw-headline" id="Q:_How_can_I_get_the_EVM_back_to_factory_default_state.3F">Q: How can I get the EVM back to factory default state?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=151" title="Edit section: Q: How can I get the EVM back to factory default state?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To flash the EVM to its factory defaults, refer to the <i>program_evm.pdf</i> document located in the<i>\factory_images\</i> folder from the DVD that came with the EVM. If you have misplaced the DVD, this folder can be downloaded directly from the EVM manufacturer site: <a rel="nofollow" class="external text" href="http://wfcache.advantech.com/support/TMDXEVM6678L_Factory_Images.zip">TMDSEVM6678</a>,<a rel="nofollow" class="external text" href="http://wfcache.advantech.com/support/6670/TMDXEVM6670L_Factory_images.zip">TMDSEVM6670</a>, TMDXEVM6657 (TBD).
</p><p>After successfully flashing, the EVM will be restored to its original NOR, NAND, and EEPROM binaries.
</p>
<h2><span id="Q:_I_have_just_updated_my_BIOS_MCSDK_software,_how_do_I_load_it_to_my_EVM?"></span><span class="mw-headline" id="Q:_I_have_just_updated_my_BIOS_MCSDK_software.2C_how_do_I_load_it_to_my_EVM.3F">Q: I have just updated my BIOS MCSDK software, how do I load it to my EVM?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=152" title="Edit section: Q: I have just updated my BIOS MCSDK software, how do I load it to my EVM?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Setup the boot mode to <i>No Boot</i> mode by having the dip switches as the following for updating the images to EVM's flash area:
</p>
<table class="FCK&#95;_ShowTableBorders" border="0" cellspacing="1" cellpadding="2" width="700" align="center">
<caption><b>No Boot mode DIP SW Settings</b>
</caption>
<tbody><tr>
<td>Pin#
</td>
<td><div style="text-align: center">1&#160;&#160;&#160;&#160;2&#160;&#160;&#160;&#160;3&#160;&#160;&#160;&#160;4</div>
</td>
<td><div style="text-align: center">1&#160;&#160;&#160;&#160;2&#160;&#160;&#160;&#160;3&#160;&#160;&#160;&#160;4</div>
</td>
<td><div style="text-align: center">1&#160;&#160;&#160;&#160;2&#160;&#160;&#160;&#160;3&#160;&#160;&#160;&#160;4</div>
</td>
<td><div style="text-align: center">1&#160;&#160;&#160;&#160;2&#160;&#160;&#160;&#160;3&#160;&#160;&#160;&#160;4</div>
</td></tr>
<tr>
<td>State
</td>
<td><div style="text-align: center">OFF-ON-ON-ON</div>
</td>
<td><div style="text-align: center">ON-ON-ON-ON</div>
</td>
<td><div style="text-align: center">ON-ON-ON-ON</div>
</td>
<td><div style="text-align: center">ON-ON-ON-ON</div>
</td></tr>
<tr>
<td>Switch
</td>
<td><div style="text-align: center">SW3</div>
</td>
<td><div style="text-align: center">SW4</div>
</td>
<td><div style="text-align: center">SW5</div>
</td>
<td><div style="text-align: center">SW6</div>
</td></tr></tbody></table>
<p><br /> <img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Pin 1 of SW3 is the endian switch - when set to <b>OFF</b> put the EVM into <i>Little Endian</i> Mode and <b>ON</b> puts the EVM into <i>Big Endian</i> Mode.
</p>
<h3><span class="mw-headline" id="Using_Program_EVM">Using Program EVM</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=153" title="Edit section: Using Program EVM">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>As of BIOS MCSDK 2.0.5, there exists a convenient script in the mcsdk_2_00_xx_xx\tools\ directory to update all the images automatically via command line. Follow the steps in program_evm_userguide.pdf (located in the mcsdk_2_00_xx_xx\tools\program_evm\ directory) to flash the new images. The images that are loaded are kept in the .\program_evm\binaries\evm66xxl\ directory; you can substitute any image here.
</p>
<table border="1">
<tbody><tr>
<td>
<div class="floatleft"><a href="File_Helpful_tips_image.html" class="image"><img alt="Helpful tips image.jpg" src="https://processors.wiki.ti.com/images/5/5c/Helpful_tips_image.jpg" width="75" height="76" /></a></div> 
<p><span style="color: Red"><b>Useful Tip</b></span>
</p><p>To avoid updating CCS from the version that came with the EVM, you can use the program_evm tool found on the EVM DVD and substitute newer images in the binaries\evm66xxl\ directory.
</p>
</td></tr></tbody></table>
<p><br /> <img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The NAND image for the Linux kernel is not provided with the BIOS MCSDK release.
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The DSS script under program_evm directory is using the default ccxml files that are created under CCS 5.0.3; So, for CCS 5.1 please provide the customized ccxml file that user created; Example steps below are for a Windows PC for C6670 EVM XDS560V2 mezzanine card. Please follow similar steps for using the dss script for CCS 5.1 under Linux.
</p>
<ol><li>program_evm&gt;set PROGRAM_EVM_TARGET_CONFIG_FILE=C:\Documents and Settings\user\CCSTargetConfigurations\evmc6670_CCS51_mezzanine.ccxml (note that there are no double quotes to be given in this path)</li>
<li>program_evm&gt;set DSS_SCRIPT_DIR="C:\ti\ccsv5\ccs_base\scripting\bin" (please observe the double quotes in the path here)</li>
<li>program_evm&gt;%DSS_SCRIPT_DIR%\dss.bat program_evm.js TMDSEVM6670Le-Le</li></ol>
<h2><span id="Q:_Can_I_update_the_new_images_individually_instead_of_using_Program_EVM?"></span><span class="mw-headline" id="Q:_Can_I_update_the_new_images_individually_instead_of_using_Program_EVM.3F">Q: Can I update the new images individually instead of using Program EVM?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=154" title="Edit section: Q: Can I update the new images individually instead of using Program EVM?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Yes. Setup your EVM to <i>No Boot</i> mode as described in the previous question. Then follow the instructions for the EEPROM/NOR/NAND images:
</p>
<h3><span class="mw-headline" id="Updating_EEPROM_Images">Updating EEPROM Images</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=155" title="Edit section: Updating EEPROM Images">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The EEPROM images are IBL (intermediate boot loader) and Power On Self Test (POST). The IBL/POST is often updated with MCSDK releases. Follow these instructions to update the EVM to the newer IBL and POST images: IBL is flashed at EEPROM 0x51 address and POST is flashed at EEPROM 0x50 address.
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  <b>For MCSDK version 2.0.3 and prior, .dat files are provided instead of .bin files. If you are using MCSDK version 2.0.3 or prior, please follow the instructions provided here by replacing .bin with .dat</b>
</p>
<h4><span class="mw-headline" id="IBL">IBL</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=156" title="Edit section: IBL">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ol><li>Copy <i>i2crom_0x51_c667#_le.bin</i> from mcsdk_2_00_xx_xx\tools\boot_loader\ibl\src\make\bin to mcsdk_2_00_xx_xx\tools\writer\eeprom\evmc667#l\bin. Rename this copied file to <i>app.bin</i>.</li>
<li>Open eepromwriter_input.txt in mcsdk_2_00_xx_xx\tools\writer\eeprom\evmc667#l\bin. Set file_name equal to app.bin and bus_addr equal to 0x51. Make sure start_addr and swap_data are set to 0. Save and close eepromwriter_input.txt.</li>
<li>Turn on and connect your EVM. Open CCSv5, load the appropriate Target Configuration, connect to Core 0, and load the corresponding GEL file.</li>
<li>Load the EEPROM writer program by going to <i>Run -&gt; Load Program </i>and browse for the eeprom writer DSP executable. For e.g, <i>eepromwriter_evm667#l.out</i> in the same folder as <i>app.bin</i> for C667# EVM.</li>
<li>View the memory browser (go to <i>View -&gt; Memory Browser</i>). Browse to address 0x0C000000. <br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  <b>For BIOS-MCSDK 2.0.8 and prior, please use address 0x80000000 instead of 0x0C000000.</b></li>
<li>Right click on the memory window and select Load Memory. Select app.bin (By default, the browse menu only displays .dat files. You will have to change the option TI Data Format (*.dat) to Raw Data Format (*.bin) to find your binary file.) <br /><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  <b>If you are loading a .dat file, check the box for the option to "Use the file header information to set the start address and size of the memory block to be loaded." This option will not be available for .bin files.</b></li>
<li>Click "Next".</li>
<li>Change the Start Address to 0x0C000000 if it is not already. Leave the swap checkbox unchecked. Click "Finish". Please select 32-bits for Type-Size option in CCS. <br /> <img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  <b>For BIOS-MCSDK 2.0.8 and prior, please use address 0x80000000 instead of 0x0C000000.</b></li>
<li>Run the program. This will program the EEPROM. <br /> A sample successful eeprom writer output would like as below. <pre>[C66xx_0] EEPROM Writer Utility Version 01.00.00.05[C66xx_0] [C66xx_0] Writing 52264 bytes from DSP memory address 0x0c000000 to EEPROM bus address 0x0051 starting from device address 0x0000 ... [C66xx_0] Reading 52264 bytes from EEPROM bus address 0x0051 to DSP memory address 0x0c010000 starting from device address 0x0000 ... [C66xx_0] Verifying data read ... [C66xx_0] EEPROM programming completed successfully</pre></li></ol>

<ol><li>IBL Configuration needs to be programmed after successfully completing step 9. Go to <i>Run -&gt; Load Program</i> and select <i>i2cparam_0x51_c667#_le_0x500.out</i> located in the <i>mcsdk_2_00_xx_xx\tools\boot_loader\ibl\src\make\bin</i> folder).</li>
<li>Go to <i>Tools -&gt; GEL Files</i> and then right click on GEL Files window and Load the i2cConfig.gel GEL file, located in the <i>mcsdk_2_00_xx_xx\tools\boot_loader\ibl\src\make\bin</i> folder.</li>
<li>Run the program. The following message will be printed on the CCS console <pre>Run the GEL for the device to be configured, press return to program the I2C.</pre></li></ol>

<p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  <b>DO NOT PRESS ENTER UNTIL STEP 1.</b>
</p>
<ol><li>Run the GEL script<i>"Scripts -&gt; EVM c6678 IBL" -&gt; setConfig_c6678_main</i>.</li>
<li>Now press "Enter" in the CCS console window, and the program will write the boot parameter table to the EEPROM. On success the message "I2c table write complete" will be printed on the CCS console.</li></ol>
<h4><span class="mw-headline" id="POST">POST</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=157" title="Edit section: POST">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<ol><li>Copy <i>post_i2crom.bin</i> from mcsdk_2_00_xx_xx\tools\post\evmc667#l\bin to mcsdk_2_00_xx_xx\tools\writer\eeprom\evmc667#l\bin.</li>
<li>Open eepromwriter_input.txt in mcsdk_2_00_xx_xx\tools\writer\eeprom\evmc667#l\bin. Set file_name equal to post_i2crom.bin and bus_addr equal to 0x50. Make sure start_addr and swap_data are set to 0. Save and close eepromwriter_input.txt.</li>
<li>Turn on and connect your EVM. Open CCSv5, load the appropriate Target Configuration, connect to Core 0, and load the corresponding GEL file.</li>
<li>Load the EEPROM writer program by going to <i>Run -&gt; Load Program </i>and browse for the eeprom writer DSP executable. For e.g, <i>eepromwriter_evm667#l.out </i>in the same folder as <i>post_i2crom.bin</i> for C667# EVM.</li>
<li>View the memory browser (go to <i>View -&gt; Memory Browser</i>). Browse to address 0x80000000.</li>
<li>Right click on the memory window and select Load Memory. Select post_i2crom.bin (By default, the browse menu only displays .dat files. You will have to change the option TI Data Format (*.dat) to Raw Data Format (*.bin) to find your binary file.) <img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  <b>If you are loading a .dat file, check the box for the option to "Use the file header information to set the start address and size of the memory block to be loaded." This option will not be available for .bin files.</b></li>
<li>Click "Next".</li>
<li>Change the Start Address to 0x80000000 if it is not already. Leave the swap checkbox unchecked. Click "Finish".</li>
<li>Run the program. This will program the EEPROM. <br /> A sample successful eeprom writer output would like as below.</li></ol>
<pre>[C66xx_0] EEPROM Writer Utility Version 01.00.00.04
[C66xx_0]
[C66xx_0] Writing 49752 bytes from DSP memory address 0x80000000 to EEPROM bus address 0x0051 starting from device address 0x0000 ...
[C66xx_0] Reading 49752 bytes from EEPROM bus address 0x0051 to DSP memory address 0x80010000 starting from device address 0x0000 ...
[C66xx_0] Verifying data read ...
[C66xx_0] EEPROM programming completed successfully
</pre>
<h3><span id="Updating_NOR/NAND_Images"></span><span class="mw-headline" id="Updating_NOR.2FNAND_Images">Updating NOR/NAND Images</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=158" title="Edit section: Updating NOR/NAND Images">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The NOR/NAND writers support reading a binary image directly. Please rename the DSP executable <i>xxx.out</i> to app.bin and use the writers to directly write a binary image file to the NAND or NOR. Please refer to writer\nand\docs\README.txt or writer\nor\docs\README.txt for details.
</p><p><br />
</p>
<table border="1">
<tbody><tr>
<td>
<div class="floatleft"><a href="File_Helpful_tips_image.html" class="image"><img alt="Helpful tips image.jpg" src="https://processors.wiki.ti.com/images/5/5c/Helpful_tips_image.jpg" width="75" height="76" /></a></div> 
<p><span style="color: Red"><b>Useful Tip</b></span>
</p><p>If booting from NOR Flash on a 6670 EVM is failing the DDR3 test with Bios MCSDK 2.0.2 or earlier, an update to the Intermediate Bootloader is available which will fix it.  If you have a more recent version of the BIOS MCSDK, this fix is included in your installation.  See the instructions for applying the update <a href="Bios_MCSDK_2.0.html" title="Bios MCSDK 2.0.2 IBL Update">here</a>.  Once you have updated the files, come back to this page and follow the instructions for updating the IBL EEPROM image
</p>
</td></tr></tbody></table>
<h2><span id="Q:_How_do_I_use_JTAG_with_CCS?"></span><span class="mw-headline" id="Q:_How_do_I_use_JTAG_with_CCS.3F">Q: How do I use JTAG with CCS?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=159" title="Edit section: Q: How do I use JTAG with CCS?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Did you know that CCS will execute all code up to the cinit when loading an out file through the JTAG? This is an option that is enabled, by default, in the Target Configuration file. Initialization code may sometimes execute before this. For example if you hook a function into the SYS/BIOS startup function list it will execute before cinit. If you need to debug that code or it is causing your load to hang (i.e. you do not get the run button highlighted) change the default setting.
</p>
<h3><span id="Solving_the_Verify_Init:_warnings_when_executing_Demos/NDK_Examples_from_CCS"></span><span class="mw-headline" id="Solving_the_Verify_Init:_warnings_when_executing_Demos.2FNDK_Examples_from_CCS">Solving the <b>Verify_Init:</b> warnings when executing Demos/NDK Examples from CCS</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=160" title="Edit section: Solving the Verify Init: warnings when executing Demos/NDK Examples from CCS">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If you get <i>Verify_Init:</i> warnings while executing the Demos/NDK examples (the sample warning output is shown below)
</p>
<pre>[C66xx_0] Verify_Init: Expected 16 entry count for gTxFreeQHnd queue 736, found 62 entries
[C66xx_0] Verify_Init: Expected 0 entry count for gRxQHnd= 704, found 22 entries
[C66xx_0] Verify_Init: Expected 0 entry count for Queue number = 0, found 1 entries
[C66xx_0] Verify_Init: Expected 0 entry count for Queue number = 704, found 22 entries
[C66xx_0] Verify_Init: Expected 0 entry count for Queue number = 4095, found 1 entries
[C66xx_0] Verify_Init: Expected 0 entry count for Queue number = 8192, found 1 entries
[C66xx_0] Warning:Queue handler Verification failed
</pre>
<p>Please make sure the following when an application is run from CCS environment.
</p>
<ol><li>SW3, SW4, SW5 and SW5 switches are all set to (ON, ON, ON, ON) mode, the only exception is the SW3[1] switch which is intended to control the endian mode of the EVM. This selects <b>EMIF16 or Emulation Boot</b> mode and bypasses the iBL interfearing with the CCS executable loaded via CCS.</li>
<li>Do a system reset between multiple load and executes of the demo/ndk examples programs</li>
<li>Please make sure the corresponding GEL file is executed before the program gets loaded and executed from CCS.</li></ol>
<p><br />
</p>
<h2><span id="Q:_Is_there_a_simple_way_to_access_documents_provided_in_the_release?"></span><span class="mw-headline" id="Q:_Is_there_a_simple_way_to_access_documents_provided_in_the_release.3F">Q: Is there a simple way to access documents provided in the release?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=161" title="Edit section: Q: Is there a simple way to access documents provided in the release?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Once BIOS-MCSDK is installed in the system, many of the documents can be accessed from <i>CCS-&gt;Help-&gt;Help Contents</i>.
</p>
<table style="width: 75%; height: 89px" id="helptable" class="FCK&#95;_ShowTableBorders" border="0">

<tbody><tr>
<td>
</td>
<td><div class="thumb tleft"><div class="thumbinner" style="width:202px;"><a href="File_Ccs-help.html" class="image"><img alt="Ccs-help.png" src="https://processors.wiki.ti.com/images/6/65/Ccs-help.png" width="200" height="528" class="thumbimage" /></a>  <div class="thumbcaption"><div class="magnify"><a href="File_Ccs-help.html" class="internal" title="Enlarge"></a></div></div></div></div>
</td></tr></tbody></table>
<p><br />
</p>
<h2><span id="Q:_How_do_I_uninstall_the_BIOS-MCSDK?"></span><span class="mw-headline" id="Q:_How_do_I_uninstall_the_BIOS-MCSDK.3F">Q: How do I uninstall the BIOS-MCSDK?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=162" title="Edit section: Q: How do I uninstall the BIOS-MCSDK?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The BIOS MCSDK installer installs the un-installer in mcsdk_##_##_##_## directory. The name of the un-installer is <i>uninstall-bios_mcsdk_2.##.##.##.exe</i>. It also adds links of the un-installer in <b>Programs-&gt;Texas Instruments-&gt;BIOS Multicore SDK</b> program menu and in Windows <i>Add and Remove Programs</i> menu with name <b>TI BIOS Multicore SDK</b>. Selecting any one of the links will start the un-installer and remove the BIOS-MCSDK components from the system.
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  Some packages are installed as separate packages (e.g., EDMA3 LLD, DSPLIB, IMGLIB, MATHLIB, SYS/BIOS, IPC) in the system. Due to this, some of the component package installers are not removed after the MCSDK installer is complete; also, to uninstall these packages, please run the corresponding uninstaller.
</p><p><img alt="Note" src="https://processors.wiki.ti.com/images/b/b0/Light_bulb_icon.png" title="Note" width="18" height="25" /><b>Note:</b>  The un-installer for MCSA will be under CCSv5 installation directory with name <i>uninstall_dvt.exe</i>.
</p>
<h2><span id="Q:_Are_there_example_code_for_various_device_peripherals?"></span><span class="mw-headline" id="Q:_Are_there_example_code_for_various_device_peripherals.3F">Q: Are there example code for various device peripherals?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=163" title="Edit section: Q: Are there example code for various device peripherals?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><b>GPIO</b>
</p>
<ol><li>The GPIO documentation for KeyStone devices is available from the link <a rel="nofollow" class="external text" href="http://www.ti.com/litv/pdf/sprugv1">General-Purpose Input/Output (GPIO) forKeyStone Devices User's Guide</a></li>
<li>The GPIO implementation is provided in file pdk_C66##_1_0_0_##\packages\ti\platform\evmc66##l\platform_lib\src\evmc66x_gpio.c</li>
<li>The FPGA implementation is provided in file pdk_C66##_1_0_0_##\packages\ti\platform\evmc66##l\platform_lib\src\evmc66x_fpga.c</li>
<li>In particular the LED operations are in function fpgaControlUserLEDs() of file pdk_C66##_1_0_0_##\packages\ti\platform\evmc66##l\platform_lib\src\evmc66x_fpga.c</li></ol>
<p><b>Timer</b>
</p>
<ol><li>The link <a rel="nofollow" class="external text" href="https://e2e.ti.com/support/processors/f/791/t/840835">SYSBIOS_Training:Timers and Clocks</a> provides detail presentation on configuring timer to get peoridic interrupt</li>
<li>An older document on SYSBIOS timer implementation is in <a rel="nofollow" class="external text" href="http://focus.ti.com/lit/an/spra829/spra829.pdf">DSP/BIOS Timers and Benchmarking Tips</a></li></ol>
<p><b>DDR3</b>
</p>
<ol><li>The DDR3 controller users guide is in <a rel="nofollow" class="external text" href="http://www.ti.com/litv/pdf/sprugv8b">DDR3 Memory Controller for KeyStone Devices User's Guide</a></li>
<li>The DDR3 initialization can be found in the GEL file of the evm</li>
<li>The C implementation is in pdk_C66##_1_0_0_##\packages\ti\platform\evmc66##l\platform_lib\src\platform.c, function platform_init(); Look for <i>if (p_flags-&gt;ddr)</i> section in the function for the sample code</li></ol>
<p><b>UART</b>
</p>
<ol><li>The UART users guide is in <a rel="nofollow" class="external text" href="http://www.ti.com/litv/pdf/sprugp1">Universal Asynchronous Receiver/Transmitter (UART) for KeyStone Devices UG</a></li>
<li>The sample code is in pdk_C66##_1_0_0_##\packages\ti\platform\evmc66##l\platform_lib\src\evmc66x_uart.c</li></ol>
<h2><span id="Q:_How_do_I_speed_up_downloading_the_BIOS-MCSDK_installer?"></span><span class="mw-headline" id="Q:_How_do_I_speed_up_downloading_the_BIOS-MCSDK_installer.3F">Q: How do I speed up downloading the BIOS-MCSDK installer?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=164" title="Edit section: Q: How do I speed up downloading the BIOS-MCSDK installer?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The size of the BIOS-MCSDK installer is large since we want to provide one bundle for all the components. The bad side of this is that if you are manually downloading the BIOS-MCSDK (or CCS) installer, you may run into issues such as download stall or slow download. One simple solution is to run a download manager/accelerator. One open source solution is <a rel="nofollow" class="external free" href="http://www.freedownloadmanager.org/">http://www.freedownloadmanager.org/</a>.
</p>
<h2><span id="Q:_Can_I_use_CCS_5.1_with_BIOS_MCSDK_2.0?"></span><span class="mw-headline" id="Q:_Can_I_use_CCS_5.1_with_BIOS_MCSDK_2.0.3F">Q: Can I use CCS 5.1 with BIOS MCSDK 2.0?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=165" title="Edit section: Q: Can I use CCS 5.1 with BIOS MCSDK 2.0?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Starting with BIOS-MCSDK 2.0.5, we support both CCS 5.0.3 and CCS 5.1.0. We are planning on maintaining CCS 5.0.3 support through all the BIOS-MCSDK 2.0.x releases; it will be dropped in the next major release, v2.1. However, the recommended version of CCS is v5.1.0 to benefit from the latest updates of features and bug fixes.
</p><p>Two notes:
</p>
<ol><li>Starting from CCS 5.1.0, the MCSA component, which is installed in the CCS directory, is bundled with CCS and installing the version from the BIOS-MCSDK installer into CCS 5.1.0 results in the BIOS-MCSDK installer to crash. The BIOS-MCSDK 2.0.5 installer has MCSA unselected, but previous versions need to be manually unchecked.</li>
<li>CCS 5.1 may include a different version of CGT than the version validated with BIOS MCSDK. See the respective release notes to find the actual versions. If there is a mismatch, it is recommended that you use the version that BIOS MCSDK lists as a dependency, and ensure that CCS projects are configured for the appropriate version when building projects.</li></ol>
<h2><span id="Q:_How_can_I_connect_and_use_two_emulators_of_the_same_type_in_the_same_CCS_instance?"></span><span class="mw-headline" id="Q:_How_can_I_connect_and_use_two_emulators_of_the_same_type_in_the_same_CCS_instance.3F">Q: How can I connect and use two emulators of the same type in the same CCS instance?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=166" title="Edit section: Q: How can I connect and use two emulators of the same type in the same CCS instance?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>For the development of some applications involving board to board communications such as SRIO or Hyperlink it may be desirable to simultaneously connect to two boards while running a single instance of Code Composer Studio. The following steps document how to create and use a Target Configuration that allows connect, program load, and debug capabilities on two boards simultaneously. To document these steps the following hardware and software was used.
</p>
<ul><li>2x c6678 boards with attached Blackhawk XDS560v2-USB Mezzanine Emulator</li>
<li>Code Composer Studio v5.0.3.00028</li></ul>
<p>Steps to connect to two boards with the same target configuration:
</p><p>1. Make sure the boards and emulators are powered up and ready to be launched for a debug session. The device manager should show two Blackhawk XDS560v2-USB Mezzanine Emulators under the BlackHawk tab.
</p><p><a href="File_1_dual_board_device_manager.html" class="image" title="Figure 1: Emulators Displayed in Device Manager"><img alt="Figure 1: Emulators Displayed in Device Manager" src="https://processors.wiki.ti.com/images/0/09/1_dual_board_device_manager.JPG" width="300" height="211" /></a>
</p><p>2. Start CCS and open the Target Configurations tab, View -&gt; Target Configurations.
</p><p>3. Right-click within the Target Configurations tab and select "New Target Configuration". Give the target configuration a name and click "Finish".
</p><p>4. In this, and the following step, we'll set up the configuration for the first target. The second target will be added later. In the "Connection" drop down menu select 'Blackhawk XDS560v2-USB Mezzanine Emulator' or the emulator type you're using.
</p><p><a href="File_2_config_first_target.html" class="image" title="Figure 2: First Target Configuration"><img alt="Figure 2: First Target Configuration" src="https://processors.wiki.ti.com/images/f/ff/2_config_first_target.JPG" width="300" height="214" /></a>
</p><p>5. In the Device selection window check the TMS320C6678 box, or the box of the processor you're using, and click "Save".
</p><p>6. In the following steps we'll add the second board to the target configuration. Click the "Advanced" tab at the bottom of the "board_name".ccxml file display.
</p><p>7. Highlight the first Blackhawk connection and Click "New...".
</p><p><a href="File_3_new_connection.html" class="image" title="Figure 3: Create New Connection"><img alt="Figure 3: Create New Connection" src="https://processors.wiki.ti.com/images/9/9e/3_new_connection.JPG" width="300" height="189" /></a>
</p><p>8. Select "Blackhawk XDS560v2-USB Mezzanine Emulator", or the second emulator type you're using, and click "Finish".
</p><p>9. Right Click the new Blackhawk connection and select "Add...".
</p><p><a href="File_4_new_board_add_proc.html" class="image" title="Figure 4: Add New Processor to Connection"><img alt="Figure 4: Add New Processor to Connection" src="https://processors.wiki.ti.com/images/b/b5/4_new_board_add_proc.JPG" width="300" height="190" /></a>
</p><p>10. In the Device selection tab highlight the TMS320C6678, or the processor you're using, and click "Finish". You're target configuration should now have two Blackhawk emulators each with a c6678 device.
</p><p><a href="File_5_two_boards.html" class="image" title="Figure 5: Target Configuration With Two Boards"><img alt="Figure 5: Target Configuration With Two Boards" src="https://processors.wiki.ti.com/images/9/90/5_two_boards.JPG" width="300" height="243" /></a>
</p><p>11. Once again, highlight the second Blackhawk Emulator so that the "Connection Properties" show.
</p><p><a href="File_6_connection_properties.html" class="image" title="Figure 6: Second Connection&#39;s Properties"><img alt="Figure 6: Second Connection&#39;s Properties" src="https://processors.wiki.ti.com/images/7/72/6_connection_properties.JPG" width="300" height="206" /></a>
</p><p>12. Under the Emulator I/O Port Number drop down menu change the setting to "I/O Port = 1" and then click "Save".
</p><p><a href="File_7_new_port.html" class="image" title="Figure 7: Change Connection Port"><img alt="Figure 7: Change Connection Port" src="https://processors.wiki.ti.com/images/e/e3/7_new_port.JPG" width="300" height="204" /></a>
</p><p>13. Start the new target configuration by right-clicking the target configuration in the "Target Configuration" tab and selecting "Launch Selected Configuration". When the launch completes you'll see sixteen cores, for two c6678 boards, in the Debug tab.
</p><p><a href="File_8_sixteen_cores.html" class="image" title="Figure 8: Sixteen Cores"><img alt="Figure 8: Sixteen Cores" src="https://processors.wiki.ti.com/images/c/cd/8_sixteen_cores.JPG" width="300" height="218" /></a>
</p><p>14. Connect to the desired cores.
</p><p><a href="File_9_connected_to_cores.html" class="image" title="Figure 9: Connected to Cores"><img alt="Figure 9: Connected to Cores" src="https://processors.wiki.ti.com/images/a/a5/9_connected_to_cores.JPG" width="300" height="290" /></a>
</p>
<h2><span id="Q:_How_do_I_get_the_latest_GEL_files_for_these_EVMs?"></span><span class="mw-headline" id="Q:_How_do_I_get_the_latest_GEL_files_for_these_EVMs.3F">Q: How do I get the latest GEL files for these EVMs?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=167" title="Edit section: Q: How do I get the latest GEL files for these EVMs?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The GEL files for supported EVMs are provided separately from the MCSDK. If you use CCS 5.1, use the Eclipse Update Manager to check for new updates and follow installation instructions if there is an update. If you use CCS 5.0, or have any problems with using the Eclipse Update Manager in CCS 5.1, you can manually download the GEL updates. See the MCSDK download page listed above for details.
</p>
<h2><span id="Q:_How_do_I_change_SoC_speed_on_my_EVM?"></span><span class="mw-headline" id="Q:_How_do_I_change_SoC_speed_on_my_EVM.3F">Q: How do I change SoC speed on my EVM?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit&amp;section=168" title="Edit section: Q: How do I change SoC speed on my EVM?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The SoC speed for the EVM can be changed by setting appropriate PLL multiplier and Divider values. Please refer to the device data sheet for details on setting the Multiplier and Divider values. The Gel file from the emupack also has sample multiplier and divider values for a given SoC speed.
</p><p>Please refer to section 2.5.3 section of the <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ds/sprs691c/sprs691c.pdf">TMS320C6678</a> data sheet for the sample multiplier and divider values.
</p><p>Please refer to section 2.4.3 section of the <a rel="nofollow" class="external text" href="http://www.ti.com/lit/ds/sprs689d/sprs689d.pdf">TMS320C6670</a> data sheet for the sample multiplier and divider values.
</p><p>This can be changed in
</p>
<ul><li>platform library (If platform library is used to program the PLL settings)
<ul><li>please update multiplier and divider values in <i><b>platform_init()</b></i> function, located under <i>pdk_C667#_1_0_0_##\packages\ti\platform\evmc667#l\platform_lib\src\platform.c</i> file. Please rebuild platform library after this change.</li></ul></li>
<li>GEL file (If GEL files are used to program the PLL)
<ul><li>please update <b>PLL1_M</b> and <b>PLL1_D</b> values in evmc667#l.gel file, located under <i>\ccsv5\ccs_base\emulation\boards\evmc667#l\gel</i> file. Please reload the gel file after this change.</li></ul></li>
<li>IBL (If IBL is used for PLL settings, e.g., for i2c boot modes)
<ul><li>please update the <i>ibl.pllConfig[ibl_MAIN_PLL].prediv</i> variable for the divider and <i>ibl.pllConfig[ibl_MAIN_PLL].mult</i> variable for multiplier values in <i><b>c667#_ibl_config()</b></i> function located under <i>mcsdk_2_00_##_##\tools\boot_loader\ibl\src\util\iblconfig\src\device.c</i> file. Please rebuild ibl after this change.</li></ul></li></ul>
<hr />

<!-- 
NewPP limit report
Cached time: 20201201010247
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.689 seconds
Real time usage: 0.739 seconds
Preprocessor visited node count: 986/1000000
Preprocessor generated node count: 1532/1000000
Postexpand include size: 6561/2097152 bytes
Template argument size: 2741/2097152 bytes
Highest expansion depth: 3/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 1786/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%   17.970      1 -total
 13.71%    2.464     43 Template:Note
 13.14%    2.362      5 Template:UsefulTip
 11.25%    2.021      1 Template:SpNote
  8.90%    1.599      1 Template:Warning
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:8540-0!canonical and timestamp 20201201010247 and revision id 216114
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>BIOS MCSDK 2.0 User Guide</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>BIOS MCSDK 2.0 User Guide</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>BIOS MCSDK 2.0 User Guide</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>BIOS MCSDK 2.0 User Guide</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>BIOS MCSDK 2.0 User Guide</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>BIOS MCSDK 2.0 User Guide</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>BIOS MCSDK 2.0 User Guide</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>BIOS MCSDK 2.0 User Guide</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>BIOS MCSDK 2.0 User Guide</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;oldid=216114">https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;oldid=216114</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Categories</a>: <ul><li><a href="Category_C667x.html" title="Category:C667x">C667x</a></li><li><a href="Category_C66x.html" title="Category:C66x">C66x</a></li><li><a href="Category_Keystone.html" title="Category:Keystone">Keystone</a></li><li><a href="Category_Multicore.html" title="Category:Multicore">Multicore</a></li><li><a href="Category_SDK.html" title="Category:SDK">SDK</a></li><li><a href="Category_SYSBIOS.html" title="Category:SYSBIOS">SYSBIOS</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=BIOS+MCSDK+2.0+User+Guide" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="BIOS_MCSDK_2-2.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk"><span><a href="Talk_BIOS_MCSDK_2-2.html" rel="discussion" title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="BIOS_MCSDK_2-2.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/BIOS_MCSDK_2-2.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/BIOS_MCSDK_2-2.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;oldid=216114" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=BIOS_MCSDK_2.0_User_Guide&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 8 May 2016, at 21:54.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.689","walltime":"0.739","ppvisitednodes":{"value":986,"limit":1000000},"ppgeneratednodes":{"value":1532,"limit":1000000},"postexpandincludesize":{"value":6561,"limit":2097152},"templateargumentsize":{"value":2741,"limit":2097152},"expansiondepth":{"value":3,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":1786,"limit":5000000},"timingprofile":["100.00%   17.970      1 -total"," 13.71%    2.464     43 Template:Note"," 13.14%    2.362      5 Template:UsefulTip"," 11.25%    2.021      1 Template:SpNote","  8.90%    1.599      1 Template:Warning"]},"cachereport":{"timestamp":"20201201010247","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":246});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/BIOS_MCSDK_2.0_User_Guide by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 04:07:50 GMT -->
</html>
