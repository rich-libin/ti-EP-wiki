<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/Optimized_In-Memory_Bitmap_Indexes by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 03:30:55 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>Optimized In-Memory Bitmap Indexes - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Optimized_In-Memory_Bitmap_Indexes","wgTitle":"Optimized In-Memory Bitmap Indexes","wgCurRevisionId":182207,"wgRevisionId":182207,"wgArticleId":8038,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Compiler"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Optimized_In-Memory_Bitmap_Indexes","wgRelevantArticleId":8038,"wgRequestId":"9fb70ee9f1789720872f90c2","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->

                    <script>var w=window;if(w.performance||w.mozPerformance||w.msPerformance||w.webkitPerformance){var d=document;AKSB=w.AKSB||{},AKSB.q=AKSB.q||[],AKSB.mark=AKSB.mark||function(e,_){AKSB.q.push(["mark",e,_||(new Date).getTime()])},AKSB.measure=AKSB.measure||function(e,_,t){AKSB.q.push(["measure",e,_,t||(new Date).getTime()])},AKSB.done=AKSB.done||function(e){AKSB.q.push(["done",e])},AKSB.mark("firstbyte",(new Date).getTime()),AKSB.prof={custid:"295384",ustr:"",originlat:"0",clientrtt:"189",ghostip:"23.11.215.94",ipv6:false,pct:"10",clientip:"163.125.46.158",requestid:"171d5c31",region:"26813",protocol:"",blver:14,akM:"g",akN:"ae",akTT:"O",akTX:"1",akTI:"171d5c31",ai:"181835",ra:"false",pmgn:"",pmgi:"",pmp:"",qc:""},function(e){var _=d.createElement("script");_.async="async",_.src=e;var t=d.getElementsByTagName("script"),t=t[t.length-1];t.parentNode.insertBefore(_,t)}(("https:"===d.location.protocol?"https:":"http:")+"//ds-aksb-a.akamaihd.net/aksb.min.js")}</script>
                    </head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Optimized_In-Memory_Bitmap_Indexes rootpage-Optimized_In-Memory_Bitmap_Indexes skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">Optimized In-Memory Bitmap Indexes</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><table border="1">

<tbody><tr>
<td><a href="File_Construction_Icon_small.html" class="image"><img alt="Construction Icon small.png" src="https://processors.wiki.ti.com/images/8/89/Construction_Icon_small.png" width="50" height="44" /></a></td>
<td><b>This page is currently under construction.  The content of this page is due to change quite frequently and thus the quality and accuracy are not guaranteed until this message has been removed.  Please feel free to contribute to this page while construction is in progress.</b>
</td></tr>

</tbody></table>
<p>This article documents an implementation of uncompressed <a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Bitmap_index">Bitmap Indexes</a>
that supports an index size up to 1024 elements. The use of bitmap indexes enables very effective software
optimizations techniques for some types of complex software applications (aka control code).
</p><p>Many embedded software applications maintain databases of objects (arrays of structs) stored
in memory, and the maintenance of these databases often involves operations such as:
</p>
<ul><li>iterate over a linked list of objects, and perform an operation on these objects.</li>
<li>iterate over all the database objects, and depending on a per-object set of logical conditions perform one or more operations</li></ul>
<p>The problem with the implementation of such maintenance operation is that the execution performance
is generally quite poor as the code most often does not get the best out of the:
</p>
<ul><li>software pipelining of loops.</li>
<li>parallel execution of multiple CPU instructions per CPU cycle.</li></ul>
<p>This is a problem that is common to most CPU architectures, including architecture that have branch
prediction built-in. (need references here: Monet-DB X100 presentation looks like a good one, need
to find others)
</p><p>For some background information on what Bitmap Indexes are please refer to Wikipedia that has a
<a rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Bitmap_index">good article on Bitmap Indexes</a>. Please note however that a significant part of the article is dedicated to compression of large bitmap indexes (read: millions of items in the index), where the present article is focused on the use of an uncompressed bitmap index implementation that has a fixed size of 1024.
</p><p>The implementation presented here has been optimized for execution on the Texas Instruments
C64x+ DSP Architecture as well as C66x Architecture.
</p><p><br />
</p>
<div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Bitmap_Indexes"><span class="tocnumber">1</span> <span class="toctext">Bitmap Indexes</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Replacing_structure_fields_with_bitmap_indexes"><span class="tocnumber">1.1</span> <span class="toctext">Replacing structure fields with bitmap indexes</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Replacing_a_linked_list_with_a_bitmap_index"><span class="tocnumber">1.2</span> <span class="toctext">Replacing a linked list with a bitmap index</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Optimized_DSP_Bitmap_Index_implementation"><span class="tocnumber">2</span> <span class="toctext">Optimized DSP Bitmap Index implementation</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Bitmap_Index_data_structure"><span class="tocnumber">2.1</span> <span class="toctext">Bitmap Index data structure</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Methods_to_initialize_and_modify_a_bitmap_index"><span class="tocnumber">2.2</span> <span class="toctext">Methods to initialize and modify a bitmap index</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Iteration_over_a_Bitmap_Index"><span class="tocnumber">2.3</span> <span class="toctext">Iteration over a Bitmap Index</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="#One-level_loop_iteration"><span class="tocnumber">2.3.1</span> <span class="toctext">One-level loop iteration</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Two-level_loop_iteration"><span class="tocnumber">2.3.2</span> <span class="toctext">Two-level loop iteration</span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#Vectorized_iteration"><span class="tocnumber">2.3.3</span> <span class="toctext">Vectorized iteration</span></a>
<ul>
<li class="toclevel-4 tocsection-11"><a href="#Compute_the_Vector"><span class="tocnumber">2.3.3.1</span> <span class="toctext">Compute the Vector</span></a></li>
<li class="toclevel-4 tocsection-12"><a href="#Process_the_Vector"><span class="tocnumber">2.3.3.2</span> <span class="toctext">Process the Vector</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-2 tocsection-13"><a href="#Boolean_logic_on_Bitmap_Indexes"><span class="tocnumber">2.4</span> <span class="toctext">Boolean logic on Bitmap Indexes</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Example_of_use_of_Bitmap_Indexes"><span class="tocnumber">2.5</span> <span class="toctext">Example of use of Bitmap Indexes</span></a>
<ul>
<li class="toclevel-3 tocsection-15"><a href="#Original_code"><span class="tocnumber">2.5.1</span> <span class="toctext">Original code</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#Optimized_code_using_Bitmap_Indexes"><span class="tocnumber">2.5.2</span> <span class="toctext">Optimized code using Bitmap Indexes</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-17"><a href="#Software_optimization_techniques_using_In-Memory_Bitmap_Indexes"><span class="tocnumber">3</span> <span class="toctext">Software optimization techniques using In-Memory Bitmap Indexes</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#convert_use_of_boolean_fields"><span class="tocnumber">3.1</span> <span class="toctext">convert use of boolean fields</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#convert_use_of_linked_lists"><span class="tocnumber">3.2</span> <span class="toctext">convert use of linked lists</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#complex_database_queries_optimization"><span class="tocnumber">3.3</span> <span class="toctext">complex database queries optimization</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#convert_to_vectorized_processing"><span class="tocnumber">3.4</span> <span class="toctext">convert to vectorized processing</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#use_of_the_count_field_to_further_optimization_by_iterating_multiples_of_2.2C_4_times"><span class="tocnumber">3.5</span> <span class="toctext">use of the count field to further optimization by iterating multiples of 2, 4 times</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Bitmap_Indexes">Bitmap Indexes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=1" title="Edit section: Bitmap Indexes">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<h2><span class="mw-headline" id="Replacing_structure_fields_with_bitmap_indexes">Replacing structure fields with bitmap indexes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=2" title="Edit section: Replacing structure fields with bitmap indexes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>It is possible to use bitmap indexes to replace boolean fields in data-structures. The benefits of doing so are the following:
</p>
<ul><li>reduction of memory storage requirements for the same information. One bit only is used for each field, vs at least 8 bits in the initial approach.</li>
<li>boolean logic can be used to combine conditions and create more complex queries using very simple bit-wise operations.</li>
<li>the resulting software is much more "software pipeline"-friendly.</li></ul>
<h2><span class="mw-headline" id="Replacing_a_linked_list_with_a_bitmap_index">Replacing a linked list with a bitmap index</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=3" title="Edit section: Replacing a linked list with a bitmap index">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>It is also possible to replace linked-lists with bitmap indexes:
</p>
<ul><li>when the order of the items in the list can easily be computed on the fly (for example by using a sort algorithm),</li>
<li>when the order does not matter (such as in the case of linked-lists used for resource allocation).</li></ul>
<h1><span class="mw-headline" id="Optimized_DSP_Bitmap_Index_implementation">Optimized DSP Bitmap Index implementation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=4" title="Edit section: Optimized DSP Bitmap Index implementation">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>Here is an optimized implementation of uncompressed bitmap indexes that supports up to 1024 objects (these indexes have a fixed size). The limitation on size allows us to store the whole bitmap in memory (it is only 136 bytes long for one bitmap index), and to use many such bitmap indexes in one application.
</p><p>This implementation has been developed and tested on Texas Instrument DSPs,
but this code should be easy to adapt for other CPU architectures, as very few TI-specific intrinsics are used.
</p>
<h2><span class="mw-headline" id="Bitmap_Index_data_structure">Bitmap Index data structure</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=5" title="Edit section: Bitmap Index data structure">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The data-structure associated to a Bitmap Index is a very simple array, designed to fit in two
cache lines. Its total size is 136 bytes.
</p><p>&lt;syntaxhighlight lang='c'&gt;
typedef struct {
</p>
<pre>  uint32_t bitmap[32];  /* Bitmap, one bit per entry.  */
  uint32_t index;       /* Index of the words in the bitmap[] array that have
                           at least one bit set, one bit per word.  */
  uint32_t count;       /* Counter of the number of bits that are set in the bitmap.  */
</pre>
<p>} BitmapIndex;
&lt;/syntaxhighlight&gt;
</p><p>The data-structure should be stored at a 64-bit aligned address for the maximum efficiency
of the code that is generated.
</p>
<h2><span class="mw-headline" id="Methods_to_initialize_and_modify_a_bitmap_index">Methods to initialize and modify a bitmap index</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=6" title="Edit section: Methods to initialize and modify a bitmap index">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Here are a few commodity functions that allow you to create a new bitmap index, set, clear and get bits from it.
These can be used as basis for a custom implementation of bitmap indexes.
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<ol><li>include &lt;inttypes.h&gt; /* C99 types.  */</li>
<li>include &lt;c6x.h&gt;      /* C64x+, C66x intrinsics.  */</li></ol>
<p>inline void BitmapIndex_init(BitmapIndex *bitmap_index) {
</p>
<pre>   int i;
</pre>
<pre>   /* Initialize an empty bitmap index.  */
   for(i=0; i&lt;32; i++) {
       bitmap_index-&gt;bitmap[i] = 0;
   }
   bitmap_index-&gt;index = 0;
   bitmap_index-&gt;count = 0;
</pre>
<p>}
</p><p>inline void BitmapIndex_set(BitmapIndex * bitmap_index, int bit) {
</p>
<pre>   int word_position = bit / 32;
   int bit_position = bit&#160;% 32;
   uint32_t bitmap = bitmap_index-&gt;bitmap[word_position];
</pre>
<p>	uint32_t mask = (0x1 &lt;&lt; bit_position);
</p>
<pre>   /* Set one bit in the bitmap.  */
   if (!(bitmap &amp; mask)) { bitmap = bitmap ^ mask; }
   bitmap_index-&gt;bitmap[word_position] = bitmap;
</pre>
<p>}
</p><p>inline void BitmapIndex_clear(BitmapIndex * bitmap_index, int bit) {
</p>
<pre>   int word_position = bit / 32;
   int bit_position = bit&#160;% 32;
   uint32_t bitmap = bitmap_index-&gt;bitmap[word_position];
</pre>
<p>	uint32_t mask = (0x1 &lt;&lt; bit_position);
</p>
<pre>   /* Clear one bit in the bitmap.  */
   if (bitmap &amp; mask) { bitmap = bitmap ^ mask; }
   bitmap_index-&gt;bitmap[word_position] = bitmap;
</pre>
<p>}
</p><p>inline uint32_t BitmapIndex_get(BitmapIndex *bitmap_index, int bit) {
</p>
<pre>   int word_position = bit / 32;
   int bit_position = bit&#160;% 32;
</pre>
<pre>   /* Get the value of one bit in the bitmap.  */
   return _extur(bitmap_index-&gt;bitmap[word_position], bit_position + bit_position * 32);
</pre>
<p>}
</p><p>inline void BitmapIndex_copy(BitmapIndex *source, BitmapIndex *destination) {
</p>
<pre>   int i;
</pre>
<pre>   /* Copy a full bitmap.  */
   for(i=0; i&lt;32; i++) {
       destination-&gt;bitmap[i] = source-&gt;bitmap[i];
   }
   destination-&gt;index = source-&gt;index;
   destination-&gt;count = source-&gt;count;
</pre>
<p>}
</p><p>inline void BitmapIndex_update(BitmapIndex *bitmap_index) {
</p>
<pre>   int i;
   uint32_t count = 0;
   uint32_t index = 0;
   uint32_t bitmap;
</pre>
<pre>   /* Update the 'index' and 'count' fields of the Bitmap Index data-structure.
      This is useful when the bitmap is updated in a batch of operations.  */
   for (i=0; i&lt;32; i++) {
       index = index &gt;&gt; 1;
       bitmap = bitmap_index-&gt;bitmap[i];
       if (bitmap&#160;!= 0) {
           index |= 0x80000000;
       }
       /* Count the number of bits set to one in the bitmap.  */
       count += _dotpu4(_bitc4(bitmap),0x01010101);
   }
   bitmap_index-&gt;index = index;
   bitmap_index-&gt;count = count;
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p>
<h2><span class="mw-headline" id="Iteration_over_a_Bitmap_Index">Iteration over a Bitmap Index</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=7" title="Edit section: Iteration over a Bitmap Index">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>There are several ways to iterate efficiently on a bitmap index.
</p>
<h3><span class="mw-headline" id="One-level_loop_iteration">One-level loop iteration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=8" title="Edit section: One-level loop iteration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>To be documented.
</p>
<h3><span class="mw-headline" id="Two-level_loop_iteration">Two-level loop iteration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=9" title="Edit section: Two-level loop iteration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The inner-loop in this method is software-pipelined by the compiler with the following characteristics:
</p>
<ul><li>ii = 3  Schedule found with 2 iterations in parallel</li>
<li>Total cycles (est.): 3 + trip_cnt * 3</li>
<li>Iteration over 1024 items (in a full bitmap index) costs about 3500 CPU cycles, or about 3.5 cyles/item.</li></ul>
<p>&lt;syntaxhighlight lang='c'&gt;
static int BitmapIndex_iterator_bitmap[32];
static int BitmapIndex_iterator_position[32];
static int BitmapIndex_iterator_bitcount[32];
</p><p>int bitmap_iteration_two_levels(BitmapIndex * bitmap_index, int * restrict vector) {
	int word_position, word_count = 0, bitcount = 0;
	int bit_position;
	int position, i, j;
	uint32_t index = _bitr(bitmap_index-&gt;index);
	uint32_t * restrict bitmap_array = bitmap_index-&gt;bitmap;
	uint32_t bitmap;
	int result = 0;
</p><p>	while (index&#160;!= 0) {
		word_position = _lmbd(1, index);
		index = index ^ (0x80000000 &gt;&gt; word_position);
		bitmap = bitmap_array[word_position];
		BitmapIndex_iterator_position[word_count] = word_position;
		BitmapIndex_iterator_bitcount[word_count] = _dotpu4(_bitc4(bitmap),0x01010101);
		BitmapIndex_iterator_bitmap[word_count++] = _bitr(bitmap);
	}
	for(i = 0; i &lt; word_count; i++) {
		bitmap = BitmapIndex_iterator_bitmap[i];
		word_position = BitmapIndex_iterator_position[i];
		bitcount = BitmapIndex_iterator_bitcount[i];
		_nassert(bitcount &gt; 0);
		for (j = 0; j &lt; bitcount; j++) {
			bit_position = _lmbd(1, bitmap);
			bitmap = bitmap ^ (0x80000000 &gt;&gt; bit_position);
			position = word_position * 32 + bit_position;
</p><p>			/* This where your code goes in.  */
			vector[result++] = position;
		}
	}
	return result;
}
&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="Vectorized_iteration">Vectorized iteration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=10" title="Edit section: Vectorized iteration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Let's assume that in the previous code you are placing your own functionality where the comment says "place your own code here".
</p><p>In this case your functionality is subject to following constraints:
</p>
<ul><li>Some register pressure due to the code operating the loop.</li>
<li>No more than two iterations in parallel with an ii of 3 cycles.</li>
<li>Up to 32x the penalty of the loop preamble.</li></ul>
<p>For complex functionality it might turn out to be very interesting to work in two passes as follows:
</p>
<ul><li>First create a vector that has the index of all the entries in the Bitmap Index.</li>
<li>Second iterate on the resulting vector in one go, and benefit from a much reduced register pressure, and the ability for the compiler to schedule much more iterations in parallel.</li></ul>
<h4><span class="mw-headline" id="Compute_the_Vector">Compute the Vector</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=11" title="Edit section: Compute the Vector">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>&lt;syntaxhighlight lang='c'&gt;
static int BitmapIndex_iterator_bitmap[32];
static int BitmapIndex_iterator_position[32];
static int BitmapIndex_iterator_bitcount[32];
</p><p>int BitmapIndex_compute_vector(BitmapIndex * bitmap_index, int * restrict vector) {
	int word_position, word_count = 0, bitcount = 0;
	int bit_position;
	int position, i, j;
	uint32_t index = _bitr(bitmap_index-&gt;index);
	uint32_t * restrict bitmap_array = bitmap_index-&gt;bitmap;
	uint32_t bitmap;
	int vector_size = 0;
</p><p>	while (index&#160;!= 0) {
		word_position = _lmbd(1, index);
		index = index ^ (0x80000000 &gt;&gt; word_position);
		bitmap = bitmap_array[word_position];
		BitmapIndex_iterator_position[word_count] = word_position;
		BitmapIndex_iterator_bitcount[word_count] = _dotpu4(_bitc4(bitmap),0x01010101);
		BitmapIndex_iterator_bitmap[word_count++] = _bitr(bitmap);
	}
	for(i = 0; i &lt; word_count; i++) {
		bitmap = BitmapIndex_iterator_bitmap[i];
		word_position = BitmapIndex_iterator_position[i];
		bitcount = BitmapIndex_iterator_bitcount[i];
		_nassert(bitcount &gt; 0);
		for (j = 0; j &lt; bitcount; j++) {
			bit_position = _lmbd(1, bitmap);
			bitmap = bitmap ^ (0x80000000 &gt;&gt; bit_position);
			position = word_position * 32 + bit_position;
</p><p>			/* Fill in the vector.  */
			vector[vector_size++] = position;
		}
	}
	return vector_size;
}
&lt;/syntaxhighlight&gt;
</p>
<h4><span class="mw-headline" id="Process_the_Vector">Process the Vector</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=12" title="Edit section: Process the Vector">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>&lt;syntaxhighlight lang='c'&gt;
</p><p>int example(BitmapIndex * bitmap_index) {
	int i, result, count;
</p><p>	result = 0;
	count = BitmapIndex_compute_vector(bitmap_index, iteration_vector);
	for (i=0; i&lt;count; i++) {
		/* Implement your own functionality here.  */
		result += database[iteration_vector[i]].metric * 7;
	}
	return result;
}
&lt;/syntaxhighlight&gt;
</p>
<h2><span class="mw-headline" id="Boolean_logic_on_Bitmap_Indexes">Boolean logic on Bitmap Indexes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=13" title="Edit section: Boolean logic on Bitmap Indexes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Some applications need to perform boolean logic operations on bitmap indexes. This allows
the applications to perform the equivalent of complex queries on a database of objects.
</p><p>This is easily implemented by performing bitwise logical operations on several bitmaps as illustrated below, and this functionality can be optimized heavily by ensuring that bitmap indexes are stored at 64-bit aligned adresses.
</p><p>&lt;syntaxhighlight lang='c'&gt;
inline void BitmapIndex_or(BitmapIndex *bitmap_index_a, BitmapIndex *bitmap_index_b,
</p>
<pre>     BitmapIndex *bitmap_index_dest) {
   int i;
   uint32_t * restrict bitmap_a = bitmap_index_a-&gt;bitmap;
   uint32_t * restrict bitmap_b = bitmap_index_b-&gt;bitmap;
   uint32_t * restrict bitmap_dest = bitmap_index_dest-&gt;bitmap;
   _nassert(((int)bitmap_a &amp; 0x7) == 0);
   _nassert(((int)bitmap_b &amp; 0x7) == 0);
   _nassert(((int)bitmap_dest &amp; 0x7) == 0);
   for (i=0; i&lt;32; i++) {
       bitmap_dest[i] = bitmap_a[i] | bitmap_b[i];
   }
   BitmapIndex_update(bitmap_index_dest);
</pre>
<p>}
</p><p>inline void BitmapIndex_or_not(BitmapIndex *bitmap_index_a, BitmapIndex *bitmap_index_b,
</p>
<pre>     BitmapIndex *bitmap_index_dest) {
   int i;
   uint32_t * restrict bitmap_a = bitmap_index_a-&gt;bitmap;
   uint32_t * restrict bitmap_b = bitmap_index_b-&gt;bitmap;
   uint32_t * restrict bitmap_dest = bitmap_index_dest-&gt;bitmap;
   _nassert(((int)bitmap_a &amp; 0x7) == 0);
   _nassert(((int)bitmap_b &amp; 0x7) == 0);
   _nassert(((int)bitmap_dest &amp; 0x7) == 0);
   for (i=0; i&lt;32; i++) {
       bitmap_dest[i] = bitmap_a[i] | (~ bitmap_b[i]);
   }
   BitmapIndex_update(bitmap_index_dest);
</pre>
<p>}
</p><p>inline void BitmapIndex_and(BitmapIndex *bitmap_index_a, BitmapIndex *bitmap_index_b,
</p>
<pre>     BitmapIndex *bitmap_index_dest) {
   int i;
   uint32_t * restrict bitmap_a = bitmap_index_a-&gt;bitmap;
   uint32_t * restrict bitmap_b = bitmap_index_b-&gt;bitmap;
   uint32_t * restrict bitmap_dest = bitmap_index_dest-&gt;bitmap;
   _nassert(((int)bitmap_a &amp; 0x7) == 0);
   _nassert(((int)bitmap_b &amp; 0x7) == 0);
   _nassert(((int)bitmap_dest &amp; 0x7) == 0);
   for (i=0; i&lt;32; i++) {
       bitmap_dest[i] = bitmap_a[i] &amp; bitmap_b[i];
   }
   BitmapIndex_update(bitmap_index_dest);
</pre>
<p>}
</p><p>inline void BitmapIndex_and_not(BitmapIndex *bitmap_index_a, BitmapIndex *bitmap_index_b,
</p>
<pre>     BitmapIndex *bitmap_index_dest) {
   int i;
   uint32_t * restrict bitmap_a = bitmap_index_a-&gt;bitmap;
   uint32_t * restrict bitmap_b = bitmap_index_b-&gt;bitmap;
   uint32_t * restrict bitmap_dest = bitmap_index_dest-&gt;bitmap;
   _nassert(((int)bitmap_a &amp; 0x7) == 0);
   _nassert(((int)bitmap_b &amp; 0x7) == 0);
   _nassert(((int)bitmap_dest &amp; 0x7) == 0);
   for (i=0; i&lt;32; i++) {
       bitmap_dest[i] = bitmap_a[i] &amp; (~ bitmap_b[i]);
   }
   BitmapIndex_update(bitmap_index_dest);
</pre>
<p>}
</p><p>inline void BitmapIndex_xor(BitmapIndex *bitmap_index_a, BitmapIndex *bitmap_index_b,
</p>
<pre>     BitmapIndex *bitmap_index_dest) {
   int i;
   uint32_t * restrict bitmap_a = bitmap_index_a-&gt;bitmap;
   uint32_t * restrict bitmap_b = bitmap_index_b-&gt;bitmap;
   uint32_t * restrict bitmap_dest = bitmap_index_dest-&gt;bitmap;
   _nassert(((int)bitmap_a &amp; 0x7) == 0);
   _nassert(((int)bitmap_b &amp; 0x7) == 0);
   _nassert(((int)bitmap_dest &amp; 0x7) == 0);
   for (i=0; i&lt;32; i++) {
       bitmap_dest[i] = bitmap_a[i] ^ bitmap_b[i];
   }
   BitmapIndex_update(bitmap_index_dest);
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p>
<h2><span class="mw-headline" id="Example_of_use_of_Bitmap_Indexes">Example of use of Bitmap Indexes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=14" title="Edit section: Example of use of Bitmap Indexes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Here is an example of software loop that can be transformed to significantly improve its performance
by converting boolean fields to bitmap indexes.
</p>
<h3><span class="mw-headline" id="Original_code">Original code</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=15" title="Edit section: Original code">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>&lt;syntaxhighlight lang='c'&gt;
</p>
<ol><li>define DATABASE_SIZE 1024</li></ol>
<p>typedef struct {
	int active;
	int urgent;
	int scheduled;
	int metric;
} DemoObject;
DemoObject database[1024];
</p><p>int example(int * statistics) {
	int i, ignored, result;
</p><p>	result = 0;
	ignored = 0;
	for (i=0; i &lt; 1024; i++) {
		/* "Complex" control loop.  */
		if (database[i].active) {
			if (database[i].scheduled &amp;&amp;&#160;!database[i].urgent) {
				/* Do something for scheduled and NOT urgent objects.  */
				result += database[i].metric * 7;
			} else if (database[i].scheduled &amp;&amp; database[i].urgent) {
				/* Do something for scheduled and urgent objects.  */
				result += database[i].metric * 10;
			} else {
				ignored++;
			}
		}
	}
	*statistics += ignored;
	return result;
}
&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="Optimized_code_using_Bitmap_Indexes">Optimized code using Bitmap Indexes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=16" title="Edit section: Optimized code using Bitmap Indexes">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>And here is what the same functionality looks like when the fields <code>active</code>, <code>scheduled</code>,
<code>urgent</code> have been converted into bitmap indexes.
</p><p>Benchmarking of this implementation shows a speed-up of the <code>example()</code> function of at least 8x!
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<ol><li>define DATABASE_SIZE 1024</li></ol>
<ol><li>pragma DATA_MEM_BANK(indexes, 0);</li></ol>
<p>BitmapIndex indexes[4];
</p><p>BitmapIndex *active = &amp;indexes[0];
BitmapIndex *urgent = &amp;indexes[1];
BitmapIndex *scheduled = &amp;indexes[2];
BitmapIndex *temporary = &amp;indexes[3];
</p><p>typedef struct {
	/* The boolean structure fields are no longer used, as they are replaced with bitmap indexes.  */
	/* Memory saving: 12K - 4 * 136 bytes = 11744 bytes, and in most cases a performance boost!  */
	int metric;
} DemoObject;
DemoObject database[1024];
</p><p>/* Utility functions for boolean logic. Assumption is made that all bitmap indexes are 64-bit aligned.  */
inline void BitmapIndex_active_not_scheduled(BitmapIndex *bitmap_index_a, BitmapIndex *bitmap_index_b,
</p>
<pre>     BitmapIndex *bitmap_index_dest) {
   int i;
   uint32_t * restrict bitmap_a = bitmap_index_a-&gt;bitmap;
   uint32_t * restrict bitmap_b = bitmap_index_b-&gt;bitmap;
   uint32_t * restrict bitmap_dest = bitmap_index_dest-&gt;bitmap;
   _nassert(((int)bitmap_a &amp; 0x7) == 0);
   _nassert(((int)bitmap_b &amp; 0x7) == 0);
   _nassert(((int)bitmap_dest &amp; 0x7) == 0);
   for (i=0; i&lt;32; i++) {
       bitmap_dest[i] = bitmap_a[i] &amp; (~ bitmap_b[i]);
   }
   BitmapIndex_update(bitmap_index_dest);
</pre>
<p>}
</p><p>inline void BitmapIndex_active_urgent_scheduled(BitmapIndex *bitmap_index_a, BitmapIndex *bitmap_index_b,
</p>
<pre>     BitmapIndex *bitmap_index_c, BitmapIndex *bitmap_index_dest) {
   int i;
   uint32_t * restrict bitmap_a = bitmap_index_a-&gt;bitmap;
   uint32_t * restrict bitmap_b = bitmap_index_b-&gt;bitmap;
   uint32_t * restrict bitmap_c = bitmap_index_c-&gt;bitmap;
   uint32_t * restrict bitmap_dest = bitmap_index_dest-&gt;bitmap;
   _nassert(((int)bitmap_a &amp; 0x7) == 0);
   _nassert(((int)bitmap_b &amp; 0x7) == 0);
   _nassert(((int)bitmap_c &amp; 0x7) == 0);
   _nassert(((int)bitmap_dest &amp; 0x7) == 0);
   for (i=0; i&lt;32; i++) {
       bitmap_dest[i] = bitmap_a[i] &amp; bitmap_b[i] &amp; bitmap_c[i];
   }
   BitmapIndex_update(bitmap_index_dest);
</pre>
<p>}
</p><p>inline void BitmapIndex_active_not_urgent_scheduled(BitmapIndex *bitmap_index_a, BitmapIndex *bitmap_index_b,
</p>
<pre>     BitmapIndex *bitmap_index_c, BitmapIndex *bitmap_index_dest) {
   int i;
   uint32_t * restrict bitmap_a = bitmap_index_a-&gt;bitmap;
   uint32_t * restrict bitmap_b = bitmap_index_b-&gt;bitmap;
   uint32_t * restrict bitmap_c = bitmap_index_c-&gt;bitmap;
   uint32_t * restrict bitmap_dest = bitmap_index_dest-&gt;bitmap;
   _nassert(((int)bitmap_a &amp; 0x7) == 0);
   _nassert(((int)bitmap_b &amp; 0x7) == 0);
   _nassert(((int)bitmap_c &amp; 0x7) == 0);
   _nassert(((int)bitmap_dest &amp; 0x7) == 0);
   for (i=0; i&lt;32; i++) {
       bitmap_dest[i] = bitmap_a[i] &amp; bitmap_b[i] &amp; (~ bitmap_c[i]);
   }
   BitmapIndex_update(bitmap_index_dest);
</pre>
<p>}
</p><p>int example(int * statistics) {
	int i, ignored, result, count;
</p><p>	result = 0;
	ignored = 0;
	BitmapIndex_active_not_urgent_scheduled(active, scheduled, urgent, temporary);
	count = BitmapIndex_compute_vector(temporary, iteration_vector);
	for (i=0; i&lt;count; i++) {
		result += database[iteration_vector[i]].metric * 7;
	}
	BitmapIndex_active_urgent_scheduled(active, scheduled, urgent, temporary);
	count = BitmapIndex_compute_vector(temporary, iteration_vector);
	for (i=0; i&lt;count; i++) {
		result += database[iteration_vector[i]].metric * 10;
	}
	BitmapIndex_active_not_scheduled(active, scheduled, temporary);
	ignored = temporary-&gt;count;
	*statistics += ignored;
	return result;
}
&lt;/syntaxhighlight&gt;
</p>
<h1><span class="mw-headline" id="Software_optimization_techniques_using_In-Memory_Bitmap_Indexes">Software optimization techniques using In-Memory Bitmap Indexes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=17" title="Edit section: Software optimization techniques using In-Memory Bitmap Indexes">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>Here are some examples of structural optimizations that are made possible by the use of Bitmap Indexes.
</p>
<h2><span class="mw-headline" id="convert_use_of_boolean_fields">convert use of boolean fields</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=18" title="Edit section: convert use of boolean fields">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h2><span class="mw-headline" id="convert_use_of_linked_lists">convert use of linked lists</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=19" title="Edit section: convert use of linked lists">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h2><span class="mw-headline" id="complex_database_queries_optimization">complex database queries optimization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=20" title="Edit section: complex database queries optimization">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h2><span class="mw-headline" id="convert_to_vectorized_processing">convert to vectorized processing</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=21" title="Edit section: convert to vectorized processing">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h2><span id="use_of_the_count_field_to_further_optimization_by_iterating_multiples_of_2,_4_times"></span><span class="mw-headline" id="use_of_the_count_field_to_further_optimization_by_iterating_multiples_of_2.2C_4_times">use of the count field to further optimization by iterating multiples of 2, 4 times</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;section=22" title="Edit section: use of the count field to further optimization by iterating multiples of 2, 4 times">edit</a><span class="mw-editsection-bracket">]</span></span></h2>

<!-- 
NewPP limit report
Cached time: 20201201023651
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.071 seconds
Real time usage: 0.073 seconds
Preprocessor visited node count: 90/1000000
Preprocessor generated node count: 104/1000000
Post‐expand include size: 348/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    1.592      1 Template:Under_Construction
100.00%    1.592      1 -total
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:8038-0!canonical and timestamp 20201201023651 and revision id 182207
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Optimized In-Memory Bitmap Indexes</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Optimized In-Memory Bitmap Indexes</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>Optimized In-Memory Bitmap Indexes</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>Optimized In-Memory Bitmap Indexes</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>Optimized In-Memory Bitmap Indexes</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Optimized In-Memory Bitmap Indexes</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Optimized In-Memory Bitmap Indexes</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>Optimized In-Memory Bitmap Indexes</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>Optimized In-Memory Bitmap Indexes</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;oldid=182207">https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;oldid=182207</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="Category_Compiler.html" title="Category:Compiler">Compiler</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=Optimized+In-Memory+Bitmap+Indexes" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="Optimized_In-Memory_Bitmap_Indexes.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Talk:Optimized_In-Memory_Bitmap_Indexes&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="Optimized_In-Memory_Bitmap_Indexes.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/Optimized_In-Memory_Bitmap_Indexes.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/Optimized_In-Memory_Bitmap_Indexes.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;oldid=182207" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=Optimized_In-Memory_Bitmap_Indexes&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 24 July 2014, at 08:43.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.071","walltime":"0.073","ppvisitednodes":{"value":90,"limit":1000000},"ppgeneratednodes":{"value":104,"limit":1000000},"postexpandincludesize":{"value":348,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    1.592      1 Template:Under_Construction","100.00%    1.592      1 -total"]},"cachereport":{"timestamp":"20201201023651","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":324});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/Optimized_In-Memory_Bitmap_Indexes by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 03:30:58 GMT -->
</html>
