<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/UserGuideOmap35xCaptureDriver_PSP_04.02.00.07 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 06:37:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>UserGuideOmap35xCaptureDriver PSP 04.02.00.07 - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"UserGuideOmap35xCaptureDriver_PSP_04.02.00.07","wgTitle":"UserGuideOmap35xCaptureDriver PSP 04.02.00.07","wgCurRevisionId":57578,"wgRevisionId":57578,"wgArticleId":9506,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"UserGuideOmap35xCaptureDriver_PSP_04.02.00.07","wgRelevantArticleId":9506,"wgRequestId":"e40bcb6ffe9fc713854b0675","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-UserGuideOmap35xCaptureDriver_PSP_04_02_00_07 rootpage-UserGuideOmap35xCaptureDriver_PSP_04_02_00_07 skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">UserGuideOmap35xCaptureDriver PSP 04.02.00.07</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div style="padding: 5px; background: none repeat scroll 0% 0% rgb(238, 238, 238); color: rgb(255, 0, 0);">
<ol><li><b>Please note that with this release we have migrated to new Media-controller framework, so the User interface has been changed. Please refer to below UserGuide for complete details about media-controller usage.</b></li>
<li><b>Also, Please note that Media-controller is not a replacement for standard V4L2 framework, this framework is plug-in to the existing V4L2 framework to allow user to create/enable/disable the link and set/get/enum format for the given link/entity.</b></li>
<li>Since this is new framework which is still under experiment, there could be issues with it. Please refer to <a rel="nofollow" class="external text" href="http://arago-project.org/git/projects/?p=linux-omap3.git;a=summary">Arago</a> for any updates or bug fixes.</li></ol>
</div>
<p><br />
<br />
</p>
<div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext"><b>Introduction</b></span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#References"><span class="tocnumber">1.1</span> <span class="toctext"><b>References</b></span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Acronyms_.26_Definitions"><span class="tocnumber">1.2</span> <span class="toctext"><b>Acronyms &amp; Definitions</b></span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Media-Controller_interface"><span class="tocnumber">2</span> <span class="toctext"><b>Media-Controller interface</b></span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="#Architecture"><span class="tocnumber">2.1</span> <span class="toctext"><b>Architecture</b></span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Software_Design_Interfaces"><span class="tocnumber">2.2</span> <span class="toctext"><b>Software Design Interfaces</b></span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#Opening_and_Closing_of_driver"><span class="tocnumber">2.2.1</span> <span class="toctext"><b>Opening and Closing of driver</b></span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Enumerate_available_Media_Entities"><span class="tocnumber">2.2.2</span> <span class="toctext"><b>Enumerate available Media Entities</b></span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Enumerate_available_Links_.26_Pads"><span class="tocnumber">2.2.3</span> <span class="toctext"><b>Enumerate available Links &amp; Pads</b></span></a></li>
<li class="toclevel-3 tocsection-10"><a href="#Enable.2FSetup.2FActivate_Links"><span class="tocnumber">2.2.4</span> <span class="toctext"><b>Enable/Setup/Activate Links</b></span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#V4L2_Sub-Device_Interface"><span class="tocnumber">3</span> <span class="toctext"><b>V4L2 Sub-Device Interface</b></span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Software_Design_Interfaces_2"><span class="tocnumber">3.1</span> <span class="toctext"><b>Software Design Interfaces</b></span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="#Opening_and_Closing_of_driver_2"><span class="tocnumber">3.1.1</span> <span class="toctext"><b>Opening and Closing of driver</b></span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#Set_the_format_at_each_pad"><span class="tocnumber">3.1.2</span> <span class="toctext"><b>Set the format at each pad</b></span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#Get_the_format_at_each_pad"><span class="tocnumber">3.1.3</span> <span class="toctext"><b>Get the format at each pad</b></span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="#V4L2_Streaming_Interface"><span class="tocnumber">4</span> <span class="toctext"><b>V4L2 Streaming Interface</b></span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="#Software_Design_Interfaces_3"><span class="tocnumber">4.1</span> <span class="toctext"><b>Software Design Interfaces</b></span></a>
<ul>
<li class="toclevel-3 tocsection-18"><a href="#Opening_and_Closing_of_driver_3"><span class="tocnumber">4.1.1</span> <span class="toctext"><b>Opening and Closing of driver</b></span></a></li>
<li class="toclevel-3 tocsection-19"><a href="#Buffer_Management"><span class="tocnumber">4.1.2</span> <span class="toctext"><b>Buffer Management</b></span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Query_Capabilities"><span class="tocnumber">4.1.3</span> <span class="toctext"><b>Query Capabilities</b></span></a></li>
<li class="toclevel-3 tocsection-21"><a href="#Input_Enumeration"><span class="tocnumber">4.1.4</span> <span class="toctext"><b>Input Enumeration</b></span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#Set_Input"><span class="tocnumber">4.1.5</span> <span class="toctext"><b>Set Input</b></span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#Get_Input"><span class="tocnumber">4.1.6</span> <span class="toctext"><b>Get Input</b></span></a></li>
<li class="toclevel-3 tocsection-24"><a href="#Standard_Enumeration"><span class="tocnumber">4.1.7</span> <span class="toctext"><b>Standard Enumeration</b></span></a></li>
<li class="toclevel-3 tocsection-25"><a href="#Standard_Detection"><span class="tocnumber">4.1.8</span> <span class="toctext"><b>Standard Detection</b></span></a></li>
<li class="toclevel-3 tocsection-26"><a href="#Set_Standard"><span class="tocnumber">4.1.9</span> <span class="toctext"><b>Set Standard</b></span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#Get_Standard"><span class="tocnumber">4.1.10</span> <span class="toctext"><b>Get Standard</b></span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#.27Format_Enumeration"><span class="tocnumber">4.1.11</span> <span class="toctext">'<i>Format Enumeration</i></span></a></li>
<li class="toclevel-3 tocsection-29"><a href="#Set_Format"><span class="tocnumber">4.1.12</span> <span class="toctext"><b>Set Format</b></span></a></li>
<li class="toclevel-3 tocsection-30"><a href="#Get_Format"><span class="tocnumber">4.1.13</span> <span class="toctext"><b>Get Format</b></span></a></li>
<li class="toclevel-3 tocsection-31"><a href="#Try_Format"><span class="tocnumber">4.1.14</span> <span class="toctext"><b>Try Format</b></span></a></li>
<li class="toclevel-3 tocsection-32"><a href="#Query_Control"><span class="tocnumber">4.1.15</span> <span class="toctext"><b>Query Control</b></span></a></li>
<li class="toclevel-3 tocsection-33"><a href="#Set_Control"><span class="tocnumber">4.1.16</span> <span class="toctext"><b>Set Control</b></span></a></li>
<li class="toclevel-3 tocsection-34"><a href="#Get_Control"><span class="tocnumber">4.1.17</span> <span class="toctext"><b>Get Control</b></span></a></li>
<li class="toclevel-3 tocsection-35"><a href="#Queue_Buffer"><span class="tocnumber">4.1.18</span> <span class="toctext"><b>Queue Buffer</b></span></a></li>
<li class="toclevel-3 tocsection-36"><a href="#Dequeue_Buffer"><span class="tocnumber">4.1.19</span> <span class="toctext"><b>Dequeue Buffer</b></span></a></li>
<li class="toclevel-3 tocsection-37"><a href="#Stream_On"><span class="tocnumber">4.1.20</span> <span class="toctext"><b>Stream On</b></span></a></li>
<li class="toclevel-3 tocsection-38"><a href="#Stream_Off"><span class="tocnumber">4.1.21</span> <span class="toctext"><b>Stream Off</b></span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-39"><a href="#Configuration_Steps"><span class="tocnumber">4.2</span> <span class="toctext"><b>Configuration Steps</b></span></a></li>
<li class="toclevel-2 tocsection-40"><a href="#Installation"><span class="tocnumber">4.3</span> <span class="toctext"><b>Installation</b></span></a>
<ul>
<li class="toclevel-3 tocsection-41"><a href="#Driver_built_statically"><span class="tocnumber">4.3.1</span> <span class="toctext"><b>Driver built statically</b></span></a></li>
<li class="toclevel-3 tocsection-42"><a href="#Driver_built_as_loadable_module"><span class="tocnumber">4.3.2</span> <span class="toctext"><b>Driver built as loadable module</b></span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-43"><a href="#Introduction_2"><span class="tocnumber">4.4</span> <span class="toctext"><b>Introduction</b></span></a></li>
<li class="toclevel-2 tocsection-44"><a href="#Hardware_Setup"><span class="tocnumber">4.5</span> <span class="toctext"><b>Hardware Setup</b></span></a></li>
<li class="toclevel-2 tocsection-45"><a href="#Applications"><span class="tocnumber">4.6</span> <span class="toctext"><b>Applications</b></span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Introduction"><b>Introduction</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=1" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The camera ISP is a key component for imaging and video applications such as video preview, video record, and still-image capture with or without digital zooming. 
<br />
The camera ISP provides the system interface and the processing capability to connect RAW image-sensor modules and video decoders to the OMAP35x device.
<br />
The capture module consists of the following interfaces:
</p>
<ul><li>One S-video SD input in BT.656 format.</li>
<li>One Composite SD input in BT.656 format.</li>
<li>One Camera sensor interface in YUV format</li></ul>
<p>BT656 video inputs are connected to one TVP5146 decoder and sensor is directly interfaced to OMAP35x CCDC. The application must create the link before starting streaming on the streaming device node of the link.
</p><p><br />
<br />
<b>NOTE:</b> Only one input can be captured or selected at any given point of time.
<br />
</p><p>The following figure shows the basic block diagram of capture interface for TVP5146 video decoder.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:483px;"><a href="File_Omap35x_capture_MC_overview.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/9/9a/Omap35x_capture_MC_overview.png" width="481" height="602" class="thumbimage" /></a>  <div class="thumbcaption">Capture Driver Component Overview</div></div></div></div>
<p><br />
The following figure shows the physical connection and inputs for TVP5146 decoder.
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:308px;"><a href="File_Omap35x_capture_input.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/4/46/Omap35x_capture_input.png" width="306" height="400" class="thumbimage" /></a>  <div class="thumbcaption">Capture Physical Input Interface</div></div></div></div>
<p><br />
</p><p>The Media-Controller framework has been adopted for OMAP3 ISP capture module. The Media-Controller framework exports hardware topology to the User space application as mesh or network of devices. Then User independently can set/get/enum formats at each entity and allows user to set/get/enumerate the link in current topology.
</p><p>Since Media-controller is just a plug-in to the existing V4L2 framework, the V4L2 Capture driver model is still being used for streaming and all standard V4L2 interfaces. The V4L2 driver model is widely used across many platforms in the Linux community. V4L2 provides good streaming support and support for many buffer formats. It also has its own buffer management mechanism that can be used.
</p><p><br />
</p>
<h2><span class="mw-headline" id="References"><b>References</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=2" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li>OMAP35x Camera Interface Subsystem (ISP) TRM</li></ul>
<p>Author: Texas Instruments, Inc.
Literature Number: SPRUFA2
</p>
<ul><li>OMAP35x Memory Management Units (MMUs)TRM</li></ul>
<p>Author: Texas Instruments, Inc.
Literature Number: SPRUFF5
</p>
<ul><li>Video for Linux Two API Specification</li></ul>
<p>Author: Michael H Schimek
Version: 0.23
</p>
<ul><li>Media-Controller Framework</li></ul>
<p>&lt;Linux Kernel&gt;/Documentation/video4linux/
<br />
</p>
<h2><span id="Acronyms_&amp;_Definitions"></span><span class="mw-headline" id="Acronyms_.26_Definitions"><b>Acronyms &amp; Definitions</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=3" title="Edit section: Acronyms &amp; Definitions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<table border="1" cellspacing="0" cellpadding="5" width="40%">
<caption><b>Capture Driver: Acronyms</b>
</caption>
<tbody><tr>
<th align="left">Acronym
</th>
<th align="left">Definition
</th></tr>
<tr>
<td>MMDC
</td>
<td>Mass Market Daughter Card/Customer Daughter Card
</td></tr>
<tr>
<td>3A
</td>
<td>Auto White Balance, Auto Focus, Auto Exposure
</td></tr>
<tr>
<td>API
</td>
<td>Application Programming Interface
</td></tr>
<tr>
<td>CCDC
</td>
<td>Input interface block of ISP
</td></tr>
<tr>
<td>DMA
</td>
<td>Direct Memory Access
</td></tr>
<tr>
<td>I/O
</td>
<td>Input &amp; Output
</td></tr>
<tr>
<td>IOCTL
</td>
<td>Input &amp; Output Control
</td></tr>
<tr>
<td>MMU
</td>
<td>Memory Management Unit
</td></tr>
<tr>
<td>V4L2
</td>
<td>Video for Linux specification version 2
</td></tr>
<tr>
<td>MC
</td>
<td>Media-Controller
</td></tr>
<tr>
<td>YUV
</td>
<td>Luminance + 2 Chrominance Difference Signals (Y, Cr, Cb) Color Encoding
</td></tr></tbody></table>
<p><br />
</p>
<pre><b>Features</b> 
</pre>
<p>The ISP Capture Driver provides the following features:
<br />
</p>
<ul><li>Supports multi software channel of capture and a corresponding device node (/dev/videoX) is created.</li>
<li>Supports multi sub-device nodes and corresponding sub device node (/dev/v4l2-subdevX) is created.</li>
<li>Supports single I/O instance and multiple control instances.</li>
<li>Supports buffer access mechanism through memory mapping and user pointers.</li>
<li>Supports dynamic switching among input interfaces with some necessary restrictions wherever applicable.</li>
<li>Supports NTSC and PAL standard on Composite and S-Video interfaces.</li>
<li>Supports 8-bit BT.656 capture in UYVY and YUYV interleaved formats.</li>
<li>Supports standard V4L2 IOCTLs to get/set various control parameters like brightness, contrast, saturation, hue and auto gain control.</li>
<li>TVP5146 (TVP514x) decoder driver module can be used statically or dynamically (insmod and rmmod supported).</li>
<li>In USERPTR mode of operation both malloc'd and IO mapped buffers are supported.</li>
<li>The camera ISP driver supports both static into kernel and modular build.</li></ul>
<p><br />
</p>
<h1><span class="mw-headline" id="Media-Controller_interface"><b>Media-Controller interface</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=4" title="Edit section: Media-Controller interface">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p><br />
OMAP3 ISP Camera driver has been migrated to the newly added Media-Controller (now onwards will refer as MC) framework into V4L2 sub-system. Basically MC exposes complex media device topology to the User Spaces a graph pf building blocks called <b>Entities</b> and they are connected to each other through <b>Pads</b>. 
User now has a capability to activate/deactivate links directly from User Space application.
<br />
</p>
<h2><span class="mw-headline" id="Architecture"><b>Architecture</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=5" title="Edit section: Architecture">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><br />
Following block diagram shows basic architecture of the MC on OMAP3 ISP Module -
</p>
<div class="center"><div class="thumb tnone"><div class="thumbinner" style="width:484px;"><a href="File_Omap35x-isp-MC-arch.html" class="image"><img alt="" src="https://processors.wiki.ti.com/images/6/62/Omap35x-isp-MC-arch.png" width="482" height="661" class="thumbimage" /></a>  <div class="thumbcaption">Media-Controller Framework for OMAP3 ISP (cut down version)</div></div></div></div>
<p><br />
The system architecture diagram illustrates the software components that are relevant to the Camera Driver. Some components are outside the scope of this design document.
</p><p><b>NOTE:</b>Currently only MT9T111/TVP5146 ==&gt; CCDC ==&gt; Memory path has been validated.
</p><p>The following is a brief description of each component in the figure.
</p><p>As shown in the above architecture diagram, media topology for OMAP3 ISP is consist of various entities, like CCDC, Previewer, Resizer, external peripherals (TVP5146 &amp; MT9T111), etc... Each entity will have one or more input/output pads depending on functionality. 
</p><p><b>MT9T111/TVP5146:</b> The MT9T111/TVP5146 Driver is platform and board independent. Driver registers to the MC framework as an sub-device entity and sub-device to V4L2 layer. This is V4L2 compliant driver with addition of MC support. MT9T111 is parallel sensor interface whereas TVP5146 is BT656 interface, both uses 8-bit data bus connected to ISP.
</p><p><b>CCDC:</b>
CCDC is a HW block in Camera ISP which acts as a data input port. It receives data from the sensor/decoder through parallel or serial interface. The CCDC driver (not a independent platform driver) registers to MC framework as media entity with various input/output pads. It is configured by the ISP driver based on the sensor/decoder attached and desired output from the camera driver.
</p><p><b>CCDC output:</b> This is streaming V4L2 device node, where standard V4L2 application would work.
</p><p><b>Resizer:</b> Resizer is HW block in Camera ISP which works in 2 ways, one-shot mode (memory-to-memory) and in on-the-fly mode (ccdc/previewer--&gt;resizer path). Resizer driver (not a independent platform driver) registers to MC framework as a media entity with 2 pads (one input and another output). The image format at the input and output pads may differ and based on that scaling ratio is being configured.
</p><p><b>Resizer input/output:</b>These are streaming device nodes, where standard V4L2 application would work.
</p><p><b>Previewer:</b>Previewer is HW block in Camera ISP which works in 2 ways, one-shot mode (memory-to-memory) and in on-the-fly mode (ccdc--&gt;previewer path). Previewer driver (not a independent platform driver) registers to MC framework as a media entity with 2 pads (one input and another output). The image format at the input and output pads may differ and based on that scaling ratio is being configured.
</p><p><b>Previewer input/output:</b>These are streaming device nodes, where standard V4L2 application would work.
</p>
<h2><span class="mw-headline" id="Software_Design_Interfaces"><b>Software Design Interfaces</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=6" title="Edit section: Software Design Interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><br />
</p>
<h3><span class="mw-headline" id="Opening_and_Closing_of_driver"><b>Opening and Closing of driver</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=7" title="Edit section: Opening and Closing of driver">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The device can be opened using open call from the application, with the device name and mode of operation as parameters. Based on underneath hardware and corresponding media topology, there could be multiple media device nodes (/dev/mediaX). In case of OMAP3 ISP, only one media topology is possible and is being exported by /dev/media0.
</p><p><b>Example:</b>
</p>
<pre>/* Open a media device in blocking mode */
fd = open("/dev/media0", O_RDWR);
if (fd == -1) {
    perror("failed to open media device\n");
    return -1;
}
/* closing of channel */
close (fd);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Enumerate_available_Media_Entities"><b>Enumerate available Media Entities</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=8" title="Edit section: Enumerate available Media Entities">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enumerate the information of available entities (both video-device and subdevice). It includes information like &lt;TBD&gt;.
<br />
Ioctl: <i>MEDIA_IOC_ENUM_ENTITIES</i>
<br />
It takes pointer to <i>media_entity_desc</i> structure. Application provides the id number for which it requires the information, in <i>id</i> member of <i>media_entity_desc</i> structure. Entities can be enumerated by oring the id with the <i>MEDIA_ENTITY_ID_FLAG_NEXT</i> flag. The driver will return information about the entity with the smallest id strictly larger than the requested one (next entity), or the &amp;EINVAL; if there is none.
<br />
<b>Example:</b>
</p>
<pre>

/* Define place holder for entities to enumerate */
struct media_entity_desc entity[20];
int index = 0;
...
...
do {
	memset(&amp;entity[index], 0, sizeof(entity));
	/* Set the id parameter to enumerate */
	entity[index].id = index | MEDIA_ENT_ID_FLAG_NEXT;

	ret = ioctl(media_fd, MEDIA_IOC_ENUM_ENTITIES, &amp;entity[index]);
	if (ret &lt; 0) {
			break;
	}else {
		/*
		 * Application should pick up respective entity and corresponding
		 * device/sub-device nodes for configuration and streaming.
		 */
		if (!strcmp(entity[index].name, "mt9t111 2-003c")) {
			entity_mt9t111 =  entity[index].id;
		}
		else if (!strcmp(entity[index].name, "tvp514x 3-005c")) {
			entity_tvp5146 =  entity[index].id;
		}
                else if (!strcmp(entity[index].name, "OMAP3 ISP CCDC")) {
			entity_ccdc =  entity[index].id;
                }
		printf("[%d]:%s\n", entity[index].id, entity[index].name);
	}
	index++;
}while (ret == 0);

printf("Total number of available entities:&#160;%u\n", index);

</pre>
<p><br />
</p>
<h3><span id="Enumerate_available_Links_&amp;_Pads"></span><span class="mw-headline" id="Enumerate_available_Links_.26_Pads"><b>Enumerate available Links &amp; Pads</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=9" title="Edit section: Enumerate available Links &amp; Pads">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enumerate the information of available links with all entities within media topology. It includes information like &lt;TBD&gt;.
<br />
Ioctl: <i>MEDIA_IOC_ENUM_LINKS</i>
<br />
It takes pointer to <i>media_links_enum</i> structure. Application provides the entity id number for which it requires the information, in <i>entity</i> member of <i>media_links_enum</i> structure which he would have known from <i>MEDIA_IOC_ENUM_ENTITIES</i>. Please make sure that you allocate memory space for pads/links for <i>pads</i> and <i>links</i> member of <i>media_links_enum</i> structure.
<br />
<b>Example:</b>
</p>
<pre>

struct media_links_enum links;
int index = 0, i;

/*
 * Details from MEDIA_IOC_ENUM_ENTITIES is being used here
 */
links.pads = malloc(sizeof( struct media_pad_desc) * entity[index].pads);
links.links = malloc(sizeof(struct media_link_desc) * entity[index].links);

for(index = 0; index &lt; num_entities; index++) {

  links.entity = entity[index].id;

  ret = ioctl(media_fd, MEDIA_IOC_ENUM_LINKS, &amp;links);
  if (ret &lt; 0) {
      break;
  } else {
    /* Display pads info */
    if(entity[index].pads)
      printf("pads for entity&#160;%d=", entity[index].id);

    for(i = 0;i&lt; entity[index].pads; i++) {
      printf("(%d,&#160;%s) ", links.pads-&gt;index, (links.pads-&gt;flags &amp; MEDIA_PAD_FLAG_INPUT)&#160;? "INPUT"&#160;: "OUTPUT");
      links.pads++;
    }
    printf("\n");

    /* Now display link info */
    for(i = 0; i &lt; entity[index].links; i++) {
      printf("[%d:%d]===&gt;[%d:%d]", links.links-&gt;source.entity,
                    links.links-&gt;source.index, 
                    links.links-&gt;sink.entity,
                    links.links-&gt;sink.index);
      if(links.links-&gt;flags &amp; MEDIA_LINK_FLAG_ENABLED)
        printf("\tACTIVE\n");
      else
        printf("\tINACTIVE \n");
      links.links++;
    }
  }
}
</pre>
<p><br />
<br />
</p>
<h3><span id="Enable/Setup/Activate_Links"></span><span class="mw-headline" id="Enable.2FSetup.2FActivate_Links"><b>Enable/Setup/Activate Links</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=10" title="Edit section: Enable/Setup/Activate Links">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to setup/enable/activate links with specified entities within media topology. 
<br />
Ioctl: <i>MEDIA_IOC_SETUP_LINK</i>
<br />
It takes pointer to <i>media_link_desc</i> structure. Application provides the all required information which would have been extracted using enumeration of media device while calling this ioctl. <br />
It take source and sink entity id, media pad type and pad index as an input argument.
</p><p><br />
<b>Example:</b>
</p>
<pre>/*
 * Details from MEDIA_IOC_ENUM_ENTITIES and MEDIA_IOC_ENUM_LINKS is being used here
 */
struct media_link_desc link;

memset(&amp;link, 0, sizeof(link));

link.flags |=  MEDIA_LINK_FLAG_ENABLED;
link.source.entity = entity_tvp5146;
link.source.index = 0;
link.source.flags = MEDIA_PAD_FLAG_OUTPUT;

link.sink.entity = entity_ccdc;
link.sink.index = 0;
link.sink.flags = MEDIA_PAD_FLAG_INPUT;

ret = ioctl(media_fd, MEDIA_IOC_SETUP_LINK, &amp;link);
if(ret) {
	printf("failed to setup/enable/activate link between tvp5146 and ccdc\n");
	goto cleanup;
}
printf("Link between [tvp5146]===&gt;[ccdc] enabled...\n");

</pre>
<p><br />
<br />
</p>
<h1><span class="mw-headline" id="V4L2_Sub-Device_Interface"><b>V4L2 Sub-Device Interface</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=11" title="Edit section: V4L2 Sub-Device Interface">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p><br />
All sub-devices in the media topology will have separate sub-device node (/dev/v4l-subdevX) exported to the 
</p>
<h2><span class="mw-headline" id="Software_Design_Interfaces_2"><b>Software Design Interfaces</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=12" title="Edit section: Software Design Interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><br />
</p>
<h3><span class="mw-headline" id="Opening_and_Closing_of_driver_2"><b>Opening and Closing of driver</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=13" title="Edit section: Opening and Closing of driver">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The device can be opened using open call from the application, with the device name and mode of operation as parameters. Based on underneath hardware and corresponding media topology, there could be multiple sub-device nodes (/dev/v4l-subdevX). In case of OMAP3 ISP, we have in all total 8 sub-devices being exported by /dev/v4l-subdevX.
</p><p><b>Example:</b>
</p>
<pre>/* Open a sub-device 0 in blocking mode */
fd = open("/dev/v4l-subdev0", O_RDWR);
if (fd == -1) {
    perror("failed to open subdev device\n");
    return -1;
}
/* closing of channel */
close (fd);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Set_the_format_at_each_pad"><b>Set the format at each pad</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=14" title="Edit section: Set the format at each pad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Before starting streaming on corresponding channel, user must set the format at each pad of every entity of the configured link. 
</p><p><br />
Ioctl: <i>VIDIOC_SUBDEV_S_FMT</i>
<br />
It takes pointer to <i>v4l2_subdev_format</i> structure. Application provides the all required information like,
</p><p>Media bus format type, possible values/options are 
</p>
<pre>  - V4L2_SUBDEV_FORMAT_TRY
  - V4L2_SUBDEV_FORMAT_ACTIVE
</pre>
<p>Data format code, possible codes options are -
</p><p>Below example illustrates how user can set the format at pad level -
</p>
<pre>  - V4L2_MBUS_FMT_UYVY8_2X8
  - V4L2_MBUS_FMT_VYUY8_2X8
</pre>
<p><b>NOTE:</b> Please note that currently we are supporting only 2 codes mentioned above but theoretically there various formats supported by driver. Please refer to the file <i>include/linux/v4l2-mediabus.h</i> for all supported media bus formats.
</p><p><br />
<b>Example:</b>
</p>
<pre>struct v4l2_subdev_format fmt;

/*
 * Set the required format
 */
memset(&amp;fmt, 0, sizeof(fmt));
fmt.pad = 0;
fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
fmt.format.code = V4L2_MBUS_FMT_UYVY8_2X8;
fmt.format.width = &lt;width&gt;;
fmt.format.height = &lt;height&gt;;
fmt.format.colorspace = V4L2_COLORSPACE_SMPTE170M;
fmt.format.field = V4L2_FIELD_INTERLACED;
ret = ioctl(ccdc_fd, VIDIOC_SUBDEV_S_FMT, &amp;fmt);
if(ret) {
    printf("failed to set format on pad&#160;%x\n", fmt.pad);
}
</pre>
<h3><span class="mw-headline" id="Get_the_format_at_each_pad"><b>Get the format at each pad</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=15" title="Edit section: Get the format at each pad">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the format set/configured at specified pad of underneath sub-device. 
<br />
Ioctl: <i>VIDIOC_SUBDEV_G_FMT</i>
<br />
It takes pointer to <i>v4l2_subdev_format</i> structure. Application provides pad number and corresponding media type. <br />
It take source and sink entity id, media pad type and pad index as an input argument.
</p><p><br />
<b>Example:</b>
</p>
<pre>struct v4l2_subdev_format fmt;

/*
 * Get the format used at pad 0 of underneath sub-device
 */
memset(&amp;fmt, 0, sizeof(fmt));
fmt.pad = 0;
fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
ret = ioctl(ccdc_fd, VIDIOC_SUBDEV_G_FMT, &amp;fmt);
if(ret) {
    printf("failed to set format on pad&#160;%x\n", fmt.pad);
}
</pre>
<p><br />
</p>
<h1><span class="mw-headline" id="V4L2_Streaming_Interface"><b>V4L2 Streaming Interface</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=16" title="Edit section: V4L2 Streaming Interface">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p><br />
</p>
<h2><span class="mw-headline" id="Software_Design_Interfaces_3"><b>Software Design Interfaces</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=17" title="Edit section: Software Design Interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><br />
</p>
<h3><span class="mw-headline" id="Opening_and_Closing_of_driver_3"><b>Opening and Closing of driver</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=18" title="Edit section: Opening and Closing of driver">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The device can be opened using open call from the application, with the device name and mode of operation as parameters. Application should open the driver in blocking mode. In this mode, DQBUF IOCTL will not return until an empty frame is available.
</p>
<pre>/* Open a video capture logical channel in blocking mode */
fd = open("/dev/video0", O_RDWR);
if (fd == -1) {
    perror("failed to open Capture device\n");
    return -1;
}
/* closing of channel */
close (fd);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Buffer_Management"><b>Buffer Management</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=19" title="Edit section: Buffer Management">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>ISP Capture driver can work with physically non-contiguous buffers. It uses the ISP MMU to capture data to buffers scattered to a set of page frames. Hence, in user pointer mode the application can allocate buffers in user space, which need not be physically contiguous, and pass this directly to driver for capture operation. The only restriction for the user buffer is that, the buffer should be aligned to 32 bytes boundary. 
<br />
The driver supports both memory usage modes:
</p>
<ol><li>Memory map buffer mode</li>
<li>User Pointer mode</li></ol>
<p><br />
In Memory map buffer mode, application can request memory from the driver by calling <i>VIDIOC_REQBUFS</i> IOCTL. In user buffer mode, application needs to allocate memory using some other mechanism in user space like <i>malloc</i> or <i>memalign</i>. In driver buffer mode, maximum number of buffers is limited to <i>VIDEO_MAX_FRAME</i> (defined in driver header files) and is limited by the available memory in the kernel.
<br />
The main steps that the application must perform for buffer allocation are:
<br />
</p>
<ol><li>Allocating Memory</li>
<li>Getting Physical Address</li>
<li>Mapping Kernel Space Address to User Space</li></ol>
<p><br />
<b>Allocating Memory </b>
<br />
This IOCTL is used to allocate memory for frame buffers. This is the necessary IOCTL for streaming IO. It has to be called for both driver buffer mode and user buffer mode. Using this IOCTL, driver will know whether driver buffer mode or user buffer mode will be used.
<br />
<i>Ioctl: VIDIOC_REQBUFS </i>
<br />
It takes a pointer to instance of <i>v4l2_requestbuffers</i> structure as an argument. User should specify buffer type as <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i>, number of buffers, and memory type <i>V4L2_MEMORY_MMAP</i>, <i>V4L2_MEMORY_USERPTR</i> at the time of buffer allocation.
<br />
<i> Constraint:</i> This IOCTL can be called only once from the application. This IOCTL is necessary IOCTL.
</p><p><b>Example:</b>
</p>
<pre>/* structure to store buffer request parameters */
struct v4l2_requestbuffers reqbuf;
reqbuf.count = numbuffers;
reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
reqbuf.memory = V4L2_MEMORY_MMAP;
ret = ioctl(fd, VIDIOC_REQBUFS, &amp;reqbuf);
if (ret &lt; 0) {
    printf("cannot allocate memory\n");
    close(fd);
    return -1;
}
printf("Number of buffers allocated =&#160;%d\n", reqbuf.count);
</pre>
<p><br />
<b> Getting Physical Address </b>
<br />
This IOCTL is used to query buffer information like buffer size and buffer physical address. This physical address is used in mmapping the buffers. This IOCTL is necessary for driver buffer mode as it provides the physical address of buffers, which are used to mmap system call the buffers.
<br />
<i> Ioctl: VIDIOC_QUERYBUF </i>
<br />
It takes a pointer to instance of <i>v4l2_buffer</i> structure as an argument. User has to specify buffer type as <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i>, buffer index, and memory type <i>(V4L2_MEMORY_MMAP)</i> at the time of querying.
<br />
<b>Example:</b>
</p>
<pre>/* allocate buffer by VIDIOC_REQBUFS */
/* structure to query the physical address of allocated buffer */
struct v4l2_buffer buffer;
buffer.index = 0; /* buffer index for quering -0 */
buffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
buffer.memory = V4L2_MEMORY_MMAP;
if (ioctl(fd, VIDIOC_QUERYBUF, &amp;buffer) &lt; -1) {
    printf("buffer query error.\n");
    close(fd);
    exit(-1);
}
The buffer.m.offset will contain the physical address returned from driver.
</pre>
<p><br />
<b>Mapping Kernel Space Address to User Space </b>
<br />
Mapping the kernel buffer to the user space can be done via mmap. This is only required for MMAP buffer mode. User can pass buffer size and physical address of buffer for getting the user space address.
<br />
<b>Example:</b>
<br />
</p>
<pre>/* allocate buffer by VIDIOC_REQBUFS */
/* query the buffer using VIDIOC_QUERYBUF */
/* addr hold the user space address */
int addr;
addr = mmap(NULL, buffer.size,PROT_READ | PROT_WRITE, MAP_SHARED, fd, buffer.m.offset);
/* buffer.m.offset is same as returned from VIDIOC_QUERYBUF */
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Query_Capabilities"><b>Query Capabilities</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=20" title="Edit section: Query Capabilities">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to verify kernel devices compatibility with V4L2 specification and to obtain information about individual hardware capabilities. In this case, it will return capabilities provided by ISP capture driver and current decoder driver.
<br />
<i> Ioctl: VIDIOC_QUERYCAP </i>
<br />
Capabilities can be video capture <i>V4L2_CAP_VIDEO_CAPTURE</i> and streaming <i>V4L2_CAP_STREAMING</i>. It takes pointer to <i>v4l2_capability</i> structure as an argument. Capabilities can be accessed by capabilities field in the <i>v4l2_capability</i> structure.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_capability capability;
ret = ioctl(fd, VIDIOC_QUERYCAP, &amp;capability);
if (ret &lt; 0) {
    printf("Cannot do QUERYCAP\n");
    return -1;
}
if (capability.capabilities &amp; V4L2_CAP_VIDEO_CAPTURE) {
    printf("Capture capability is supported\n");
}
if (capability.capabilities &amp; V4L2_CAP_STREAMING) {
    printf("Streaming is supported\n");
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Input_Enumeration"><b>Input Enumeration</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=21" title="Edit section: Input Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enumerate the information of available inputs (analog interface). It includes information like name of input type and supported standards for that input type.
<br />
<i> Ioctl: VIDIOC_ENUMINPUT</i>
<br />
It takes pointer to <i>v4l2_input</i> structure. Application provides the index number for which it requires the information, in index member of <i>v4l2_input</i> structure. Index with value zero indicates first input type of the decoder. It returns combination of the standards supported on this input in the std member of <i>v4l2_input</i> structure.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_input input;
i = 0;
while(1) {
	input.index = i;
	ret = ioctl(fd, VIDIOC_ENUMINPUT, &amp;input);
	if (ret &lt; 0)
	break;
	printf("name =&#160;%s\n", input.name);
	i++;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Set_Input"><b>Set Input</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=22" title="Edit section: Set Input">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set input type (analog interface type). 
<br />
<i> Ioctl: VIDIOC_S_INPUT</i>
<br />
This IOCTL takes pointer to integer containing index of the input which has to be set. Application will provide the index number as an argument.
<br />
0 - Composite input, 
1 - S-Video input.
<br />
<b>Example:</b>
</p>
<pre>int index = 1; /*To set S-Video input*/
struct v4l2_input input;
ret = ioctl(fd, VIDIOC_S_INPUT, &amp;index);
if (ret &lt; 0) {
    perror("VIDIOC_S_INPUT\n");
    close(fd);
    return -1;
}
input.index = index;
ret = ioctl(fd, VIDIOC_ENUMINPUT, &amp;input);
if (ret &lt; 0) {
    perror("VIDIOC_ENUMINPUT\n");
    close(fd);
    return -1;
}
printf("name of the input =&#160;%s\n",input.name);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Get_Input"><b>Get Input</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=23" title="Edit section: Get Input">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the current input type (analog interface type). 
<br />
<i> Ioctl: VIDIOC_G_INPUT</i>
<br />
This IOCTL takes pointer to integer using which the detected inputs will be returned. It will return the software managed input detected during open system call. Application will provide the index number as an output argument.
<br />
<b>Example:</b>
</p>
<pre>int input;
struct v4l2_input input;
ret = ioctl(fd, VIDIOC_G_INPUT, &amp;input);
if (ret &lt; 0) {
    perror("VIDIOC_G_INPUT\n");
    close(fd);
    return -1;
}
input.index = index;
ret = ioctl(fd, VIDIOC_ENUMINPUT, &amp;input);
if (ret &lt; 0) {
    perror("VIDIOC_ENUMINPUT\n");
    close(fd);
    return -1;
}
printf("name of the input =&#160;%s\n", input.name);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Standard_Enumeration"><b>Standard Enumeration</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=24" title="Edit section: Standard Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enumerate the information regarding video standards. This IOCTL is used to enumerate all the standards supported by the registered decoder.
<br />
<i> Ioctl: VIDIOC_ENUMSTD</i>
<br />
This IOCTL takes a pointer to <i>v4l2_standard</i> structure. Application provides the index of the standard to be enumerated in the index member of this structure. It provides information like standard name, standard ID defined at V4L2 header files (few new standards are included in the respective decoder header files, which were not available in standard V4L2 header files), and numerator and denominator values for frame period and frame lines. It takes index as an argument as a part of <i>v4l2_standard</i> structure.
<br />
Index with value zero provides information for the first standard among all the standards of all the registered decoders.
If the index value exceeds the number of supported standards, it returns an error.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_standard standard;
i = 0;
while(1) {
	standard.index = i;
	ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
	if (ret &lt; 0)
		break;
	printf("name =&#160;%s\n", std.name);
	printf("framelines =&#160;%d\n", std.framelines);
	printf("numerator =&#160;%d\n",
	std.frameperiod.numerator);
	printf("denominator =&#160;%d\n",
	std.frameperiod.denominator);
	i++;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Standard_Detection"><b>Standard Detection</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=25" title="Edit section: Standard Detection">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to detect the current video standard set in the current decoder.
<br />
<i> Ioctl: VIDIOC_QUERYSTD</i>
<br />
It takes a pointer to <i>v4l2_std_id</i> instance as an output argument. Driver will call the current decoder's function internally (which has been initialized) to detect the current standard set in hardware. Support of this IOCTL depends on decoder device, whether it can detect a standard or not.
<br />
<b>Note:</b> This IOCTL should be called by the application so that the camera driver can configure ISP properly with the detected decoder standard. Standard IDs are defined in the V4L2 header files
<br />
<b>Example:</b>
</p>
<pre>v4l2_std_id std;
struct v4l2_standard standard;
ret = ioctl(fd, VIDIOC_QUERYSTD, &amp;std);
if (ret &lt; 0) {
	perror("VIDIOC_QUERYSTD\n");
	close(fd);
	return -1;
}
while(1) {
	standard.index = i;
	ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
	if (ret &lt; 0)
		break;
	if (standard.std &amp; std) {
		printf("%s standard detected\n", standard.name);
		break;
	}
	i++;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Set_Standard"><b>Set Standard</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=26" title="Edit section: Set Standard">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set the standard in the decoder.
<br />
<i> Ioctl: VIDIOC_S_STD</i>
<br />
It takes a pointer to <i>v4l2_std_id</i> instance as an input argument. If the standard is not supported by the decoder, the driver will return an error Standard IDs are defined in the V4L2 header files (few new standards are included in respective decoder header files, which were not available in standard V4L2 header files).
</p><p><b>Note:</b> Application need not call this IOCTL as the decoder can auto detect the current standard. This is required only when the application needs to set a particular standard. In this case, the decoder driver auto detect function is disabled. Auto detect can be enabled again only by closing and re-opening the driver.
<br />
<b>Example:</b>
</p>
<pre>v4l2_std_id std = V4L2_STD_NTSC;
ret = ioctl(fd, VIDIOC_S_STD, &amp;std);
if (ret &lt; 0) {
	perror("S_STD\n");
	close(fd);
	return -1;
}
while(1) {
	standard.index = i;
	ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
	if (ret &lt; 0)
		break;
	if (standard.std &amp; std) {
		printf("%s standard is selected\n");
		break;
	}
	i++;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Get_Standard"><b>Get Standard</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=27" title="Edit section: Get Standard">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the current standard in the current decoder.
<br />
<i> Ioctl: VIDIOC_G_STD</i>
<br />
It takes a pointer to <i>v4l2_std_id</i> instance as an output argument. Standard IDs are defined in the V4L2 header files
<br />
<b>Example:</b>
</p>
<pre>v4l2_std_id std;
ret = ioctl(fd, VIDIOC_G_STD, &amp;std);
if (ret &lt; 0) {
	perror("G_STD\n");
	close(fd);
	return -1;
}
while(1) {
	standard.index = i;
	ret = ioctl(fd, VIDIOC_ENUMSTD, &amp;standard);
	if (ret &lt; 0)
		break;
	if (standard.std &amp; std) {
		printf("%s standard is selected\n");
		break;
	}
	i++;
}
</pre>
<p><br />
</p>
<h3><span id="'Format_Enumeration"></span><span class="mw-headline" id=".27Format_Enumeration">'<i>Format Enumeration</i></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=28" title="Edit section: &#039;Format Enumeration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enumerate the information of pixel formats. The driver supports only two pixel form at -8-bit UYVY interleaved and 8-bit YUYV interleaved.
<br />
<i> Ioctl: VIDIOC_ENUM_FMT </i>
<br />
It takes a pointer to instance of <i>v4l2_fmtdesc</i> structure as an output parameter. Application must provide the buffer type in the type argument of <i>v4l2_fmtdesc</i> structure as <i> V4L2_BUF_TYPE_VIDEO_CAPTURE </i> and index member of this structure as zero.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_fmtdesc fmt;
i = 0;
while(1) {
	fmt.index = i;
	ret = ioctl(fd, VIDIOC_ENUM_FMT, &amp;fmt);
	if (ret &lt; 0)
		break;
	printf("description =&#160;%s\n",fmt.description);
	if (fmt.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
		printf("Video capture type\n");
	if (fmt.pixelformat == V4L2_PIX_FMT_YUYV)
		printf("V4L2_PIX_FMT_YUYV\n");
	i++;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Set_Format"><b>Set Format</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=29" title="Edit section: Set Format">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set the format parameters. The format parameters are line offset, storage format, pixel format, and so on. This IOCTL is one of the necessary IOCTL. If it is not set, it uses the following default values:
<br />
</p>
<ul><li>Default storage format - V4L2_FIELD_INTERLACED</li></ul>
<p><br />
This IOCTL expects proper width and height members of the <i>v4l2_format</i> structure from application as per the standard selected. Please note that, <i>V4L2_FIELD_INTERLACED</i> is the only storage format supported.
<br />
The application can decide the buffer pixel format using pixelformat member of this IOCTL. The current driver supports - 8-bit UYVY interleaved and 8-bit YUYV interleaved formats.
<br />
The desired pitch of the buffer can be set by using the bytesperline member. The pitch should be at least one line size in bytes. When changing the pitch, the application should also modify the sizeimage member accordingly - sizeimage should be at least pitch * image height.
<br />
The driver allocates buffer of size sizeimage member of the <i>v4l2_format</i> structure passed through this IOCTL for both mmap buffer and user pointer mode. Driver validates the provided buffer size along with the other members and uses this buffer size for calculating offsets for storing video data.
<br />
This IOCTL is a necessary IOCTL for the user buffer mode because driver will know the buffer size for user buffer mode. If it not called for the user buffer mode, driver assumes the default buffer size and calculates offsets accordingly.
<br />
<i> Ioctl: VIDIOC_S_FMT </i>
<br />
It will take pointer to instance of v4l2_format structure as an input parameter. If the type member is <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i>, it checks pixel format, pitch value, and image size. It returns an error, if the parameters are invalid.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_format fmt;
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
/* for  NTSC standard */
fmt.fmt.pix.width = 720;
fmt.fmt.pix.height = 480;
fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;
ret = ioctl(fd, VIDIOC_S_FMT, &amp;fmt);
if (ret &lt; 0) {
	perror("VIDIOC_S_FMT\n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Get_Format"><b>Get Format</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=30" title="Edit section: Get Format">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the current format parameters.
<br />
<i>Ioctl: VIDIOC_G_FMT </i>
<br />
It takes a pointer to instance of <i>v4l2_format</i> structure as an input parameter. Driver provides format parameters in the structure pointer passed as an argument. <i>v4l2_format</i> structure contains parameters like pixel format, image size, bytes per line, and field type. For type <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i>, the <i>v4l2_pix_format</i> structure of fmt union is filled.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_format fmt;
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ret = ioctl(fd, VIDIOC_G_FMT, &amp;fmt);
if (ret &lt; 0) {
	perror("VIDIOC_G_FMT\n");
	close(fd);
	return -1;
}
if (fmt.fmt.pix.pixelformat == V4L2_PIX_FMT_YUYV)
	printf("8-bit UYVY pixel format\n");
printf("Size of the buffer =&#160;%d\n", fmt.fmt.pix.sizeimage);
printf("Line offset =&#160;%d\n", fmt.fmt.pix.bytesperline);
if (fmt.fmt.pix.field == V4L2_FIELD_INTERLACED)
	printf("Storate format is interlaced frame format");
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Try_Format"><b>Try Format</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=31" title="Edit section: Try Format">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to validate the format parameters provided by the application. It checks parameters and returns the correct parameter, if any parameter is incorrect. It returns error only if the parameters passed are ambiguous.
<br />
<i>Ioctl: VIDIOC_TRY_FMT</i>
<br />
It takes a pointer to instance of v4l2_format structure as an input/output parameter If the type member is <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i>, it checks pixel format, pitch value, and image size. It returns errors to the application, if the parameters are invalid.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_format fmt;
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_UYVY;
fmt.fmt.pix.sizeimage = size;
fmt.fmt.pix.bytesperline = pitch;
fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;
ret = ioctl(fd, VIDIOC_TRY_FMT, &amp;fmt);
if (ret &lt; 0) {
	perror("VIDIOC_TRY_FMT\n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Query_Control"><b>Query Control</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=32" title="Edit section: Query Control">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the information of controls that is, brightness, contrast, and so on supported by the current decoder.
<br />
<i>Ioctl: VIDIOC_QUERYCTRL</i>
<br />
This IOCTL takes a pointer to the instance of <i>v4l2_queryctrl</i> structure as the argument and returns the control information in the same pointer. Application provides the control ID in the <i>v4l2_queryctrl</i> id member in this structure. This control ID is defined in V4L2 header file, for which information is needed. If the control command specified by Id is not supported in current decoder, driver will return an error.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_queryctrl ctrl;
ctrl.id = V4L2_CID_CONTRAST;
ret = ioctl(fd, VIDIOC_QUERYCTRL, &amp;ctrl);
if (ret &lt; 0) {
	perror("VIDIOC_QUERYCTRL \n");
	close(fd);
	return -1;
}
printf("name =&#160;%s\n", ctrl.name);
printf("min =&#160;%d max =&#160;%d step =&#160;%d default =&#160;%d\n",
ctrl.minimum, ctrl.maximum, ctrl.step, ctrl.default_value);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Set_Control"><b>Set Control</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=33" title="Edit section: Set Control">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to set the value for a particular control in current decoder. To set the control value, this IOCTL can also be called when streaming is on.
<br />
<i>Ioctl: VIDIOC_S_CTRL</i>
<br />
It takes a pointer to instance of <i>v4l2_control</i> structure as an input parameter. Application provides control ID and control values in the <i>v4l2_control</i> id and value member in this structure. If the control command specified by Id is not supported in the current decoder and if value of the control is out of range, driver returns an error. Otherwise, it sets the control in the registers.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_control ctrl;
ctrl.id = V4L2_CID_CONTRAST;
ctrl.value = 100;
ret = ioctl(fd, VIDIOC_S_CTRL, &amp;ctrl);
if (ret &lt; 0) {
	perror("VIDIOC_S_CTRL\n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Get_Control"><b>Get Control</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=34" title="Edit section: Get Control">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to get the value for a particular control in the current decoder.
<br />
<i>Ioctl: VIDIOC_G_CTRL</i>
<br />
It takes a pointer to instance of <i>v4l2_control</i> structure as an output parameter. Application provides the control ID of id member in this structure. If the control command specified by Id is not supported in the current decoder, driver returns an error. Otherwise, it returns the value of the control in the value member of the <i>v4l2_control</i> structure.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_control ctrl;
ctrl.id = V4L2_CID_CONTRAST;
ret = ioctl(fd, VIDIOC_G_CTRL, &amp;ctrl);
if (ret &lt; 0) {
	perror("VIDIOC_G_CTRL\n");
	close(fd);
	return -1;
}
printf("value =&#160;%x\n", ctrl.value);
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Queue_Buffer"><b>Queue Buffer</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=35" title="Edit section: Queue Buffer">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to enqueue the buffer in buffer queue. This IOCTL will enqueue an empty buffer in the driver buffer queue. This IOCTL is one of necessary IOCTL for streaming IO. If no buffer is enqueued before starting streaming, driver returns an error as there is no buffer available. So at least one buffer must be enqueued before starting streaming. This IOCTL is also used to enqueue empty buffers after streaming is started. 
<br />
<i>Ioctl: VIDIOC_QBUF</i>
<br />
This IOCTL takes a pointer to instance of <i>v4l2_buffer</i> structure as an argument. Application has to specify the buffer type
<i>(V4L2_BUF_TYPE_VIDEO_CAPTURE)</i>, buffer index, and memory type <i>V4L2_MEMORY_MMAP</i> or <i>V4L2_MEMORY_USERPTR</i> at the time of queuing. For the user pointer buffer exchange mechanism, application also has to provide buffer pointer in the m.userptr member of <i>v4l2_buffer</i> structure.
<br />
Driver will enqueue buffer in the driver's incoming queue. It will take pointer to instance of v4l2_ buffer structure as an input parameter.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_buffer buf;
buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
buf.type = V4L2_MEMORY_MMAP;
buf.index = 0;
ret = ioctl(fd, VIDIOC_QBUF, &amp;buf);
if (ret &lt; 0) {
	perror("VIDIOC_QBUF\n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Dequeue_Buffer"><b>Dequeue Buffer</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=36" title="Edit section: Dequeue Buffer">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to dequeue the buffer in the buffer queue. This IOCTL will dequeue the captured buffer from buffer queue of the driver. This IOCTL is one of necessary IOCTL for the streaming IO. This IOCTL can be used only after streaming is started. This IOCTL will block until an empty buffer is available.
<br />
<b>Note:</b> The application can dequeue all buffers from the driver - the driver will not hold the last buffer to itself. In this case, the driver will disable the capture operation and the capture operation resumes when a buffer is queued to the driver again.
<br />
<i>Ioctl: VIDIOC_DQBUF</i>
<br />
It takes a pointer to instance of v4l2_buffer structure as an output parameter. Application has to specify the buffer type <i>V4L2_BUF_TYPE_VIDEO_CAPTURE</i> and memory type <i>V4L2_MEMORY_MMAP</i> or <i>V4L2_MEMORY_USERPTR</i> at the time of dequeueing.
<br />
If this IOCTL is called with the file descriptor, with which <i>VIDIOC_REQBUF</i> is not performed, driver will return an error. Driver will enqueue buffer, if the buffer queue is not empty.
<br />
<b>Example:</b>
</p>
<pre>struct v4l2_buffer buf;
buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
buf.type = V4L2_MEMORY_MMAP;
ret = ioctl(fd, VIDIOC_DQBUF, &amp;buf);
if (ret &lt; 0) {
	perror("VIDIOC_DQBUF\n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Stream_On"><b>Stream On</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=37" title="Edit section: Stream On">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to start video capture functionality. 
<br />
<i>Ioctl: VIDIOC_STREAMON</i>
<br />
If streaming is already started, this IOCTL call returns an error. 
<br />
<b>Example:</b>
</p>
<pre>v4l2_buf_type buftype = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ret = ioctl(fd, VIDIOC_STREAMON, &amp;buftype);
if (ret &lt; 0) {
	perror("VIDIOC_STREAMON \n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<h3><span class="mw-headline" id="Stream_Off"><b>Stream Off</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=38" title="Edit section: Stream Off">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>This IOCTL is used to stop video capture functionality. 
<br />
<i>Ioctl: VIDIOC_STREAMOFF</i>
<br />
If streaming is not started, this IOCTL call returns an error.
<br />
<b>Example:</b>
</p>
<pre>v4l2_buf_type buftype = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ret = ioctl(fd, VIDIOC_STREAMOFF, &amp;buftype);
if (ret &lt; 0) {
	perror("VIDIOC_STREAMOFF \n");
	close(fd);
	return -1;
}
</pre>
<p><br />
</p>
<pre><b>Driver Configuration</b> 
</pre>
<p><br />
</p>
<h2><span class="mw-headline" id="Configuration_Steps"><b>Configuration Steps</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=39" title="Edit section: Configuration Steps">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To enable capture driver support in the kernel, start <i>Linux Kernel Configuration</i> tool.
</p><p><br />
</p>
<pre>$ make menuconfig  ARCH=arm
</pre>
<ul><li>Select <i>Device Drivers</i> from the main menu.</li></ul>
<pre>...
...
Kernel Features  ---&gt;
Boot options  ---&gt;
CPU Power Management  ---&gt;
Floating point emulation  ---&gt;
Userspace binary formats  ---&gt;
Power management options  ---&gt;
[*] Networking support  ---&gt;
<b>Device Drivers  ---&gt;</b>
...
...
</pre>
<ul><li>Select <i>Multimedia support</i> from the menu.</li></ul>
<pre>...
...
Sonics Silicon Backplane  ---&gt;
Multifunction device drivers  ---&gt;
[*] Voltage and Current Regulator Support  ---&gt;
<b>&lt;*&gt; Multimedia support  ---&gt;</b>
Graphics support  ---&gt;
&lt;*&gt; Sound card support  ---&gt;
[*] HID Devices  ---&gt;
[*] USB support  ---&gt;
...
...
</pre>
<ul><li>Select <i>Media Controller API</i> from the menu</li></ul>
<pre>...
...
--- Multimedia support
     *** Multimedia core support *** 
<b>[*]   Media Controller API (EXPERIMENTAL)</b>
&lt;*&gt;   Video For Linux
...
...
</pre>
<p><br />
</p>
<ul><li>Select <i>Video For Linux</i> from the menu.</li></ul>
<pre>...
...
*** Multimedia core support ***
[*]   Media Controller API (EXPERIMENTAL)
<b>&lt;*&gt;   Video For Linux</b>
[*]     Enable Video For Linux API 1 (DEPRECATED)
&lt; &gt;   DVB for Linux
...
...
</pre>
<ul><li>Select <i>V4L2 sub-device userspace API</i> from the menu.</li></ul>
<pre>...
...
*** Multimedia core support ***
[*]   Media Controller API (EXPERIMENTAL)
&lt;*&gt;   Video For Linux
[*]     Enable Video For Linux API 1 (DEPRECATED)
<b>[*]     V4L2 sub-device userspace API (EXPERIMENTAL)</b>
&lt; &gt;   DVB for Linux
...
...
</pre>
<ul><li>Select <i>Video capture adapters</i> from the same menu. Press &lt;ENTER&gt; to enter the corresponding sub-menu.</li></ul>
<pre>...
...
[ ]   Customize analog and hybrid tuner modules to build  ---&gt;
<b>[*]   Video capture adapters  ---&gt;</b>
[ ]   Radio Adapters  ---&gt;
[ ]   DAB adapters
...
...
</pre>
<ul><li>Select <i>OMAP3 Camera Support</i> from the menu.</li></ul>
<pre>...
...
&lt; &gt;   SR030PC30 VGA camera sensor support
<b>&lt;*&gt;   OMAP 3 Camera support (EXPERIMENTAL)</b>
[ ]     OMAP 3 Camera debug messages
...
...
</pre>
<ul><li>De-Select <i>Autoselect pertinent encoders/decoders and other helper chips</i> from the same menu option. After De-selecting this</li></ul>
<p>option, new option <i>Encoders/decoders and other helper chips</i> will drop down.
</p>
<pre>...
--- Video capture adapters
[ ]   Enable advanced debug functionality
[ ]   Enable old-style fixed minor ranges for video devices
<b>[ ]   Autoselect pertinent encoders/decoders and other helper chips</b>
Encoders/decoders and other helper chips  ---&gt;
&lt; &gt;   Virtual Video Driver
&lt; &gt;   CPiA Video For Linux
</pre>
<ul><li>Go inside option <i>Encoders/decoders and other helper chips</i>.</li></ul>
<pre>...
--- Video capture adapters
[ ]   Enable advanced debug functionality
[ ]   Enable old-style fixed minor ranges for video devices
[ ]   Autoselect pertinent encoders/decoders and other helper chips
<b>        Encoders/decoders and other helper chips ---&gt;</b>
&lt; &gt;   Virtual Video Driver
&lt; &gt;   CPiA Video For Linux
</pre>
<ul><li>Select TVP514x Video decoder driver from the menu.</li></ul>
<pre>...
...
&lt; &gt; Philips SAA7171/3/4 audio/video decoders
&lt; &gt; Philips SAA7191 video decoder
<b>&lt;*&gt; Texas Instruments TVP514x video decoder</b>
&lt; &gt; Texas Instruments TVP5150 video decoder
...
...
</pre>
<ul><li>Select <i>Aptina MT9T111 VGA CMOS IMAGE SENSOR</i> from the menu.</li></ul>
<pre>...
...
&lt; &gt; Aptina MT9V113 VGA CMOS IMAGE SENSOR
<b>&lt;*&gt; Aptina MT9T111 VGA CMOS IMAGE SENSOR</b>
&lt; &gt; TCM825x camera sensor support
...
...
</pre>
<p>The selection between MT9T111 camera sensor and TVP5146 video decoder is done through media-controller interface dynamically.
</p>
<h2><span class="mw-headline" id="Installation"><b>Installation</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=40" title="Edit section: Installation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><b>NOTE:</b> Please note that with this release older revision of OMAP3EVM (&lt;Rev-E) is not supported.
<br />
</p>
<h3><span class="mw-headline" id="Driver_built_statically"><b>Driver built statically</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=41" title="Edit section: Driver built statically">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If the OMAP35x Camera driver and TVP514x driver are built statically into the kernel, it is activated during boot-up. There is no special procedure to install the driver.
<br />
</p>
<h3><span class="mw-headline" id="Driver_built_as_loadable_module"><b>Driver built as loadable module</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=42" title="Edit section: Driver built as loadable module">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Currently modular build is not supported in this release.
<br />
</p>
<pre><b>Sample Applications</b> 
</pre>
<p>This chapter describes the sample application provided along with the package. The binary and the source for these sample application can are available in the Examples directory of the Release Package folder.
</p>
<h2><span class="mw-headline" id="Introduction_2"><b>Introduction</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=43" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Writing a capture application involves the following steps:
<br />
</p>
<ul><li>Opening media device</li>
<li>Enumerate/Create/Setup the links</li>
<li>Opening underneath sub device</li>
<li>Set the format at each pad underneath link</li>
<li>Opening the capture device.</li>
<li>Set the parameters of the device.</li>
<li>Allocate and initialize capture buffer</li>
<li>Receive video data from the device.</li>
<li>Close the device.</li></ul>
<p><br />
</p>
<h2><span class="mw-headline" id="Hardware_Setup"><b>Hardware Setup</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=44" title="Edit section: Hardware Setup">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Following are the steps required to run the capture sample application:
<br />
</p>
<ul><li>If you are using OMAP3EVM (&gt;=Rev-G) revision board, TVP5146 decoder is present on board. If camera sensor module is being used, then please interface it to port J31.</li>
<li>In care of Analog input, cConnect a DVD player/camera generating a NTSC video signal to the S-Video or Composite jack of the daughter card or EVM.</li>
<li>Run the sample application after booting the kernel. Please use <i>-h</i> or <i>--help</i> for available command line options.</li></ul>
<p><b>NOTE:</b> Please note that, the software doesn't support older revision of EVM's (&lt;=Rev D).
</p><p><br />
</p>
<h2><span class="mw-headline" id="Applications"><b>Applications</b></span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;section=45" title="Edit section: Applications">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Following are the list of capture sample application provided with the release:
<br />
</p>
<ul><li><b>MMAP Loopback Application (saMmapLoopback.c):</b></li></ul>
<p>This sample application using driver allocated buffers to capture video data from any one of the active inputs and displays the video in the active display (LCD / DVI / TV) using display driver.
Application is ported to media-controller framework and automatically creates, setup the link; configures the format at each pad of the link and start streaming.
</p><p><br />
</p>
<ul><li><b>USERPTR Loopback Application (saUserPtrLoopback.c):</b></li></ul>
<p>This sample application using user allocated buffers to capture video data from any one of the active inputs and displays the video in the active display (LCD / DVI / TV) using display driver.
Application is ported to media-controller framework and automatically creates, setup the link; configures the format at each pad of the link and start streaming.
</p>
<!-- 
NewPP limit report
Cached time: 20201130035359
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.108 seconds
Real time usage: 0.111 seconds
Preprocessor visited node count: 450/1000000
Preprocessor generated node count: 786/1000000
Postexpand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip postexpand size: 11362/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:9506-0!canonical and timestamp 20201130035359 and revision id 57578
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>UserGuideOmap35xCaptureDriver PSP 04.02.00.07</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>UserGuideOmap35xCaptureDriver PSP 04.02.00.07</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 04.02.00.07</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 04.02.00.07</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 04.02.00.07</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 04.02.00.07</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 04.02.00.07</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 04.02.00.07</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>UserGuideOmap35xCaptureDriver PSP 04.02.00.07</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;oldid=57578">https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;oldid=57578</a>"					</div>
				<div id="catlinks" class="catlinks catlinks-allhidden" data-mw="interface"></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=UserGuideOmap35xCaptureDriver+PSP+04.02.00.07" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="UserGuideOmap35xCaptureDriver_PSP_04.02.00.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Talk:UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="UserGuideOmap35xCaptureDriver_PSP_04.02.00.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/UserGuideOmap35xCaptureDriver_PSP_04.02.00.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/UserGuideOmap35xCaptureDriver_PSP_04.02.00.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;oldid=57578" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=UserGuideOmap35xCaptureDriver_PSP_04.02.00.07&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 28 April 2011, at 13:04.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.108","walltime":"0.111","ppvisitednodes":{"value":450,"limit":1000000},"ppgeneratednodes":{"value":786,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":11362,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20201130035359","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":256});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/UserGuideOmap35xCaptureDriver_PSP_04.02.00.07 by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 06:37:45 GMT -->
</html>
