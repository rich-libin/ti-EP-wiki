<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/Framework_Components_DMAN3/ACPY3_Users_Guide by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 04:32:43 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>Framework Components DMAN3/ACPY3 Users Guide - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Framework_Components_DMAN3/ACPY3_Users_Guide","wgTitle":"Framework Components DMAN3/ACPY3 Users Guide","wgCurRevisionId":181241,"wgRevisionId":181241,"wgArticleId":474,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Pages using invalid self-closed HTML tags","EndOfLife","DaVinci Algorithms","XDAIS","Framework Components","Codec Engine"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Framework_Components_DMAN3/ACPY3_Users_Guide","wgRelevantArticleId":474,"wgRequestId":"3c0eab2b3a1190422d5e672b","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Framework_Components_DMAN3_ACPY3_Users_Guide rootpage-Framework_Components_DMAN3 skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">Framework Components DMAN3/ACPY3 Users Guide</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div style="margin:5px 5px 10px 5px; padding:2px 20px; background-color: #ffcccc; color: #ff0000; border-left: 5px solid #ff0000; border-right: 5px solid #ff1100; font-size: 1.0em;">
<p><b>END OF LIFE</b>
</p><p>As of FC 3.23, DMAN3 and ACPY3 packages are no longer supported. Please consider other alternatives like <a href="../Framework_Components_RMAN_Users_Guide.html" title="Framework Components RMAN Users Guide">RMAN</a> for resource management, and ECPY for DMA transfers.
</p>
</div>
<p>This article describes the standard DMA software abstractions and interfaces <a href="../Category_XDAIS.html" title="Category:XDAIS">XDAIS-compliant algorithms</a> designed for the EDMA3 controller using <a href="../Category_Framework_Components.html" title="Category:Framework Components">Framework Components</a>. XDAIS defines a standard DMA resource specification and negotiation protocol (IDMA3). Framework Components provides a DMA Resource Manager (DMAN3), and a functional DMA interface and library (ACPY3) compliant with IDMA3. This document provides both reference information and guidelines for producers and consumers of IDMA3-compliant algorithms and components.
</p>
<div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Fundamental_Framework_Components_DMA_Concepts"><span class="tocnumber">2</span> <span class="toctext">Fundamental Framework Components DMA Concepts</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Logical_DMA_Channels_.26_DMA_Handles"><span class="tocnumber">2.1</span> <span class="toctext">Logical DMA Channels &amp; DMA Handles</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Scratch_vs._Persistent_DMA_Resources"><span class="tocnumber">2.2</span> <span class="toctext">Scratch vs. Persistent DMA Resources</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#DMA_Resource_Management_using_DMAN3"><span class="tocnumber">2.3</span> <span class="toctext">DMA Resource Management using DMAN3</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#DMA_Transfer_Submission_and_Synchronization_using_ACPY3"><span class="tocnumber">2.4</span> <span class="toctext">DMA Transfer Submission and Synchronization using ACPY3</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#FIFO_Ordering_of_DMA_Transfers_and_Linked_DMA_Transfers"><span class="tocnumber">2.4.1</span> <span class="toctext">FIFO Ordering of DMA Transfers and Linked DMA Transfers</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Channel_Privacy_and_Synchronization"><span class="tocnumber">2.4.2</span> <span class="toctext">Channel Privacy and Synchronization</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#DMA_Transfer_Configuration_Settings"><span class="tocnumber">2.4.3</span> <span class="toctext">DMA Transfer Configuration Settings</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#IDMA3:_Standard_Interface_for_Negotiating_DMA_Resources"><span class="tocnumber">3</span> <span class="toctext">IDMA3: Standard Interface for Negotiating DMA Resources</span></a>
<ul>
<li class="toclevel-2 tocsection-11"><a href="#IDMA3_versus_IDMA2"><span class="tocnumber">3.1</span> <span class="toctext">IDMA3 versus IDMA2</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#IDMA3_Interface_Definition"><span class="tocnumber">3.2</span> <span class="toctext">IDMA3 Interface Definition</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="#DMA_Channel_Descriptor:_IDMA3_ChannelRec"><span class="tocnumber">3.2.1</span> <span class="toctext">DMA Channel Descriptor: IDMA3_ChannelRec</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#IDMA3_Functions:_IDMA3_Fxns"><span class="tocnumber">3.2.2</span> <span class="toctext">IDMA3 Functions: IDMA3_Fxns</span></a></li>
<li class="toclevel-3 tocsection-15"><a href="#IDMA3_Object_and_Handle_Structures:_IDMA3_Obj"><span class="tocnumber">3.2.3</span> <span class="toctext">IDMA3 Object and Handle Structures: IDMA3_Obj</span></a></li>
<li class="toclevel-3 tocsection-16"><a href="#IDMA3_Protocol_Object_for_Channel_Environment_Memory_Management"><span class="tocnumber">3.2.4</span> <span class="toctext">IDMA3 Protocol Object for Channel Environment Memory Management</span></a></li>
<li class="toclevel-3 tocsection-17"><a href="#IDMA3_Enumeration_Type_Documentation"><span class="tocnumber">3.2.5</span> <span class="toctext">IDMA3 Enumeration Type Documentation</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-18"><a href="#DMAN3:_.E2.80.98C64x.2B_DMA_Resource_Manager"><span class="tocnumber">4</span> <span class="toctext">DMAN3: ‘C64x+ DMA Resource Manager</span></a>
<ul>
<li class="toclevel-2 tocsection-19"><a href="#Using_DMAN3_for_Algorithm_Integration"><span class="tocnumber">4.1</span> <span class="toctext">Using DMAN3 for Algorithm Integration</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#DMAN3_Configuration"><span class="tocnumber">4.2</span> <span class="toctext">DMAN3 Configuration</span></a>
<ul>
<li class="toclevel-3 tocsection-21"><a href="#Introduction_to_Configuration_Options"><span class="tocnumber">4.2.1</span> <span class="toctext">Introduction to Configuration Options</span></a></li>
<li class="toclevel-3 tocsection-22"><a href="#Configuration_Parameters"><span class="tocnumber">4.2.2</span> <span class="toctext">Configuration Parameters</span></a></li>
<li class="toclevel-3 tocsection-23"><a href="#DMAN3_Configuration_Examples"><span class="tocnumber">4.2.3</span> <span class="toctext">DMAN3 Configuration Examples</span></a>
<ul>
<li class="toclevel-4 tocsection-24"><a href="#Configuring_DMAN3_for_Optimal_Sharing_of_Physical_DMA_Resources"><span class="tocnumber">4.2.3.1</span> <span class="toctext">Configuring DMAN3 for Optimal Sharing of Physical DMA Resources</span></a></li>
<li class="toclevel-4 tocsection-25"><a href="#DMA_Channel_Memory_Allocation"><span class="tocnumber">4.2.3.2</span> <span class="toctext">DMA Channel Memory Allocation</span></a></li>
<li class="toclevel-4 tocsection-26"><a href="#IDMA3_Protocol_Environment_Memory_Allocation"><span class="tocnumber">4.2.3.3</span> <span class="toctext">IDMA3 Protocol Environment Memory Allocation</span></a></li>
</ul>
</li>
<li class="toclevel-3 tocsection-27"><a href="#Configuring_DMAN3_at_Runtime"><span class="tocnumber">4.2.4</span> <span class="toctext">Configuring DMAN3 at Runtime</span></a></li>
<li class="toclevel-3 tocsection-28"><a href="#Configuring_DMAN3_Using_XDC"><span class="tocnumber">4.2.5</span> <span class="toctext">Configuring DMAN3 Using XDC</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-29"><a href="#DMAN3_Functions"><span class="tocnumber">4.3</span> <span class="toctext">DMAN3 Functions</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#DMAN3_New_Features"><span class="tocnumber">4.4</span> <span class="toctext">DMAN3 New Features</span></a>
<ul>
<li class="toclevel-3 tocsection-31"><a href="#Configuration_of_DMAN3_to_use_the_EDMA3_LLD_Resource_Manager"><span class="tocnumber">4.4.1</span> <span class="toctext">Configuration of DMAN3 to use the EDMA3 LLD Resource Manager</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-32"><a href="#ACPY3:_Functional_DMA_Abstraction_Layer"><span class="tocnumber">5</span> <span class="toctext">ACPY3: Functional DMA Abstraction Layer</span></a>
<ul>
<li class="toclevel-2 tocsection-33"><a href="#ACPY3_Functions_and_Comparison_to_ACPY2"><span class="tocnumber">5.1</span> <span class="toctext">ACPY3 Functions and Comparison to ACPY2</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#ACPY3_Interface"><span class="tocnumber">5.2</span> <span class="toctext">ACPY3 Interface</span></a>
<ul>
<li class="toclevel-3 tocsection-35"><a href="#Logical_Channel_Configuration_Parameters"><span class="tocnumber">5.2.1</span> <span class="toctext">Logical Channel Configuration Parameters</span></a></li>
<li class="toclevel-3 tocsection-36"><a href="#ACPY3_configure"><span class="tocnumber">5.2.2</span> <span class="toctext">ACPY3_configure</span></a></li>
<li class="toclevel-3 tocsection-37"><a href="#ACPY3_fastConfigure16b"><span class="tocnumber">5.2.3</span> <span class="toctext">ACPY3_fastConfigure16b</span></a></li>
<li class="toclevel-3 tocsection-38"><a href="#ACPY3_fastConfigure32b"><span class="tocnumber">5.2.4</span> <span class="toctext">ACPY3_fastConfigure32b</span></a></li>
<li class="toclevel-3 tocsection-39"><a href="#ACPY3_start"><span class="tocnumber">5.2.5</span> <span class="toctext">ACPY3_start</span></a></li>
<li class="toclevel-3 tocsection-40"><a href="#ACPY3_wait"><span class="tocnumber">5.2.6</span> <span class="toctext">ACPY3_wait</span></a></li>
<li class="toclevel-3 tocsection-41"><a href="#ACPY3_waitLinked"><span class="tocnumber">5.2.7</span> <span class="toctext">ACPY3_waitLinked</span></a></li>
<li class="toclevel-3 tocsection-42"><a href="#ACPY3_complete"><span class="tocnumber">5.2.8</span> <span class="toctext">ACPY3_complete</span></a></li>
<li class="toclevel-3 tocsection-43"><a href="#ACPY3_completeLinked"><span class="tocnumber">5.2.9</span> <span class="toctext">ACPY3_completeLinked</span></a></li>
<li class="toclevel-3 tocsection-44"><a href="#ACPY3_activate"><span class="tocnumber">5.2.10</span> <span class="toctext">ACPY3_activate</span></a></li>
<li class="toclevel-3 tocsection-45"><a href="#ACPY3_deactivate"><span class="tocnumber">5.2.11</span> <span class="toctext">ACPY3_deactivate</span></a></li>
<li class="toclevel-3 tocsection-46"><a href="#ACPY3_init"><span class="tocnumber">5.2.12</span> <span class="toctext">ACPY3_init</span></a></li>
<li class="toclevel-3 tocsection-47"><a href="#ACPY3_exit"><span class="tocnumber">5.2.13</span> <span class="toctext">ACPY3_exit</span></a></li>
<li class="toclevel-3 tocsection-48"><a href="#ACPY3_setFinal"><span class="tocnumber">5.2.14</span> <span class="toctext">ACPY3_setFinal</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-49"><a href="#Cache_Coherency_Issues_for_Algorithm_Consumers"><span class="tocnumber">6</span> <span class="toctext">Cache Coherency Issues for Algorithm Consumers</span></a></li>
<li class="toclevel-1 tocsection-50"><a href="#For_Algorithm_Producers:_Creating_Algorithms_that_Use_DMA"><span class="tocnumber">7</span> <span class="toctext">For Algorithm Producers: Creating Algorithms that Use DMA</span></a>
<ul>
<li class="toclevel-2 tocsection-51"><a href="#IDMA3_and_ACPY3_Related_Changes_that_affect_the_Algorithm_Developers"><span class="tocnumber">7.1</span> <span class="toctext">IDMA3 and ACPY3 Related Changes that affect the Algorithm Developers</span></a></li>
<li class="toclevel-2 tocsection-52"><a href="#Rules_and_Guidelines_Summary"><span class="tocnumber">7.2</span> <span class="toctext">Rules and Guidelines Summary</span></a></li>
<li class="toclevel-2 tocsection-53"><a href="#Implementing_the_IDMA3_Interface"><span class="tocnumber">7.3</span> <span class="toctext">Implementing the IDMA3 Interface</span></a></li>
<li class="toclevel-2 tocsection-54"><a href="#Configuring_Logical_Channels_and_DMA_Transfers"><span class="tocnumber">7.4</span> <span class="toctext">Configuring Logical Channels and DMA Transfers</span></a>
<ul>
<li class="toclevel-3 tocsection-55"><a href="#Performance_Considerations"><span class="tocnumber">7.4.1</span> <span class="toctext">Performance Considerations</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-56"><a href="#Scheduling_Asynchronous_DMA_Transfers_on_Logical_Channels"><span class="tocnumber">7.5</span> <span class="toctext">Scheduling Asynchronous DMA Transfers on Logical Channels</span></a>
<ul>
<li class="toclevel-3 tocsection-57"><a href="#Alignment_Issues_Using_ACPY3_start"><span class="tocnumber">7.5.1</span> <span class="toctext">Alignment Issues Using ACPY3_start</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-58"><a href="#Synchronizing_and_Serializing_DMA_Transfers"><span class="tocnumber">7.6</span> <span class="toctext">Synchronizing and Serializing DMA Transfers</span></a></li>
<li class="toclevel-2 tocsection-59"><a href="#Cache_Coherency_Issues_for_Algorithm_Producers"><span class="tocnumber">7.7</span> <span class="toctext">Cache Coherency Issues for Algorithm Producers</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-60"><a href="#The_Fast_Copy_.28FCPY.29_Algorithm_Example"><span class="tocnumber">8</span> <span class="toctext">The Fast Copy (FCPY) Algorithm Example</span></a>
<ul>
<li class="toclevel-2 tocsection-61"><a href="#IFCPY_Interface_Functions"><span class="tocnumber">8.1</span> <span class="toctext">IFCPY_Interface Functions</span></a>
<ul>
<li class="toclevel-3 tocsection-62"><a href="#Instance_Heap_Memory_Requirements"><span class="tocnumber">8.1.1</span> <span class="toctext">Instance Heap Memory Requirements</span></a></li>
<li class="toclevel-3 tocsection-63"><a href="#The_Use_of_IDMA3_and_ACPY3_Interfaces"><span class="tocnumber">8.1.2</span> <span class="toctext">The Use of IDMA3 and ACPY3 Interfaces</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-64"><a href="#The_fastcopytest_Example"><span class="tocnumber">9</span> <span class="toctext">The fastcopytest Example</span></a></li>
<li class="toclevel-1 tocsection-65"><a href="#References"><span class="tocnumber">10</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-66"><a href="#Appendix_A._Code_for_the_fastcopytest_Example"><span class="tocnumber">11</span> <span class="toctext">Appendix A. Code for the fastcopytest Example</span></a></li>
<li class="toclevel-1 tocsection-67"><a href="#Appendix_B:_Code_for_FCPY_TI_Algorithm"><span class="tocnumber">12</span> <span class="toctext">Appendix B: Code for FCPY_TI Algorithm</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Introduction">Introduction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=1" title="Edit section: Introduction">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The direct memory access (DMA) controller performs asynchronously scheduled data transfers between memory regions without the intervention of the CPU. The parallel operation of the DMA with the execution of the CPU relieves the CPU of the burden of these data transfers. This allows a system to achieve greater throughput.
</p><p>Algorithms and client applications may want to take advantage of the DMA to overlap data movement with CPU processing. However, XDAIS does not allow compliant algorithms to <i>directly</i> access or control any hardware peripherals, including the DMA. All system DMA resources must be controlled by the client application.
</p><p>The new Framework Components DMA utilities allow XDAIS algorithms and client applications to utilize DMA resources by providing standard DMA software abstractions and interfaces. Framework Components now includes the following DMA modules and interfaces:
</p>
<ul><li><b>IDMA3.</b> This is the standard interface to algorithms for DMA resource specification and negotiation protocols. This interface allows the client application to query and provide the algorithm its requested DMA resources.</li>
<li><b>DMAN3.</b> This is the DMA resource manager. It is responsible for managing and granting DMA resources to algorithms and applications based on the IDMA3 interface.</li>
<li><b>ACPY3.</b> This is the functional DMA interface and library. The ACPY3 interface describes a comprehensive list of DMA operations that an algorithm can perform on the logical DMA channels acquired through the IDMA3 protocol. These functions are implemented as part of the client application and are called by the algorithm.</li></ul>
<p>The following figure shows which modules are implemented by client application frameworks and which are implemented by algorithms or components. Arrows indicate which modules use other modules.
</p>
<div style="text-align: center;">
<p><a href="../File_App_and_dma.html" class="image" title="interaction"><img alt="interaction" src="https://processors.wiki.ti.com/images/c/cd/App_and_dma.png" width="534" height="298" /></a><br /><b>Figure 1. Client Application and Algorithm Interaction with DMA Resources</b>
</p>
</div>
<p>Client applications use the algorithm's IDMA3 interface to query the algorithm's DMA resource requirements and grant the algorithm logical DMA resources via handles. Each granted handle provides the algorithm a uniform, private logical DMA channel abstraction. Algorithms, upon getting provisioned by the framework with their DMA resource needs, may call ACPY3 functions to schedule DMA transfers on the logical DMA channels. Alternatively, algorithms may provide their own DMA functions to program the physical DMA resources acquired through the IDMA3 protocol.
</p><p>The basic ideas and objectives described in the "Use of the DMA Resource" chapter of <i>TMS320 DSP Algorithm Standard Rules and Guidelines</i> (SPRU352) apply to the design, implementation and use of the ACPY3 and IDMA3 interfaces. Collectively, IDMA3, DMAN3, and ACPY3 provide a flexible and efficient model that greatly simplifies the management of system DMA resources and services by the client application. They also provide a simple and powerful mechanism for algorithms to configure and access DMA services.
</p><p>The following tables summarize the API functions and structures used by the IDMA3, ACPY3, and DMAN3 interfaces.
</p>
<table>
<caption><b>Table 1. IDMA3 Functions</b>
</caption>
<tbody><tr>
<th>Functions
</th>
<th>Description
</th></tr>
<tr>
<td><code>dmaChangeChannels()</code>
</td>
<td>Called by an application whenever logical channels are moved at run-time.
</td></tr>
<tr>
<td><code>dmaGetChannelCnt()</code>
</td>
<td>Called by an application to query an algorithm about its number of logical DMA channel requests.
</td></tr>
<tr>
<td><code>dmaGetChannels()</code>
</td>
<td>Called by an application to query an algorithm about its DMA channel requests at initialization time, or to get the current channel holdings.
</td></tr>
<tr>
<td><code>dmaInit()</code>
</td>
<td>Called by an application to grant DMA handle(s) to the algorithm at initialization.
</td></tr></tbody></table>
<p><br />
</p>
<table>
<caption><b>Table 2. IDMA3 Channel Request Descriptor (IDMA3_ChannelRec)</b>
</caption>
<tbody><tr>
<th>Structure Fields
</th>
<th>Description
</th></tr>
<tr>
<td>Handle
</td>
<td>Handle to logical DMA channel
</td></tr>
<tr>
<td>numTransfers
</td>
<td>Number of DMA transfers that are submitted using this logical channel handle. Single (==1) or Linked ( &gt;= 2)
</td></tr>
<tr>
<td>numWaits
</td>
<td>Number of individual transfers that can be waited in a linked start. (1 for single transfers or to wait for all transfers to complete.)
</td></tr>
<tr>
<td>priority
</td>
<td>Relative priority recommendation {Urgent, High, Medium, Low}.
</td></tr>
<tr>
<td>protocol
</td>
<td>Optional protocol handle for allocating channel environment (“env”) memory and calling custom channel initialization function.
</td></tr>
<tr>
<td>persistent
</td>
<td>When persistent is set to TRUE, the granted physical EDMA resources (PaRAMs and TCCs) are for exclusive use by this channel. They cannot be shared with any other IDMA3 channel.
</td></tr></tbody></table>
<p><br />
</p>
<table>
<caption><b>Table 3. IDMA3 Channel (IDMA3_Obj)</b>
</caption>
<tbody><tr>
<th>Structure Fields
</th>
<th>Description
</th></tr>
<tr>
<td>numTccs
</td>
<td>The number of TCCs allocated to this channel.
</td></tr>
<tr>
<td>numPaRams
</td>
<td>The number of PaRAM entries allocated to this channel.
</td></tr>
<tr>
<td>tccTable
</td>
<td>Array of TCCs assigned to this channel.
</td></tr>
<tr>
<td>paRamAddr
</td>
<td>PaRAMs assigned to channel.
</td></tr>
<tr>
<td>qdmaChan
</td>
<td>Physical QDMA Channel assigned to handle.
</td></tr>
<tr>
<td>transferPending
</td>
<td>Run-time channel state that must be maintained by channel owner. Must be set to true when a new transfer is started on this channel. Must be set to false when a wait/sync operation is performed on this channel.
</td></tr>
<tr>
<td>env
</td>
<td>When the channel IDMA3_Protocol requires it, “env” points to the private channel memory allocated for the channel by the framework DMA resource manager.
</td></tr>
<tr>
<td>protocol
</td>
<td>The IDMA3_Protocol handle used by the DMA manager to determine memory requirements for the “env”.
</td></tr>
<tr>
<td>persistent
</td>
<td>Indicates if the channel has been allocated with persistent property.
</td></tr></tbody></table>
<p><br />
</p>
<table>
<caption><b>Table 4. IDMA3 Protocol Object (IDMA3_ProtocolObj)</b>
</caption>
<tbody><tr>
<th>Structure Fields
</th>
<th>Description
</th></tr>
<tr>
<td>name
</td>
<td>The name of the optional custom protocol that will be used by the algorithm requesting the IDMA3 channel resources.
<p>This object contains function pointers to be used when determining channel “env” memory requirements and for custom channel initialization and finalization.
</p>
</td></tr>
<tr>
<td>getEnvMemRec
</td>
<td>When not NULL, points to the function called by the DMA manager to query the IDMA3 protocol's memory requirements for the IDMA3 channel’s environment (“env”) pointer.
</td></tr>
<tr>
<td>initHandle
</td>
<td>When not NULL, points to the function to be called by DMA manager after allocation of the “env” memory to perform custom IDMA3 protocol initialization of channel state.
</td></tr>
<tr>
<td>deInitHandle
</td>
<td>When not NULL, points to the function to be called by DMA manager when a channel is freed to perform any custom IDMA3 protocol de-initialization.
</td></tr></tbody></table>
<p><br />
</p>
<table>
<caption><b>Table 5. DMAN3 Functions</b>
</caption>
<tbody><tr>
<th>Functions
</th>
<th>Description
</th></tr>
<tr>
<td><code>DMAN3_grantDmaChannels()</code>
</td>
<td>Grant logical channel resources to one of more algorithm instances sharing a common groupId.
</td></tr>
<tr>
<td><code>DMAN_exit()</code>
</td>
<td>Finalization method of the DMAN module.
</td></tr>
<tr>
<td><code>DMAN3_init()</code>
</td>
<td>Initialize the DMAN3 module.
</td></tr>
<tr>
<td><code>DMAN3_releaseDmaChannels()</code>
</td>
<td>Remove logical channel resources from one or more algorithm instances.
</td></tr>
<tr>
<td><code>DMAN3_createChannels()</code>
</td>
<td>Allocate DMA resources and initialize memory for one or more logical DMA channels.
</td></tr>
<tr>
<td><code>DMAN3_freeChannels()</code>
</td>
<td>Free DMA resources and memory allocated to one or more logical DMA channel.
</td></tr></tbody></table>
<p><br />
</p>
<table>
<caption><b>Table 6. ACPY3 Functions</b>
</caption>
<tbody><tr>
<th>Functions
</th>
<th>Description
</th></tr>
<tr>
<td><code>ACPY3_activate()</code>
</td>
<td>Activates given channel. Take over shared resources prior to use.
</td></tr>
<tr>
<td><code>ACPY3_deactivate()</code>
</td>
<td>Deactivates given channel. Give back shared resources at the end of use.
</td></tr>
<tr>
<td><code>ACPY3_complete()</code>
</td>
<td>Check if the data transfers on a specific logical channel have completed.
</td></tr>
<tr>
<td><code>ACPY3_completeLinked()</code>
</td>
<td>Check if an individual transfer on a specific logical channel have completed.
</td></tr>
<tr>
<td><code>ACPY3_configure()</code>
</td>
<td>Configure a logical channel.
</td></tr>
<tr>
<td><code>ACPY3_exit()</code>
</td>
<td>Free resources used by the ACPY3 module <span style="color: RED">[FRAMEWORK API]</span>
</td></tr>
<tr>
<td><code>ACPY3_setFinal()</code>
</td>
<td>Dynamically change the number of transfers in a sequence of linked transfers. Sets given transferNo as the last in a sequence of linked transfers.
</td></tr>
<tr>
<td><code>ACPY3_init()</code>
</td>
<td>Initialize the ACPY3 module. <span style="color: RED">[FRAMEWORK API]</span>
</td></tr>
<tr>
<td><code>ACPY3_fastConfigure16b()</code>
</td>
<td>Modify a single (16-bit) parameter of the logical DMA Channel.
</td></tr>
<tr>
<td><code>ACPY3_fastConfigure32b()</code>
</td>
<td>Modify a single (32-bit) parameter of the logical DMA Channel.
</td></tr>
<tr>
<td><code>ACPY3_start()</code>
</td>
<td>Issue a request for a data transfer using current channel settings.
</td></tr>
<tr>
<td><code>ACPY3_wait()</code>
</td>
<td>Wait for all data transfers to complete on a specific logical channel.
</td></tr>
<tr>
<td><code>ACPY3_waitLinked()</code>
</td>
<td>Wait for an individual data transfer to complete on the logical channel.
</td></tr></tbody></table>
<p><br />
</p>
<table>
<caption><b>Table 7. ACPY3_Params Structure Fields</b>
</caption>
<tbody><tr>
<th>Structure Fields
</th>
<th>Description
</th></tr>
<tr>
<td>transferType
</td>
<td>Transfer type: ACPY3_1D1D, ACPY3_1D2D, ACPY3_2D1D or ACPY3_2D2D
</td></tr>
<tr>
<td>srcAddr
</td>
<td>Source Address of the DMA transfer.
</td></tr>
<tr>
<td>dstAddr
</td>
<td>Destination Address of the DMA transfer.
</td></tr>
<tr>
<td>elementSize
</td>
<td>Number of consecutive bytes in each 1D transfer vector (ACNT).
</td></tr>
<tr>
<td>numElements
</td>
<td>Number of 1D vectors in 2D transfers (BCNT).
</td></tr>
<tr>
<td>numFrames
</td>
<td>Number of 2D frames in 3D transfers (CCNT).
</td></tr>
<tr>
<td>srcElementIndex
</td>
<td>Offset in number of bytes from beginning of each 1D vector to the beginning of the
<p>next 1D vector (SBIDX).
</p>
</td></tr>
<tr>
<td>dstElementIndex
</td>
<td>Offset in number of bytes from beginning of each 1D vector to the beginning of the
<p>next 1D vector (DBIDX).
</p>
</td></tr>
<tr>
<td>srcFrameIndex
</td>
<td>Offset in number of bytes from beginning of the first 1D vector of source frame to
<p>the beginning of the first element in the next frame. (SCIDX: signed value between -32768 and 32767)
</p>
</td></tr>
<tr>
<td>dstFrameIndex
</td>
<td>Offset in number of bytes from beginning 1D vector of first element in destination frame to the beginning of the first element in next frame. (DCIDX: signed value between -32768 and 32767).
</td></tr>
<tr>
<td>waitId
</td>
<td>For a linked transfer entry:
<p>-1&#160;: no individual wait on this transfer 0 &lt;= waitId &lt; numWaits&#160;: this transfer can be waited on or polled for completion. Ignored for single-transfers and for the last transfer in a sequence of linked transfers, which are always synchronized with waitId == (numWaits – 1).
</p>
</td></tr></tbody></table>
<h2><span class="mw-headline" id="Fundamental_Framework_Components_DMA_Concepts">Fundamental Framework Components DMA Concepts</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=2" title="Edit section: Fundamental Framework Components DMA Concepts">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The following subsections highlight the fundamental concepts and features supported by the Framework Components associated with DMA resources and services.
</p>
<h3><span id="Logical_DMA_Channels_&amp;_DMA_Handles"></span><span class="mw-headline" id="Logical_DMA_Channels_.26_DMA_Handles">Logical DMA Channels &amp; DMA Handles</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=3" title="Edit section: Logical DMA Channels &amp; DMA Handles">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The <i>logical DMA channel</i> is the fundamental software abstraction for characterizing hardware DMA resources and services. Each logical DMA channel represents a private hardware DMA resource and a private state identified by and accessed through a <i>DMA handle</i>. Applications are in charge of the physical DMA resources and grant IDMA3 channel handles to algorithms that request them using the IDMA3 interface.
</p>
<h3><span class="mw-headline" id="Scratch_vs._Persistent_DMA_Resources">Scratch vs. Persistent DMA Resources</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=4" title="Edit section: Scratch vs. Persistent DMA Resources">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The physical EDMA3 resources associated with each logical DMA channel can be can be requested as scratch or persistent, borrowing the concepts from xDAIS/IALG as it applies to memory. Application frameworks or resource managers such as DMAN3 can optimize resource allocation of scarce physical resources by arranging a group of algorithms to share the same physical resources when the channels have been requested as “scratch” (persistent=false).
</p><p>When more than one processing thread shares a scratch resource (memory or IDMA3 channel), the application framework must ensure that at any given time only one of the processing threads is active. Upon activation, the processing thread may use the scratch resources without interference from other sharing threads. However they must assume that the state of the resource upon activation is undefined and perform necessary initialization. Additionally, at the point of deactivation, they must be completely finished with their use of the scratch resources (for example, by not leave any outstanding DMA transfers or unchecked transfer completion codes) and save any context information they may need for the next activation, as covered under xDAIS DMA Rule 1. For xDAIS-compliant algorithms, the activation and deactivation events correspond to the instance IALG::algActivate and IALG::algDeactivate calls.
</p>
<h3><span class="mw-headline" id="DMA_Resource_Management_using_DMAN3">DMA Resource Management using DMAN3</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=5" title="Edit section: DMA Resource Management using DMAN3">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The IDMA3 interface does not specify or mandate the use of a particular framework DMA Resource manager. However, the TI Framework Components package provides DMAN3 as a fully-supported and configurable DMA Resource manager in charge of managing the EDMA3.0 physical resources that the application framework has given exclusively to DMAN3.
</p><p>In a typical Framework Component based application, DMAN3 grants each algorithm the DMA resources it requests via the IDMA3 interface. The algorithm subsequently may call ACPY3 functions to configure logical channel settings, to request DMA transfers, or to synchronize with on-going transfers.
</p><p>DMAN3 can be configured using a runtime C interface or statically using XDC tooling. The configuration provides DMAN3 with the physical EDMA3 resources: PaRAMs, TCCs, QDMA channels. DMAN3 configuration dictates how it allocates and manages the memory supplied to each logical DMA channel. DMAN3 additionally supports sharing of physical EDMA3 resources among algorithms created with the same scratch groupId whenever it is possible. It is the responsibility of the application framework to ensure that algorithms created using the same DMAN3 scratch groupIds do not pre-empt each other. See the section titled <a href="#DMAN3_Configuration_Examples">DMAN3 Configuration Examples</a> for some common allocation scenarios and tips.
</p>
<h3><span class="mw-headline" id="DMA_Transfer_Submission_and_Synchronization_using_ACPY3">DMA Transfer Submission and Synchronization using ACPY3</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=6" title="Edit section: DMA Transfer Submission and Synchronization using ACPY3">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Algorithms or applications can use the physical DMA resources obtained through the IDMA3 interface directly or using any custom DMA library. However, the TI Framework Components package provides a high performance library, ACPY3, which may be used to perform a rich set of DMA operations using the logical DMA channels acquired through the IDMA3 protocol.
</p><p>The ACPY3 API introduces several DMA transfer-related abstractions highlighted in the following subsections.
</p>
<h4><span class="mw-headline" id="FIFO_Ordering_of_DMA_Transfers_and_Linked_DMA_Transfers">FIFO Ordering of DMA Transfers and Linked DMA Transfers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=7" title="Edit section: FIFO Ordering of DMA Transfers and Linked DMA Transfers">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Several outstanding DMA transfer requests may be submitted asynchronously to run concurrently on separate logical DMA channels. Only transfer requests started on the same logical channel are guaranteed to start and complete in a strictly first-in first-out (FIFO) ordering.
</p><p>In order to start multiple DMA transfers simultaneously but in a strict FIFO order, the IDMA3 interface introduces the notion of logical channels with more than 1 configurable transfer. Each ACPY3_start issued on a logical DMA channel, in effect, issues these as linked DMA transfers, similar to the mechanism provided by the EDMA3.0 hardware. In addition to the enforced FIFO ordering, the ACPY3 library submits linked transfers more efficiently, so their use is encouraged even if FIFO ordering is not strictly required.
</p><p>ACPY3 additionally allows synchronizing with one or more intermediate transfers within a linked channel. The number of intermediate waits must be indicated in the “numWaits” field when requesting an IDMA3 channel that will be used to wait on intermediate transfers.
</p>
<h4><span class="mw-headline" id="Channel_Privacy_and_Synchronization">Channel Privacy and Synchronization</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=8" title="Edit section: Channel Privacy and Synchronization">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Algorithms have exclusive ownership of each received logical channel and can operate safely without fear of external components (such as other algorithms or other system code) accessing the channel and issuing transfer requests or changing channel configuration settings. They must, however, follow the ACPY3 API to activate and deactivate each IDMA3 channel during instance activation and deactivation, respectively.
</p><p>All synchronization calls are issued on a per channel basis, as opposed to a per transfer basis. An algorithm can issue either a blocking wait, or a non-blocking query call to synchronize with a logical channel’s completion status.
</p>
<h4><span class="mw-headline" id="DMA_Transfer_Configuration_Settings">DMA Transfer Configuration Settings</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=9" title="Edit section: DMA Transfer Configuration Settings">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The purpose of acquiring logical channel handles is to submit DMA transfer requests. Each submitted DMA transfer request specifies a source and destination memory region. A background DMA activity asynchronously carries out the copying of the contents of the source memory region to the destination.
</p><p>The configuration setting of a logical channel is similar to the hardware register settings of the underlying EDMA3.0 hardware DMA device. However, each logical channel retains its configured DMA transfer settings. The most recently configured transfer settings at the time the ACPY3_start function is called apply to the asynchronously started DMA transfer.
</p><p>Two properties of DMA transfers make them desirable and performance critical for algorithms:
</p>
<ul><li>The physical transfer/copy operation takes place in the “background” under the close control of specialized circuitry and controllers. This allows algorithms to issue transfer requests in advance and to perform other useful operations while data is being copied in the background.</li>
<li>The physical layout of source or destination DMA transfer blocks need not be a single contiguous chunk of memory. By setting a few channel configuration parameters, algorithms can specify complex layout patterns. This can lead to significant performance improvements even if the algorithm cannot take advantage of asynchronous execution and the CPU sits idle while waiting for the transfer to complete.</li></ul>
<p>The unit of DMA transfer is a block composed of frames and elements. Each DMA transfer is submitted on a logical channel via the ACPY3_start function. The <i>source</i> and <i>destination addresses</i> for the blocks and the <i>number of elements</i> in each frame are now part of the channel’s configuration settings. The configuration parameters are intrinsic properties of each logical channel and are set exclusively when the algorithm calls ACPY3 configuration functions. The previously configured properties of each logical channel at the time of an ACPY3_start request determine the actual memory copied from source to destination. Each DMA transfer is characterized by the following list configurable attributes. (Figure 2 illustrates the memory layout of a DMA transfer block characterized by these configuration parameters). Note that the element and frame index parameters can be configured independently for both source and destination.
</p>
<ul><li><b>transferType.</b> 1D-to-1D, 1D-to-2D, 2D-to-1D or 2D-to-2D</li>
<li><b>elementSize.</b> The number of 8-bit bytes per element. The element size for ACPY3 transfers can be a variable number, 1 &lt;= number &lt;= 65535, whereas the IDMA2/ACPY2 specification required this to be either 1,2, or 4.</li>
<li><b>numFrames.</b> The number of frames in a block, 1 &lt;= number &lt;= 65535.</li>
<li><b>SrcElementIndex and DstElementIndex.</b> The offset in 8-bit bytes between the start addresses of two consecutive elements in a frame. Element indexes must be specified only when the source or destination is a 2D transfer. They are ignored for 1D transfers. Element indexes can be signed (i.e. negative) values in the range: -32767 &lt;= number &lt;= 32768.</li>
<li><b>SrcFrameIndex and DstFrameIndex 1.</b> The offset in 8-bit bytes between the start addresses of the first elements of two consecutive frames. (NOTE: This corresponds to the AB-synched SRC/DST CIDX settings in the EDMA3.0 DMA parameters.) Frame indexes must be specified only when the number of frames &gt; 1, otherwise they are ignored. Frame indexes can be signed (negative or positive) values in the range: -32767 &lt;= number &lt;= 32768.</li>
<li><b>numElements.</b> The number of elements per frame, 1 &lt;= number &lt;= 65535.</li>
<li><b>srcAddr and dstAddr.</b> 8-bit byte-addresses.</li></ul>
<div style="text-align: center;">
<p><a href="../File_Dma_transfer_block.html" class="image" title="interaction"><img alt="interaction" src="https://processors.wiki.ti.com/images/f/f2/Dma_transfer_block.png" width="456" height="588" /></a><br /><b>Figure 2. DMA Transfer Block</b>
</p>
</div>
<p><b>Note:</b> The current implementation of ACPY3 does not support the use of numFrames or frame indexes due to QDMA-based hardware implementation restrictions. These may be supported in future releases using an EDMA-based implementation.
</p>
<h2><span class="mw-headline" id="IDMA3:_Standard_Interface_for_Negotiating_DMA_Resources">IDMA3: Standard Interface for Negotiating DMA Resources</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=10" title="Edit section: IDMA3: Standard Interface for Negotiating DMA Resources">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>TMS320 DSP Algorithm Standard (xDAIS) compliant algorithms designed for the ‘C64x+ EDMA3 controller must implement the IDMA3 interface to publish and acquire DMA resources they will use. The application framework DMA Resource Manager (DMAN3 is one reference implementation provided by the Framework Components) calls IDMA3 interface functions to query and subsequently allocate and grant the requested DMA resources. The IDMA3 interface is similar to the xDAIS IDMA2 interface in terms of its definition and role. IDMA3 introduces the notion of a logical DMA channels abstraction via a handle similar to that used in IDMA2.
</p>
<h3><span class="mw-headline" id="IDMA3_versus_IDMA2">IDMA3 versus IDMA2</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=11" title="Edit section: IDMA3 versus IDMA2">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The following key changes have been introduced as compared to the IDMA2/ACPY2 interfaces:
</p>
<ul><li>IDMA3 is no longer a pure hardware abstraction of generic DMA resources. Logical channels obtained through the IDMA3 interface expose some physical EDMA3 resources: Parameter RAM Sets (PaRAMs), Transfer Completion Codes (TCCs), and QDMA Channel ids.</li>
<li>IDMA3 introduces the notion of <i>scratch vs. persistent</i> resources for the physical EDMA3 resources assigned to each IDMA3 channel. This approach is similar to the IALG scratch memory concept, which allows frameworks to efficiently share/overlay algorithm instance scratch buffers using instance activation and deactivation. This approach in IDMA3 allows sharing of TCCs and PaRAM entries and nicely hooks with IALG activate/deactivate events.</li></ul>
<dl><dd>Channels that cannot be used in a shared context must be requested with “Persistent=TRUE”, otherwise the resource manager is free to arrange the sharing of granted physical DMA resources.</dd></dl>
<ul><li>Each IDMA3 channel can be optionally associated with a custom IDMA3 protocol. When a non-null “protocol” object is provided, the DMA resource manager uses IDMA3_Protocol functions to perform additional memory allocation for the logical DMA channel’s environment (“env”) field or to call protocol-specific handle initialization and de-initialization functions. This feature allows frameworks to support custom DMA service function libraries (ACPY3 is just one such library) with custom initialization and finalization functions.</li>
<li>Each logical DMA channel can be assigned a relative channel priority.</li></ul>
<p>For performance reasons, support was added for the following EDMA3.0-centric DMA concepts:
</p>
<ul><li>Hardware linked transfers that can be quickly started through QDMA.</li>
<li>Waiting on an intermediate transfer's completion in the case of linked transfers.</li></ul>
<p>Finally, based on existing algorithm use cases, the following changes were made to allow ACPY3 to have a more streamlined and high-performance design:
</p>
<ul><li>The queue IDs defined in IDMA2 are no longer needed. This means there is no requirement to enforce inter-channel FIFO ordering of submitted DMA transfers. When FIFO ordering is needed, you must use linked transfers.</li>
<li>FIFO completion of DMA transfers is supported only on individual logical DMA channels and linked transfers.</li>
<li>Support has been added for intermediate synchronization points associated with “wait-ids” for individual transfers within a linked transfer chain.</li></ul>
<h3><span class="mw-headline" id="IDMA3_Interface_Definition">IDMA3 Interface Definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=12" title="Edit section: IDMA3 Interface Definition">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The IDMA3 interface is implemented by algorithms that need EDMA3 resources. The application framework DMA Resource Manager calls the algorithm’s IDMA3 interface functions to query and subsequently allocate and grant the requested DMA resources. (DMAN3 is a reference implementation of a DMA Resource Manager provided by the Framework Components.) If required, the framework calls IDMA3 channel-specific IDMA3_Protocol functions to allocate, initialize, and free additional channel environment memory, which is part of the logical DMA channel state.
</p><p>The algorithm implements the IDMA3 interface by defining and initializing a global structure of type IDMA3_Fxns. Every function defined in this structure must be implemented and assigned to the appropriate field in this structure. Figure 3 illustrates the calling sequence for IDMA3 functions and how these functions relate to the IALG functions performed during algorithm instance creation and real-time operation.
</p>
<div style="text-align: center;">
<p><a href="../File_IDMA3_Function_Calling_Sequence1.html" class="image" title="interaction"><img alt="interaction" src="https://processors.wiki.ti.com/images/9/90/IDMA3_Function_Calling_Sequence1.png" width="611" height="328" /></a><br /><b>Figure 3. IDMA3 Function Calling Sequence</b>
</p>
</div>
<p>The dmaChangeChannels() and dmaGetChannels() functions can be called at any time in the algorithm’s real-time stages. The algMoved() and algNumAlloc() functions were omitted from this figure for simplicity.
</p><p>The dmaGetChannels() and dmaInit() functions must be called after algInit() and before algActivate(). The dmaGetChannelCnt( ) function can be called before the algorithm instance object is created if the framework wants to query the algorithm about its DMA resource requirements before creating the instance object.
</p><p><b>Note:</b> Framework Components provides a DMA resource manager, DMAN3, which provides functions to perform the IDMA3 operations to create algorithms that implement the IDMA3 interface. This is discussed in the section <a href="#DMAN3:_.E2.80.98C64x.2B_DMA_Resource_Manager">DMAN3: ‘C64x+ DMA Resource Manager</a>.
</p><p>Figure 4 illustrates a typical system with an algorithm implementing the IALG and IDMA3 interfaces and the application with a DMA manager. Notice that the algorithm calls the ACPY3 run-time functions, which are implemented by the Framework Components. The ACPY3 interface provides a comprehensive list of DMA functions that an algorithm can call using the IDMA3 handles to program the logical DMA channels obtained through the IDMA3 interface. These functions allow the algorithm to:
</p>
<ul><li>Configure each logical channel’s DMA transfer settings.</li>
<li>Submit asynchronous DMA transfer requests.</li>
<li>Synchronize with the completion status of submitted transfers (both blocking and non-blocking).</li></ul>
<div style="text-align: center;">
<p><a href="../File_Implement_IALG_IDMA3_interfaces.html" class="image" title="interaction"><img alt="interaction" src="https://processors.wiki.ti.com/images/9/98/Implement_IALG_IDMA3_interfaces.png" width="563" height="288" /></a><br /><b>Figure 4. Algorithm Implementing IALG and IDMA3 Interfaces and Application Using Framework Components</b>
</p>
</div>
<h4><span class="mw-headline" id="DMA_Channel_Descriptor:_IDMA3_ChannelRec">DMA Channel Descriptor: IDMA3_ChannelRec</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=13" title="Edit section: DMA Channel Descriptor: IDMA3 ChannelRec">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The IDMA3 interface functions use the IDMA3_ChannelRec structure definition to characterize the properties of each logical DMA channel to be granted to the requesting algorithm or module. The DMA Manager utilizes the information passed in a channel descriptor and responds by constructing a logical IDMA3 channel containing the physical DMA resources that are assigned to the channel, and passes the handle of the DMA channel using the same channel descriptor.
</p><p>This structure has the following data fields:
</p>
<table border="1">

<tbody><tr>
<td>IDMA3_Handle
</td>
<td>handle
</td></tr>
<tr>
<td>Int
</td>
<td>numTransfers
</td></tr>
<tr>
<td>Int
</td>
<td>numWaits
</td></tr>
<tr>
<td>IDMA3_Priority
</td>
<td>priority
</td></tr>
<tr>
<td>IDMA3_ProtocolHandle
</td>
<td>protocol
</td></tr>
<tr>
<td>Bool
</td>
<td>persistent
</td></tr></tbody></table>
<p><br /> The following list describes these fields:
</p>
<ul><li><b>IDMA3_Handle IDMA3_ChannelRec::handle</b></li></ul>
<dl><dd>The handle to a logical DMA channel.</dd></dl>
<ul><li><b>Int IDMA3_ChannelRec::numTransfers</b></li></ul>
<dl><dd>The maximum number of linked DMA transfers that will be submitted using this logical channel handle. Single (==1) or Linked ( &gt;= 2).</dd></dl>
<ul><li><b>Int IDMA3_ChannelRec::numWaits</b></li></ul>
<dl><dd>The maximum number of transfers that can be independently waited upon. This includes intermediate transfers of a linked DMA transfer. A wait, with a waitId of (numWaits – 1) is configured to indicate the end of the linked or single transfer on a particular channel. Hence, while requesting a handle with a configured number of numWaits, always count the default wait required to indicate the end of transfer. For example, if only 1 intermediate transfer is to be tracked, IDMA3_ChannelRec::numWaits should be 2. Use a waitId of 0 to track the intermediate transfer and a waitId of 1 (numWaits – 1) to track the end of the entire transfer.</dd></dl>
<ul><li><b>IDMA3_Priority IDMA3_ChannelRec::priority</b></li></ul>
<dl><dd>The relative priority recommendation for transfers submitted on this channel: High, Medium, or Low. See the section about <a href="#IDMA3_Enumeration_Type_Documentation">IDMA3 Enumeration Type Documentation</a> for constants to use for priorities.</dd></dl>
<ul><li><b>IDMA3_ProtocolHandle IDMA3_ChannelRec::protocol</b></li></ul>
<dl><dd>When non-null, the protocol object provides an interface for querying and initializing logical DMA channel for use by the given protocol. The protocol can be IDMA3_PROTOCOL_NULL; in this case no “env” is allocated. For example, when requesting a logical channel to be used with ACPY3 functions, the protocol needs to be set to &amp;ACPY3_PROTOCOL.</dd></dl>
<ul><li><b>Bool IDMA3_ChannelRec::persistent</b></li></ul>
<dl><dd>When persistent is set to TRUE, the PaRAMs and TCCs are allocated exclusively for this channel. They cannot be shared with any other IDMA3 channel.</dd></dl>
<h4><span class="mw-headline" id="IDMA3_Functions:_IDMA3_Fxns">IDMA3 Functions: IDMA3_Fxns</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=14" title="Edit section: IDMA3 Functions: IDMA3 Fxns">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The application framework calls the following functions to query and grant DMA resources requested by the algorithm at initialization time, and to make changes to these resources at run-time. These IDMA3 functions must be implemented by all algorithms that need to access physical DMA resources of the EDMA3 controller.
</p>
<table border="1">

<tbody><tr>
<td>Void *implementationId
</td></tr>
<tr>
<td>Void (*dmaChangeChannels )(IALG_Handle, IDMA3_ChannelRec *)
</td></tr>
<tr>
<td>Uns (*dmaGetChannelCnt )(Void)
</td></tr>
<tr>
<td>Uns (*dmaGetChannels )(IALG_Handle, IDMA3_ChannelRec *)
</td></tr>
<tr>
<td>Int (*dmaInit )(IALG_Handle, IDMA3_ChannelRec *)
</td></tr></tbody></table>
<ul><li><b>implementationId</b> – This holds a unique value that identifies the module implementing this interface. This same value must be used in all interfaces implemented by the module. Since all compliant algorithms must implement the IALG interface, it is sufficient for these algorithms to set this field to the address of the module’s declared IALG_Fxns structure.</li>
<li><b>dmaChangeChannels()</b> – The application framework’s DMA resource manager calls this function whenever a logical channel is moved at run-time.</li>
<li><b>dmaGetChannelCnt()</b> – The application framework’s DMA resource manager calls this function to query an algorithm about the maximum number of logical DMA channels requested.</li>
<li><b>dmaGetChannels()</b> – The application framework’s DMA resource manager calls this function to query an algorithm about its DMA channel requests at initialization time, or to get the current channel holdings.</li>
<li><b>dmaInit()</b> – The application framework’s DMA resource manager calls this function to grant DMA handle(s) to the algorithm at initialization time. The algorithm uses this function to complete the initialization of its instance object.</li></ul>
<h4><span class="mw-headline" id="IDMA3_Object_and_Handle_Structures:_IDMA3_Obj">IDMA3 Object and Handle Structures: IDMA3_Obj</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=15" title="Edit section: IDMA3 Object and Handle Structures: IDMA3 Obj">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The IDMA3 channel object holds the private state associated with each logical DMA channel. The application framework DMA manager creates and initializes the logical channel provisioned with the physical EDMA3 resources that are exposed in this structure definition, and passes its handle to the requesting algorithm using the IDMA3 interface.
</p><p>The holder of a handle to an IDMA3 channel may directly access the physical resources assigned to the channel or use a standard (ACPY3) or custom DMA functional library that recognizes IDMA3 channel handles.
</p><p>When the channel is created with its persistent field set to “false”, the physical DMA resources assigned to the channel are be considered to be “scratch” memory, as the definition applies to IALG memory attributes. Algorithms must perform initialization of the resource state each time they are put in an “active” state (via an algActivate call) and must save any necessary channel context when they are deactivated (via algDeactivate). When using ACPY3, calling ACPY3_activate and ACPY3_deactivate during instance activation and deactivation, respectively, performs this required context initialization and deinitialization.
</p><p>Figure 5 shows how the algHandle points to an IALG_Obj object, which in turn points to an IDMA3_Obj object.
</p>
<div style="text-align: center;">
<p><a href="../File_IDMA3_Logical_Channels1.html" class="image" title="IDMA3 Logical Channels"><img alt="IDMA3 Logical Channels" src="https://processors.wiki.ti.com/images/2/2d/IDMA3_Logical_Channels1.png" width="508" height="271" /></a><br /><b>Figure 5. IDMA3 Logical Channels</b>
</p>
</div>
<p>The IDMA3_Handle data type is a pointer to the IDMA_Obj structure. The IDMA3_Obj structure has the following data fields:
</p>
<table border="1">

<tbody><tr>
<td>MdUns
</td>
<td>numTccs
</td></tr>
<tr>
<td>MdUns
</td>
<td>numPaRams
</td></tr>
<tr>
<td>SmUns *
</td>
<td>tccTable
</td></tr>
<tr>
<td>Uns *
</td>
<td>paRamAddr
</td></tr>
<tr>
<td>MdUns
</td>
<td>qdmaChan
</td></tr>
<tr>
<td>Bool
</td>
<td>transferPending
</td></tr>
<tr>
<td>Void *
</td>
<td>env
</td></tr>
<tr>
<td>IDMA3_ProtocolHandle
</td>
<td>protocol
</td></tr>
<tr>
<td>Bool
</td>
<td>persistent
</td></tr></tbody></table>
<p><br /> The following list describes these fields:
</p>
<ul><li><b>MdUns IDMA3_Obj::numTccs</b></li></ul>
<dl><dd>The number of TCCs allocated to this channel.</dd></dl>
<ul><li><b>MdUns IDMA3_Obj::numPaRams</b></li></ul>
<dl><dd>The number of contiguous EDMA3 Parameter RAM (PaRAM Set) register sets allocated to this channel.</dd></dl>
<ul><li><b>SmUns* IDMA3_Obj::tccTable</b></li></ul>
<dl><dd>The address of the array containing TCCs assigned to this channel.</dd></dl>
<ul><li><b>Uns* IDMA3_Obj::paRamAddr</b></li></ul>
<dl><dd>The physical address of the first PaRAM assigned to this channel.</dd></dl>
<ul><li><b>MdUns IDMA3_Obj::qdmaChan</b></li></ul>
<dl><dd>The index of the physical QDMA channel assigned to the handle.</dd></dl>
<ul><li><b>Bool IDMA3_Obj::transferPending</b></li></ul>
<dl><dd>The channel state. This must be maintained by the channel handle owner. The transferPending state must be set to true each time a new DMA transfer is physically submitted using this DMA channel. The state must be cleared to false before a new physical transfer can be submitted using this channel.</dd></dl>
<ul><li><b>Void* IDMA3_Obj::env</b></li></ul>
<dl><dd>An optional “environment” memory that may be allocated as a private extension of the channel state. Memory for the “env” must be supplied by the framework prior to calling the IDMA3_Fxns::dmaInit function only if the IDMA3 channel descriptor requires it by providing a non-null “protocol” handle and a non-null getEnvMemRec() function pointer.</dd></dl>
<dl><dd>The IDMA3_Protocol object’s getEnvMemRec() function characterizes the size, alignment and space attributes of the “env” memory needed for the channel. The framework is responsible for allocating and reclaiming the “env” memory.</dd></dl>
<dl><dd>During channel creation, the “env” pointer must always be created as private and persistent memory assigned to the IDMA3 channel object. However, the framework/resource manager is also allowed to allocate the requested internal “env” memory as “scratch” memory that can only be used when the channel is in an active state.</dd></dl>
<dl><dd>In the scratch allocation case, the framework/resource manager must still allocate the “env” as a “persistent” shadow memory, possibly in “external memory”, and then pass the address of the scratch “internal” “env” memory in the first word of the returned IDMA3_Obj's “env” pointer. If a channel’s “env” memory is created as “persistent” with no “scratch” shadow, then the first word of the env memory must be set to null.</dd></dl>
<ul><li><b>IDMA3_ProtocolHandle IDMA3_Obj::protocol</b></li></ul>
<dl><dd>When non-null, this points to the channel protocol function table used by the DMA manager to interrogate and provision memory for the channel’s “env” area.</dd></dl>
<ul><li><b>Bool IDMA3_Obj::persistent</b></li></ul>
<dl><dd>This flag indicates whether the channel was allocated with the persistent property.</dd></dl>
<h4><span class="mw-headline" id="IDMA3_Protocol_Object_for_Channel_Environment_Memory_Management">IDMA3 Protocol Object for Channel Environment Memory Management</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=16" title="Edit section: IDMA3 Protocol Object for Channel Environment Memory Management">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The IDMA3 protocol object (the “protocol” field of the channel descriptor) is used only when the requestor of the IDMA3 channel requires:
</p>
<ul><li>Additional environment memory (assigned to the channel’s “env” pointer) to be allocated by the framework as part of the channel object, or</li>
<li>Custom initialization or de-initialization functions to be called by the framework upon channel creation and deletion.</li></ul>
<p>If these requirements do not apply, you may request the IDMA3 channel with a null “protocol” field and skip the details of this section.
</p><p>Algorithms or framework libraries (such as ACPY3) may need some additional persistent and private “environment” memory to be associated with each IDMA3 channel in order to manage channel state or to create shadow copies of registers, data structures, etc. The IDMA3 interface defines a protocol, via the IDMA3_ProtocolObj specification, that can be implemented and used by individual algorithms or functional DMA libraries to request and receive channel environment memory from the resource management framework during channel creation.
</p><p>Custom DMA libraries may take advantage of this feature and require that IDMA3 channels are requested and created using specific IDMA3 Protocol Objects. An example of this is the ACPY3 library, which supplies its own protocol object, ACPY3_PROTOCOL. Algorithms or applications that will use ACPY3 to submit DMA transfers are simply required to set the “protocol” field to the address of ACPY3_PROTOCOL when they request an IDMA3 channel for ACPY3 use.
</p><p>When the IDMA3 channel descriptor (IDMA3_ChannelRec) contains a non-null IDMA3_ProtocolObj reference, the provided functions are called to determine channel environment memory requirements and to perform initialization and de-initialization of the channel object. If the IDMA3 protocol does not require the functionality associated with any particular function, it may be set to null. The application framework and DMA resource manager are responsible for calling the IDMA3_Protocol functions.
</p><p>The IDMA3_ProtocolObj contains the following fields:
</p>
<table border="1">

<tbody><tr>
<td>String name
</td></tr>
<tr>
<td>Void (*getEnvMemRec )(IDMA3_ChannelRec *, IDMA3_MemRec *)
</td></tr>
<tr>
<td>Bool (*initHandle )(IDMA3_Handle)
</td></tr>
<tr>
<td>Bool (*deInitHandle )(IDMA3_Handle)
</td></tr></tbody></table>
<p>The following list describes these fields:
</p>
<ul><li><b>String IDMA3_ProtocolObj::name</b></li></ul>
<dl><dd>The name of the protocol.</dd></dl>
<ul><li><b>Void(*IDMA3_ProtocolObj::getEnvMemRec)(IDMA3_ChannelRec *, IDMA3_MemRec *)</b></li></ul>
<dl><dd>The function is called by the application framework/DMA manager to obtain the IDMA3 protocol's memory requirements (IDMA3_MemRec) for its environment for the given IDMA3 channel descriptor. This is usually done when creating a logical DMA channel.</dd></dl>
<ul><li><b>Bool(* IDMA3_ProtocolObj::initHandle)(IDMA3_Handle)</b></li></ul>
<dl><dd>This function is called after allocation. It allows the IDMA3 protocol to do any initialization of its environment. It initializes the “env” memory passed in the IDMA3 channel handle and any other channel state. Returns TRUE on success, FALSE otherwise. If FALSE is returned channel creation fails.</dd>
<dd>If the framework/resource manager allocates the requested internal “env” memory as “scratch”, the “env” pointer passed in the IDMA3_Handle points to a persistent and private shadow memory (possibly in “external memory”), which contains the address of the “scratch” allocated “internal” “env” memory in the first word of the “persistent” “env” pointer.</dd>
<dd>If the first word of the env memory is NULL, then no separate “scratch” memory has been allocated and the “env” memory itself is “persistent”.</dd></dl>
<ul><li><b>Bool(* IDMA3_ProtocolObj::deInitHandle)(IDMA3_Handle)</b></li></ul>
<dl><dd>This function is called when a channel is freed. It deinitializes a channel before assigned resources and memory are freed by the DMA manager. It is called so that the IDMA3 protocol can do any required de-initialization or freeing any memory that may have been allocated in initHandle().</dd></dl>
<h4><span class="mw-headline" id="IDMA3_Enumeration_Type_Documentation">IDMA3 Enumeration Type Documentation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=17" title="Edit section: IDMA3 Enumeration Type Documentation">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The following enumerated types are defined for use by the IDMA3 API:
</p>
<ul><li><b>enum IDMA3_MemType</b></li></ul>
<table border="1">

<tbody><tr>
<th>Constant
</th>
<th>Memory Type
</th></tr>
<tr>
<td>IDMA3_INTERNAL
</td>
<td>Internal data memory
</td></tr>
<tr>
<td>IDMA3_EXTERNAL
</td>
<td>External data memory
</td></tr></tbody></table>
<ul><li><b>enum IDMA3_Priority</b></li></ul>
<table border="1">

<tbody><tr>
<th>Constant
</th>
<th>IDMA3 Priority Level
</th></tr>
<tr>
<td>IDMA3_PRIORITY_URGENT
</td>
<td>Urgent
</td></tr>
<tr>
<td>IDMA3_PRIORITY_HIGH
</td>
<td>High
</td></tr>
<tr>
<td>IDMA3_PRIORITY_MEDIUM
</td>
<td>Medium
</td></tr>
<tr>
<td>IDMA3_PRIORITY_LOW
</td>
<td>Low
</td></tr></tbody></table>
<h2><span id="DMAN3:_‘C64x+_DMA_Resource_Manager"></span><span class="mw-headline" id="DMAN3:_.E2.80.98C64x.2B_DMA_Resource_Manager">DMAN3: ‘C64x+ DMA Resource Manager</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=18" title="Edit section: DMAN3: ‘C64x+ DMA Resource Manager">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>DMAN3 is the DMA Resource Manager responsible for granting and reclaiming physical DMA resources such as EDMA3.0 PaRAM Register sets and transfer completion codes (TCCs). DMAN3 creates logical DMA channels based on the IDMA3 interface specification and grants these to requesting algorithms or other software components.
</p><p>The application framework configures DMAN3 during system start-up (prior to its first use) with a dedicated set of EDMA3.0 physical DMA resources: PaRAM Sets, TCCs, and QDMA channels. Algorithms receive DMA handles from DMAN3 and use them to call ACPY3 functions to configure logical channel settings, to request DMA transfers or to synchronize with on-going transfers.
</p><p>DMAN3 functions are intended to provide application frameworks a convenient and easy-to-use layer to integrate algorithms that request DMA resources.
</p>
<h3><span class="mw-headline" id="Using_DMAN3_for_Algorithm_Integration">Using DMAN3 for Algorithm Integration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=19" title="Edit section: Using DMAN3 for Algorithm Integration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The following steps provide a generic and convenient set of instructions for using the DMAN3 module to instantiate algorithm instances that request DMA resources. The code examples are from the fastcopytest.c example provided with this application note.
</p>
<ol><li>Include the DMAN3 and ACPY3 modules in the application. You can use the DMAN3 module as provided or make changes to it as needed by your application.
<dl><dd><code>#include &lt;ti/sdo/fc/dman3/dman3.h&gt;</code></dd>
<dd><code>#include &lt;ti/sdo/fc/acpy3/acpy3.h&gt;</code></dd></dl></li>
<li>Create an algorithm instance using the IALG interface and set values for fields in the algorithm-specific params structure, which is declared in i&lt;mod&gt;.h. Use the standard IALG interface to allocate and grant the memory buffers requested by the algorithm and initialize the instance object.
<dl><dd><code>FCPY_Params fcpyParams;</code></dd>
<dd><code>FCPY_Handle alg;</code></dd>
<dd><code>IDMA3_Fxns *dmaFxns[NUMALGS];</code></dd>
<dd><code>IALG_Handle alg[NUMALGS];</code></dd>
<dd><code>...</code></dd>
<dd><code>FCPY_init();</code></dd>
<dd><code></code></dd>
<dd><code>fcpyParams = FCPY_PARAMS; /* use the default creation parameters */</code></dd>
<dd><code></code></dd>
<dd><code>if ((alg = FCPY_create(&amp;FCPY_IALG, &amp;fcpyParams)) == NULL) {</code>
<dl><dd><code>    	SYS_abort("Could not create algorithm instance");</code></dd></dl></dd>
<dd><code>}</code></dd></dl></li>
<li>Call the DMAN3 and ACPY3 module initialization functions.&lt;/code&gt;
<dl><dd><code>/* Assign internal and external Heaps to DMAN3 module. */</code></dd>
<dd><code>DMAN3_PARAMS.heapInternal = L1DHEAP;   </code></dd>
<dd><code>DMAN3_PARAMS.heapExternal = EXTERNALHEAP;   </code></dd>
<dd><code></code></dd>
<dd><code>/* Initialize DMA manager &amp; ACPY3 lib for xDAIS algs and grant DMA resources */ </code></dd>
<dd><code>DMAN3_init();</code></dd>
<dd><code>ACPY3_init();</code></dd></dl></li>
<li>Define a scratch sharing context by associating a group-id to use for DMA resource allocation using DMAN3 module. All subsequent DMAN3 calls using the same group-id will share underlying physical DMA resources.
<dl><dd><code>Int groupId = 1;</code></dd>
<dd><code>Int numAlgs = 1;</code></dd></dl></li>
<li>Use the DMAN3 module to grant the DMA resources requested by the algorithm.
<dl><dd><code>alg[0]     = (IALG_Handle)fcpyAlg;</code></dd>
<dd><code>dmaFxns[0] = &amp;FCPY_IDMA3;</code></dd>
<dd><code></code></dd>
<dd><code>if (DMAN3_grantDmaChannels(groupId, alg, dmaFxns, numAlgs)&#160;!= DMAN3_SOK) {</code>
<dl><dd><code>    SYS_abort("Problem adding algorithm's dma resources");</code></dd></dl></dd>
<dd><code>}</code></dd></dl></li></ol>
<h3><span class="mw-headline" id="DMAN3_Configuration">DMAN3 Configuration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=20" title="Edit section: DMAN3 Configuration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The DMAN3 module manages physical and logical DMA resources for DSP algorithms and drivers. Allocation of following physical EDMA/QDMA resources is needed to ensure interoperability:
</p>
<ul><li>TCCs (Transfer Completion Codes)</li>
<li>PaRAM entries (Parameter RAM)</li>
<li>QDMA channels</li></ul>
<p>The DMAN3 functions manage system EDMA/QDMA resources that are pre-allocated to it by initializing the global DMAN3 configuration parameter DMAN3_PARAMS during the initial system configuration. The DMAN3_init() function uses the initial system DMAN3 configuration settings and assumes that it exclusively owns and manages these resources. For example, the system integrator could identify and allocate 48 PaRAM entries to DMAN3. The rest could be distributed between the drivers, power managers on the chip, and possibly other frameworks that have access to the shared DMA resource.
</p>
<h4><span class="mw-headline" id="Introduction_to_Configuration_Options">Introduction to Configuration Options</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=21" title="Edit section: Introduction to Configuration Options">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The following section describes the configuration parameters of the DMA Manager module, DMAN3. Each configuration option can be set at design time by the system integrator to ensure optimal sharing of DMA resources for the execution environment.
</p><p>There are two ways to configure DMAN3 parameters.
</p>
<ul><li>You can use a low-level C language based approach to directly modify an interface-defined global configuration structure, DMAN3_PARAM, as defined in the DMAN3 API specification. The DMAN3_Params structure defines the configurable parameters of the DMAN3 module.</li>
<li>Alternately, you can use XDC tooling to configure the RTSC module, DMAN3.</li></ul>
<p>The XDC tooling approach results in the generation of the same low-level C based global configuration structures, so the type of configuration technology used does not matter to the underlying DMAN3 library implementation.
</p>
<h4><span class="mw-headline" id="Configuration_Parameters">Configuration Parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=22" title="Edit section: Configuration Parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The following is a list of the configurable DMAN3 parameters and a description of each.
</p><p>Two names are given for each configuration parameter in this section. First, the DMAN3 parameters named in the DMAN3_Params struct in the dman3.h header file are listed as DMAN3_Params::&lt;attribute name&gt;. The DMAN3 parameters are also configurable via the RTSC DMAN3 package interface; these names are specified in DMAN3.xdc and are listed in this section as DMAN3.&lt;attribute name&gt;.
</p>
<ul><li><b>Uns* DMAN3_Params::qdmaPaRamBase</b><br /><b>UInt DMAN3.qdmaPaRamBase</b></li></ul>
<dl><dd>This identifies the physical base address of PARAM0 in the EDMA3/QDMA hardware whose resources are being managed by DMAN3. Set this to the actual base address of the PaRAM entries for the particular device on which DMAN3 is being configured.</dd></dl>
<ul><li><b>Uns DMAN3_Params::maxPaRamEntries</b><br /><b>UInt DMAN3.maxPaRamEntries</b></li></ul>
<dl><dd>The total number of PaRAM entries on the target hardware. Set this to the actual number of PaRAM entries available on the particular device on which DMAN3 is being configured.</dd></dl>
<ul><li><b>Uns DMAN3_Params::paRamBaseIndex</b><br /><b>UInt DMAN3.paRamBaseIndex</b></li></ul>
<dl><dd>(0&gt;value&gt;255) This represents the first PaRAM table entry number that is assigned by configuration for exclusive DMAN3 allocation.&#160;:Contiguous PaRAM entries will be allocated exclusively for DMAN starting from this index.</dd></dl>
<ul><li><b>Uns DMAN3_Params::numPaRamEntries</b><br /><b>UInt DMAN3.numPaRamEntries </b></li></ul>
<dl><dd>The number of PaRAM table entries starting at DMAN3_PARAM_BASE_INDEX assigned by configuration for exclusive DMAN3 allocation.</dd></dl>
<div style="text-align: center;">
<p><a href="../File_Param_entries.html" class="image" title="PaRAM Table Entries"><img alt="PaRAM Table Entries" src="https://processors.wiki.ti.com/images/3/39/Param_entries.png" width="314" height="289" /></a><br />
</p>
</div>
<ul><li><b>Uns DMAN3_Params::maxQdmaChannels</b><br /><b>UInt DMAN3.maxQdmaChannels</b></li></ul>
<dl><dd>The total number of physical QDMA channels available on the target hardware. Set this to the actual number of QDMA channels that are available on the device for which DMAN3 is being configured.</dd></dl>
<ul><li><b>Uns DMAN3_Params::numQdmaChannels</b><br /><b>UInt DMAN3.numQdmaChannels </b></li></ul>
<dl><dd>The number of physical QDMA channels that are assigned to DMAN3 via configuration. This number is assigned to DMAN3_NUM_QDMA_CHANNELS.</dd></dl>
<ul><li><b>Uns* DMAN3_Params::qdmaChannels</b><br /><b>UInt DMAN3.qdmaChannels[DMAN3_NUM_QDMA_CHANNELS]</b></li></ul>
<dl><dd>An array of size DMAN3_NUM_QDMA_CHANNELS that contains the channel numbers of the physical QDMA channels assigned to DMAN3 via configuration. DMAN3 exclusively owns these QDMA channels and assumes that they will not be used by any other resource. These channels need not be contiguous.</dd></dl>
<ul><li><b>Uns DMAN3_Params::tccAllocationMaskH</b><br /><b>UInt DMAN3.tccAllocationMaskH</b></li></ul>
<dl><dd>A 32-bit bitmask representing a configuration-provided list of TCCs for exclusive DMAN3 allocation in the range 32-63. For example, for TCCs in the range 32-63 the High Mask (tccAllocationMaskH) is configured so that a “1” in bit position “i" indicates the TCC: (32 + i ) is assigned to DMAN3.</dd></dl>
<ul><li><b>Uns DMAN3_Params::tccAllocationMaskL</b><br /><b>UInt DMAN3.tccAllocationMaskL</b></li></ul>
<dl><dd>A 32-bit bitmask representing a configuration-provided list of TCCs for exclusive DMAN3 allocation in the range 0-31. For example, for TCCs in the range 0-31 the Low Mask (tccAllocationMaskL) is configured so that a “1” in bit position “i" indicates the TCC: “i" is assigned to DMAN3.</dd></dl>
<ul><li><b>SmUns DMAN3_Params::numTccGroup[DMAN3_MAXGROUPS]</b><br /><b>Int DMAN3.numTccGroup[DMAN3_MAXGROUPS]</b></li></ul>
<dl><dd>An array containing the number of TCCs to be assigned to groups for sharing.</dd>
<dd>Algorithms in a particular scratch group (with the same group ID), share the same shared scratch pool. DMA channels requested by a given group use TCCs allocated for that group. The numTccGroup array indicates, for each group ID, the number of TCCs allocated to it.</dd>
<dd>Depending on the calls you make to create DMA channels in the same scratch group, you may or may not share the same TCCs.</dd></dl>
<ul><li><b></b></li></ul>
<p>MdUns DMAN3_Params::numPaRamGroup[DMAN3_MAXGROUPS] <b><br /></b>Int DMAN3.numPaRamGroup[DMAN3_MAXGROUPS]<b></b>
</p>
<dl><dd>Arrays containing the list of PaRAM entries that will be assigned to groups for sharing.</dd>
<dd>Algorithms in a particular scratch group (with the same group ID), share the same shared scratch pool. DMA channels requested by a given group use TCCs allocated for that group. The numPaRamGroup array indicates, for each group ID, the number of PaRAMs allocated to it.</dd>
<dd>Depending on the calls you make to create DMA channels in the same scratch group, you may or may not share the same PaRAMs</dd></dl>
<ul><li><b>Bool DMAN3_Params::idma3Internal</b><br /><b>Bool DMAN3.idma3Internal</b></li></ul>
<dl><dd>Use the internal memory heap to dynamically allocate IDMA3 objects. If this value is “false”, IDMA3 objects are allocated in the heap specified by heapExternal. If the value of idma3Internal is “true”, IDMA3 objects are allocated in the heap specified by heapInternal.</dd></dl>
<ul><li><b></b></li></ul>
<p>Int DMAN3_Params::heapInternal <b><br /></b>String DMAN3.heapInternal<b></b>
</p>
<dl><dd>The Memory Heap ID for dynamic allocation of DMAN3 objects that must be allocated in L1D Internal RAM. The internal heap could be used for allocation of memory for IDMA3 objects if indicated by the idma3Internal flag.</dd>
<dd>A value of -1 for heapInternal indicates that the heap is NOT DEFINED. If heapInternal is not defined, then any IDMA3 protocol call that requests IDMA3 objects to be created in the internal memory, will fail. When using RTSC module configuration you are required to provide a valid DSP/BIOS heap label.</dd></dl>
<ul><li><b></b></li></ul>
<p>Int DMAN3_Params::heapExternal <b><br /></b>String DMAN3.heapExternal<b></b>
</p>
<dl><dd>The Memory Heap ID for dynamic allocation of private DMAN3 data structures that can be allocated in external memory. The heapExternal memory space is used by DMAN3 to allocate memory for holding DMA channel descriptors that point to logical DMA channels. This space could also be used to hold IDMA3 objects if the flag idma3Internal is set to false.</dd>
<dd>A value of -1 indicates that the heap is NOT DEFINED. If heapExternal is not defined then DMAN3 attempts to use heapInternal. As a consequence, at least one of them must be defined. When using RTSC module configuration you are required to provide a valid DSP/BIOS heap label.</dd></dl>
<ul><li><b></b></li></ul>
<p>DMAN3_ScratchAllocFxn DMAN3_Params::scratchAllocFxn <b><br /></b>String DMAN3.scratchAllocFxn<b></b>
</p>
<dl><dd>Algorithms, while requesting IDMA3 channels from DMAN3, might specify a particular IDMA3 protocol that provides custom DMA services. This protocol might require additional memory allocation for the channel’s environment (“env” field). The scratchAllocFxn is a function call that when non-null is used to allocate the protocol’s environment memory. If scratchAllocFxn is null, this additional memory is allocated in the internal heap specified by the heapInternal parameter.</dd>
<dd>If the scratchAllocFxn is provided, but fails to allocate the memory, DMAN3 attempts to allocate the memory dynamically using its heapInternal.</dd>
<dd><b>Note:</b> The Framework Component DSKT2 provides a scratchAllocFxn implementation that can be used to allocate, when possible, the IDMA3 protocol handle’s environment memory in the shared scratch area, provided that DSKT2 was also used to create the actual algorithm instance using the same scratch group ID.</dd></dl>
<ul><li><b></b></li></ul>
<p>DMAN3_ScratchFreeFxn DMAN3_Params::scratchFreeFxn <b><br /></b>String DMAN3.scratchFreeFxn<b></b>
</p>
<dl><dd>The scratchFreeFxn is a function call that is used to free memory allocated using the scratchAllocFxn by DMAN3.</dd>
<dd><b>Note:</b> The Framework Component DSKT2 provides a scratchFreeFxn implementation that must be called if memory has been allocated using DSKT2’s scratchAllocFxn</dd></dl>
<ul><li><b></b></li></ul>
<p>Uns DMAN3_Params::nullPaRamIndex <b><br /></b>UInt DMAN3.nullPaRamIndex<b></b>
</p>
<dl><dd>The index of the PaRAM entry to be reserved as a “NULL” PaRAM. Any QDMA channel that is inactive is mapped to the nullPaRamIndex entry by setting up the QCHMAP register accordingly. This PaRAM index must not be used by the application domain for scheduling EDMA3 transfers.</dd>
<dd><b>Note:</b> This index is not counted against the numPaRAMEntries configuration setting.</dd></dl>
<ul><li><b></b></li></ul>
<p>bool DMAN3.debug <b></b>
</p>
<dl><dd>A value of true for the debug parameter enables the debug profile of the DMAN3 library. This results in a larger and slower version of the library being linked in. It provides extra parameter checking and causes debug trace statements to be generated in the DSP/BIOS SYS trace buffer.</dd></dl>
<h4><span class="mw-headline" id="DMAN3_Configuration_Examples">DMAN3 Configuration Examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=23" title="Edit section: DMAN3 Configuration Examples">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>In the following subsections we discuss some common DMAN3 configuration scenarios.
</p>
<h5><span class="mw-headline" id="Configuring_DMAN3_for_Optimal_Sharing_of_Physical_DMA_Resources">Configuring DMAN3 for Optimal Sharing of Physical DMA Resources</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=24" title="Edit section: Configuring DMAN3 for Optimal Sharing of Physical DMA Resources">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>DMAN3 attempts to maintain a separate sharable pool of physical EDMA3 resources such as PaRAMs and TCCs for each scratch group, identified by the groupId. The groupId argument passed to a DMAN3 function is used to determine the shared scratch resource pool to satisfy the allocation request. However, the shared resource pool for a particular groupId does not get created until the first DMAN3 allocation call using that groupId. The initial size of the shared scratch PaRAM or TCC pool is determined by the “greater” of:
</p>
<ul><li>The size of the resource needed to satisfy the current allocation request.</li>
<li>The DMAN3 configuration setting for DMAN3::numPaRamGroup[groupId] for the PaRAM pool.</li>
<li>The DMAN3 configuration setting for DMAN3::numPaRamGroup[groupId] for the TCC pool.</li></ul>
<p>Therefore it may be important to configure the DMAN3 numPaRamGroup and numPaRamGroup properties for optimal allocation to ensure that all allocation requests can be satisfied using the same shared resource pool for that groupId.
</p><p>For example, if algorithm instances A and B, assigned to the same groupId, i, require 10 PaRAMs for A’s channel requirements and 20 PaRAMs for B, then setting:
</p>
<dl><dd><code>DMAN3::numPaRamGroup[i] = 20</code></dd></dl>
<p>ensures that, irrespective of the order in which the A and B instances are created, they can be assigned PaRAMs from the same shared PaRAM pool assigned to group:i. For the same example, suppose you used a different DMAN3 setting such as:
</p>
<dl><dd><code>DMAN3::numPaRamGroup[i] = 5</code></dd></dl>
<p>If A is created first and then B, then 10 PaRAMs are created for A, and the shared PaRAM pool has size=10 for group:i. This results in not being able to satisfy B’s PaRAM allocation from group:i’s shared pool. DMAN3 would still try to satisfy B’s request by privately allocating 20 PaRAMs to B, in a non-sharable manner, if at the time of the call DMAN3 has enough PaRAMs available for non-shared allocation. If there are not enough such PaRAMs available, B’s allocation returns failure, indicating not enough PaRAMs.
</p><p>With the latter setting, if B is created first, the initial shared PaRAM pool allocation of 20 PaRAMs for group:i would be able to satisfy the subsequent allocation request for A from the shared pool. But, in this scenario, the optimal allocation imposes an order of creation constraint (B first, then A) for the application.
</p><p>A similar argument applies when configuring the DMAN3 numTccGroup setting.
</p>
<h5><span class="mw-headline" id="DMA_Channel_Memory_Allocation">DMA Channel Memory Allocation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=25" title="Edit section: DMA Channel Memory Allocation">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>The DMAN3 configuration settings, .heapInternal and .heapExternal are used for allocation of IDMA3 channel objects and internal data structures. These heaps can be used to control memory allocation by DMAN3 in conjunction with the DMAN3 Config parameter .idma3Internal (the default is true).
</p><p>A value of “false” means the IDMA3 objects are allocated in the heap specified by DMAN3_PARAMS.heapExternal. If the value of .idma3Internal is “true”, IDMA3 objects are allocated in the heap specified by DMAN3_PARAMS.heapInternal.
</p>
<h5><span class="mw-headline" id="IDMA3_Protocol_Environment_Memory_Allocation">IDMA3 Protocol Environment Memory Allocation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=26" title="Edit section: IDMA3 Protocol Environment Memory Allocation">edit</a><span class="mw-editsection-bracket">]</span></span></h5>
<p>In addition to the memory allocated for the IDMA3 channel handle, if the IDMA3 channel is requested with an IDMA3 Protocol, such as ACPY3_PROTOCOL, there may be additional memory allocation for the channel's environment memory (assigned to “env”.) The IDMA3_Protocol may additionally require the environment memory to be allocated in “internal” memory with some size and alignment constraints, as is the case for ACPY3. In this case, the following DMAN3 configuration settings become important:
</p>
<dl><dd><code>.scratchAllocFxn (default = null)</code></dd>
<dd><code>.scratchFreeFxn  (default = null)</code></dd></dl>
<p>When .scratchAllocFxn and .scratchFreeFxn are null, DMAN3 uses .heapInternal to dynamically allocate and free IDMA3 channel env memory. However when not-null, it calls these functions instead to allocate and free the “env” memory.
</p><p>While there is no dependency between DMAN3 and DSKT2, it is possible to configure DMAN3 by plugging these functions with the specialized DSKT2 APIs DSKT2_allocScratch() and DSKT2_freeScratch() for the DMAN3 config params scratchAllocFxn and scratchFreeFxn respectively. Doing this causes the internal memory requests for the IDMA3_Protocol requested channel “env” memory to be allocated from the DSKT2 managed scratch memory pool for the algorithm instance, when shared scratch DSKT2 memory is available.
</p>
<h4><span class="mw-headline" id="Configuring_DMAN3_at_Runtime">Configuring DMAN3 at Runtime</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=27" title="Edit section: Configuring DMAN3 at Runtime">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The runtime way to configure the DMAN3 configuration parameters is quite straightforward. (This method can be employed by small systems as an alternative to setting these via XDC config.) To modify the DMAN3 configuration parameters, include the <b>ti/sdo/fc/dman3/dman3.h</b> header file in your C file, and override each of the parameters with the modified values <i>prior</i> to calling <code>DMAN3_init()</code>.
</p><p>The following code shows how to modify the <code>heapInternal</code> and <code>heapExternal</code> parameters in a DSP/BIOS 5 based system:
</p><p>&lt;syntaxhighlight lang="c"&gt;
</p>
<ol><li>include &lt;xdc/std.h&gt;</li>
<li>include &lt;ti/sdo/fc/dman3/dman3.h&gt;</li></ol>
<p>extern int L1DHEAP;      /* DSP/BIOS 5 Heap Label for L1DRAM memory allocation */
extern int EXTERNALHEAP; /* DSP/BIOS 5 Heap Label for external memory allocation */
</p><p>Int main(Void)
{
</p>
<pre>   DMAN3_PARAMS.heapInternal = L1DHEAP;
   DMAN3_PARAMS.heapExternal = EXTERNALHEAP;
</pre>
<pre>   DMAN3_init();
   /* ... */
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p>
<h4><span class="mw-headline" id="Configuring_DMAN3_Using_XDC">Configuring DMAN3 Using XDC</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=28" title="Edit section: Configuring DMAN3 Using XDC">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>In the program configuration file, define the DSP/BIOS 5 heaps that will be assigned to DMAN3 heaps. For example, the following code snippet from the dman3/example/fastcopytest.tcf DSP/BIOS configuration file creates two DSP/BIOS heaps with appropriate attributes and heap labels: EXTERNALHEAP and L1DHEAP:
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
/*
</p>
<pre>* app.tcf
*/
</pre>
<p>utils.loadPlatform("ti.platforms.evmDM6446");
DDR = prog.module("MEM").instance("DDR2");
</p><p>/*
</p>
<pre>*  Create external memory segment for this (simulated) board
*  Enable heaps in it and define the label for heap usage.
*/
</pre>
<p>DDR.base             = 0x83F00000;
DDR.len              = 0x0FFE00;     // may be much bigger -- this is sim
DDR.space            = "code/data";  // code/data so we can place code in it
DDR.createHeap       = true;
DDR.enableHeapLabel  = true;
DDR["heapLabel"]     = prog.extern("EXTERNALHEAP");
DDR.heapSize         = 0x8000;
DDR.comment          = "DDR";
</p><p>/*
</p>
<pre>*  Enable heaps in the L1DSRAM (internal L1 cache ram, fixed size)
*  and define the label for heap usage.
*/
</pre>
<p>bios.L1DSRAM.createHeap       = true;
bios.L1DSRAM.enableHeapLabel  = true;
bios.L1DSRAM["heapLabel"]     = prog.extern("L1DHEAP");
bios.L1DSRAM.heapSize         = 0x800;
&lt;/syntaxhighlight&gt;
</p><p>The XDC module configuration of the application uses and configures the DMAN3 module to make changes to the default DMAN3 configuration settings. For example, the following code snippet from dman3/examples/fastcopytest.cfg assigns the application-defined DSP/BIOS heap "L1DHEAP" to <code>DMAN3.heapInternal</code>, which is defined as the DSP/BIOS heap. It assigns "EXTERNALHEAP" to <code>DMAN3.heapExternal</code>. Then, it assigns the EDMA3 PaRAMs 78 through 125 and TCCs 32 through 63 to the DMAN3 module. It assigns 6 of the 8 available QDMA channels {0, 1, 4, 5, 6, and 7} to DMAN3.
</p><p>It also sets 16 PaRAMs and 16 TCCs for scratch group 0 and sets 32 PaRAMs and 16 TCCs for scratch group 1.
</p><p>&lt;syntaxhighlight lang="javascript"&gt;
/*
</p>
<pre>* app.cfg
*/
</pre>
<p>var DMAN3 = xdc.useModule('ti.sdo.fc.dman3.DMAN3');
</p><p>DMAN3.heapInternal = "L1DHEAP";
DMAN3.heapExternal = "EXTERNALHEAP";
</p><p>DMAN3.paRamBaseIndex = 78;
DMAN3.numPaRamEntries = 48;
DMAN3.tccAllocationMaskH = 0xffffffff;
DMAN3.tccAllocationMaskL = 0x0;
DMAN3.numTccGroup   = [16, 16, 0, 0, 0, 0];
DMAN3.numPaRamGroup = [16, 32, 0, 0, 0, 0];
</p><p>DMAN3.qdmaChannels = [0, 1, 4, 5, 6, 7];
DMAN3.maxQdmaChannels = 8;
DMAN3.numQdmaChannels = 6;
&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="DMAN3_Functions">DMAN3 Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=29" title="Edit section: DMAN3 Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The DMAN3 API provides the following functions - see the <a rel="nofollow" class="external text" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/fc/latest_2_x/docs/html/group__ti__sdo__fc__dman3___d_m_a_n3.html">FC API Reference Guide</a> for more details:
</p>
<ul><li><code>DMAN3_init()</code></li>
<li><code>DMAN3_exit()</code></li>
<li><code>DMAN3_grantDmaChannels()</code></li>
<li><code>DMAN3_releaseDmaChannels()</code></li>
<li><code>DMAN3_createChannels()</code></li>
<li><code>DMAN3_freeChannels()</code></li></ul>
<p>DMAN3 functions perform the following resource management functions:
</p>
<ol><li>Assign and reclaim PaRAM, QDMA channel, and TCC resources
<ul><li>DMAN3 actively uses the IDMA3 interface to query and grant DMA resources to algorithms (e.g. <code>DMAN3_grantDmaChannels()</code>)</li>
<li>DMAN3 passively provides functions to non-algorithm users to acquire logical and physical DMA resources (e.g. <code>DMAN3_createChannels()</code>)</li></ul></li>
<li>Allocate and free internal memory for the following:
<ul><li>IDMA3 channel descriptors. Private memory is allocated to hold the handles that are passed back to the algorithm while calling IDMA3::dmaInit().</li>
<li>Channel private parameter RAM state array to cache persistent DMA transfer settings for each PaRAM entry (memory allocated dynamically in internal RAM).</li>
<li>Channel private TCC table.</li>
<li>Other channel private state.</li></ul></li></ol>
<h3><span class="mw-headline" id="DMAN3_New_Features">DMAN3 New Features</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=30" title="Edit section: DMAN3 New Features">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>As of Framework Components release 2.20, a new feature has been added to DMAN3 that allows DMAN3's EDMA3 resources to be handled by the EDMA3 Low Level Driver's Resource Manager.
</p><p>The EDMA3 Low Level Driver (EDMA3 LLD) package has been developed by the Platform Support Package(PSP) team in TI India for use by device drivers. It consists of both a functional library and a resource management library for the EDMA3 hardware
</p>
<ul><li>EDMA3 LLD Driver is the functional part of this package that is used by other peripheral drivers for submission and synchronizing of transfers.</li>
<li>EDMA3 LLD Resource Manager (EDMA3 LLD RM) is the resource management layer of this package that performs pure resource management of the EDMA3 hardware resources.</li></ul>
<p>Framework Components (as of release 2.20) has migrated to optionally use the EDMA3 LLD RM to obtain access to "available" EDMA3 resources on the system. The idea is that any entity (drivers, algorithms, applications) that requires access to EDMA3 hardware should negotiate its resources using this centralized EDMA3 LLD RM.
</p>
<h4><span class="mw-headline" id="Configuration_of_DMAN3_to_use_the_EDMA3_LLD_Resource_Manager">Configuration of DMAN3 to use the EDMA3 LLD Resource Manager</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=31" title="Edit section: Configuration of DMAN3 to use the EDMA3 LLD Resource Manager">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Following are the steps to configure DMAN3 to use the external resource manager (EDMA3 LLD RM) to obtain EDMA3 resources:-
</p>
<ul><li><b>DMAN3.useExternalRM</b> A new configuration paramter has been added to be able to configure DMAN3 to use an external Resource manager. Setting this paramter to "true" in the config file will let the EDMA3 Low Level Resource Manager libraries get linked in. Note:- If not using XDC based configuration, then in your pjt file or Makefile, you need to link in the dman3RM.a* library instead of the dman3.a* library</li></ul>
<ul><li>Several SOC and setup specific DMAN3 parameters are no longer required to be set if it is configured to use the external resource manager. DMAN3 can now obtain this information from the EDMA3 LLD RM as required. Here is a list of XDC configuration parameters that need not be configured if <b>DMAN3.useExternalRM</b> is set to <b>true</b> &#160;:-</li></ul>
<table border="1">

<tbody><tr>
<td>DMAN3.qdmaPaRamBase
</td></tr>
<tr>
<td>DMAN3.maxPaRamEntries
</td></tr>
<tr>
<td>DMAN3.maxQdmaChannels
</td></tr>
<tr>
<td>DMAN3.maxTCs
</td></tr>
<tr>
<td>DMAN3.paRamBaseIndex
</td></tr>
<tr>
<td>DMAN3.numPaRamEntries
</td></tr>
<tr>
<td>DMAN3.nullPaRamIndex
</td></tr>
<tr>
<td>DMAN3.qdmaChannels
</td></tr>
<tr>
<td>DMAN3.tccAllocationMask*
</td></tr>
<tr>
<td>DMAN3.qdmaQueueMap
</td></tr>
<tr>
<td>DMAN3.queueTCMap
</td></tr>
<tr>
<td>DMAN3.queuePri
</td></tr>
<tr>
<td>DMAN3.numTccGroup
</td></tr>
<tr>
<td>DMAN3.numParamGroup
</td></tr></tbody></table>
<p>Note:- If not using XDC based configuration, then when the DMAN3_PARAMS structure is declared, it maybe populated with any values for the fields corresponding to the above configuration. Fields irrelevant will be ignored by the DMAN3 library.
</p>
<ul><li>A new EDMA3 meta config module has been added to Framework Components, that basically is used to configure the EDMA3 LLD RM. Instead of configuring the DMAN3 with all the information above, a subset of that information is to be configured in the EDMA3 module <b>ti.sdo.fc.edma3.Settings</b>. <a href="../Configuration_of_EDMA3_RM_in_Framework_Components.html" title="Configuration of EDMA3 RM in Framework Components">This article explains the various EDMA3 LLD config parameters</a>.</li></ul>
<p>Note:- If not using XDC based configuration, then you could look at the following file in the Framework Components package to get an idea of the configuration that will be required. In $(FC_INSTALL_DIR)/examples/ti/sdo/fc/dman3/examples/fastcopy:
</p>
<ul><li>fastcopytest.c (see content under <code>#ifdef EDMA3_CONFIG</code>)</li>
<li>dm6446_bios/dman3_lld_config.c (this file may be include as is in your application, and modified as necessary).</li></ul>
<h2><span class="mw-headline" id="ACPY3:_Functional_DMA_Abstraction_Layer">ACPY3: Functional DMA Abstraction Layer</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=32" title="Edit section: ACPY3: Functional DMA Abstraction Layer">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The ACPY3 module introduces the notion of a logical DMA channel similar to the ACPY2 interface.
</p>
<h3><span class="mw-headline" id="ACPY3_Functions_and_Comparison_to_ACPY2">ACPY3 Functions and Comparison to ACPY2</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=33" title="Edit section: ACPY3 Functions and Comparison to ACPY2">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In summary, the ACPY3 API provides a much lower level of abstraction compared to the ACPY2 interface. ACPY3 is designed to target EDMA3.0/QDMA, while ACPY2 provided a "generic" DMA abstraction layer.
</p><p>Before submitting a DMA transfer on a logical DMA channel, the channel should be configured for the desired DMA transfer settings via the ACPY3_configure functions.
</p><p>The fast-configure functions can be used to change a single attribute of the previously configured DMA transfer settings. This configuration approach allows ACPY3 to internally track changed transfer settings and to optimize number of register (PaRAM) writes whenever applicable. Changed settings can be tracked by maintaining a “dirty” bit for each modified field.
</p><p>The ACPY3_start function is used to submit single or linked EDMA transfers. The ACPY3_start function hides the TCC and PaRAM usage of the QDMA API and provides an easy-to-use interface without sacrificing performance.
</p>
<h3><span class="mw-headline" id="ACPY3_Interface">ACPY3 Interface</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=34" title="Edit section: ACPY3 Interface">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The ACPY3 API provides the following functions:
</p>
<table border="1">

<tbody><tr>
<td><a href="#ACPY3_activate">ACPY3_activate</a>
</td></tr>
<tr>
<td><a href="#ACPY3_complete">ACPY3_complete</a>
</td></tr>
<tr>
<td><a href="#ACPY3_completeLinked">ACPY3_completeLinked</a>
</td></tr>
<tr>
<td><a href="#ACPY3_configure">ACPY3_configure</a>
</td></tr>
<tr>
<td><a href="#ACPY3_deactivate">ACPY3_deactivate</a>
</td></tr>
<tr>
<td><a href="#ACPY3_exit">ACPY3_exit</a>
</td></tr>
<tr>
<td><a href="#ACPY3_fastConfigure16b">ACPY3_fastConfigure16b</a>
</td></tr>
<tr>
<td><a href="#ACPY3_fastConfigure32b">ACPY3_fastConfigure32b</a>
</td></tr>
<tr>
<td><a href="#ACPY3_init">ACPY3_init</a>
</td></tr>
<tr>
<td><a href="#ACPY3_setFinal">ACPY3_setFinal</a>
</td></tr>
<tr>
<td><a href="#ACPY3_start">ACPY3_start</a>
</td></tr>
<tr>
<td><a href="#ACPY3_wait">ACPY3_wait</a>
</td></tr>
<tr>
<td><a href="#ACPY3_waitLinked">ACPY3_waitLinked</a>
</td></tr></tbody></table>
<h4><span class="mw-headline" id="Logical_Channel_Configuration_Parameters">Logical Channel Configuration Parameters</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=35" title="Edit section: Logical Channel Configuration Parameters">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>Before issuing a DMA transfer, each logical channel must be configured to perform the desired DMA transfer. The ACPY3_Params structure defines the configurable properties of logical DMA channels. Each individual transfer in a Linked Transfer can be configured independently. Assigning a value to the waitId property of a transfer allows the possibility of issuing an ACPY3_waitLinked, which waits until the specified transfer is completed, but does not necessarily wait for the remaining transfers to complete.
</p><p>The ACPY3_Params structure contains the following DMA transfer parameters. These define the configuration of a logical channel.
</p>
<table border="1">

<tbody><tr>
<td>ACPY3_TransferType
</td>
<td>transferType
</td></tr>
<tr>
<td>Void *
</td>
<td>srcAddr
</td></tr>
<tr>
<td>Void *
</td>
<td>dstAddr
</td></tr>
<tr>
<td>MdUns
</td>
<td>elementSize
</td></tr>
<tr>
<td>MdUns
</td>
<td>numElements
</td></tr>
<tr>
<td>MdUns
</td>
<td>numFrames
</td></tr>
<tr>
<td>MdInt
</td>
<td>srcElementIndex
</td></tr>
<tr>
<td>MdInt
</td>
<td>dstElementIndex
</td></tr>
<tr>
<td>MdInt
</td>
<td>srcFrameIndex
</td></tr>
<tr>
<td>MdInt
</td>
<td>dstFrameIndex
</td></tr>
<tr>
<td>MdInt
</td>
<td>waitId
</td></tr></tbody></table>
<p>The following list describes these fields:
</p>
<ul><li><b></b></li></ul>
<p>ACPY3_TransferType ACPY3_Params::transferType  <b></b>
</p>
<dl><dd>1D1D, 1D2D, 2D1D or 2D2D</dd></dl>
<ul><li><b></b></li></ul>
<p>Void * ACPY3_Params::srcAddr  <b></b>
</p>
<dl><dd>Source address of the DMA transfer</dd></dl>
<ul><li><b></b></li></ul>
<p>Void * ACPY3_Params::dstAddr  <b></b>
</p>
<dl><dd>Destination address of the DMA transfer</dd></dl>
<ul><li><b></b></li></ul>
<p>MdUns ACPY3_Params::elementSize  <b></b>
</p>
<dl><dd>Number of consecutive bytes in each 1D transfer vector (ACNT)</dd></dl>
<ul><li><b></b></li></ul>
<p>MdUns ACPY3_Params::numElements  <b></b>
</p>
<dl><dd>Number of 1D vectors in 2D transfers (BCNT)</dd></dl>
<ul><li><b></b></li></ul>
<p>MdUns ACPY3_Params::numFrames <b></b>
</p>
<dl><dd>Number of 2D frames in 3D transfers (CCNT)</dd></dl>
<ul><li><b></b></li></ul>
<p>MdInt ACPY3_Params::srcElementIndex  <b></b>
</p>
<dl><dd>Offset in number of bytes from beginning of each 1D vector to the beginning of the next 1D vector. (SBIDX)</dd></dl>
<ul><li><b></b></li></ul>
<p>MdInt ACPY3_Params::dstElementIndex  <b></b>
</p>
<dl><dd>Offset in number of bytes from beginning of each 1D vector to the beginning of the next 1D vector. (DBIDX)</dd></dl>
<ul><li><b></b></li></ul>
<p>MdInt ACPY3_Params::srcFrameIndex  <b></b>
</p>
<dl><dd>Offset in number of bytes from beginning of 1D vector of current (source) frame to the beginning of next frame's first 1D vector. (SCIDX) Signed value between -32768 and 32767.</dd></dl>
<ul><li><b></b></li></ul>
<p>MdInt ACPY3_Params::dstFrameIndex  <b></b>
</p>
<dl><dd>Offset in number of bytes from beginning of 1D vector of current (destination) frame to the beginning of next frame's first 1D vector. (DCIDX) Signed value between -32768 and 32767.</dd></dl>
<ul><li><b></b></li></ul>
<p>MdInt ACPY3_Params::waitId  <b></b>
</p>
<dl><dd>For a single transfer entry, this field is ignored. It is set to 0 (numWaits – 1) internally to track the particular transfer.</dd>
<dd>For a linked transfer entry:
<ul><li>waitId = -1&#160;: No individual wait on this transfer.</li>
<li>0 &lt; waitId &lt; numWaits&#160;: This transfer can be waited on or polled for completion.</li>
<li>For the last transfer, this field is ignored. It is internally tracked with a waitId of numWaits – 1.</li></ul></dd></dl>
<h4><span class="mw-headline" id="ACPY3_configure">ACPY3_configure</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=36" title="Edit section: ACPY3 configure">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This function configures all DMA transfer settings for the logical channel. ACPY3_configure must be called at least once for each individual transfer in a logical channel prior to starting the DMA transfer using ACPY3_start. The syntax is:
</p>
<pre>Void ACPY3_configure(
  IDMA3_Handle   handle,
  ACPY3_Params  *params,
  MdInt          transferNo
);
</pre>
<p><b>Parameters:</b> The parameters are all input values. The following list describes each one:
</p>
<table border="1">

<tbody><tr>
<td>handle
</td>
<td>IDMA3 channel handle.
</td></tr>
<tr>
<td>params
</td>
<td>DMA transfer-specific parameters used to configure this logical DMA channel.
</td></tr>
<tr>
<td>transferNo
</td>
<td>Indicates the individual transfer to be configured using the passed “params”.
</td></tr></tbody></table>
<p><b>Return Value:</b> None
</p><p><b>Preconditions:</b>
</p>
<ul><li>The channel must be in an active state.</li>
<li>The params-&gt;waitId must not be numWaits - 0 unless you are configuring the last transfer.</li>
<li>The IDMA_Obj handle must be valid.</li>
<li>The handle-&gt;protocol field must be set to &amp;ACPY3_PROTOCOL.</li>
<li>0 &lt;= transferNo &lt; originally requested number of transfers.</li></ul>
<h4><span class="mw-headline" id="ACPY3_fastConfigure16b">ACPY3_fastConfigure16b</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=37" title="Edit section: ACPY3 fastConfigure16b">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This is a fast configuration function for modifying existing channel settings. Exactly one 16-bit channel transfer property, corresponding to the specified ACPY3_Param field, can be modified. The remaining settings of the channel configuration are unchanged. The syntax is:
</p>
<pre>Void ACPY3_fastConfigure16b(
 IDMA3_Handle         handle,
 ACPY3_ParamField16b  fieldId,
 MdUns                value,
 MdInt                transferNo
);
</pre>
<p><b>Parameters:</b> The parameters are all input values. The following list describes each one:
</p>
<table border="1">

<tbody><tr>
<td>handle
</td>
<td>IDMA3 channel handle.
</td></tr>
<tr>
<td>fieldId
</td>
<td>Indicates which parameter is to be modified.
</td></tr>
<tr>
<td>value
</td>
<td>New value of the parameter to be modified.
</td></tr>
<tr valign="top">
<td>transferNo
</td>
<td>Indicates which transfer the parameters correspond to. (This is the same value that would be passed to the ACPY3_configure() logical DMA handle and environment (env, envSize) fields.
</td></tr></tbody></table>
<p><b>Enumerated Types:</b> The following enumerated type is defined for use by the ACPY3 API:
</p><p><b>enum ACPY3_ParamField16b</b>
</p>
<table border="1">

<tbody><tr>
<th>Constant
</th>
<th>Value
</th></tr>
<tr>
<td>ACPY3_PARAMFIELD_ELEMENTSIZE
</td>
<td>8
</td></tr>
<tr>
<td>ACPY3_PARAMFIELD_NUMELEMENTS
</td>
<td>10
</td></tr>
<tr>
<td>ACPY3_PARAMFIELD_ELEMENTINDEX_SRC
</td>
<td>16
</td></tr>
<tr>
<td>ACPY3_PARAMFIELD_ELEMENTINDEX_DST
</td>
<td>18
</td></tr>
<tr>
<td>ACPY3_PARAMFIELD_FRAMEINDEX_SRC
</td>
<td>24
</td></tr>
<tr>
<td>ACPY3_PARAMFIELD_FRAMEINDEX_DST
</td>
<td>26
</td></tr>
<tr>
<td>ACPY3_PARAMFIELD_NUMFRAMES
</td>
<td>28
</td></tr></tbody></table>
<p><b>Return Value:</b> None
</p><p><b>Precondition:</b>
</p>
<ul><li>The IDMA3_Handle must be valid.</li>
<li>The algorithm instance must be in an "active" state using the IALG interface.</li>
<li>The channel must have first been configured with ACPY3_configure.</li>
<li>The channel must be in an “active” state.</li></ul>
<h4><span class="mw-headline" id="ACPY3_fastConfigure32b">ACPY3_fastConfigure32b</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=38" title="Edit section: ACPY3 fastConfigure32b">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This is a fast configuration function for modifying existing channel settings. Exactly one 32-bit channel transfer property, corresponding to the specified ACPY3_Param field, can be modified. The remaining settings of the channel configuration are unchanged.
</p><p>Once a channel has been configured once with ACPY3_configure(), ACPY3_fastConfigure32b() can be used to update any of the 32-bit parameter fields, for example, the source address of the data to be transferred.
</p><p>The syntax is:
</p>
<pre>Void ACPY3_fastConfigure32b(
 IDMA3_Handle         handle,
 ACPY3_ParamField32b  fieldId,
 Uns                  value,
 MdInt                transferNo
);
</pre>
<p><b>Parameters:</b> The parameters are all input values. The following list describes each one:
</p>
<table border="1">

<tbody><tr>
<td>handle
</td>
<td>IDMA3 channel handle.
</td></tr>
<tr>
<td>fieldId
</td>
<td>Indicates which of the parameters is to be modified.
</td></tr>
<tr>
<td>value
</td>
<td>New value of the parameter to be modified.
</td></tr>
<tr valign="top">
<td>transferNo
</td>
<td>Indicates which transfer the parameters correspond to (the same value that would be passed to the ACPY3_configure()). Logical DMA handle and environment (env, envSize) fields.
</td></tr></tbody></table>
<p><b>Enumerated Types:</b>
</p><p>The following enumerated type is defined for use by the ACPY3 API: <b>enum ACPY3_ParamField32b</b>
</p>
<table border="1">

<tbody><tr>
<th>Constant
</th>
<th>Value
</th></tr>
<tr>
<td>ACPY3_PARAMFIELD_SRCADDR
</td>
<td>4
</td></tr>
<tr>
<td>ACPY3_PARAMFIELD_DSTADDR
</td>
<td>12
</td></tr>
<tr>
<td>ACPY3_PARAMFIELD_ELEMENTINDEXES
</td>
<td>16
</td></tr>
<tr>
<td>ACPY3_PARAMFIELD_FRAMEINDEXES
</td>
<td>24
</td></tr></tbody></table>
<p><b>Return Value:</b> None
</p><p><b>Preconditions:</b>
</p>
<ul><li>The IDMA3_Handle must be valid.</li>
<li>The algorithm instance must be in an "active" state using the IALG interface.</li>
<li>The channel must be in an “active” state.</li></ul>
<h4><span class="mw-headline" id="ACPY3_start">ACPY3_start</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=39" title="Edit section: ACPY3 start">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This function is called to submit a single or linked DMA transfer. The properties of each individual transfer are the most recent configuration setting for that transfer. The syntax is:
</p>
<pre>Void ACPY3_start(IDMA3_Handle handle);
</pre>
<p><b>Parameters:</b> The parameter is an input value. The following list describes it:
</p>
<table>

<tbody><tr>
<td>handle
</td>
<td>IDMA3 channel handle.
</td></tr></tbody></table>
<p><b>Return Value:</b> None
</p><p><b>Preconditions:</b>
</p>
<ul><li>The IDMA3_Handle must be valid.</li>
<li>The channel must be in an “active” state.</li>
<li>The channel must be in a “configured” state.</li>
<li>handle-&gt;transferPending must be FALSE.</li></ul>
<p><b>Postcondition:</b>
</p>
<ul><li>handle-&gt;transferPending is TRUE.</li></ul>
<h4><span class="mw-headline" id="ACPY3_wait">ACPY3_wait</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=40" title="Edit section: ACPY3 wait">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The ACPY3_wait function performs a polling wait operation, waiting for the completion of all DMA transfers issued by the most recent ACPY3_start operation on the given channel handle. ACPY3_wait() uses waitId “numWaits -1” to wait for the completion of all transfers. Therefore, this waitId should not be used to configure any intermediate transfers. This function does not return until all the data transfers on the given channel have completed.
</p><p>The syntax is:
</p>
<pre>Void ACPY3_wait(IDMA3_Handle handle);
</pre>
<p><b>Parameters:</b> The parameter is an input value. The following list describes it: handle IDMA3 channel handle.
</p><p><b>Return Value:</b> None
</p><p><b>Preconditions:</b>
</p>
<ul><li>The IDMA3_Handle must be valid.</li>
<li>The channel must be in an “active” state.</li></ul>
<p><b>Postcondition:</b>
</p>
<ul><li>handle-&gt;transferPending is FALSE</li></ul>
<h4><span class="mw-headline" id="ACPY3_waitLinked">ACPY3_waitLinked</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=41" title="Edit section: ACPY3 waitLinked">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>ACPY3_wait function performs a polling wait operation, waiting for the completion of an individual DMA transfer issued by the most recent ACPY3_start operation on the given channel handle. The transfer that gets waited on is the individual transfer that was configured with the associated waitId. This function does not return until the data transfer that was configured with “waited” has completed.
</p><p>The syntax is:
</p>
<pre>Void ACPY3_waitLinked(
 IDMA3_Handle   handle,
 MdUns          waitId
);
</pre>
<p><b>Parameters:</b> The parameters are all input values. The following list describes each one:
</p>
<table border="1">

<tbody><tr>
<td>handle
</td>
<td>IDMA3 channel handle.
</td></tr>
<tr valign="top">
<td>waitId
</td>
<td>The waitId for the transfer to wait on. This was passed in ACPY3_Params to ACPY3_configure().
</td></tr></tbody></table>
<p><b>Return Value:</b> None
</p><p><b>Preconditions:</b>
</p>
<ul><li>The IDMA3_Handle must be valid.</li>
<li>The channel must be in an “active” state.</li>
<li>0 &lt;= waitId &lt; the originally requested number of waitIds</li>
<li>The channel must contain one transfer T, which is the i-th transfer, such that i &lt; handle-&gt;numPaRams and T is configured with the given waitId.</li></ul>
<h4><span class="mw-headline" id="ACPY3_complete">ACPY3_complete</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=42" title="Edit section: ACPY3 complete">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>ACPY3_complete is the non-blocking counterpart of the ACPY3_wait function. It returns true or false depending on whether all transfers have been completed or not, respectively. The online reference API documentation contain more information. The syntax is:
</p>
<pre>Bool ACPY3_complete(IDMA3_Handle handle);
</pre>
<p>Parameters: The parameter is an input value. The following list describes it:
</p>
<table border="1">

<tbody><tr>
<td>handle
</td>
<td>IDMA3 channel handle.
</td></tr></tbody></table>
<p><b>Return Value:</b> TRUE or FALSE
</p><p><b>Preconditions:</b>
</p>
<ul><li>The IDMA3_Handle must be valid.</li>
<li>The channel must be in an “active” state.</li></ul>
<h4><span class="mw-headline" id="ACPY3_completeLinked">ACPY3_completeLinked</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=43" title="Edit section: ACPY3 completeLinked">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>ACPY3_complete is the non-blocking counterpart of the ACPY3_waitLinked function. It returns true or false depending on whether the individual transfer associated with the waitId has been completed or not, respectively. The online reference API documentation contain more information. The syntax is:
</p>
<pre>int ACPY3_completeLinked(IDMA3_Handle handle, MdUns waitId);
</pre>
<p><b>Parameters:</b> The parameters are all input values. The following list describes each one:
</p>
<table border="1">

<tbody><tr>
<td>handle
</td>
<td>IDMA3 channel handle.
</td></tr>
<tr valign="top">
<td>waitId
</td>
<td>The waitId to check for completion. This was passed in ACPY3_Params to ACPY3_configure().
</td></tr></tbody></table>
<p><b>Return Value:</b> TRUE or FALSE
</p><p><b>Preconditions:</b>
</p>
<ul><li>The IDMA3_Handle must be valid.</li>
<li>The channel must be in an “active” state.</li>
<li>0 &lt;= waitId &lt; the originally requested number of waitIds</li></ul>
<h4><span class="mw-headline" id="ACPY3_activate">ACPY3_activate</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=44" title="Edit section: ACPY3 activate">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>ACPY3_activate activates the specified channel. It must be called once before submitting DMA transfers on any IDMA3 channel. The executing task remains the active user of all shared scratch resources, and thus should not be pre-empted by any other task that uses DMA resources created using the same Group ID.
</p>
<pre>Void ACPY3_activate(IDMA3_Handle handle);
</pre>
<p><b>Parameters:</b> The parameter is an input value. The following list describes it:
</p>
<table border="1">

<tbody><tr>
<td>handle
</td>
<td>IDMA3 channel handle.
</td></tr></tbody></table>
<p><b>Return Value:</b> None
</p><p><b>Precondition:</b>
</p>
<ul><li>The IDMA3_Handle must be valid.</li>
<li>The algorithm instance must be in an "active" state using the IALG interface.</li></ul>
<p><b>Postconditions:</b>
</p>
<ul><li>The channel is in an “active” state; any ACPY3 functions can be called using this handle.</li>
<li>The handle-&gt;transferPending is FALSE.</li></ul>
<h4><span class="mw-headline" id="ACPY3_deactivate">ACPY3_deactivate</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=45" title="Edit section: ACPY3 deactivate">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>ACPY3_deactivate is called to deactivate a channel when a task is ready to relinquish ownership of the shared scratch resources.
</p>
<pre>Void ACPY3_deactivate(IDMA3_Handle handle);
</pre>
<p><b>Parameters:</b> The parameter is an input value. The following list describes it:
</p>
<table border="1">

<tbody><tr>
<td>handle
</td>
<td>IDMA3 channel handle.
</td></tr></tbody></table>
<p><b>Return Value:</b> None
</p><p><b>Preconditions:</b>
</p>
<ul><li>The IDMA3_Handle must be valid.</li>
<li>The algorithm instance must be in an "active" state using the IALG interface.</li>
<li>The channel must be in an “active” state.</li></ul>
<p><b>Postcondition:</b>
</p>
<ul><li>The channel is in a “deactivated” state.</li></ul>
<h4><span class="mw-headline" id="ACPY3_init">ACPY3_init</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=46" title="Edit section: ACPY3 init">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This is the ACPY3 module initialization function.
</p>
<pre>Void ACPY3_init(Void);
</pre>
<p><b>Parameters:</b> None
</p><p><b>Return Value:</b> None
</p>
<h4><span class="mw-headline" id="ACPY3_exit">ACPY3_exit</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=47" title="Edit section: ACPY3 exit">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This is the ACPY3 module finalization function.
</p>
<pre>Void ACPY3_exit(Void);
</pre>
<p><b>Parameters:</b> None
</p><p><b>Return Value:</b> None
</p>
<h4><span class="mw-headline" id="ACPY3_setFinal">ACPY3_setFinal</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=48" title="Edit section: ACPY3 setFinal">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This function indicates that a given transfer is the last in a sequence of linked transfers. This function can be used to dynamically change the number of transfers in a series of linked transfers. Any waitId previously associated with the transfer "transferNo" is replaced with the waitId “numWaits – 1” since ACPY3_wait() uses this waitId to check for transfer completion.
</p><p>This function can be used if a channel was created to transfer numTransfers linked transfers, but at some point, it may be that fewer transfers than numTransfers should be started.
</p>
<pre>Void ACPY3_setFinal(
 IDMA3_Handle  handle,
 MdInt         transferNo
);
</pre>
<p><b>Parameters:</b> The parameters are all input values. The following list describes each one:
</p>
<table border="1">

<tbody><tr>
<td>handle
</td>
<td>IDMA3 channel handle.
</td></tr>
<tr valign="top">
<td>transferNo
</td>
<td>Indicates which transfer will be the last in a set of linked transfers. (This is the same value that was passed to ACPY3_configure().)
</td></tr></tbody></table>
<p><b>Return Value:</b> None
</p><p><b>Preconditions:</b>
</p>
<ul><li>The IDMA3_Handle must be valid.</li>
<li>The channel must be in an “active” state.</li></ul>
<p><b>Postcondition:</b>
</p>
<ul><li>The transferNo's waitId is set to “numWaits – 1”.</li>
<li>Any previously associated waitId with the old "final" transfer is cleared. As a consequence, applications may need to call ACPY3_configure() to restore the appropriate waited.</li></ul>
<h2><span class="mw-headline" id="Cache_Coherency_Issues_for_Algorithm_Consumers">Cache Coherency Issues for Algorithm Consumers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=49" title="Edit section: Cache Coherency Issues for Algorithm Consumers">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>On several C6x1x devices, data that is in both external memory and the L2 cache can cause problems with DMA transfers in several ways.
</p><p>In Figure 6, memory corresponding to location x has been brought into the L2 cache. The copy in the cache has been modified, but has not yet been written back to external memory. If a DMA transfer copies the data from location x to another location, it would be reading stale data. To avoid this problem, the cache must be flushed before the DMA read proceeds.
</p>
<div style="text-align: center;">
<p><a href="../File_Coherency_read.html" class="image" title="DMA Read Access Coherency Problem"><img alt="DMA Read Access Coherency Problem" src="https://processors.wiki.ti.com/images/6/63/Coherency_read.png" width="571" height="91" /></a><br /><b>Figure 6. DMA Read Access Coherency Problem</b>
</p>
</div>
<p>In Figure 7, the location x has been brought into the L2 cache. Suppose a DMA transfer writes new data to location x in external memory. In this case, the CPU would access the old cached data in a subsequent read, unless the cached copy is invalidated.
</p>
<div style="text-align: center;">
<p><a href="../File_Coherency_write.html" class="image" title="DMA Write Access Coherency Problem"><img alt="DMA Write Access Coherency Problem" src="https://processors.wiki.ti.com/images/7/7a/Coherency_write.png" width="571" height="97" /></a><br /><b>Figure 6. DMA Write Access Coherency Problem</b>
</p>
</div>
<p>To deal with these coherency problems, several new guidelines and rules have been added to the TMS320 DSP Algorithm Standard. Previously, the xDAIS rules and guidelines for using DMA applied only to algorithms. In Version 2.5 of the TMS320 DSP Algorithm Standard Developer's Kit, the following new guidelines and rules have been added that apply to client applications.
</p><p><br />
</p>
<hr />
<dl><dd><b>DMA Guideline 3</b></dd></dl>
<dl><dd>To ensure correctness, all C6000 algorithms using IDMA2 or IDMA3 need to be supplied with the internal memory they request from the client.</dd></dl>
<hr />
<p>This guideline has been added in conjunction with a new requirement in the xDAIS specification that the client application must inform the algorithm of the type of memory (for example, internal or external) used by each buffer it allocates to the algorithm. The client application does this via the IALG_MemRec structure passed to the algorithm using algInit(). The algorithm can use this information to decide how to respond if it does not receive the type of memory it requests.
</p>
<hr />
<dl><dd><b>DMA Rule 7</b></dd>
<dd></dd>
<dd>If a C6000 algorithm has implemented the IDMA2 or IDMA3 interface, all input and output buffers residing in external memory, and passed to this algorithm through its function calls, should be allocated on a cache line boundary and be a multiple of caches lines in size. The application must also clean the cache entries for these buffers before passing them to the algorithm. (This rule applies to client applications.)</dd></dl>
<hr />
<p>This rule is targeted at the application or client application writer. It ensures that cached entries for buffers passed to the algorithm are flushed to avoid the coherency problem shown in Figure 7. For example, the fastcopytest.c example described in the SPRA789 application note uses the following CSL macro to clean the cache before initializing the data arrays and before performing an algorithm that uses DMA transfers.
</p>
<pre>CACHE_clean(. . .);
</pre>
<p>It is important that input and output buffers be allocated on a cache line boundary and be a multiple of the cache line length in size. As shown in Figure 8, if location x is accessed by the DMA but other data (v) shares the same cache line, the entire cache line may be brought into the cache when v is accessed. Location x would then end up in the cache, which violates the reason behind DMA Rule 6.
</p>
<div style="text-align: center;">
<p><a href="../File_Cache_boundaries.html" class="image" title="Cache Line Boundaries and the L2 Cache"><img alt="Cache Line Boundaries and the L2 Cache" src="https://processors.wiki.ti.com/images/9/9c/Cache_boundaries.png" width="571" height="146" /></a><br /><b>Figure 8. Cache Line Boundaries and the L2 Cache</b>
</p>
</div>
<h2><span class="mw-headline" id="For_Algorithm_Producers:_Creating_Algorithms_that_Use_DMA">For Algorithm Producers: Creating Algorithms that Use DMA</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=50" title="Edit section: For Algorithm Producers: Creating Algorithms that Use DMA">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>This section is intended for developers of xDAIS-compliant algorithms that use DMA. After a brief summary and references for the changes introduced by the IDMA3 and ACPY3 requirements, we discuss how algorithm producers do the following:
</p>
<ul><li>Implement the required interfaces to request and receive DMA resources</li>
<li>Configure DMA channels</li>
<li>Schedule DMA transfers</li>
<li>Synchronize with completion status of scheduled transfers</li></ul>
<h3><span class="mw-headline" id="IDMA3_and_ACPY3_Related_Changes_that_affect_the_Algorithm_Developers">IDMA3 and ACPY3 Related Changes that affect the Algorithm Developers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=51" title="Edit section: IDMA3 and ACPY3 Related Changes that affect the Algorithm Developers">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Algorithm producers should be aware of a number of changes to the ways they need to develop algorithms that use DMA. These new C6000 DMA guidelines apply to both IDMA2 and IDMA3.
</p>
<ul><li><b>IDMA3 interface.</b> All ‘C64x algorithms that intend to run on ‘C64x+ DSP core devices that require DMA resources must implement the IDMA3 interface. Non-‘C64x+ algorithms may continue to use IDMA2.</li>
<li><b>Configuring channels.</b> Algorithms should optimize DMA transfers by configuring each channel a single time. Optimized fast configuration functions for configuring channels have been added to the ACPY3 interface.</li>
<li><b>Scratch Group ID.</b> All physical EDMA3 resources that are granted to different processing threads using the same DMAN3 scratch groupId are <i>potentially</i> shared. Such processing threads must not pre-empt each other since the underlying physical resource allocations may be shared.</li>
<li><b>Scheduling.</b> The ACPY3_start() function is used to schedule a transfer. This function takes a single channel handle argument. This is a change from the deprecated ACPY2_start function.</li>
<li><b>Synchronization.</b> All linked transfers issued on the same channel start and complete in the same order they were issued. It is possible to wait for all transfers or just an individual transfer in the link chain associated with the configured waitIds.</li>
<li><b>Cache coherency.</b> Data that is stored in both external memory and the L2 cache can cause problems with DMA transfers in several ways.</li></ul>
<h3><span class="mw-headline" id="Rules_and_Guidelines_Summary">Rules and Guidelines Summary</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=52" title="Edit section: Rules and Guidelines Summary">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The TMS320 DSP Algorithm Standard specifies the following rules and guidelines for all C6000 algorithms that request and use DMA resources and for applications that integrate such algorithms. All algorithms designed for ‘C64x+ EDMA3 controller must implement the IDMA3 interface.
</p>
<ul><li><b>DMA Rule 1.</b> All data transfer must be completed before return to caller.</li>
<li><b>DMA Rule 2.</b> All algorithms using the DMA resource must implement the IDMA2 or IDMA3 interface.</li>
<li><b>DMA Rule 3.</b> Each of the IDMA2 or IDMA3 methods implemented by an algorithm must be independently relocatable.</li>
<li><b>DMA Rule 4.</b> [DEPRECATED] All algorithms must state the maximum number of concurrent DMA transfers for each logical channel.</li>
<li><b>DMA Rule 5.</b> All algorithms must characterize the average and maximum size of the data transfers per logical channel for each operation. Also, all algorithms must characterize the average and maximum frequency of data transfers per logical channel for each operation.</li>
<li><b>DMA Rule 6.</b> An algorithm using IDMA2 or IDMA3 must not directly access buffers in external memory involved in DMA transfers. This includes the input buffers passed to the algorithm through its function interface.</li>
<li><b>DMA Rule 7.</b> If an algorithm has implemented the IDMA2 or IDMA3 interface, all input and output buffers residing in external memory and passed to this algorithm through its function calls should be allocated on a cache line boundary and be a multiple of caches lines in size. The application must also clean the cache entries for these buffers before passing them to the algorithm. (Applies to client applications.)</li>
<li><b>DMA Rule 8.</b> All buffers residing in external memory involved in a DMA transfer should be allocated on a cache line boundary and be a multiple of cache lines in size.</li>
<li><b>DMA Rule 9.</b> Algorithms should not use stack allocated buffers as source or destination of any DMA transfer.</li>
<li><b>DMA Guideline 1.</b> The data transfer should complete before the CPU operations executing in parallel.</li>
<li><b>DMA Guideline 2.</b> Algorithms should request a distinct IDMA2 or IDMA3 logical channel for distinct type of DMA transfer it issues.</li>
<li><b>DMA Guideline 3.</b> To ensure correctness, all algorithms using IDMA2 or IDMA3 need to be supplied with the internal memory they request from the client application using algAlloc(). (Applies to client applications.)</li></ul>
<h3><span class="mw-headline" id="Implementing_the_IDMA3_Interface">Implementing the IDMA3 Interface</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=53" title="Edit section: Implementing the IDMA3 Interface">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>A ‘C64x+ algorithm that requests DMA resources must implement the IDMA3 interface. The FCPY_TI algorithm discussed in this application note provides an example implementation of the IDMA3 interface. The following list describes each function that must be implemented and shows an example.
</p>
<dl><dt><ul><li>dmaChangeChannels.</li></ul></dt>
<dd>This function should update the algorithm instance object's persistent memory using the channel descriptors table.</dd></dl>
<p>&lt;syntaxhighlight lang="c"&gt;
</p>
<pre>/*
 *  ======== FCPY_TI_dmaChangeChannels ========
 *  Update instance object with new logical channel.
 */
</pre>
<pre>Void FCPY_TI_dmaChangeChannels(IALG_Handle handle, IDMA3_ChannelRec dmaTab[])
{
   FCPY_TI_Obj *fcpy = (Void *)handle;
   fcpy-&gt;dmaHandle1D1D8B = dmaTab[CHANNEL0].handle;
   fcpy-&gt;dmaHandle1D2D8B = dmaTab[CHANNEL1].handle;
   fcpy-&gt;dmaHandle2D1D8B = dmaTab[CHANNEL2].handle;
}&lt;/syntaxhighlight&gt;
</pre>
<dl><dt><ul><li>dmaGetChannels.</li></ul></dt>
<dd>This function should fill the channel descriptors table (passed by the client application) with the channel characteristics for each logical channel required by the algorithm.</dd></dl>
<p>&lt;syntaxhighlight lang="c"&gt;
</p>
<pre>/*
 *  ======== FCPY_TI_dmaGetChannels ========
 *  Declare DMA resource requirement/holdings.
 */
Int FCPY_TI_dmaGetChannels(IALG_Handle handle, IDMA3_ChannelRec dmaTab[])
{
   FCPY_TI_Obj *fcpy = (Void *)handle;
   int i;
</pre>
<pre>   /* Initial values on logical channels */
   dmaTab[0].handle = fcpy-&gt;dmaHandle1D1D8B;
   dmaTab[1].handle = fcpy-&gt;dmaHandle1D2D8B;
   dmaTab[2].handle = fcpy-&gt;dmaHandle2D1D8B;
</pre>
<pre>   /*   */
   dmaTab[0].numTransfers = 1;
   dmaTab[0].numWaits = 1;
</pre>
<pre>   dmaTab[1].numTransfers = 1;
   dmaTab[1].numWaits = 1;
</pre>
<pre>   dmaTab[2].numTransfers = 1;
   dmaTab[2].numWaits = 1;
</pre>
<pre>   /*
    * Request logical DMA channels for use with ACPY3
    * AND with environment size obtained from ACPY3 implementation
    * AND with low priority.
    */
   for (i=0; i&lt;NUM_LOGICAL_CH; i++) {
       dmaTab[i].priority = IDMA3_PRIORITY_LOW;
       dmaTab[i].protocol = &amp;ACPY3_PROTOCOL;
       dmaTab[i].persistent = FALSE;    }
</pre>
<pre>   return (NUM_LOGICAL_CH);
}&lt;/syntaxhighlight&gt;
</pre>
<dl><dt><ul><li>dmaGetChannelCnt.</li></ul></dt>
<dd>This function should return the number of channels requested by the dmaGetChannels() function.</dd></dl>
<p>&lt;syntaxhighlight lang="c"&gt;
</p>
<pre>#define NUM_LOGICAL_CH 3
</pre>
<pre>/*
 *  ======== FCPY_TI_dmaGetChannelCnt ========
 *  Return max number of logical channels requested.
 */
Int FCPY_TI_dmaGetChannelCnt(Void)
{
    return(NUM_LOGICAL_CH);
}
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<dl><dt><ul><li>dmaInit.</li></ul></dt>
<dd>This function should save the handles for the logical channels granted by the framework in the algorithm instance object's persistent memory.</dd></dl>
<p>&lt;syntaxhighlight lang="c"&gt;
</p>
<pre>/*
 *  ======== FCPY_TI_dmaInit========
 *  Initialize instance object with granted logical channel.
 */
Int FCPY_TI_dmaInit(IALG_Handle handle, IDMA3_ChannelRec dmaTab[])
{
    FCPY_TI_Obj *fcpy = (Void *)handle;
</pre>
<pre>    fcpy-&gt;dmaHandle1D1D8B = dmaTab[CHANNEL0].handle;
    fcpy-&gt;dmaHandle1D2D8B = dmaTab[CHANNEL1].handle;
    fcpy-&gt;dmaHandle2D1D8B = dmaTab[CHANNEL2].handle;
</pre>
<pre>    return (IALG_EOK);
}
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="Configuring_Logical_Channels_and_DMA_Transfers">Configuring Logical Channels and DMA Transfers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=54" title="Edit section: Configuring Logical Channels and DMA Transfers">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>For every logical DMA channel, before any DMA transfer requests can be submitted to the channel, the algorithm must configure the channel’s transfer parameters. Each configurable property characterizes the layout of each DMA transfer block as depicted in Figure 2 (page 10) and corresponds to one of the fields of the ACPY3_Params structure in Table 7 (page 6).
</p><p>Logical channels always "remember" the most recently applied configuration settings, so additional reconfiguration is unnecessary unless a different type of transfer setting is needed. When a transfer request is submitted, the current channel transfer parameters are recorded and applied when the memory transfer is carried out.
</p><p>There are several ACPY3 functions to configure the transfer parameters of the logical channel for the type of DMA transfer:
</p>
<ul><li><b>Configure-all function:</b> ACPY3_configure. It takes an ACPY3_Params argument, and replaces the entire channel settings with the new configuration.</li>
<li><b>Fast configuration functions:</b> ACPY3_fastConfigure16b and ACPY3_fastConfigure32b. Each function selectively updates exactly one parameter of the current configuration.</li></ul>
<h4><span class="mw-headline" id="Performance_Considerations">Performance Considerations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=55" title="Edit section: Performance Considerations">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>For algorithms that rely heavily on the speed of completion of DMA transfers, minimizing the configuration overhead is extremely critical. Indeed, the addition of new fast configuration functions, the change to the transfer request submission function, <code>ACPY3_start()</code>, and the new DMA Guideline 2 all result from performance requirements that were not adequately addressed by the deprecated ACPY specifications.
</p><p>If a logical channel is configured at the same time a DMA transfer request is submitted, the function incurs a substantial amount of overhead. A straightforward optimization technique is to break the work into two parts: one for channel configuration and the other for transfer request submission. Therein lies the motivation for one of the new guidelines:
</p><p><br />
</p>
<hr />
<dl><dd><b>DMA Guideline 2</b></dd>
<dd>Algorithms should minimize channel (re)configuration overhead by requesting a dedicated logical DMA channel for each distinct type of DMA transfer it issues, and should avoid calling <code>ACPY3_configure()</code>. Algorithms should use the fast configuration functions where possible.</dd></dl>
<hr />
<p><br /> DMA Guideline 2 is a useful guideline to follow when different types of DMA transfers are needed in a critical loop of an algorithm. By defining different IDMA3 logical channels for each transfer type, <code>ACPY3_configure()</code> can be called on each channel at the beginning of the algorithm code. Then, transfer requests can be rapidly submitted on these pre-configured channels in the critical loop using <code>ACPY3_start()</code> calls, eliminating re-configuration overhead.
</p><p>By following DMA Guideline 2, the algorithm code can be structured as follows to minimize channel configuration overhead:
</p><p>&lt;syntaxhighlight lang="c"&gt;
Void MYALG_TI_process(...) {
</p>
<pre>   /* Configure the logical channels */
   ACPY3_configure(dma1D1D8bit_handle,  &amp;params1, transferId);
   ACPY3_configure(dma2D2D32bit_handle, &amp;params2, transferId);
   ACPY3_configure(dma1D1D16bit_handle, &amp;params2, transferId);
   ...
</pre>
<pre>   /* Critical loop in the algorithm */
   for (...) {
       ...
       ACPY3_start(dma1D1D8bit_handle); /* channel is configured once */
       ...
   }
   ...
</pre>
<p>}&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="Scheduling_Asynchronous_DMA_Transfers_on_Logical_Channels">Scheduling Asynchronous DMA Transfers on Logical Channels</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=56" title="Edit section: Scheduling Asynchronous DMA Transfers on Logical Channels">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Algorithms call the ACPY3_start function to submit a request for an asynchronous transfer of a memory block copy from the specified source to the destination memory block. The source and destination addresses need to be properly aligned with respect to the configured element size. ACPY3_start returns to the caller (the algorithm) as soon as the transfer request is submitted to a logical or physical hardware queue or devices that will asynchronously perform the copy operation. The exact source and destination memory layout that gets physically copied is determined by the transfer parameters at the time the ACPY3_start call has been issued.
</p>
<h4><span class="mw-headline" id="Alignment_Issues_Using_ACPY3_start">Alignment Issues Using ACPY3_start</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=57" title="Edit section: Alignment Issues Using ACPY3 start">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>ACPY3_start places no restriction on address alignment.
</p>
<h3><span class="mw-headline" id="Synchronizing_and_Serializing_DMA_Transfers">Synchronizing and Serializing DMA Transfers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=58" title="Edit section: Synchronizing and Serializing DMA Transfers">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>An algorithm can submit several transfer requests on each logical channel it owns. Actual physical DMA transfers are started and completed by the hardware resources available to the ACPY3 module.
</p><p>When an algorithm needs to check the completion status of submitted transfers, it can call a blocking "wait" function, ACPY3_wait(), or a non-blocking "completion status" check function, ACPY3_complete(). The wait or completion status is for the entire channel. That is, the status returned is for the last submitted transfer on that logical channel.
</p><p>ACPY3 specifications ensure that all transfers issued on the same channel start and complete in the same real-time order as they were issued. The need for synchronizing DMA transfers can be reduced because of these new requirements. This provides additional opportunities to optimize algorithms that use DMA resources.
</p>
<h3><span class="mw-headline" id="Cache_Coherency_Issues_for_Algorithm_Producers">Cache Coherency Issues for Algorithm Producers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=59" title="Edit section: Cache Coherency Issues for Algorithm Producers">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Algorithms must enforce coherence and alignment/size constraints for internal buffers they request through the IALG interface. In the section <a href="#Cache_Coherency_Issues_for_Algorithm_Consumers">Cache Coherency Issues for Algorithm Consumers</a>, the figures show problems that can occur if coherency between the cache and the external memory are not observed.
</p><p>To deal with these coherency problems, the following new rules have been added:
</p>
<hr />
<dl><dd><b>DMA Rule 6</b></dd>
<dd></dd>
<dd>C6000 algorithms using IDMA2 or IDMA3 must not directly access buffers in external memory involved in DMA transfers. This includes the input buffers passed to the algorithm through its function interface.</dd></dl>
<hr />
<p>DMA Rule 6 ensures that xDAIS algorithms operate correctly without the need to issue cache clean and flush operations, which are low-level operations that should be dealt with at the client application level. With the introduction of DMA Rule 6, no external buffers involved in DMA transfers end up in the L2 cache, therefore no external coherency problems should occur.
</p><p>Also remember that the DMA Rule 7, which is targeted at the client application writer, ensures that cached entries for buffers passed into the algorithm are flushed to avoid the coherency problem shown in Figure 7.
</p><p>It is important that these buffers are allocated on a cache line boundary and are a multiple of caches lines in size. As shown in Figure 9, if for some location x that is accessed by the DMA, there is other data v sharing the same cache line, the entire cache line may be brought into the cache when v is accessed. Location x would then end up in the cache, which violates the purpose of DMA Rule 6.
</p>
<div style="text-align: center;">
<p><a href="../File_Cache_boundaries.html" class="image" title="Cache Line Boundaries and the L2 Cache"><img alt="Cache Line Boundaries and the L2 Cache" src="https://processors.wiki.ti.com/images/9/9c/Cache_boundaries.png" width="571" height="146" /></a><br /><b>Figure 9. Cache Line Boundaries and the L2 Cache</b>
</p>
</div>
<hr />
<dl><dd><b>DMA Rule 8</b></dd>
<dd></dd>
<dd>For C6000 algorithms, all buffers residing in external memory involved in a DMA transfer should be allocated on a cache line boundary and be a multiple of cache lines in size.</dd></dl>
<hr />
<p>DMA Rule 8 is added for algorithm writers who divide buffers supplied to them through their function interface into smaller buffers, and then use the smaller buffers in DMA transfers. In this case, the transfer must also occur on buffers aligned on a cache line boundary. Note that this does not mean the transfer size needs to be a multiple of the cache line length in size. Instead, the “buffer” containing memory locations involved in the transfer must be considered a single buffer; the algorithm must not directly access part of the buffer as per DMA Rule 6.
</p>
<hr />
<dl><dd><b>DMA Rule 9</b></dd>
<dd></dd>
<dd>C6000 algorithms should not use stack allocated buffers as source or destination for any DMA transfer.</dd></dl>
<hr />
<p>DMA Rule 9 is necessary since buffers allocated on the stack are not aligned on cache line boundaries, and there is no mechanism to force alignment. Furthermore, this rule is good practice, as it helps to minimize an algorithm's stack size requirements.
</p>
<h2><span id="The_Fast_Copy_(FCPY)_Algorithm_Example"></span><span class="mw-headline" id="The_Fast_Copy_.28FCPY.29_Algorithm_Example">The Fast Copy (FCPY) Algorithm Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=60" title="Edit section: The Fast Copy (FCPY) Algorithm Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In this section we present a toy algorithm, FCPY_TI, used to illustrate how to implement the IDMA3 interface and use DMA via ACPY3 calls. Sample code is provided in <a href="#Appendix_B:_Code_for_FCPY_TI_Algorithm">Appendix B</a>.
</p><p>The FCPY algorithm's <code>doCopy()</code> function illustrates a contrived scenario of copying a 2D buffer from one location in memory to another using DMA. In the process, <code>doCopy()</code> does a 2D to 1D transfer from the source to a work buffer using the parameters [srcLineLen, srcNumLines, srcStride], copies the contents of the work buffer to a second work buffer using a 1D to 1D transfer, and finally copies the contents of the second work buffer to the destination using the parameters [dstLineLen, dstNumLines, dstStride].
</p>
<div style="text-align: center;">
<p><a href="../File_Docopy.html" class="image" title="FCPY doCopy operation"><img alt="FCPY doCopy operation" src="https://processors.wiki.ti.com/images/3/31/Docopy.png" width="576" height="169" /></a><br /><b>Figure 10. Illustration of FCPY doCopy operation</b>
</p>
</div>
<p>The FCPY instance object can be configured using the following structure: &lt;syntaxhighlight lang="c"&gt;
</p>
<pre>typedef struct IFCPY_Params {
    Int  size;         /* Size of this structure */
    Int  srcLineLen;   /* Source line length */
    Int  srcNumLines;  /* Number of lines for source */
    Int  srcStride;    /* Stride between lines for source */
    Int  dstLineLen;   /* Destination line length */
    Int  dstNumLines;  /* Number of lines for destination */
    Int  dstStride;    /* Stride between lines for destination */
} IFCPY_Params;
</pre>
<p>&lt;/syntaxhighlight&gt;
</p><p>Note that <code>(srcLineLen * srcNumLines) = (dstLineLen * dstNumLines)</code> must hold true for the algorithm to operate correctly. Otherwise the behavior is undefined.
</p>
<h3><span class="mw-headline" id="IFCPY_Interface_Functions">IFCPY_Interface Functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=61" title="Edit section: IFCPY Interface Functions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The function table for the algorithm is shown below: &lt;syntaxhighlight lang="c"&gt;
</p>
<pre>typedef struct IFCPY_Fxns {
    IALG_Fxns   ialg;    /* IFCPY extends IALG */
    XDAS_Bool  (*control)(IFCPY_Handle handle, IFCPY_Cmd cmd, IFCPY_Status *status);
    Void       (*doCopy)(IFCPY_Handle handle, Int in[], Int out[]);
} IFCPY_Fxns;
</pre>
<p>&lt;/syntaxhighlight&gt;
</p><p>In addition to implementing the ialg interface, this algorithm also implements a control (<code>FCPY_TI_control()</code>) function that has two commands:
</p>
<ul><li>IFCPY_GETSTATUS: returns the IFCPY_Params structure’s non-size parameters.</li>
<li>IFCPY_SETSTATUS: sets the IFCPY_Params structure’s non-size parameters.</li></ul>
<p>The doCopy function (<code>FCPY_TI_doCopy()</code>) is the process function of the algorithm.
</p>
<h4><span class="mw-headline" id="Instance_Heap_Memory_Requirements">Instance Heap Memory Requirements</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=62" title="Edit section: Instance Heap Memory Requirements">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>This algorithm requests three buffers:
</p>
<table>

<tbody><tr>
<th>Buffer
</th>
<th>Size
</th>
<th>Alignment
</th>
<th>Space
</th>
<th>Attrs
</th></tr>
<tr>
<td>0
</td>
<td><code>sizeof(FCPY_TI_Obj)</code>
</td>
<td>0
</td>
<td>External
</td>
<td>Persist
</td></tr>
<tr>
<td>1
</td>
<td><code>(srcLineLen * srcNumLines) * sizeof(Char)</code>
</td>
<td>128
</td>
<td>Internal
</td>
<td>Scratch
</td></tr>
<tr>
<td>2
</td>
<td><code>(srcLineLen * srcNumLines) * sizeof(Char)</code>
</td>
<td>128
</td>
<td>Internal
</td>
<td>Scratch
</td></tr></tbody></table>
<p>The alignment of these buffers is set at 128 to align at cache boundaries, so that <a href="../Cache_Management.html" title="Cache Management">cache coherence issues</a> do not arise.
</p>
<h4><span class="mw-headline" id="The_Use_of_IDMA3_and_ACPY3_Interfaces">The Use of IDMA3 and ACPY3 Interfaces</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=63" title="Edit section: The Use of IDMA3 and ACPY3 Interfaces">edit</a><span class="mw-editsection-bracket">]</span></span></h4>
<p>The IDMA3 interface has been implemented for fcpy_ti to request three different logical channels for the three types of transfers required in the algorithm, following the new DMA performance guideline. In the algorithm’s processing function, <code>FCPY_TI_doCopy()</code>, ACPY3 run-time functions are used to show their invocation procedures.
</p>
<h2><span class="mw-headline" id="The_fastcopytest_Example">The fastcopytest Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=64" title="Edit section: The fastcopytest Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To show how the ACPY3 functions can be used in an actual application, an example, fastcopytest, has been developed. It uses the FCPY_TI algorithm, which follows the new guidelines for achieving high performance. This section describes the example application. Sample code is provided in <a href="#Appendix_A._Code_for_the_fastcopytest_Example">Appendix A. Code for the fastcopytest Example</a>.
</p>
<div style="text-align: center;">
<p><a href="../File_App_and_dma.html" class="image" title="Dependencies in the fastcopytest Example"><img alt="Dependencies in the fastcopytest Example" src="https://processors.wiki.ti.com/images/c/cd/App_and_dma.png" width="534" height="298" /></a><br /><b>Figure 11. Dependencies in the fastcopytest Example</b>
</p>
</div>
<p>As Figure 11 shows, to simplify interaction between the IDMA3 interface and the ACPY3 library, a DMA manager module (DMAN3) is used as an extra layer between the algorithm and the application. This module queries the algorithm for its DMA resource needs through the algorithm's IDMA3 interface, allocates the necessary memory for logical channels, and grants the memory to the algorithm.
</p><p>The example uses the FCPY_TI algorithm, which copies a 2D buffer with a frame index value—the number of 8-bit bytes between the last byte of a row in the 2D buffer and the first byte of its next row—of x into another buffer with a frame index value of y.
</p><p>Note that this algorithm is also part of the example. It is not performance-driven and aims to show the use of the ACPY3 functions. It first does a 2D to 1D transfer of the data in the input buffer into an internal buffer, then transfers the data to a second internal buffer using a 1D to 1D transfer. Finally, it does a 1D to 2D transfer from the second buffer to the output buffer.
</p><p>You may also refer to the <a href="http://www.ti.com/lit/pdf/spru609" class="extiw" title="tidoc:spru609">TMS320C621x/C671x DSP Two-Level Internal Memory Reference Guide</a>, for more details about the DMA-related cache coherence issues.
</p><p>The fastcopytest application does the appropriate module initializations and uses an instance of the FCPY_TI algorithm to copy a 64x64 block from an input buffer to an output buffer. It divides the block into four quadrants, and makes four separate calls to FCPY_TI to copy the data one quadrant at a time. It prints the word "Pass" in the DSP/BIOS Message Log when all data transfers complete successfully.
</p>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=65" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ol><li><i>TMS320 DSP Algorithm Standard Rules and Guidelines</i> (<a href="http://www.ti.com/lit/pdf/SPRU352" class="extiw" title="tidoc:SPRU352">SPRU352</a>)</li>
<li><i>TMS320 DSP Algorithm Standard API Reference</i> (<a href="http://www.ti.com/lit/pdf/SPRU360" class="extiw" title="tidoc:SPRU360">SPRU360</a>)</li>
<li><i>TMS320 DSP Algorithm Standard Developer’s Guide</i> (<a href="http://www.ti.com/lit/pdf/SPRU424" class="extiw" title="tidoc:SPRU424">SPRU424</a>)</li>
<li><i>TMS320C6000 Peripherals Reference Guide</i> (<a href="http://www.ti.com/lit/pdf/SPRU190" class="extiw" title="tidoc:SPRU190">SPRU190</a>)</li>
<li><i>TMS320C621x/C671x EDMA Queue Management Guidelines</i> (<a href="http://www.ti.com/lit/pdf/SPRA720" class="extiw" title="tidoc:SPRA720">SPRA720</a>)</li>
<li><i>TMS320C621x/C671x DSP Two-Level Internal Memory Reference Guide</i> (<a href="http://www.ti.com/lit/pdf/SPRU609" class="extiw" title="tidoc:SPRU609">SPRU609</a>)</li></ol>
<h2><span class="mw-headline" id="Appendix_A._Code_for_the_fastcopytest_Example">Appendix A. Code for the fastcopytest Example</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=66" title="Edit section: Appendix A. Code for the fastcopytest Example">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The fastcopytest example distributed in Framework Components uses the FCPY_TI algorithm and the ACPY3 implementation to illustrate how IDMA3 functions are implemented and how ACPY3 functions are used to perform DMA transfers. You can find that example in $(FC_INSTALL_DIR)/examples/ti/sdo/fc/dman3/examples/fastcopy. <a rel="nofollow" class="external text" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/fc/latest_2_x/examples/ti/sdo/fc/dman3/examples/fastcopy/fastcopytest.c">A direct link to the latest release's fastcopytest.c is also available here.</a>
</p>
<h2><span class="mw-headline" id="Appendix_B:_Code_for_FCPY_TI_Algorithm">Appendix B: Code for FCPY_TI Algorithm</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit&amp;section=67" title="Edit section: Appendix B: Code for FCPY TI Algorithm">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The FCPY_TI algorithm follows the guidelines for achieving high performance.
</p><p><br /> <b>ifcpy.h</b> &lt;syntaxhighlight lang="c"&gt;
/*
</p>
<pre>*  ======== ifcpy.h ========
*  This header defines all types, constants, and functions shared by all
*  implementations of the FCPY algorithm.
*/
</pre>
<ol><li>ifndef IFCPY_</li>
<li>define IFCPY_</li></ol>
<ol><li>include &lt;ti/xdais/ialg.h&gt;</li>
<li>include &lt;ti/xdais/xdas.h&gt;</li></ol>
<ol><li>ifdef __cplusplus</li></ol>
<p>extern "C" {
</p>
<ol><li>endif /*__cplusplus*/</li></ol>
<p>/*
</p>
<pre>*  ======== IFCPY_Obj ========
*  This structure must be the first field of all FCPY instance objects.
*/
</pre>
<p>typedef struct IFCPY_Obj {
</p>
<pre>   struct IFCPY_Fxns *fxns;
</pre>
<p>} IFCPY_Obj;
</p><p>/*
</p>
<pre>*  ======== IFCPY_Handle ========
*  This handle is used to reference all FCPY instance objects.
*/
</pre>
<p>typedef struct IFCPY_Obj *IFCPY_Handle;
</p><p>/*
</p>
<pre>*  ======== IFCPY_Cmd ========
*  This structure defines the control commands for the FCPY module.
*/
</pre>
<p>typedef enum IFCPY_Cmd {
</p>
<pre>   IFCPY_GETSTATUS,
   IFCPY_SETSTATUS
</pre>
<p>} IFCPY_Cmd;
</p><p>/*
</p>
<pre>*  ======== IFCPY_Params ========
*  This structure defines the creation parameters for all FCPY instance
*  objects.
*/
</pre>
<p>typedef struct IFCPY_Params {
</p>
<pre>   Int  size;        /* Size of this structure */
</pre>
<pre>   /* The following two parameters are read-only */
   Int  srcLineLen;  /* Source line length (# of 8-bit elements) */
   Int  srcNumLines; /* Number of lines for source */
</pre>
<pre>   /* The following parameters are read/write */
   Int  srcStride;   /* Stride between lines for source */
   Int  dstLineLen;  /* Destination line length (# of 8-bit elements) */
   Int  dstNumLines; /* Number of lines for destination */
   Int  dstStride;   /* Stride between lines for destination */
</pre>
<p>} IFCPY_Params;
</p><p>extern const IFCPY_Params IFCPY_PARAMS; /* default params */
</p><p>/*
</p>
<pre>*  ======== IFCPY_Status ========
*  This structure defines the parameters that can be changed at runtime
*  (read/write), and the instance status parameters (read-only).
*/
</pre>
<p>typedef struct IFCPY_Status {
</p>
<pre>   Int  size;            /* Size of this structure */
</pre>
<pre>   /* The following two parameters are read-only */
   Int  srcLineLen;      /* Source line length (# of 8-bit elements) */
   Int  srcNumLines;     /* Number of lines for source */
</pre>
<pre>   /* The following parameters are read/write */
   Int  srcStride;       /* Stride between lines for source */
   Int  dstLineLen;      /* Destination line length (# of 8-bit elements) */
   Int  dstNumLines;     /* Number of lines for destination */
   Int  dstStride;       /* Stride between lines for destination */
</pre>
<p>} IFCPY_Status;
</p><p>/*
</p>
<pre>*  ======== IFCPY_Fxns ========
*  This structure defines all of the operations on FCPY objects.
*/
</pre>
<p>typedef struct IFCPY_Fxns {
</p>
<pre>   IALG_Fxns   ialg;    /* IFCPY extends IALG */
   XDAS_Bool  (*control)(IFCPY_Handle handle, IFCPY_Cmd cmd,
       IFCPY_Status *status);
   Void       (*doCopy)(IFCPY_Handle handle, Void * in, Void * out);
</pre>
<p>} IFCPY_Fxns;
</p>
<ol><li>ifdef __cplusplus</li></ol>
<p>}
</p>
<ol><li>endif /*__cplusplus*/</li></ol>
<ol><li>endif  /* IFCPY_ */</li></ol>
<p>&lt;/syntaxhighlight&gt;
</p><p><br /> <b>fcpy_ti.h</b> &lt;syntaxhighlight lang="c"&gt;
/*
</p>
<pre>*  ======== fcpy_ti.h ========
*  Interface header for the FCPY_TI module.
*/
</pre>
<ol><li>ifndef FCPY_TI_</li>
<li>define FCPY_TI_</li></ol>
<ol><li>ifndef IDMA3_USEFULLPACKAGEPATH</li>
<li>define IDMA3_USEFULLPACKAGEPATH</li>
<li>endif</li></ol>
<ol><li>include &lt;ti/xdais/ialg.h&gt;</li>
<li>include &lt;ifcpy.h&gt;</li>
<li>include &lt;ti/xdais/idma3.h&gt;</li></ol>
<ol><li>ifdef __cplusplus</li></ol>
<p>extern "C" {
</p>
<ol><li>endif /*__cplusplus*/</li></ol>
<p>/*  ======== FCPY_TI_Handle ========
</p>
<pre>*  FCPY algorithm instance handle
*/
</pre>
<p>typedef struct FCPY_TI_Obj *FCPY_TI_Handle;
</p><p>/*  ======== FCPY_TI_exit ========
</p>
<pre>*  Required module finalization function.
*/
</pre>
<p>extern Void FCPY_TI_exit(Void);
</p><p>/*  ======== FCPY_TI_init ========
</p>
<pre>*  Required module initialization function.
*/
</pre>
<p>extern Void FCPY_TI_init(Void);
</p><p>/*  ======== FCPY_TI_IALG ========
</p>
<pre>*  TI's implementation of FCPY's IALG interface
*/
</pre>
<p>extern IALG_Fxns FCPY_TI_IALG;
</p><p>/*  ======== FCPY_TI_IFCPY ========
</p>
<pre>*  TI's implementation of FCPY's IFCPY interface
*/
</pre>
<p>extern IFCPY_Fxns FCPY_TI_IFCPY;
</p><p>/*  ======== FCPY_TI_IDMA3 ========
</p>
<pre>*  TI's implementation of FCPY's IDMA2 interface
*/
</pre>
<p>extern IDMA3_Fxns FCPY_TI_IDMA3;
</p>
<ol><li>ifdef __cplusplus</li></ol>
<p>}
</p>
<ol><li>endif /*__cplusplus*/</li></ol>
<ol><li>endif /* FCPY_TI_ */</li></ol>
<p class="mw-empty-elt">
</p><p><b>fcpy_ti_priv.h</b> &lt;syntaxhighlight lang="c"&gt;
/*
</p>
<pre>*  ======== fcpy_ti_priv.h ========
*  Internal vendor specific (TI) interface header for FCPY
*  algorithm. Only the implementation source files include
*  this header; this header is not shipped as part of the algorithm.
*
*  This header contains declarations that are specific to
*  this implementation and which do not need to be exposed
*  in order for an application to use the FCPY algorithm.
*/
</pre>
<ol><li>ifndef FCPY_TI_PRIV_</li>
<li>define FCPY_TI_PRIV_</li></ol>
<ol><li>include &lt;ti/xdais/ialg.h&gt;</li>
<li>include &lt;ti/xdais/xdas.h&gt;</li>
<li>include &lt;ifcpy.h&gt;</li>
<li>include &lt;ti/xdais/idma3.h&gt;</li></ol>
<ol><li>ifdef __cplusplus</li></ol>
<p>extern "C" {
</p>
<ol><li>endif /*__cplusplus*/</li></ol>
<p>typedef struct FCPY_TI_Obj {
</p>
<pre>   IALG_Obj    ialg;        /* MUST be first field of all DAIS algs */
   Int         *workBuf1;   /* on-chip scratch */
   Int         *workBuf2;   /* on-chip scratch */
   Int         srcLineLen;  /* Source line length (# of 8-bit elements) */
   Int         srcNumLines; /* Number of lines for source */
   Int         srcStride;   /* Stride between lines for source */
   Int         dstLineLen;  /* Destination line length (# of 8-bit elements) */
   Int         dstNumLines; /* Number of lines for destination */
   Int         dstStride;   /* Stride between lines for destination */
   IDMA3_Handle dmaHandle1D1D8B;  /* DMA logical channel for 1D to 1D xfers */
   IDMA3_Handle dmaHandle1D2D8B;  /* DMA logical channel for 1D to 2D xfers */
   IDMA3_Handle dmaHandle2D1D8B;  /* DMA logical channel for 2D to 1D xfers */ } FCPY_TI_Obj;
</pre>
<p>/* IALG fxn declarations */
extern Void FCPY_TI_activate(IALG_Handle handle);
extern Void FCPY_TI_deactivate(IALG_Handle handle);
extern Int FCPY_TI_alloc(const IALG_Params *algParams, IALG_Fxns **parentFxns,
</p>
<pre>                       IALG_MemRec memTab[]);
</pre>
<p>extern Int FCPY_TI_free(IALG_Handle handle, IALG_MemRec memTab[]);
</p><p>extern Int FCPY_TI_initObj(IALG_Handle handle,
</p>
<pre>                         const IALG_MemRec memTab[], IALG_Handle parent,
                         const IALG_Params *algParams);
</pre>
<p>extern Void FCPY_TI_moved(IALG_Handle handle,
</p>
<pre>                         const IALG_MemRec memTab[], IALG_Handle parent,
                         const IALG_Params *algParams);
</pre>
<p>/* IFCPY fxn declarations */
extern Void FCPY_TI_doCopy(IFCPY_Handle handle, Void * in, Void * out); extern XDAS_Bool FCPY_TI_control(IFCPY_Handle handle, IFCPY_Cmd cmd,
</p>
<pre>                                    IFCPY_Status *status);
</pre>
<p>/* IDMA3 fxn declarations */
extern Void FCPY_TI_dmaChangeChannels(IALG_Handle handle,
</p>
<pre>                       IDMA3_ChannelRec dmaTab[]);
</pre>
<p>extern Uns FCPY_TI_dmaGetChannelCnt(Void);
</p><p>extern Uns FCPY_TI_dmaGetChannels(IALG_Handle handle,
</p>
<pre>                       IDMA3_ChannelRec dmaTab[]);
</pre>
<p>extern Int FCPY_TI_dmaInit(IALG_Handle handle, IDMA3_ChannelRec dmaTab[]);
</p>
<ol><li>ifdef __cplusplus</li></ol>
<p>}
</p>
<ol><li>endif /*__cplusplus*/</li></ol>
<ol><li>endif  /* FCPY_TI_PRIV_ */</li></ol>
<p>&lt;/syntaxhighlight&gt;
</p><p><br /> <b>fcpy_ti_ialg.c</b> &lt;syntaxhighlight lang="c"&gt;
/*
</p>
<pre>*  ======== fcpy_ti_ialg.c ========
*  FCPY Module - TI implementation of the FCPY module.
*  This file contains the implementation of the required IALG interface.
*/
</pre>
<ol><li>pragma CODE_SECTION(FCPY_TI_alloc, ".text:algAlloc")</li>
<li>pragma CODE_SECTION(FCPY_TI_free, ".text:algFree")</li>
<li>pragma CODE_SECTION(FCPY_TI_initObj, ".text:algInit")</li>
<li>pragma CODE_SECTION(FCPY_TI_moved, ".text:algMoved")</li></ol>
<ol><li>ifndef IDMA3_USEFULLPACKAGEPATH</li>
<li>define IDMA3_USEFULLPACKAGEPATH</li>
<li>endif</li></ol>
<ol><li>include &lt;std.h&gt;</li>
<li>include &lt;fcpy_ti_priv.h&gt;</li>
<li>include &lt;ifcpy.h&gt;</li>
<li>include &lt;ti/xdais/ialg.h&gt;</li></ol>
<ol><li>define OBJECT 0</li>
<li>define WORKBUF1 1</li>
<li>define WORKBUF2 2</li>
<li>define NUMBUFS 3</li>
<li>define ALIGN_FOR_CACHE 128  /* alignment on cache boundary */</li></ol>
<p>/*
</p>
<pre>*  ======== FCPY_TI_alloc ========
*  Request memory.
*/
</pre>
<p>Int FCPY_TI_alloc(const IALG_Params *algParams,
</p>
<pre>                IALG_Fxns **parentFxns, IALG_MemRec memTab[]) {
   const IFCPY_Params *params = (Void *)algParams;
</pre>
<pre>   if (params == NULL) {
       params = &amp;IFCPY_PARAMS;  /* Use interface default params */
   }
</pre>
<pre>   /* Request memory for FCPY object */
   memTab[OBJECT].size = sizeof (FCPY_TI_Obj);
   memTab[OBJECT].alignment = 0;    /* No alignment required */
   memTab[OBJECT].space = IALG_EXTERNAL;
   memTab[OBJECT].attrs = IALG_PERSIST;
</pre>
<pre>   /* Request memory for working buffer 1 */
   memTab[WORKBUF1].size = (params-&gt;srcLineLen) * (params-&gt;srcNumLines) *
       sizeof (Char);
   memTab[WORKBUF1].alignment = ALIGN_FOR_CACHE;
   memTab[WORKBUF1].space = IALG_DARAM0;
   memTab[WORKBUF1].attrs = IALG_SCRATCH;
</pre>
<pre>   /* Request memory for working buffer 2 */
   memTab[WORKBUF2].size = (params-&gt;srcLineLen) * (params-&gt;srcNumLines) *
       sizeof (Char);
   memTab[WORKBUF2].alignment = ALIGN_FOR_CACHE;
   memTab[WORKBUF2].space = IALG_DARAM0;
   memTab[WORKBUF2].attrs = IALG_SCRATCH;
</pre>
<pre>   return (NUMBUFS);
</pre>
<p>}
</p><p>/*  ======== FCPY_TI_free ========
</p>
<pre>*  Return a complete memTab structure.
*/
</pre>
<p>Int FCPY_TI_free(IALG_Handle handle, IALG_MemRec memTab[]) {
</p>
<pre>   FCPY_TI_Obj *fcpy = (Void *)handle;
</pre>
<pre>   FCPY_TI_alloc(NULL, NULL, memTab);
</pre>
<pre>   memTab[OBJECT].base = handle;
</pre>
<pre>   memTab[WORKBUF1].base = fcpy-&gt;workBuf1;
   memTab[WORKBUF1].size = (fcpy-&gt;srcLineLen) * (fcpy-&gt;srcNumLines) * sizeof (Char);
</pre>
<pre>   memTab[WORKBUF2].base = fcpy-&gt;workBuf2;
   memTab[WORKBUF2].size = (fcpy-&gt;srcLineLen) * (fcpy-&gt;srcNumLines) * sizeof (Char);
</pre>
<pre>   return (NUMBUFS);
</pre>
<p>}
</p><p>/*
</p>
<pre>*  ======== FCPY_TI_initObj ========
*  Initialize instance object.
*/
</pre>
<p>Int FCPY_TI_initObj(IALG_Handle handle,
</p>
<pre>               const IALG_MemRec memTab[], IALG_Handle parent,
               const IALG_Params *algParams) {
   FCPY_TI_Obj *fcpy = (Void *)handle;
   const IFCPY_Params *params = (Void *)algParams;
</pre>
<pre>   if (params == NULL) {
       params = &amp;IFCPY_PARAMS;  /* Use interface defult params */
   }
</pre>
<pre>   /* Set addresses of internal buffers */
   fcpy-&gt;workBuf1 = memTab[WORKBUF1].base;
   fcpy-&gt;workBuf2 = memTab[WORKBUF2].base;
</pre>
<pre>   /* Configure the instance object */
   fcpy-&gt;srcLineLen  = params-&gt;srcLineLen;
   fcpy-&gt;srcStride   = params-&gt;srcStride;
   fcpy-&gt;srcNumLines = params-&gt;srcNumLines;
   fcpy-&gt;dstLineLen  = params-&gt;dstLineLen;
   fcpy-&gt;dstStride   = params-&gt;dstStride;
   fcpy-&gt;dstNumLines = params-&gt;dstNumLines;
</pre>
<pre>   return (IALG_EOK);
</pre>
<p>}
</p><p>/*  ======== FCPY_TI_moved ========
</p>
<pre>*  Re-initialize buffer ptrs to new location.
*/
</pre>
<p>Void FCPY_TI_moved(IALG_Handle handle,
</p>
<pre>               const IALG_MemRec memTab[], IALG_Handle parent,
               const IALG_Params *algParams) {
   FCPY_TI_Obj *fcpy = (Void *)handle;
</pre>
<pre>   fcpy-&gt;workBuf1 = memTab[WORKBUF1].base;
   fcpy-&gt;workBuf2 = memTab[WORKBUF2].base;
</pre>
<p>}&lt;/syntaxhighlight&gt;
</p><p><br /> <b>fcpy_ti_idma3.c</b> &lt;syntaxhighlight lang="c" fcpy="FCPY" module="Module" ti="TI" implementation="implementation" of="of" a="a" algorithm="algorithm" this="This" file="file" contains="contains" an="an" the="the" idma3="IDMA3" interface="interface"&gt;
</p>
<ol><li>include &lt;fcpy_ti_priv.h&gt;</li>
<li>include &lt;ti/xdais/ialg.h&gt;</li>
<li>include &lt;ti/xdais/idma3.h&gt;</li>
<li>include &lt;ti/sdo/fc/acpy3/acpy3.h&gt;</li></ol>
<ol><li>define NUM_LOGICAL_CH 3</li></ol>
<p>/*
</p>
<pre>*  ======== FCPY_TI_dmaChangeChannels ========
*  Update instance object with new logical channel.
*/
</pre>
<p>Void FCPY_TI_dmaChangeChannels(IALG_Handle handle, IDMA3_ChannelRec dmaTab[]) {
</p>
<pre>   FCPY_TI_Obj *fcpy = (Void *)handle;
</pre>
<pre>   fcpy-&gt;dmaHandle1D1D8B = dmaTab[0].handle;
   fcpy-&gt;dmaHandle1D2D8B = dmaTab[1].handle;
   fcpy-&gt;dmaHandle2D1D8B = dmaTab[2].handle;
</pre>
<p>}
</p><p>/*
</p>
<pre>*  ======== FCPY_TI_dmaGetChannelCnt ========
*  Return max number of logical channels requested.
*/
</pre>
<p>Uns FCPY_TI_dmaGetChannelCnt(Void)
{
</p>
<pre>   return(NUM_LOGICAL_CH);
</pre>
<p>}
</p><p>/*
</p>
<pre>*  ======== FCPY_TI_dmaGetChannels ========
*  Declare DMA resource requirement/holdings.
*/
</pre>
<p>Uns FCPY_TI_dmaGetChannels(IALG_Handle handle, IDMA3_ChannelRec dmaTab[]) {
</p>
<pre>   FCPY_TI_Obj *fcpy = (Void *)handle;
   int i;
</pre>
<pre>   /* Initial values on logical channels */
   dmaTab[0].handle = fcpy-&gt;dmaHandle1D1D8B;
   dmaTab[1].handle = fcpy-&gt;dmaHandle1D2D8B;
   dmaTab[2].handle = fcpy-&gt;dmaHandle2D1D8B;
</pre>
<pre>   /*   */
   dmaTab[0].numTransfers = 1;
   dmaTab[0].numWaits = 1;
</pre>
<pre>   dmaTab[1].numTransfers = 1;
   dmaTab[1].numWaits = 1;
</pre>
<pre>   dmaTab[2].numTransfers = 1;
   dmaTab[2].numWaits = 1;
</pre>
<pre>   /*
    * Request logical DMA channels for use with ACPY3
    * AND with environment size obtained from ACPY3 implementation
    * AND with low priority.
    */
   for (i=0; i&lt;NUM_LOGICAL_CH; i++) {
       dmaTab[i].priority = IDMA3_PRIORITY_LOW;
       dmaTab[i].protocol = &amp;ACPY3_PROTOCOL;
       dmaTab[i].persistent = FALSE;
   }
</pre>
<pre>   return (NUM_LOGICAL_CH);
</pre>
<p>}
</p><p>/*
</p>
<pre>*  ======== FCPY_TI_dmaInit========
*  Initialize instance object with granted logical channel.
*/
</pre>
<p>Int FCPY_TI_dmaInit(IALG_Handle handle, IDMA3_ChannelRec dmaTab[]) {
</p>
<pre>   FCPY_TI_Obj *fcpy = (Void *)handle;
</pre>
<pre>   fcpy-&gt;dmaHandle1D1D8B = dmaTab[0].handle;
   fcpy-&gt;dmaHandle1D2D8B = dmaTab[1].handle;
   fcpy-&gt;dmaHandle2D1D8B = dmaTab[2].handle;
</pre>
<pre>   return (IALG_EOK);
</pre>
<p>}&lt;/syntaxhighlight&gt;
</p><p><br /> <b>fcpy_ti_idmavt.c</b> &lt;syntaxhighlight lang="c"&gt;
/*
</p>
<pre>*  ======== fcpy_ti_idma3vt.c ========
*  This file contains the function table definitions for the
*  IDMA3 interface implemented by the FCPY_TI module.
*/
</pre>
<ol><li>include &lt;std.h&gt;</li></ol>
<ol><li>include &lt;ti/xdais/idma3.h&gt;</li>
<li>include &lt;fcpy_ti.h&gt;</li>
<li>include &lt;fcpy_ti_priv.h&gt;</li></ol>
<p>/*
</p>
<pre>*  ======== FCPY_TI_IDMA3 ========
*  This structure defines TI's implementation of the IDMA2 interface
*  for the FCPY_TI module.
*/
</pre>
<p>IDMA3_Fxns FCPY_TI_IDMA3 = {      /* module_vendor_interface */
</p>
<pre>   &amp;FCPY_TI_IALG,              /* IALG functions */
   FCPY_TI_dmaChangeChannels,  /* ChangeChannels */
   FCPY_TI_dmaGetChannelCnt,   /* GetChannelCnt */
   FCPY_TI_dmaGetChannels,     /* GetChannels */
   FCPY_TI_dmaInit             /* initialize logical channels */
</pre>
<p>};
fcpy_ti_ifcpy.c
/*
</p>
<pre>*  ======== fcpy_ti_ifcpy.c ========
*  FCPY Module - TI implementation of a FCPY algorithm
*
*  This file contains the implementation of the IFCPY abstract interface.
*/
</pre>
<ol><li>pragma CODE_SECTION(FCPY_TI_doCopy, ".text:doCopy")</li>
<li>pragma CODE_SECTION(FCPY_TI_control, ".text:control")</li></ol>
<ol><li>include &lt;std.h&gt;</li></ol>
<ol><li>include &lt;ti/xdais/xdas.h&gt;</li>
<li>include &lt;ti/xdais/idma3.h&gt;</li>
<li>include &lt;ti/sdo/fc/acpy3/acpy3.h&gt;</li></ol>
<ol><li>include &lt;ifcpy.h&gt;</li>
<li>include &lt;fcpy_ti_priv.h&gt;</li>
<li>include &lt;fcpy_ti.h&gt;</li></ol>
<p>/*
</p>
<pre>*  ======== FCPY_TI_doCopy ========
*/
</pre>
<p>Void FCPY_TI_doCopy(IFCPY_Handle handle, Void * in, Void * out) {
</p>
<pre>   FCPY_TI_Obj *fcpy = (Void *)handle;
   ACPY3_Params params;
</pre>
<pre>   /*
    * Activate Channel  scratch DMA channels.
    */
   ACPY3_activate(fcpy-&gt;dmaHandle1D1D8B);
   ACPY3_activate(fcpy-&gt;dmaHandle1D2D8B);
   ACPY3_activate(fcpy-&gt;dmaHandle2D1D8B);
</pre>
<pre>   /* Configure the logical channel */
   params.transferType = ACPY3_1D1D;
</pre>
<pre>   params.srcAddr = (void *)(fcpy-&gt;workBuf1);
   params.dstAddr = (void *)(fcpy-&gt;workBuf2);
   params.elementSize = (Uns)(fcpy-&gt;srcLineLen) * (fcpy-&gt;srcNumLines);
   params.numElements = 1;
   params.numFrames = 1;
   params.srcElementIndex = 0;
   params.dstElementIndex = 0;
   params.srcFrameIndex = 0;
   params.dstFrameIndex = 0;
   params.waitId = 0;
</pre>
<pre>   /* Configure logical dma channel */
   ACPY3_configure(fcpy-&gt;dmaHandle1D1D8B, &amp;params, 0);
</pre>
<pre>   /* Configure the logical channel */
</pre>
<pre>   params.transferType = ACPY3_2D1D;
</pre>
<pre>   params.srcAddr = (void *)in;
   params.dstAddr = (void *)(fcpy-&gt;workBuf1);
   params.elementSize = (Uns)(fcpy-&gt;srcLineLen);
   params.numElements = fcpy-&gt;srcNumLines;
   params.numFrames = 1;
   params.srcElementIndex = fcpy-&gt;srcStride + fcpy-&gt;srcLineLen&#160;;
   params.dstElementIndex = fcpy-&gt;srcLineLen;
   params.srcFrameIndex = 0;
   params.dstFrameIndex = 0;
   params.waitId = 0;
</pre>
<pre>   //params.numFrames = fcpy-&gt;srcNumLines;
   //params.srcFrameIndex = fcpy-&gt;srcStride;
   //params.dstFrameIndex = 0;
</pre>
<pre>   /* Configure logical dma channel */
   ACPY3_configure(fcpy-&gt;dmaHandle2D1D8B, &amp;params, 0);
</pre>
<pre>   /* Configure the logical channel */
   params.transferType = ACPY3_1D2D;
   //params.elemSize = IDMA3_ELEM8;
   //params.numFrames = 0;
   //params.srcFrameIndex = 0;
   //params.dstFrameIndex = 0;
</pre>
<pre>   params.srcAddr = (void *)(fcpy-&gt;workBuf2);
   params.dstAddr = (void *)out;
   params.elementSize = (Uns)(fcpy-&gt;dstLineLen);
   //params.numElements = fcpy-&gt;dstNumLines;
   params.numFrames = 1;
   params.srcElementIndex = fcpy-&gt;dstLineLen&#160;;
   //params.dstElementIndex = fcpy-&gt;dstLineLen + fcpy-&gt;dstStride;
</pre>
<pre>   /* Configure logical dma channel */
   ACPY3_configure(fcpy-&gt;dmaHandle1D2D8B, &amp;params, 0);
   ACPY3_fastConfigure16b(fcpy-&gt;dmaHandle1D2D8B,
           ACPY3_PARAMFIELD_NUMELEMENTS,
           fcpy-&gt;dstNumLines, 0);
</pre>
<pre>   ACPY3_fastConfigure16b(fcpy-&gt;dmaHandle1D2D8B,
           ACPY3_PARAMFIELD_ELEMENTINDEX_DST,
           fcpy-&gt;dstLineLen + fcpy-&gt;dstStride, 0);
</pre>
<pre>   //ACPY2_setNumFrames(fcpy-&gt;dmaHandle1D2D8B, fcpy-&gt;dstNumLines);
   //ACPY2_setDstFrameIndex(fcpy-&gt;dmaHandle1D2D8B, fcpy-&gt;dstStride);
</pre>
<pre>   /* Use DMA to fcpy input buffer into working buffer */
   ACPY3_start(fcpy-&gt;dmaHandle2D1D8B);
   //ACPY2_start(fcpy-&gt;dmaHandle2D1D8B, (Void *)in,
   //    (Void *)(fcpy-&gt;workBuf1),
   //    (Uns)(fcpy-&gt;srcLineLen));
</pre>
<pre>   /* Check that dma transfer has completed before finishing "processing" */
   while (!ACPY3_complete(fcpy-&gt;dmaHandle2D1D8B)) {
      &#160;;
   };
</pre>
<pre>   /* Use the DMA to copy data from working buffer 1 to working buffer 2 */
   ACPY3_start(fcpy-&gt;dmaHandle1D1D8B);
   //ACPY2_start(fcpy-&gt;dmaHandle1D1D8B, (Void *)(fcpy-&gt;workBuf1),
   ///   (Void *)(fcpy-&gt;workBuf2),
   //    (Uns)((fcpy-&gt;srcLineLen) * (fcpy-&gt;srcNumLines)));
</pre>
<pre>   /* wait for transfer to finish  */
   ACPY3_wait(fcpy-&gt;dmaHandle1D1D8B);
</pre>
<pre>   /* Quickly configure NumFrames and FrameIndex values for dmaHandle1D2D8B */
   //ACPY2_setNumFrames(fcpy-&gt;dmaHandle1D2D8B, fcpy-&gt;dstNumLines);
   //ACPY2_setDstFrameIndex(fcpy-&gt;dmaHandle1D2D8B, fcpy-&gt;dstStride);
</pre>
<pre>   /* Use the DMA to copy data from working buffer 2 to output buffer */
   ACPY3_start(fcpy-&gt;dmaHandle1D2D8B);
   //ACPY2_start(fcpy-&gt;dmaHandle1D2D8B, (Void *)(fcpy-&gt;workBuf2),
   //    (Void *)out, (Uns)(fcpy-&gt;dstLineLen));
</pre>
<pre>   /* wait for all transfers to complete before returning to the client */
   ACPY3_wait(fcpy-&gt;dmaHandle1D2D8B);
</pre>
<pre>   /*
    * DeActivate Channel  scratch DMA channels.
    */
   ACPY3_deactivate(fcpy-&gt;dmaHandle1D1D8B);
   ACPY3_deactivate(fcpy-&gt;dmaHandle1D2D8B);
   ACPY3_deactivate(fcpy-&gt;dmaHandle2D1D8B);
</pre>
<p>}
</p><p>/*
</p>
<pre>*  ======== FCPY_TI_control ========
*/
</pre>
<p>XDAS_Bool FCPY_TI_control(IFCPY_Handle handle, IFCPY_Cmd cmd, IFCPY_Status *status)
{
</p>
<pre>   FCPY_TI_Obj *fcpy = (FCPY_TI_Obj *)handle;
</pre>
<pre>   if (cmd == IFCPY_GETSTATUS) {
       status-&gt;srcLineLen = fcpy-&gt;srcLineLen;
       status-&gt;srcNumLines = fcpy-&gt;srcNumLines;
       status-&gt;srcStride = fcpy-&gt;srcStride;
       status-&gt;dstLineLen = fcpy-&gt;dstLineLen;
       status-&gt;dstNumLines = fcpy-&gt;dstNumLines;
       status-&gt;dstStride = fcpy-&gt;dstStride;
       return (XDAS_TRUE);
   }
   else if (cmd == IFCPY_SETSTATUS) {
       /*
        * Note that srcLineLen and srcNumLines cannot be changed once the
        * algorithm has been instantiated, as they determine the sizes of
        * the internal buffers used in FCPY_TI
        */
       fcpy-&gt;srcStride = status-&gt;srcStride;
       fcpy-&gt;dstLineLen = status-&gt;dstLineLen;
       fcpy-&gt;dstNumLines = status-&gt;dstNumLines;
       fcpy-&gt;dstStride = status-&gt;dstStride;
       return (XDAS_TRUE);
   }
</pre>
<pre>   /* Should not happen */
   return (XDAS_FALSE);
</pre>
<p>}&lt;/syntaxhighlight&gt;
</p><p><br /> <b>fcpy_ti_ialg.c</b> &lt;syntaxhighlight lang="c"&gt;
/*
</p>
<pre>*  ======== fcpy_ti_ialg.c ========
*  FCPY Module - TI implementation of the FCPY module.
*  This file contains the implementation of the required IALG interface.
*/
</pre>
<ol><li>pragma CODE_SECTION(FCPY_TI_alloc, ".text:algAlloc")</li>
<li>pragma CODE_SECTION(FCPY_TI_free, ".text:algFree")</li>
<li>pragma CODE_SECTION(FCPY_TI_initObj, ".text:algInit")</li>
<li>pragma CODE_SECTION(FCPY_TI_moved, ".text:algMoved")</li></ol>
<ol><li>ifndef IDMA3_USEFULLPACKAGEPATH</li>
<li>define IDMA3_USEFULLPACKAGEPATH</li>
<li>endif</li></ol>
<ol><li>include &lt;std.h&gt;</li>
<li>include &lt;fcpy_ti_priv.h&gt;</li>
<li>include &lt;ifcpy.h&gt;</li>
<li>include &lt;ti/xdais/ialg.h&gt;</li></ol>
<ol><li>define OBJECT 0</li>
<li>define WORKBUF1 1</li>
<li>define WORKBUF2 2</li>
<li>define NUMBUFS 3</li>
<li>define ALIGN_FOR_CACHE 128  /* alignment on cache boundary */</li></ol>
<p>/*  ======== FCPY_TI_alloc ========
</p>
<pre>*  Request memory.
*/
</pre>
<p>Int FCPY_TI_alloc(const IALG_Params *algParams,
</p>
<pre>                IALG_Fxns **parentFxns, IALG_MemRec memTab[]) {
   const IFCPY_Params *params = (Void *)algParams;
</pre>
<pre>   if (params == NULL) {
       params = &amp;IFCPY_PARAMS;  /* Use interface default params */
   }
</pre>
<pre>   /* Request memory for FCPY object */
   memTab[OBJECT].size = sizeof (FCPY_TI_Obj);
   memTab[OBJECT].alignment = 0;    /* No alignment required */
   memTab[OBJECT].space = IALG_EXTERNAL;
   memTab[OBJECT].attrs = IALG_PERSIST;
</pre>
<pre>   /* Request memory for working buffer 1 */
   memTab[WORKBUF1].size = (params-&gt;srcLineLen) * (params-&gt;srcNumLines) *
       sizeof (Char);
   memTab[WORKBUF1].alignment = ALIGN_FOR_CACHE;
   memTab[WORKBUF1].space = IALG_DARAM0;
   memTab[WORKBUF1].attrs = IALG_SCRATCH;
</pre>
<pre>   /* Request memory for working buffer 2 */
   memTab[WORKBUF2].size = (params-&gt;srcLineLen) * (params-&gt;srcNumLines) *
       sizeof (Char);
   memTab[WORKBUF2].alignment = ALIGN_FOR_CACHE;
   memTab[WORKBUF2].space = IALG_DARAM0;
   memTab[WORKBUF2].attrs = IALG_SCRATCH;
</pre>
<pre>   return (NUMBUFS);
</pre>
<p>}
</p><p>/*  ======== FCPY_TI_free ========
</p>
<pre>*  Return a complete memTab structure.
*/
</pre>
<p>Int FCPY_TI_free(IALG_Handle handle, IALG_MemRec memTab[]) {
</p>
<pre>   FCPY_TI_Obj *fcpy = (Void *)handle;
</pre>
<pre>   FCPY_TI_alloc(NULL, NULL, memTab);
</pre>
<pre>   memTab[OBJECT].base = handle;
   memTab[WORKBUF1].base = fcpy-&gt;workBuf1;
   memTab[WORKBUF1].size = (fcpy-&gt;srcLineLen) * (fcpy-&gt;srcNumLines)
       * sizeof (Char);
   memTab[WORKBUF2].base = fcpy-&gt;workBuf2;
   memTab[WORKBUF2].size = (fcpy-&gt;srcLineLen) * (fcpy-&gt;srcNumLines)
       * sizeof (Char);
</pre>
<pre>   return (NUMBUFS);
</pre>
<p>}
</p><p>/*  ======== FCPY_TI_initObj ========
</p>
<pre>*  Initialize instance object.
*/
</pre>
<p>Int FCPY_TI_initObj(IALG_Handle handle,
</p>
<pre>               const IALG_MemRec memTab[], IALG_Handle parent,
               const IALG_Params *algParams) {
   FCPY_TI_Obj *fcpy = (Void *)handle;
   const IFCPY_Params *params = (Void *)algParams;
</pre>
<pre>   if (params == NULL) {
       params = &amp;IFCPY_PARAMS;  /* Use interface defult params */
   }
   /* Set addresses of internal buffers */
   fcpy-&gt;workBuf1 = memTab[WORKBUF1].base;
   fcpy-&gt;workBuf2 = memTab[WORKBUF2].base;
</pre>
<pre>   /* Configure the instance object */
   fcpy-&gt;srcLineLen  = params-&gt;srcLineLen;
   fcpy-&gt;srcStride   = params-&gt;srcStride;
   fcpy-&gt;srcNumLines = params-&gt;srcNumLines;
   fcpy-&gt;dstLineLen  = params-&gt;dstLineLen;
   fcpy-&gt;dstStride   = params-&gt;dstStride;
   fcpy-&gt;dstNumLines = params-&gt;dstNumLines;
</pre>
<pre>   return (IALG_EOK);
</pre>
<p>}
</p><p>/*  ======== FCPY_TI_moved ========
</p>
<pre>*  Re-initialize buffer ptrs to new location.
*/
</pre>
<p>Void FCPY_TI_moved(IALG_Handle handle,
</p>
<pre>               const IALG_MemRec memTab[], IALG_Handle parent,
               const IALG_Params *algParams) {
   FCPY_TI_Obj *fcpy = (Void *)handle;
   fcpy-&gt;workBuf1 = memTab[WORKBUF1].base;
   fcpy-&gt;workBuf2 = memTab[WORKBUF2].base;
}
</pre>
<p>asm("_FCPY_TI_IALG  .set _FCPY_TI_IFCPY");
&lt;/syntaxhighlight&gt;
</p>
<!-- 
NewPP limit report
Cached time: 20201130181331
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.248 seconds
Real time usage: 0.256 seconds
Preprocessor visited node count: 455/1000000
Preprocessor generated node count: 716/1000000
Post‐expand include size: 436/2097152 bytes
Template argument size: 204/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 622/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    1.723      1 Template:EndOfLife
100.00%    1.723      1 -total
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:474-0!canonical and timestamp 20201130181330 and revision id 181241
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="../File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Framework Components DMAN3/ACPY3 Users Guide</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Framework Components DMAN3/ACPY3 Users Guide</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>Framework Components DMAN3/ACPY3 Users Guide</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>Framework Components DMAN3/ACPY3 Users Guide</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>Framework Components DMAN3/ACPY3 Users Guide</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Framework Components DMAN3/ACPY3 Users Guide</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Framework Components DMAN3/ACPY3 Users Guide</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>Framework Components DMAN3/ACPY3 Users Guide</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>Framework Components DMAN3/ACPY3 Users Guide</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="../File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;oldid=181241">https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;oldid=181241</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="../Special_Categories.html" title="Special:Categories">Categories</a>: <ul><li><a href="https://processors.wiki.ti.com/index.php?title=Category:Pages_using_invalid_self-closed_HTML_tags&amp;action=edit&amp;redlink=1" class="new" title="Category:Pages using invalid self-closed HTML tags (page does not exist)">Pages using invalid self-closed HTML tags</a></li><li><a href="../Category_EndOfLife.html" title="Category:EndOfLife">EndOfLife</a></li><li><a href="../Category_DaVinci_Algorithms.html" title="Category:DaVinci Algorithms">DaVinci Algorithms</a></li><li><a href="../Category_XDAIS.html" title="Category:XDAIS">XDAIS</a></li><li><a href="../Category_Framework_Components.html" title="Category:Framework Components">Framework Components</a></li><li><a href="../Category_Codec_Engine.html" title="Category:Codec Engine">Codec Engine</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=Framework+Components+DMAN3%2FACPY3+Users+Guide" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="../Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="ACPY3_Users_Guide.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk"><span><a href="../Talk_Framework_Components_DMAN3/ACPY3_Users_Guide.html" rel="discussion" title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="ACPY3_Users_Guide.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="../Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="../Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="../Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="../Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="../Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="../Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="../Special_WhatLinksHere/Framework_Components_DMAN3/ACPY3_Users_Guide.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="../Special_RecentChangesLinked/Framework_Components_DMAN3/ACPY3_Users_Guide.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="../Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;oldid=181241" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=Framework_Components_DMAN3/ACPY3_Users_Guide&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 9 July 2014, at 13:38.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="../Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="../Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="../Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="../Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.248","walltime":"0.256","ppvisitednodes":{"value":455,"limit":1000000},"ppgeneratednodes":{"value":716,"limit":1000000},"postexpandincludesize":{"value":436,"limit":2097152},"templateargumentsize":{"value":204,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":622,"limit":5000000},"timingprofile":["100.00%    1.723      1 Template:EndOfLife","100.00%    1.723      1 -total"]},"cachereport":{"timestamp":"20201130181331","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":231});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/Framework_Components_DMAN3/ACPY3_Users_Guide by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 04:32:57 GMT -->
</html>
