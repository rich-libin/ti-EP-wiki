<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/Codec_Engine_Application_Developers_Guide by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 04:31:20 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>Codec Engine Application Developers Guide - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Codec_Engine_Application_Developers_Guide","wgTitle":"Codec Engine Application Developers Guide","wgCurRevisionId":193327,"wgRevisionId":193327,"wgArticleId":670,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Codec Engine","DaVinci Training"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Codec_Engine_Application_Developers_Guide","wgRelevantArticleId":670,"wgRequestId":"c860f0960dd8684398618918","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Codec_Engine_Application_Developers_Guide rootpage-Codec_Engine_Application_Developers_Guide skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">Codec Engine Application Developers Guide</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><p><b>Note:</b> This article was sourced from (and intends to supercede!) <a href="http://www.ti.com/lit/pdf/sprue67" class="extiw" title="tidoc:sprue67">SPRUE67</a>.
</p><p>The <a href="Codec_Engine.html" title="Codec Engine">Codec Engine</a> is a set of APIs that you use to instantiate and run XDAIS algorithms. A VISA interface is provided as well for interacting with <a href="XDM_FAQ.html" title="XDM FAQ">XDM</a>-compliant XDAIS algorithms.
</p><p>The intended audience for this section is the embedded-OS <a href="Codec_Engine_Roles.html#CE_Application_Author" title="Codec Engine Roles">application developer</a> needing to create and interact with XDAIS algorithms.
</p>
<div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Overview"><span class="tocnumber">1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#The_Core_Engine_APIs"><span class="tocnumber">2</span> <span class="toctext">The Core Engine APIs</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Codec_Engine_Setup_Code"><span class="tocnumber">2.1</span> <span class="toctext">Codec Engine Setup Code</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Opening_an_Engine"><span class="tocnumber">2.2</span> <span class="toctext">Opening an Engine</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Closing_an_Engine"><span class="tocnumber">2.3</span> <span class="toctext">Closing an Engine</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Adding_Engines_to_the_Engine_Database_.28BIOS_6.29"><span class="tocnumber">2.4</span> <span class="toctext">Adding Engines to the Engine Database (BIOS 6)</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Adding_Algorithms_to_Engines_.28BIOS_6.29"><span class="tocnumber">2.5</span> <span class="toctext">Adding Algorithms to Engines (BIOS 6)</span></a>
<ul>
<li class="toclevel-3 tocsection-8"><a href="#Example_1"><span class="tocnumber">2.5.1</span> <span class="toctext">Example 1</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Example_2"><span class="tocnumber">2.5.2</span> <span class="toctext">Example 2</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-10"><a href="#Getting_Memory_and_CPU_Information_from_an_Engine"><span class="tocnumber">2.6</span> <span class="toctext">Getting Memory and CPU Information from an Engine</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Getting_Information_about_Algorithms_Configured_into_an_Engine"><span class="tocnumber">2.7</span> <span class="toctext">Getting Information about Algorithms Configured into an Engine</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-12"><a href="#The_VISA_Classes:_Video.2C_Image.2C_Speech.2C_Audio..._and_more.21"><span class="tocnumber">3</span> <span class="toctext">The VISA Classes: Video, Image, Speech, Audio... and more!</span></a>
<ul>
<li class="toclevel-2 tocsection-13"><a href="#VISA_API_Setup_Code"><span class="tocnumber">3.1</span> <span class="toctext">VISA API Setup Code</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Creating_an_Algorithm_Instance"><span class="tocnumber">3.2</span> <span class="toctext">Creating an Algorithm Instance</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Deleting_an_Algorithm_Instance"><span class="tocnumber">3.3</span> <span class="toctext">Deleting an Algorithm Instance</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Controlling_an_Algorithm_Instance"><span class="tocnumber">3.4</span> <span class="toctext">Controlling an Algorithm Instance</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Processing_Data_with_an_Algorithm_Instance"><span class="tocnumber">3.5</span> <span class="toctext">Processing Data with an Algorithm Instance</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Overriding_a_Remote_Algorithm.27s_Priority_and_Memory_Requests"><span class="tocnumber">3.6</span> <span class="toctext">Overriding a Remote Algorithm's Priority and Memory Requests</span></a>
<ul>
<li class="toclevel-3 tocsection-19"><a href="#Overriding_the_Algorithm.27s_Configured_Priority"><span class="tocnumber">3.6.1</span> <span class="toctext">Overriding the Algorithm's Configured Priority</span></a></li>
<li class="toclevel-3 tocsection-20"><a href="#Overriding_an_Algorithm.27s_Memory_Requests"><span class="tocnumber">3.6.2</span> <span class="toctext">Overriding an Algorithm's Memory Requests</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-21"><a href="#The_Server_APIs"><span class="tocnumber">4</span> <span class="toctext">The Server APIs</span></a>
<ul>
<li class="toclevel-2 tocsection-22"><a href="#Getting_a_Server_Handle"><span class="tocnumber">4.1</span> <span class="toctext">Getting a Server Handle</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Getting_Memory_Heap_Information"><span class="tocnumber">4.2</span> <span class="toctext">Getting Memory Heap Information</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#Reconfiguring_the_Server.27s_Algorithm_Heap"><span class="tocnumber">4.3</span> <span class="toctext">Reconfiguring the Server's Algorithm Heap</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#Getting_Trace_from_the_Server"><span class="tocnumber">4.4</span> <span class="toctext">Getting Trace from the Server</span></a>
<ul>
<li class="toclevel-3 tocsection-26"><a href="#Example_BIOS_5"><span class="tocnumber">4.4.1</span> <span class="toctext">Example BIOS 5</span></a></li>
<li class="toclevel-3 tocsection-27"><a href="#Example_BIOS_6"><span class="tocnumber">4.4.2</span> <span class="toctext">Example BIOS 6</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-28"><a href="#Getting_Server_CPU_Load"><span class="tocnumber">4.5</span> <span class="toctext">Getting Server CPU Load</span></a>
<ul>
<li class="toclevel-3 tocsection-29"><a href="#Example_BIOS_5_2"><span class="tocnumber">4.5.1</span> <span class="toctext">Example BIOS 5</span></a></li>
<li class="toclevel-3 tocsection-30"><a href="#Example_BIOS_6_2"><span class="tocnumber">4.5.2</span> <span class="toctext">Example BIOS 6</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-31"><a href="#What_Happens_to_DSP_Memory_Issues.3F"><span class="tocnumber">5</span> <span class="toctext">What Happens to DSP Memory Issues?</span></a>
<ul>
<li class="toclevel-2 tocsection-32"><a href="#Buffer_Handling_and_Shared_Memory_Maps"><span class="tocnumber">5.1</span> <span class="toctext">Buffer Handling and Shared Memory Maps</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#Memory_Fragmentation"><span class="tocnumber">5.2</span> <span class="toctext">Memory Fragmentation</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Cache_Alignment"><span class="tocnumber">5.3</span> <span class="toctext">Cache Alignment</span></a></li>
<li class="toclevel-2 tocsection-35"><a href="#Cache_Coherence"><span class="tocnumber">5.4</span> <span class="toctext">Cache Coherence</span></a>
<ul>
<li class="toclevel-3 tocsection-36"><a href="#GPP_.2B_DSP_Environments"><span class="tocnumber">5.4.1</span> <span class="toctext">GPP + DSP Environments</span></a></li>
<li class="toclevel-3 tocsection-37"><a href="#Single-Processor_Environments"><span class="tocnumber">5.4.2</span> <span class="toctext">Single-Processor Environments</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-38"><a href="#What_Happens_to_DSP_Real-Time_Issues.3F"><span class="tocnumber">6</span> <span class="toctext">What Happens to DSP Real-Time Issues?</span></a>
<ul>
<li class="toclevel-2 tocsection-39"><a href="#Transaction_Latency"><span class="tocnumber">6.1</span> <span class="toctext">Transaction Latency</span></a></li>
<li class="toclevel-2 tocsection-40"><a href="#Multi-_vs._Uni-Processor_Performance"><span class="tocnumber">6.2</span> <span class="toctext">Multi- vs. Uni-Processor Performance</span></a></li>
<li class="toclevel-2 tocsection-41"><a href="#Local_Performance"><span class="tocnumber">6.3</span> <span class="toctext">Local Performance</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-42"><a href="#What_About_Codec_Engine_Debugging.3F"><span class="tocnumber">7</span> <span class="toctext">What About Codec Engine Debugging?</span></a>
<ul>
<li class="toclevel-2 tocsection-43"><a href="#Codec_Engine_Debugging_from_the_ARM_on_ARM.2BDSP_Systems"><span class="tocnumber">7.1</span> <span class="toctext">Codec Engine Debugging from the ARM on ARM+DSP Systems</span></a></li>
<li class="toclevel-2 tocsection-44"><a href="#Codec_Engine_Debugging_on_a_DSP-only_System"><span class="tocnumber">7.2</span> <span class="toctext">Codec Engine Debugging on a DSP-only System</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-45"><a href="#What_About_Software_Trace.3F"><span class="tocnumber">8</span> <span class="toctext">What About Software Trace?</span></a>
<ul>
<li class="toclevel-2 tocsection-46"><a href="#Software_Trace_for_BIOS_5_Based_Versions_of_Codec_Engine"><span class="tocnumber">8.1</span> <span class="toctext">Software Trace for BIOS 5 Based Versions of Codec Engine</span></a>
<ul>
<li class="toclevel-3 tocsection-47"><a href="#Configuring_TraceUtil_at_Design_Time"><span class="tocnumber">8.1.1</span> <span class="toctext">Configuring TraceUtil at Design Time</span></a></li>
<li class="toclevel-3 tocsection-48"><a href="#Supporting_TraceUtil_in_Your_Application.27s_C_Code"><span class="tocnumber">8.1.2</span> <span class="toctext">Supporting TraceUtil in Your Application's C Code</span></a></li>
<li class="toclevel-3 tocsection-49"><a href="#Configuring_the_DSP_Server_for_DSP.2FBIOS_Logging"><span class="tocnumber">8.1.3</span> <span class="toctext">Configuring the DSP Server for DSP/BIOS Logging</span></a></li>
<li class="toclevel-3 tocsection-50"><a href="#Configuring_the_DSP_Server_To_Redirect_Trace_Output"><span class="tocnumber">8.1.4</span> <span class="toctext">Configuring the DSP Server To Redirect Trace Output</span></a></li>
<li class="toclevel-3 tocsection-51"><a href="#Configuring_TraceUtil_at_Application_Start_Time"><span class="tocnumber">8.1.5</span> <span class="toctext">Configuring TraceUtil at Application Start Time</span></a></li>
<li class="toclevel-3 tocsection-52"><a href="#Controlling_Trace_at_Run-Time_Through_a_Named_Pipe"><span class="tocnumber">8.1.6</span> <span class="toctext">Controlling Trace at Run-Time Through a Named Pipe</span></a></li>
<li class="toclevel-3 tocsection-53"><a href="#Trace_Mask_Values"><span class="tocnumber">8.1.7</span> <span class="toctext">Trace Mask Values</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-54"><a href="#Software_Trace_for_BIOS_6_Based_Versions_of_Codec_Engine"><span class="tocnumber">8.2</span> <span class="toctext">Software Trace for BIOS 6 Based Versions of Codec Engine</span></a>
<ul>
<li class="toclevel-3 tocsection-55"><a href="#Log_Configuration"><span class="tocnumber">8.2.1</span> <span class="toctext">Log Configuration</span></a></li>
<li class="toclevel-3 tocsection-56"><a href="#Trace_Mask_Values_2"><span class="tocnumber">8.2.2</span> <span class="toctext">Trace Mask Values</span></a></li>
<li class="toclevel-3 tocsection-57"><a href="#Setting_Trace_Masks_at_Run-Time"><span class="tocnumber">8.2.3</span> <span class="toctext">Setting Trace Masks at Run-Time</span></a></li>
<li class="toclevel-3 tocsection-58"><a href="#Easy_Trace_Enable_for_Linux_Applications"><span class="tocnumber">8.2.4</span> <span class="toctext">Easy Trace Enable for Linux Applications</span></a></li>
</ul>
</li>
</ul>
</li>
<li class="toclevel-1 tocsection-59"><a href="#Additional_Documents_and_Resources"><span class="tocnumber">9</span> <span class="toctext">Additional Documents and Resources</span></a></li>
</ul>
</div>

<h1><span class="mw-headline" id="Overview">Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=1" title="Edit section: Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The Codec Engine has <a href="#The_Core_Engine_APIs">Core Engine APIs</a> and VISA APIs that are available to the <a href="Codec_Engine_Roles.html#CE_Application_Author" title="Codec Engine Roles">Application Author</a>. The following table shows the Core Engine API modules:
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">

<caption><i>Codec Engine Modules</i>
</caption>
<tbody><tr>
<td><b>Description</b>
</td>
<td><b>Module Abbreviation</b>
</td>
<td><b>Package Name</b>
</td>
<td><b>Header File(s)</b>
</td>
<td><b>See Section</b>
</td></tr>
<tr>
<td>Initialization function
</td>
<td>CERuntime_
</td>
<td>ti.sdo.ce
</td>
<td>CERuntime.h
</td>
<td><a href="#Codec_Engine_Setup_Code">Codec Engine Setup Code</a>
</td></tr>
<tr>
<td>Codec Engine Runtime
</td>
<td>Engine_, Server_
</td>
<td>ti.sdo.ce
</td>
<td>Engine.h, Server.h
</td>
<td><a href="#The_Core_Engine_APIs">The Core Engine APIs</a>
</td></tr>
<tr>
<td>OS Abstraction Layer for memory
</td>
<td>Memory_
</td>
<td>ti.sdo.ce.osal
</td>
<td>Memory.h
</td>
<td><a href="#What_Happens_to_DSP_Memory_Issues.3F">What Happens to DSP Memory Issues?</a>
</td></tr></tbody></table>
<p>In addition to modules that perform setup and teardown activities, a memory abstraction module provides support for applications that use Codec Engine in a GPP+DSP system.
</p><p>The following table shows the VISA API modules:
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">

<caption><i>VISA Modules</i>
</caption>
<tbody><tr>
<th><b>Description</b>
</th>
<th><b>Module Prefix</b>
</th>
<th><b>Package Name</b>
</th>
<th><b>Header File(s)</b>
</th></tr>
<tr>
<td>Video Encoder Interface (deprecated)
</td>
<td>VIDENC_
</td>
<td>ti.sdo.ce.video
</td>
<td>videnc.h
</td></tr>
<tr>
<td>Video Encoder Interface
</td>
<td>VIDENC1_
</td>
<td>ti.sdo.ce.video1
</td>
<td>videnc1.h
</td></tr>
<tr>
<td>Video Encoder Interface
</td>
<td>VIDENC2_
</td>
<td>ti.sdo.ce.video2
</td>
<td>videnc2.h
</td></tr>
<tr>
<td>Video Decoder Interface (deprecated)
</td>
<td>VIDDEC_
</td>
<td>ti.sdo.ce.video
</td>
<td>viddec.h
</td></tr>
<tr>
<td>Video Decoder Interface (deprecated)
</td>
<td>VIDDEC1_
</td>
<td>ti.sdo.ce.video1
</td>
<td>viddec1.h
</td></tr>
<tr>
<td>Video Decoder Interface
</td>
<td>VIDDEC2_
</td>
<td>ti.sdo.ce.video2
</td>
<td>viddec2.h
</td></tr>
<tr>
<td>Video Decoder Interface
</td>
<td>VIDDEC3_
</td>
<td>ti.sdo.ce.video3
</td>
<td>viddec3.h
</td></tr>
<tr>
<td>Image Encoder Interface (deprecated)
</td>
<td>IMGENC_
</td>
<td>ti.sdo.ce.image
</td>
<td>imgenc.h
</td></tr>
<tr>
<td>Image Encoder Interface
</td>
<td>IMGENC1_
</td>
<td>ti.sdo.ce.image1
</td>
<td>imgenc1.h
</td></tr>
<tr>
<td>Image Decoder Interface (deprecated)
</td>
<td>IMGDEC_
</td>
<td>ti.sdo.ce.image
</td>
<td>imgdec.h
</td></tr>
<tr>
<td>Image Decoder Interface
</td>
<td>IMGDEC1_
</td>
<td>ti.sdo.ce.image1
</td>
<td>imgdec1.h
</td></tr>
<tr>
<td>Speech Encoder Interface (deprecated)
</td>
<td>SPHENC_
</td>
<td>ti.sdo.ce.speech
</td>
<td>sphenc.h
</td></tr>
<tr>
<td>Speech Encoder Interface
</td>
<td>SPHENC1_
</td>
<td>ti.sdo.ce.speech1
</td>
<td>sphenc1.h
</td></tr>
<tr>
<td>Speech Decoder Interface (deprecated)
</td>
<td>SPHDEC_
</td>
<td>ti.sdo.ce.speech
</td>
<td>sphdec.h
</td></tr>
<tr>
<td>Speech Decoder Interface
</td>
<td>SPHDEC1_
</td>
<td>ti.sdo.ce.speech1
</td>
<td>sphdec1.h
</td></tr>
<tr>
<td>Audio Encoder Interface (deprecated)
</td>
<td>AUDENC_
</td>
<td>ti.sdo.ce.audio
</td>
<td>audenc.h
</td></tr>
<tr>
<td>Audio Encoder Interface
</td>
<td>AUDENC1_
</td>
<td>ti.sdo.ce.audio1
</td>
<td>audenc1.h
</td></tr>
<tr>
<td>Audio Decoder Interface (deprecated)
</td>
<td>AUDDEC_
</td>
<td>ti.sdo.ce.audio
</td>
<td>auddec.h
</td></tr>
<tr>
<td>Audio Decoder Interface
</td>
<td>AUDDEC1_
</td>
<td>ti.sdo.ce.audio1
</td>
<td>auddec1.h
</td></tr>
<tr>
<td>Universal Interface
</td>
<td>UNIVERSAL_
</td>
<td>ti.sdo.ce.universal
</td>
<td>universal.h
</td></tr>
<tr>
<td>Video Analytics Interface (beta)
</td>
<td>VIDANALYTICS_
</td>
<td>ti.sdo.ce.vidanalytics
</td>
<td>vidanalytics.h
</td></tr>
<tr>
<td>Video Transcode Interface
</td>
<td>VIDTRANSCODE_
</td>
<td>ti.sdo.ce.vidtranscode
</td>
<td>vidtranscode.h
</td></tr></tbody></table>
<p>The VISA interfaces provided with CE include support for all <a href="XDM_FAQ.html#What.27s_with_the_XDM_versioning.3F" title="XDM FAQ">XDM interfaces</a>.
</p><p>Example "Copy" codecs complying with the <a href="XDM_FAQ.html" title="XDM FAQ">XDM</a> 1.x interfaces are provided with the XDAIS 5.21 (or newer) product. CE utilizes those codecs in <a href="Codec_Engine_Examples.html" title="Codec Engine Examples">some of its examples</a>.  For example, the video1_copy example utilizes the VIDENC1 and VIDDEC1 VISA interfaces to communicate with the videnc1_copy and viddec1_copy codecs.
</p><p>The package name corresponds to the path your application must use to reference the header file it includes to use a particular module. For example, the speech encoder module, SPHENC1, has a package name of ti.sdo.ce.speech1.  The #include statement for this module is:
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<ol><li>include &lt;ti/sdo/ce/speech1/sphenc1.h&gt;</li></ol>
<p>&lt;/syntaxhighlight&gt;
</p><p>Your application uses the Engine module to open and close instances of the Codec Engine.  You can also use this module to get information about memory use and CPU loading. See the section <a href="#The_Core_Engine_APIs">The Core Engine APIs</a>.
</p><p>Once your application has opened an instance of the Codec Engine, you use the modules in the VISA packages (for example, VIDENC for video encoding) to create instances of various algorithms. Using the handle for the algorithm instance you create, you then use the same module to run or otherwise control the algorithm. See the section <a href="#The_VISA_Classes:_Video.2C_Image.2C_Speech.2C_Audio">The VISA Classes: Video, Image, Speech, Audio</a>.
</p><p>Reference documentation for the Codec Engine APIs is installed with the Codec Engine software at $(CE_INSTALL_DIR)/docs/html, and also <a rel="nofollow" class="external text" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ce/latest_2_x/docs/html/index.html">available online</a>. This chapter provides an overview of the APIs and how you use them. For details about the calling syntax, see the reference documentation.
</p>
<h1><span class="mw-headline" id="The_Core_Engine_APIs">The Core Engine APIs</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=2" title="Edit section: The Core Engine APIs">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The Codec Engine has a "core" module called "Engine". Your application uses this module to open and close Engine instances. Multi-threaded applications must either serialize access to a shared Engine instance or create a separate Engine instance for each thread.
</p>
<hr />
<p><b>Note:</b> Be aware that Engine handles are not thread-protected. Each thread that uses an Engine instance should perform its own <code>Engine_open()</code> call and use its own Engine handle. This protects each Engine instance from access by other threads in a multi-threaded environment.
</p>
<hr />
<p>You can also use the Engine module to get information about memory use and CPU loading.
</p><p>The APIs for the Engine module are described in detail in the <a rel="nofollow" class="external text" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ce/latest_2_x/docs/html/group___c_o_d_e_c_e_n_g_i_n_e.html">CE API Reference Guide</a>.  A brief summary of commonly used Engine_* APIs is here:
</p>
<ul><li><code>Engine_open()</code> - Open an Engine.</li>
<li><code>Engine_close()</code> - Close an Engine.</li>
<li><code>Engine_getLastError()</code> - Get the error code of the last failed operation.</li>
<li><code>Engine_getUsedMem()</code> - Get Engine memory usage.</li>
<li><code>Engine_getNumAlgs()</code> - Get the number of algorithms in an Engine.</li>
<li><code>Engine_getAlgInfo()</code> Get information about an algorithm.</li>
<li><code>Engine_getCpuLoad()</code> - Get Server's CPU usage in percent.  (Note, this API is now deprecated.  Users should instead use <code>Server_getCpuLoad()</code>)</li></ul>
<p>After opening an Engine, you create algorithm instances using the VISA APIs described in the section <a href="#The_VISA_Classes:_Video.2C_Image.2C_Speech.2C_Audio">The VISA Classes: Video, Image, Speech, Audio</a>.
</p><p>Reference documentation for the Codec Engine APIs is installed with the Codec Engine software at $(CE_INSTALL_DIR)/docs/html, <a rel="nofollow" class="external text" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/ce/latest_2_x/docs/html/index.html">as well as online here</a>.  For details about the calling syntax, see the reference documentation.
</p>
<h2><span class="mw-headline" id="Codec_Engine_Setup_Code">Codec Engine Setup Code</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=3" title="Edit section: Codec Engine Setup Code">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>An application that will use the Codec Engine should include the following header files, where these directory paths are relative to the XDCPATH, which includes $(CE_INSTALL_DIR)/packages and $(XDC_INSTALL_DIR)/packages.
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<ol><li>include &lt;xdc/std.h&gt;</li>
<li>include &lt;ti/sdo/ce/Engine.h&gt;</li>
<li>include &lt;ti/sdo/ce/CERuntime.h&gt;</li></ol>
<p>&lt;/syntaxhighlight&gt;
</p><p>In addition, the application must include the header file for any VISA modules it uses. For example:
&lt;syntaxhighlight lang='c'&gt;
</p>
<ol><li>include &lt;ti/sdo/ce/audio1/auddec1.h&gt;</li></ol>
<p>&lt;/syntaxhighlight&gt;
</p><p>Notice that the paths to the header files exactly correspond to the package paths shown in Table 4–2, Codec Engine Modules.
All applications that use the Codec Engine must call <code>CERuntime_init()</code> before any other APIs.
</p><p>In addition, when running a GPP+DSP application that uses Codec Engine, you must load any dependent drivers, e.g. <a href="DSPLink_Overview.html" title="DSPLink Overview">DSP Link</a> and <a href="CMEM_Overview.html" title="CMEM Overview">CMEM</a>.  How these dependent modules are loaded depends on the GPP OS.
</p>
<ul><li>Linux - examine the examples/apps/system_files/*/loadmodules.sh and $(CE_INSTALL_DIR)/examples/build_instructions.html.</li>
<li>WinCE - examine $(CE_INSTALL_DIR)/examples/build_instructions_wince.html</li></ul>
<h2><span class="mw-headline" id="Opening_an_Engine">Opening an Engine</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=4" title="Edit section: Opening an Engine">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>When you open an Engine, you specify the name of the Engine you want to open. For example:
&lt;syntaxhighlight lang='c'&gt;
Engine_Handle hEngine;
Engine_Error err;
</p><p>hEngine = Engine_open("auddec", NULL, &amp;err);
&lt;/syntaxhighlight&gt;
</p>
<hr />
<p><b>Note:</b> Be aware that Engine handles are not thread-protected. Each thread that uses an Engine instance should perform its own <code>Engine_open()</code> call and use its own Engine handle. This protects each Engine instance from access by other threads in a multi-threaded environment.
</p>
<hr />
<p>Engines are created and configured by your <a href="Codec_Engine_Roles.html#CE_Engine_Integrator" title="Codec Engine Roles">Engine Integrator</a> in the config script (typically a .cfg file).  These config scripts define which algorithms to configure and build into each Engine.  See the page called <a href="Integrating_a_Codec_Engine.html" title="Integrating a Codec Engine">Integrating a Codec Engine</a> for information the Engine Integrator needs to create such Engines.
</p><p>For example, on GPP+CPU systems (e.g. <a href="DaVinci.html" title="DaVinci">DM644x</a>, DM6467, <a href="OMAP3_Overview.html" title="OMAP3 Overview">OMAP3</a>, OMAP-L13x, etc.), algorithms may run locally (on the GPP) or "remotely" (on the DSP).  For remote algorithms, the Engine transparently uses a "DSP Server" and the DSP Link transport to run the remote algorithms.  When there are remote algorithms configured into an Engine, the first request to open that Engine (i.e., <code>Engine_open()</code>) results in the following underlying actions:
</p>
<ul><li>Power ON the DSP (if support is available and enabled).  If enabled, this is handled by LPM (Local Power Manager), which is only supported on DM644x, OMAP2 and OMAP3)</li>
<li>Call the Link APIs needed to initialize the DSP and the transport. For DSPLink and BIOS 5 based systems: <code>PROC_setup()</code>, <code>PROC_attach()</code>, <code>POOL_open()</code>, <code>PROC_load()</code>, <code>PROC_start()</code>, and <code>MSGQ_transportOpen()</code>. For SysLink and BIOS 6 based systems: <code>ProcMgr_open()</code>, <code>ProcMgr_attach()</code>, <code>ProcMgr_load()</code>, and <code>ProcMgr_start()</code>.</li>
<li>Perform the initial handshakes from the GPP side to the remote dispatcher on the DSP.</li></ul>
<p>If the <code>Engine_Handle</code> returned by <code>Engine_open()</code> is <code>NULL</code>, the Engine could not be opened.  If the errorcode parameter is non-NULL, the <code>Engine_Error</code> value contains more details - some commonly returned error codes include:
</p>
<ul><li><code>Engine_EOK</code> - Success.</li>
<li><code>Engine_EEXIST</code> - Name does not exist.</li>
<li><code>Engine_ENOMEM</code> - Can't allocate memory.</li>
<li><code>Engine_EDSPLOAD</code> - Can't load the DSP.</li>
<li><code>Engine_ENOCOMM</code> - Can't create a communication connection to the DSP.</li>
<li><code>Engine_ENOSERVER</code> - Can't locate the Server on the DSP.</li>
<li><code>Engine_ECOMALLOC</code> - Can't allocate a communication buffer.</li></ul>
<p>Your application can handle this error. For example:
&lt;syntaxhighlight lang='c'&gt;
ce = Engine_open(engineName, NULL, &amp;errorCode);
if (ce == NULL) {
</p>
<pre>   printf("Error: could not open engine \"%s\"; Error code&#160;%d.\n", engineName, errorCode);
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p>
<h2><span class="mw-headline" id="Closing_an_Engine">Closing an Engine</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=5" title="Edit section: Closing an Engine">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To close an Engine instance and free memory it uses, your application should call <code>Engine_close()</code>. For example:
</p><p>&lt;syntaxhighlight lang='c'&gt;
Engine_close(ce);
&lt;/syntaxhighlight&gt;
</p><p>You should do this only after you have deleted any algorithm instances created for this Engine.
</p><p>For example, given the DM644x-based example described in the previous section with remote algorithms performed on the DSP, the last call to <code>Engine_close()</code> results in the following underlying actions:
</p>
<ul><li>Call the Link APIs needed to "finalize" the DSP and the transport. For DSPLink and BIOS 5 based systems: <code>MSGQ_transportClose()</code>, <code>PROC_stop()</code>, <code>POOL_close()</code>, <code>PROC_detach()</code>, and <code>PROC_destroy()</code>. For SysLink and BIOS 6 based systems:  <code>ProcMgr_stop()</code>, <code>ProcMgr_unload()</code>, <code>ProcMgr_detach()</code>, and <code>ProcMgr_close()</code>.</li>
<li>Power OFF the DSP (if support is available and enabled).</li></ul>
<h2><span id="Adding_Engines_to_the_Engine_Database_(BIOS_6)"></span><span class="mw-headline" id="Adding_Engines_to_the_Engine_Database_.28BIOS_6.29">Adding Engines to the Engine Database (BIOS 6)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=6" title="Edit section: Adding Engines to the Engine Database (BIOS 6)">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In BIOS 5 based versions of Codec Engine, all engines must be statically configured into the application’s .cfg file. BIOS 6 based versions of Codec Engine do not have this restriction, allowing engine names to be added at run-time, to the database of engines that can be opened.
</p><p>To add an engine, use the function, <code>Engine_add()</code>, specifying the name of the engine and the name of the server image (if applicable) to load when the engine is opened. The example code below adds an engine named "universal_copy" with a remote server. The server has an algorithm that implements <code>ti.sdo.ce.universal.IUNIVERSAL</code>, that we will want to call from the host.
</p><p>&lt;syntaxhighlight lang='c'&gt;
/* Include header file, ti.sdo.ce.universal, for stub functions */
</p>
<ol><li>include &lt;ti/sdo/ce/universal/universal.h&gt;</li>
<li>include &lt;ti/sdo/ce/Engine.h&gt;</li></ol>
<p>Int main(Int argc, String argv[])
{
</p>
<pre>   ...
</pre>
<pre>   /*
    *  The Engine_Desc structure will hold the engine name and server
    *  name that get passed to Engine_add().
    */
   Engine_Desc engDesc;
</pre>
<pre>   /* Initialize the Engine_Desc object with default values. */
   Engine_initDesc(&amp;engDesc);
</pre>
<pre>   /* name of the engine that will be passed to Engine_open() */
   engDesc.name = "universal_copy";
</pre>
<pre>   /*
    *  For SysLink based systems, the name of the DSP executable
    *  that will be loaded onto the remote processor when the engine
    *  is opened. The server name will be passed as is to the SysLink
    *  ProcMgr_load() function.
    */
   engDesc.remoteName = "all_DSP.xe674";
</pre>
<pre>   /* Add the engine name to the database */
   retVal = Engine_add(&amp;engDesc);
   ...
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p><p>If the engine has a remote server, as in the example above, the server will be queried for its algorithms when the engine is opened. These algorithms will then be added to the engine’s algorithm table. However, these algorithms must be invoked through a stub function on the host (since they are remote), so for the algorithms in the server that you will invoke, you must build the algorithm’s stub function into your application. To enable this, Codec Engine provides an API, <code>Engine_addStubFxns()</code>. For the example above, we would add the following code to bring in the UNIVERSAL stub functions.
</p><p><br />
&lt;syntaxhighlight lang='c'&gt;
</p>
<pre>   /*
    *  Bring in the UNIVERSAL stub functions so we can create the
    *  universal_copy codec on the remote processor. NOTE: We should
    *  do this before opening the engine.
    */
   Engine_addStubFxns("UNIVERSAL_STUBS", (IALG_Fxns *)&amp;UNIVERSAL_STUBS);
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<h2><span id="Adding_Algorithms_to_Engines_(BIOS_6)"></span><span class="mw-headline" id="Adding_Algorithms_to_Engines_.28BIOS_6.29">Adding Algorithms to Engines (BIOS 6)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=7" title="Edit section: Adding Algorithms to Engines (BIOS 6)">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>For BIOS 6 based versions of Codec Engine, algorithms can be added at run-time to an engine, using the API, Engine_addAlg(). This API currently only supports adding local algorithms, which can be built into the executable, or reside in a shared library (for Linux OS). If an engine with a remote server executable was added (with Engine_add()) to a SysLink-base system, as in the example in the previous section, there is no need to call Engine_addAlg() for the server algorithms; those algorithms will be added automatically when the engine is opened.
</p><p>Engine_addAlg() has the following signature:
</p><p>Engine_Error Engine_addAlg(String name, Engine_Handle engine, String location, Engine_AlgDesc *pAlgDesc);
</p><p>The engine to which the algorithm is to be added can be specified either by an engine name or an engine handle. If this function is called before any thread has opened the engine, then the ‘name’ parameter must be used to specify the engine, and the ‘engine’ parameter should be set to NULL. In this case, the added algorithm will be available to all threads that subsequently open the engine.
</p><p>If the engine has already been opened, the ‘engine’ parameter should be used to specify the engine to which the algorithm will be added, and the ‘name’ parameter should be set to NULL. In this case, the algorithm added will only be available for the engine handle that was passed to <code>Engine_addAlg()</code>; attempting to create the algorithm using a different engine handle will fail. Furthermore, if the engine is open, calling <code>Engine_addAlg()</code> with a non-NULL engine name will result in an <code>Engine_EINUSE</code> error. You must use the Engine_Handle parameter to specify the engine, if any thread has opened the engine.
</p><p>The ‘location’ parameter is a string that can be used to identify the location of the algorithm. For example, this could be the name of a shared library that needs to be loaded. If the algorithm is built into the executable, ‘location’ should be set to NULL.
</p><p>The ‘pAlgDesc’ parameter holds the algorithm name, functions, codec type, and scratch group ID (if local). For a full description of the Engine_AlgDesc fields, please refer to the Codec Engine API Reference Guide. The fields that you must set depend on whether or not the algorithm is being loaded from a library.
</p>
<h3><span class="mw-headline" id="Example_1">Example 1</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=8" title="Edit section: Example 1">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The simplest use case of <code>Engine_addAlg()</code> is when the algorithm is built into the executable. The example code below adds a local "universal_copy" algorithm to a "universal_copy" engine. Error checking code has been left out for simplification. For a full listing of this example see the main_hlos_local.c file in the ti/sdo/ce/examples/apps/universal_copy directory.
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<ol><li>include &lt;ti/sdo/ce/Engine.h&gt;</li>
<li>include &lt;ti/sdo/ce/CERuntime.h&gt;</li></ol>
<p>/* Defines the UNIVERSAL_VISATYPE, the type of alg we are adding */
</p>
<ol><li>include &lt;ti/sdo/ce/universal/universal.h&gt;</li></ol>
<p>/* Include this header file for algorithm's IALG function table */
</p>
<ol><li>include &lt;ti/xdais/dm/examples/universal_copy/universal_copy_ti.h&gt;</li></ol>
<p>Int main(Int argc, String argv[])
{
</p>
<pre>   Engine_Desc    engDesc;
   Engine_AlgDesc algDesc;
   Engine_Error status;
</pre>
<pre>   /* Initialize Codec Engine */
   CERuntime_init();
</pre>
<pre>   /* Add the "universal_copy" engine */
   Engine_initDesc(&amp;engDesc);
   engDesc.name = "universal_copy";
   status = Engine_add(&amp;engDesc);
</pre>
<pre>   /* Add the "universal_copy" alg to the "universal_copy" engine */
   Engine_initAlgDesc(&amp;algDesc); /* Set fields to defaults */
</pre>
<pre>   algDesc.name = "universal_copy";
   algDesc.fxns = (IALG_Fxns *)&amp;UNIVERSALCOPY_TI_IUNIVERSALCOPY;
   algDesc.idmaFxns = NULL;
   algDesc.isLocal = TRUE;
   algDesc.groupId = 0;
   algDesc.iresFxns = NULL;
   algDesc.types = UNIVERSAL_VISATYPE;
</pre>
<pre>   status = Engine_addAlg("universal_copy", NULL, NULL, &amp;algDesc);
</pre>
<pre>   ...
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p><p>Note that in the code above, we pass NULL for the ‘location’ of the algorithm, and fill in the algorithm descriptor. We also specify the engine name and pass NULL for the handle, since this engine has not been opened.
</p>
<h3><span class="mw-headline" id="Example_2">Example 2</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=9" title="Edit section: Example 2">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In this example, we assume that the algorithm is built into a Linux shared library called "libsphdec1_copy_dll.so.1.0.0". This shared library must export the following function:
</p><p>Int GetEngineAlgDesc(Engine_DllAlgDesc *algDesc)
</p><p>The purpose of GetEngineAlgDesc() is for Codec Engine to query the library for algorithm properties, mainly function tables, and store them in the Engine_DllAlgDesc object. Please refer to the Codec Engine API Reference Guide for a full description of the EngineDllAlgDesc fields.
</p><p>Below is a partial listing of the code. The libraries for this example are located in ti/sdo/ce/examples/codecs/sphdec1_copy_dll and sphenc1_copy_dll, and the application is located in ti/sdo/ce/examples/apps/speech1_copy_dll.
</p><p>&lt;syntaxhighlight lang='c'&gt;
Int smain(Int argc, String argv[])
{
</p>
<pre>   Engine_Desc    desc;
   Engine_AlgDesc attrs;
   Engine_Error status;
</pre>
<pre>   ...
</pre>
<pre>   /* Add the engine name to the set of engines that can be opened */
   Engine_initDesc(&amp;desc);
   desc.name = "engine";
   status = Engine_add(&amp;desc);
</pre>
<pre>   /* Open the engine */
   ce = Engine_open("engine", NULL, NULL);
</pre>
<pre>   /*
    *  Fill in the alg descriptor. Note: We only need to fill in the
    *  name and groupId since alg functions will be obtained from the
    *  library.
    */
   Engine_initAlgDesc(&amp;attrs);
</pre>
<pre>   attrs.name = "sphdec1_copy";
   attrs.groupId = 1;
</pre>
<pre>   /* Add the alg. Pass engine handle, since engine is opened. */
   status = Engine_addAlg(NULL, ce, "./libsphdec1_copy_dll.so.1.0.0",
                          &amp;attrs);
</pre>
<pre>   ...
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p>
<h2><span class="mw-headline" id="Getting_Memory_and_CPU_Information_from_an_Engine">Getting Memory and CPU Information from an Engine</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=10" title="Edit section: Getting Memory and CPU Information from an Engine">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>You can use the <code>Engine_getUsedMem()</code> function to get information about memory used by an Engine instance. The value returned is the total amount of memory (in MAUs) currently allocated from the available heaps. Note that this value may vary between calls, depending upon DSP Server activity. For example, when the first algorithm is instantiated on the DSP Server, data structures in addition to those needed for the individual algorithm instance may be allocated. This extra memory is allocated "when first needed" and remains allocated with its global state retained even after this algorithm is deleted. The memory is not reallocated on subsequent allocations of this or other algorithms on the DSP Server.
</p><p>In addition to <code>Engine_getUsedMem()</code>, there are <a href="#The_Server_APIs">Server APIs</a> for getting information about the memory usage of individual heaps on the DSP.
</p><p>You can use the <code>Server_getCpuLoad()</code> function to get the DSP Server's CPU usage as an integer from 0 to 100. This value indicates the percentage of time the DSP Server is processing measured over a period of approximately 1 second. If the load is unavailable, a negative value is returned.
</p>
<h2><span class="mw-headline" id="Getting_Information_about_Algorithms_Configured_into_an_Engine">Getting Information about Algorithms Configured into an Engine</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=11" title="Edit section: Getting Information about Algorithms Configured into an Engine">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>An application may determine the number of algorithms configured into an Engine and their properties, such as the name of the algorithm and whether it is local or remote.
</p><p>The number of algorithms can be obtained with the following API:
</p><p>&lt;syntaxhighlight lang='c'&gt;
Engine_Error Engine_getNumAlgs(String name, Int *numAlgs);
&lt;/syntaxhighlight&gt;
</p><p>The parameter, "name", is the name of the Engine. This function returns the following values:
</p>
<ul><li><code>Engine_EOK</code> - Success. In this case, <code>*numAlgs</code> returns the number of algorithms configured into the Engine.</li>
<li><code>Engine_EEXIST</code> - There is no Engine with the given name.</li></ul>
<p><br />
Newer versions of Codec Engine have added the API, <code>Engine_getNumAlgs2()</code>:
</p><p>&lt;syntaxhighlight lang='c'&gt;
Engine_Error Engine_getNumAlgs2(String name, Engine_Handle engine, Int *numAlgs);
&lt;/syntaxhighlight&gt;
</p><p>This allows you to specify the engine by either a handle, if the engine has been opened, or by name. By using the engine handle, the number of algorithms returned will include those added after the engine was opened. Use either "name" or "engine", and set the other to NULL.
</p><p>Once the number of algorithms in the Engine is known, the application can iteratively call the function <code>Engine_getAlgInfo()</code> to obtain information about each of the algorithms. The information is put into the <code>Engine_AlgInfo</code> structure, which is defined as follows:
</p><p>&lt;syntaxhighlight lang='c'&gt;
typedef struct Engine_AlgInfo {
</p>
<pre>   Int     algInfoSize;    /* Size of this structure */
   String  name;           /* Name of algorithm */
   String *typeTab;        /* inheritance hierarchy */
   Bool    isLocal;        /* if TRUE, run locally */
</pre>
<p>} Engine_AlgInfo;
&lt;/syntaxhighlight&gt;
</p><p>The first field of the <code>Engine_AlgInfo</code> structure, <code>.algInfoSize</code>, must be set by the application to the size of this structure; it will be used to support future enhancements to this structure. The following example shows the usage of these APIs (error checking has been left out for readability):
</p><p>&lt;syntaxhighlight lang='c'&gt;
Int numAlgs, i;
Engine_AlgInfo algInfo;
</p><p>/* Determine how many algorithms are in the "audio_copy" Engine */
Engine_getNumAlgs("audio_copy", &amp;numAlgs);
</p><p>/* just need to initialize this struct once, so outside of the for loop below */
algInfo.algInfoSize = sizeof(Engine_AlgInfo);
</p><p>/* for each algorithm in the "audio_copy" Engine, print its details */
for (i = 0; i &lt; numAlgs; i++) {
</p>
<pre>   Engine_getAlgInfo("audio_copy", &amp;algInfo, i);
   printf("alg[%d]: name =&#160;%s typeTab =&#160;%s local =&#160;%d\n", i, algInfo.name, *(algInfo.typeTab), algInfo.isLocal);
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p><p>The output may look like the following:
</p>
<pre>alg[0]: name = auddec_copy typeTab = ti.sdo.ce.audio.IAUDDEC local = 0
alg[1]: name = audenc_copy typeTab = ti.sdo.ce.audio.IAUDENC local = 0
</pre>
<p>The <code>typeTab</code> field indicates what 'type' of algorithm it is (e.g. video decoder, image encoder, etc.).  This field is actually a NULL-terminated array of strings giving the inheritance hierarchy; in the example above, we printed out the first string only.  This field can be used, for example to tell the difference between an XDM 0.9 audio decoder (i.e. ti.sdo.ce.audio.IAUDDEC) and a XDM 1.0 audio decoder (i.e. ti.sdo.ce.audio1.IAUDDEC1).
</p><p>The return values of <code>Engine_getAlgInfo()</code> are the following:
</p>
<ul><li><code>Engine_EOK</code> - Success.</li>
<li><code>Engine_EEXIST</code> - There is no Engine with the given name.</li>
<li><code>Engine_EINVAL</code> - The <code>.algInfoSize</code> field of the <code>Engine_AlgInfo</code> object passed to this function does not match the size of the <code>Engine_AlgInfo</code> object in the Codec Engine library.</li>
<li><code>Engine_ENOTFOUND</code> - The index of the algorithm is out of range.</li></ul>
<p><br />
Newer versions of Codec Engine have added the following API:
</p><p>&lt;syntaxhighlight lang='c'&gt;
Engine_Error Engine_getAlgInfo2(String name, Engine_Handle engine,
</p>
<pre>       Engine_AlgInfo2 *algInfo2, Int index);
</pre>
<p>&lt;/syntaxhighlight&gt;
</p><p>This API can be passed either an engine handle or an engine name, and the one that is not used should be set to NULL. The <code>Engine_AlgInfo2</code> structure is defined as:
</p><p>&lt;syntaxhighlight lang='c'&gt;
typedef struct Engine_AlgInfo2 {
</p>
<pre>   Int         algInfoSize;    /**&lt; Size of this structure. */
   String      name;           /**&lt; Name of algorithm. */
   String      types;          /**&lt; Inheritance hierarchy. */
   Bool        isLocal;        /**&lt; If TRUE, run locally. */
</pre>
<p>} Engine_AlgInfo2;
&lt;/syntaxhighlight&gt;
</p><p>Note that the only change from <code>Engine_AlgInfo</code> to <code>Engine_AlgInfo2</code> is the "types" string that replaces the "typeTab" string array. The "types" string is a ‘;’ separated string of the codec class inheritance hierarchy of the algorithm.
</p>
<h1><span id="The_VISA_Classes:_Video,_Image,_Speech,_Audio..._and_more!"></span><span class="mw-headline" id="The_VISA_Classes:_Video.2C_Image.2C_Speech.2C_Audio..._and_more.21">The VISA Classes: Video, Image, Speech, Audio... and more!</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=12" title="Edit section: The VISA Classes: Video, Image, Speech, Audio... and more!">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>For each of the VISA classes (e.g. VIDDEC, AUDENC, UNIVERSAL, etc.), the following APIs are provided, where <i>MOD</i> is the module prefix:
</p>
<ul><li><i>MOD</i><code>_create()</code> - Create an instance of this type of algorithm.</li>
<li><i>MOD</i><code>_process()</code> - Execute the "process" method in this instance of the algorithm.  Block until complete.</li>
<li><i>MOD</i><code>_control()</code> - Execute the "control" method in this instance of the algorithm.</li>
<li><i>MOD</i><code>_delete()</code> - Delete the specified instance of this type of algorithm.</li></ul>
<p>In the CE 2.10 release, asynchronous APIs were added (for remote algorithms only) to enable applications to return immediately from the <i>MOD</i><code>_process()</code> calls.  Due to that support, each module also includes:
</p>
<ul><li><i>MOD</i><code>_processAsync()</code> - Begin executing the "process" method in this instance of the algorithm.  Return immediately.</li>
<li><i>MOD</i><code>_processWait()</code> - Wait for the "process" method in a previously called <i>MOD</i><code>_processAsync</code> call to complete.</li></ul>
<h2><span class="mw-headline" id="VISA_API_Setup_Code">VISA API Setup Code</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=13" title="Edit section: VISA API Setup Code">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>For each VISA API module your application uses, you should include the appropriate header file. For example, the following statement includes the header file for the AUDDEC audio decoder API module.  The directory path is relative to the CE_INSTALL_DIR/packages package repository.
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<ol><li>include &lt;ti/sdo/ce/audio/auddec.h&gt;</li></ol>
<p>&lt;/syntaxhighlight&gt;
</p>
<h2><span class="mw-headline" id="Creating_an_Algorithm_Instance">Creating an Algorithm Instance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=14" title="Edit section: Creating an Algorithm Instance">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To create an algorithm instance within an Engine, you use the <code>*_create()</code> function for the appropriate VISA encoder or decoder module. For example:
</p><p>&lt;syntaxhighlight lang='c'&gt;
Engine_Handle hEngine;
AUDDEC_Handle hAuddec;
</p><p>/* allocate and initialize audio decoder on the Engine */
hAuddec = AUDDEC_create(hEngine, "auddec_copy", NULL);
&lt;/syntaxhighlight&gt;
</p><p>In this function, the first argument — <code>hEngine</code> — is the <code>Engine_Handle</code> returned by the <code>Engine_open()</code> function.
</p><p>The second argument — "auddec_copy" - is a string that identifies the type of algorithm to create.  These strings are part of the configuration created by your <a href="Codec_Engine_Roles.html#CE_Engine_Integrator" title="Codec Engine Roles">Engine Integrator</a>.
</p><p>The third argument allows you to specify parameters to use when instantiating the algorithm.  These parameters control aspects of algorithm behavior.  The parameter structure is different for each VISA encoder or decoder class. For example, the audio decoder parameter structure is as follows:
</p><p>&lt;syntaxhighlight lang='c'&gt;
typedef struct IAUDDEC_Params {
</p>
<pre>   XDAS_Int32 size;           /* Size of this structure */
   XDAS_Int32 maxSampleRate;  /* Max sampling freq in Hz */
   XDAS_Int32 maxBitrate;  /* Max bit-rate in bits per sec */
   XDAS_Int32 maxNoOfCh;  /* Max number of channels */
   XDAS_Int32 dataEndianness; /* Endianness of input data */
</pre>
<p>} IAUDDEC_Params;
&lt;/syntaxhighlight&gt;
This function returns a handle that other functions use to access the algorithm instance.
</p>
<h2><span class="mw-headline" id="Deleting_an_Algorithm_Instance">Deleting an Algorithm Instance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=15" title="Edit section: Deleting an Algorithm Instance">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To delete an algorithm instance and free the resources it uses, your application calls <i>MOD</i><code>_delete()</code>. For example:
&lt;syntaxhighlight lang='c'&gt;
/* tear down the codec and Engine */
AUDDEC_delete(hAuddec);
&lt;/syntaxhighlight&gt;
</p><p>You should do this only after you have freed any buffers or other memory related to the algorithm instance.
</p>
<h2><span class="mw-headline" id="Controlling_an_Algorithm_Instance">Controlling an Algorithm Instance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=16" title="Edit section: Controlling an Algorithm Instance">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>You can control and query the capabilities of an algorithm using the module's <i>MOD</i><code>_control()</code> function.
</p><p>For example, the following code uses the <code>AUDDEC_control()</code> function to query a decoder to verify that the decoder accepts one input buffer, returns one output buffer, and uses buffer sizes that can handle <code>NSAMPLES</code> bytes of data.
&lt;syntaxhighlight lang='c'&gt;
</p>
<ol><li>define NSAMPLES  1024</li>
<li>define IFRAMESIZE (NSAMPLES * sizeof(Int8)) /* raw (in) */</li>
<li>define OFRAMESIZE (NSAMPLES * sizeof(Int8)) /* decoded */</li></ol>
<p>static Char inBuf[IFRAMESIZE];
static Char outBuf[OFRAMESIZE];
</p><p>XDM_BufDesc inBufDesc;
XDM_BufDesc outBufDesc;
XDAS_Int32 status;
XDAS_Int32 bufSizes = NSAMPLES;
IAUDDEC_DynamicParams decDynParams;
IAUDDEC_Status decStatus;
</p><p>/* prepare "global" buffer descriptor settings */
inBufDesc.numBufs = outBufDesc.numBufs = 1;
inBufDesc.bufSizes = outBufDesc.bufSizes = &amp;bufSizes;
</p><p>/* Query the decoder */
status = AUDDEC_control(hAuddec, XDM_GETSTATUS, &amp;decDynParams, &amp;decStatus);
if (status&#160;!= AUDDEC_EOK) {
</p>
<pre>   /* failure, report error and exit */
   printf("decode control status =&#160;%ld\n", status);
   return;
</pre>
<p>}
</p><p>/* Validate decoder codec will meet buffer requirements */
if ((inBufDesc.numBufs &gt; decStatus.bufInfo.maxNumInBufs) ||
</p>
<pre>   (sizeof(inBuf) &gt; decStatus.bufInfo.maxInBufSize[0]) ||
   (outBufDesc.numBufs &gt; decStatus.bufInfo.maxNumOutBufs) ||
   (sizeof(outBuf) &gt; decStatus.bufInfo.maxOutBufSize[0])) {
</pre>
<pre>   /* failure, report error and exit */
   printf("Error:  decoder codec feature conflict\n");
   return;
</pre>
<p>}
&lt;/syntaxhighlight&gt;
In the <code>AUDDEC_control()</code> function example, the first argument <code>hAuddec</code> is the handle to the algorithm returned by the <code>AUDDEC_create()</code> function.
</p><p>The second argument is a command ID constant from ti/xdais/dm/xdm.h.  More details about available command IDs is available in the <a rel="nofollow" class="external text" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/xdais/6_24/exports/xdais_6_24/docs/html/group__ti__xdais__dm___x_d_m.html#g4d2482d53629e138b96af2e3fe702477">XDM Reference Guide's XDM_CmdId documentation</a>
</p><p>The third and fourth arguments are the addresses of <i>MOD</i><code>_DynamicParams</code> and <i>MOD</i><code>_Status</code> structures, respectively.  These structures are different for each of the VISA APIs.
</p>
<h2><span class="mw-headline" id="Processing_Data_with_an_Algorithm_Instance">Processing Data with an Algorithm Instance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=17" title="Edit section: Processing Data with an Algorithm Instance">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>You can run an algorithm using the module's <i>MOD</i><code>_process()</code> function.
</p><p>For example, the following code continues the example in the previous section. It uses the <code>AUDDEC_process()</code> function to read frames from "in", decode the audio, and write the output to "out".
</p><p>&lt;syntaxhighlight lang='c'&gt;
Int n;
XDM_BufDesc           inBufDesc;
XDM_BufDesc           outBufDesc;
IAUDDEC_InArgs        decInArgs;
IAUDDEC_OutArgs       decOutArgs;
</p><p>/* prepare "global" buffer descriptor settings */
inBufDesc.numBufs = outBufDesc.numBufs = 1;
inBufDesc.bufSizes = outBufDesc.bufSizes = &amp;bufSizes;
decInArgs.size = sizeof(decInArgs);
...
</p><p>/* Read complete frames from in, decode and write to out */
for (n = 0; fread(inBuf, sizeof (inBuf), 1, in) == 1; n++) {
</p>
<pre>   XDAS_Int8 *src = inBuf;
   XDAS_Int8 *dst = outBuf;
</pre>
<pre>   /* prepare "per loop" buffer descriptor settings */
   inBufDesc.bufs = &amp;src;
   outBufDesc.bufs = &amp;dst;
   decInArgs.size = sizeof(decInArgs);
   decInArgs.numBytes = sizeof(inBuf);
</pre>
<pre>   /* decode the frame */
   status = AUDDEC_process(hAuddec, &amp;inBufDesc, &amp;outBufDesc,
       &amp;decInArgs, &amp;decOutArgs);
</pre>
<pre>   if (status&#160;!= AUDDEC_EOK) {
       printf("frame&#160;%d: decode status =&#160;%ld\n", n, status);
   }
</pre>
<pre>   /* write to file */
   fwrite(dst, sizeof (outBuf), 1, out);
</pre>
<p>}
printf("%d frames decoded\n", n);
&lt;/syntaxhighlight&gt;
</p><p>In this <code>AUDDEC_process()</code> function example, the first argument — <code>hAuddec</code> — is the handle to the algorithm returned by the <code>AUDDEC_create()</code> function.
</p><p>The second and third arguments for the audio decoder module (and for most other VISA modules) provide the address of a buffer descriptor structure of type <code>XDM_BufDesc</code>. This type has the following structure definition:
</p><p>&lt;syntaxhighlight lang='c'&gt;
typedef struct XDM_BufDesc {
</p>
<pre>   XDAS_Int8  **bufs;
   XDAS_Int32  numBufs;
   XDAS_Int32  *bufSizes;
</pre>
<p>} XDM_BufDesc;
&lt;/syntaxhighlight&gt;
</p><p>The fourth and fifth arguments for the AUDDEC module (and for most other VISA modules) provide the address of input and output arguments for the algorithm.  This structure is different for each of the VISA classes.
</p>
<h2><span id="Overriding_a_Remote_Algorithm's_Priority_and_Memory_Requests"></span><span class="mw-headline" id="Overriding_a_Remote_Algorithm.27s_Priority_and_Memory_Requests">Overriding a Remote Algorithm's Priority and Memory Requests</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=18" title="Edit section: Overriding a Remote Algorithm&#039;s Priority and Memory Requests">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<h3><span id="Overriding_the_Algorithm's_Configured_Priority"></span><span class="mw-headline" id="Overriding_the_Algorithm.27s_Configured_Priority">Overriding the Algorithm's Configured Priority</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=19" title="Edit section: Overriding the Algorithm&#039;s Configured Priority">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In some situations, an application developer may want to run multiple instances of a remote codec at different priorities. As an example, suppose you want to run two instances of the sample audio encoder copy codec: one at priority 4, the other at priority 5. The server containing this codec is originally configured with the audio encoder running at priority 4, as shown in the following configuration code (assuming that Server.MINPRI is 1):
</p><p>&lt;syntaxhighlight lang='javascript'&gt;
Server.algs = [
</p>
<pre>   {name: "audenc_copy", mod: AUDENC_COPY, threadAttrs: {
       stackMemId: 0, priority: Server.MINPRI + 3}
   },
   ...
</pre>
<p>];
&lt;/syntaxhighlight&gt;
</p><p>It may seem that the solution to this problem is to configure the DSP Server by adding another audio encoder with the new priority and a different name to the list of server algorithms, as follows:
</p><p>&lt;syntaxhighlight lang='javascript'&gt;
Server.algs = [
</p>
<pre>   /* Audio copy encoder configured with priority 4 */
   {name: "audenc_copy", mod: AUDENC_COPY, threadAttrs: {
      stackMemId: 0, priority: Server.MINPRI + 3}
   },
</pre>
<pre>   /* Audio copy encoder configured with priority 5 (<b>WRONG</b>)*/
   {name: "audenc_copy_2", mod: AUDENC_COPY, threadAttrs: {
      stackMemId: 0, priority: Server.MINPRI + 4}
   },
   ...
</pre>
<p>];
&lt;/syntaxhighlight&gt;
</p><p>However, this generates an error when trying to rebuild the server, since the auto-generated UUIDs for these two codecs, determined by the mod (AUDENC_COPY) configuration parameter, will be identical. Since it is the UUID, and not the codec name, that is passed internally from the ARM application to the DSP server to instantiate the codec, these two codecs would be indistinguishable. Therefore, this method will not work.
</p><p>The correct way to create a codec with a priority other than the one configured in the DSP server, is through the name parameter passed to the <i>MOD</i><code>_create()</code> API.  The name will be the codec name with the overriding priority appended to it, separated with a ":". For example, to run the audio encoder shown above at priority 5, pass the name "audenc_copy:5" to <code>AUDENC_create()</code>.  The following code fragment creates two audio copy encoders running at different priorities (error checking is left out for readability).
</p><p>&lt;syntaxhighlight lang='c'&gt;
Engine_Handle  hEngine;
AUDENC_Handle  enc;
AUDENC_Handle  enc_high;
</p><p>hEngine = Engine_open("audio_copy", NULL, NULL);
</p><p>/* Create codec at the server-configured priority */
enc = AUDENC_create(hEngine, "audenc_copy", NULL);
</p><p>/*
</p>
<pre>* Create second instance of codec, overriding the
* server-configured priority with a priority of 5.
*/
</pre>
<p>enc_high = AUDENC_create(hEngine, "audenc_copy:5", NULL);
&lt;/syntaxhighlight&gt;
</p>
<h3><span id="Overriding_an_Algorithm's_Memory_Requests"></span><span class="mw-headline" id="Overriding_an_Algorithm.27s_Memory_Requests">Overriding an Algorithm's Memory Requests</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=20" title="Edit section: Overriding an Algorithm&#039;s Memory Requests">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>It is possible to ignore a codec's requests for placement of allocated buffers and force all of the codec's memory requests to be allocated in the external heap mapped to the DSKT2 module's ESDATA configuration parameter.
</p><p>This is also done by appending to the codec name passed to the <i>MOD</i><code>_create()</code> function.  To override memory placement requests, append ":1" to the name <i>after</i> the adjustment for priority. For example, the names below passed to <code>AUDENC_create()</code> have the following meanings:
</p>
<ul><li>"audenc_copy:5:1"</li></ul>
<dl><dd>Create audenc_copy with priority 5 and with buffers allocated in external memory.</dd></dl>
<ul><li>"audenc_copy::1"</li></ul>
<dl><dd>Create audenc_copy with its configured priority and with buffers allocated in external memory.</dd></dl>
<p>Appending "::0" to the codec name (or ":0" if a new priority is also appended), means the codec memory requests should be respected. For example, passing the following names to AUDENC_create() are equivalent:
</p>
<ul><li>"audenc_copy"</li>
<li>"audenc_copy::0"</li></ul>
<h1><span class="mw-headline" id="The_Server_APIs">The Server APIs</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=21" title="Edit section: The Server APIs">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>On multicore systems (both heterogeneous and homogenous), Engines that are configured with remote algorithms (e.g., algorithms on other processors) transparently use a "Server".  The Server is an executable that includes algorithms and their frameworks (e.g., BIOS, <a href="Framework_Components_FAQ.html" title="Framework Components FAQ">Framework Components</a>, codecs, etc).
</p><p>For heterogeneous systems where Link is used, the Server typically is dynamically loaded onto the remote processor during <code>Engine_open()</code>.
</p><p>The Server APIs can be used by applications to access information about the remote Server and to control the Server.  More specifically, these APIs allow an application to obtain information about the number of memory heaps configured in the Server, the current usage of an individual memory heap, and to reconfigure the base and size of the Server's algorithm heap.
</p><p>The APIs related to the Server are:
</p>
<ul><li><code>Engine_getServer()</code> - Get the handle to a Server.</li>
<li><code>Server_getNumMemSegs()</code> - Get the number of heaps in a Server.</li>
<li><code>Server_getMemStat()</code> - Get statistics about a Server heap.</li>
<li><code>Server_redefineHeap()</code> - Set base and size of a Server heap.</li>
<li><code>Server_restoreHeap()</code> - Reset Server heap to default base and size.</li></ul>
<h2><span class="mw-headline" id="Getting_a_Server_Handle">Getting a Server Handle</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=22" title="Edit section: Getting a Server Handle">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To access the Server for the Engine, the application must first obtain a Server handle by calling the <code>Engine_getServer()</code> API.  For example:
</p><p>&lt;syntaxhighlight lang='c'&gt;
Engine_Handle hEngine;
Server_Handle hServer;
</p><p>hEngine = Engine_open("auddec", NULL, NULL);
hServer = Engine_getServer(hEngine);
&lt;/syntaxhighlight&gt;
</p>
<hr />
<p><b>Note:</b> As with Engine handles, Server handles are not thread protected. Each thread that uses a Server handle must perform its own <code>Engine_getServer()</code> call (using its own Engine handle) or guarantee synchronized access to a shared Server handle.
If the value returned by <code>Engine_getServer()</code> is NULL, then the Engine has no Server.
</p>
<hr />
<h2><span class="mw-headline" id="Getting_Memory_Heap_Information">Getting Memory Heap Information</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=23" title="Edit section: Getting Memory Heap Information">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The application can obtain the number of memory heaps configured into the Server by calling <code>Server_getNumMemSegs()</code>. For example:
</p><p>&lt;syntaxhighlight lang='c'&gt;
Server_Handle hServer;
Int numSegs;
</p><p>/* Get the server handle from a previously opened Engine */
hServer = Engine_getServer(hEngine);
</p><p>/* Determine how many memory segments exist on the remote Server */
Server_getNumMemSegs(hServer, &amp;numSegs);
&lt;/syntaxhighlight&gt;
</p><p>This API returns the following error codes:
</p>
<ul><li><code>Server_EOK</code> - success. In this case, <code>numSegs</code> contains the number of heaps in the Server.</li>
<li><code>Server_ERUNTIME</code> - an internal runtime error occurred.</li></ul>
<p>Once the number of heaps is known, the application can then iterate through this number, to obtain statistics about each heap, using <code>Server_getMemStat()</code>. The memory statistics are returned in a <code>Server_MemStat</code> structure:
</p><p>&lt;syntaxhighlight lang='c'&gt;
typedef struct Server_MemStat {
</p>
<pre>   Char   name[Server_MAXSEGNAMELENTH+1];  /* Name of heap segment */
   Uint32 base;                            /* Base address of heap */
   Uint32 size;                            /* Original heap size */
   Uint32 used;                            /* DSP MAUs of heap used */
   Uint32 maxBlockLen;                     /* Length of largest free block */
</pre>
<p>} Server_MemStat;
&lt;/syntaxhighlight&gt;
</p><p>The following example code shows the usage of these APIs (error checking is left out for readability).
</p><p>&lt;syntaxhighlight lang='c'&gt;
Server_Handle hServer;
Int i, numSegs;
Server_MemStat stat;
</p><p>/* Determine how many memory segments exist on the remote Server */
Server_getNumMemSegs(hServer, &amp;numSegs);
</p><p>/* For each memory segment, print details about it */
for (i = 0; i &lt; numSegs; i++) {
</p>
<pre>   Server_getMemStat(hServer, i, &amp;stat);
   printf("%s: base: 0x%x size: 0x%x used: 0x%x, max free block: 0x%x",
           stat.name, stat.base, stat.size, stat.used, stat.maxBlockLen);
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p><p>The values returned by <code>Server_getMemStat()</code> are the following:
</p>
<ul><li><code>Server_EOK</code> - Success</li>
<li><code>Server_ENOTFOUND</code> - The segment number was out of range</li>
<li><code>Server_ERUNTIME</code> - An internal runtime error occurred</li></ul>
<h2><span id="Reconfiguring_the_Server's_Algorithm_Heap"></span><span class="mw-headline" id="Reconfiguring_the_Server.27s_Algorithm_Heap">Reconfiguring the Server's Algorithm Heap</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=24" title="Edit section: Reconfiguring the Server&#039;s Algorithm Heap">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Note, this is an advanced feature that most users will not utilize.
</p><p>The Server is configured with a memory segment that is used exclusively for algorithm heaps - <a href="DDRALGHEAP.html" title="DDRALGHEAP">DDRALGHEAP</a>.  In some situations, the Server may intentionally be configured with a minimal algorithm heap, with the intent that the application may want to provide, at runtime, a larger contiguous memory block to be used by the Server for the algorithm heap.  This enables the algorithm heap to be allocated at runtime (rather than reserved at build time), and allows the app processor to use this memory for other purposes when the Server is not being used.
</p><p>The following Server APIs provide the means to reconfigure the algorithm heap:
</p><p>&lt;syntaxhighlight lang='c'&gt;
Server_Status Server_redefineHeap(Server_Handle server, String name, Uint32 base, Uint32 size);
</p><p>Server_Status Server_restoreHeap(Server_Handle server, String name);
&lt;/syntaxhighlight&gt;
</p><p>The <code>name</code> parameter passed to these functions is the name of the heap to be reconfigured; it must not be more than <code>Server_MAXSEGNAMELENGTH</code> characters long. The <code>base</code> address passed to <code>Server_redefineHeap()</code> must be a Server-appropriate address, and the memory from base to base + size must be physically contiguous. The <code>size</code> parameter is given in Server-specific MADUs (minimum addressable data units).  The base address should be 8-byte aligned, but there are no alignment restrictions on size; a value of 0 for size is acceptable.
</p><p>The Server's algorithm heap can only be reconfigured when no memory is currently allocated in the heap.  The <code>Server_restoreHeap()</code> function resets the base address and size of the algorithm heap back to their original values (the values before any calls to <code>Server_redefineHeap()</code> were made). After a successful call to <code>Server_restoreHeap()</code>, the memory previously "redefined" to the heap can be used again by the system.
</p><p>The return values of <code>Server_redefineHeap()</code> are the following:
</p>
<ul><li><code>Server_EOK</code> - Success.</li>
<li><code>Server_EINVAL</code> - Changing to the new base address and size would cause an overlap with another heap.</li>
<li><code>Server_EINUSE</code> - Memory is currently allocated in the algorithm heap.</li>
<li><code>Server_ENOTFOUND</code> - No heap with the given name was found.</li>
<li><code>Server_ERUNTIME</code> - An internal runtime error occurred.</li></ul>
<p><code>Server_restoreHeap()</code> returns any of the following values:
</p>
<ul><li><code>Server_EOK</code> - Success.</li>
<li><code>Server_EINVAL</code> - Changing back to the original base address and size would cause an overlap with another heap.</li>
<li><code>Server_EINUSE</code> - Memory is currently allocated in the algorithm heap.</li>
<li><code>Server_ENOTFOUND</code> - No heap with the given name was found.</li>
<li><code>Server_ERUNTIME</code> - An internal runtime error occurred.</li></ul>
<p>The following code illustrates how these two APIs could be used on a GPP+DSP device.  In this example, a physically contiguous chunk of memory is allocated by the GPP application using <code>Memory_contigAlloc()</code>. However, the address returned by this function is a virtual address on the GPP, so it must be converted to a DSP address before passing it to <code>Server_redefineHeap()</code>. The <code>Memory_getBufferPhysicalAddress()</code> function converts the virtual address to a physical address on the GPP.
</p><p>After the algorithm is run, the algorithm heap is reset to its original size and location. Error checking is left out for better readability.
</p><p>&lt;syntaxhighlight lang='c'&gt;
Engine_Handle hEngine;
Server_Handle hServer;
XDAS_Int8  *buf;
Uint32 physAddr;
</p><p>/*
</p>
<pre>* Open the Engine and get Server handle. Note, the
* Engine_open() call will load and start the DSP.
*/
</pre>
<p>hEngine = Engine_open("audio_copy", NULL, NULL);
hServer = Engine_getServer(hEngine);
</p><p>/* Allocate a large block of physically contiguous memory for our "alg heap" */
buf = (XDAS_Int8 *)Memory_contigAlloc(BUFSIZE, ALIGNMENT);
</p><p>/* Convert virtual address to physical address. */
physAddr = Memory_getBufferPhysicalAddress(buf, BUFSIZE, NULL);
</p><p>/* Reconfigure the algorithm heap */
Server_redefineHeap(hServer, "DDRALGHEAP", physAddr, BUFSIZE);
</p><p>/* ...Create, run and delete codecs... */
</p><p>/* Reconfigure alg heap back to its original state. */
Server_restoreHeap(hServer, "DDRALGHEAP");
</p><p>/* Free the "alg heap" buffer */
Memory_contigFree(buf, BUFSIZE);
&lt;/syntaxhighlight&gt;
</p><p>In other scenarios, the application may need to reconfigure the algorithm heap to an address that is not obtained by allocating a buffer on the ARM. For example, suppose there are fixed memory spaces on the DSP that the application will alternate between for the algorithm heap, depending on what algorithms will be run. In this case, the application can pass the DSP address directly to <code>Server_redefineHeap()</code>.
</p>
<h2><span class="mw-headline" id="Getting_Trace_from_the_Server">Getting Trace from the Server</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=25" title="Edit section: Getting Trace from the Server">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The Server API, <code>Server_setTrace()</code>, provides a way to set trace masks on the remote server from the host application at run-time. This function takes a server handle and trace mask string as arguments:
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<pre>   Int Server_setTrace(Server_Handle server, String mask)
</pre>
<p>&lt;/syntaxhighlight&gt;
</p><p>The format of the mask string depends on whether you are using a BIOS 5 or a BIOS 6 based version of Codec Engine. Please see the appropriate section of, “What about Software Trace?” for the description of trace mask strings that apply.
</p><p><code>Server_fwriteTrace()</code> can be used to write the server’s trace buffer to a file stream. The API is the following:
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<pre>   Int Server_fwriteTrace(Server_Handle server, String prefix, FILE *out)
</pre>
<p>&lt;/syntaxhighlight&gt;
</p><p>The ‘prefix’ string will be pre-pended to each output line for easy identification. This function returns the number of bytes written to the file stream, including the ‘prefix’ string. If you do not want a prefix to be pre-pended to the trace output, just use “” for the ‘prefix’ string (not NULL).
</p><p>In multi-process systems where the Link Arbiter Daemon (LAD) is used to channel requests to the server, <code>Server_connectTrace()</code> should be called before calling the Server trace APIs, and <code>Server_disconnectTrace()</code> should be called after (see example below).
</p><p>Below are two examples of <code>Server_setTrace()</code> and <code>Server_fwriteTrace()</code> usage, the first for BIOS 5 versions of Codec Engine, and the second for BIOS 6 versions. The only difference between the two use cases are the masks passed to <code>Server_setTrace()</code>.
</p>
<h3><span class="mw-headline" id="Example_BIOS_5">Example BIOS 5</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=26" title="Edit section: Example BIOS 5">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In this example, it is assumed that LAD is used to send requests to the server. Error checking has been omitted from the code fragment below, but the source code in the Codec Engine example app, server_api_example, can be consulted for proper error handling. Here we turn on trace levels 0, 5, 6, and 7 for all Codec Engine modules. The level 0 is used mainly for function entry and exit, levels 5, 6, and 7 correspond to benchmark trace, warnings, and errors, respectively.
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<pre>   /* Connect for server trace data */
   status = Server_connectTrace(server, &amp;traceToken);
</pre>
<pre>   /* Set server trace mask */
   status = Server_setTrace(server, "*=0567");
</pre>
<pre>   /* Dump server trace to stdout */
   count = Server_fwriteTrace((Server_Handle)server, "", stdout);
</pre>
<pre>   /* discconnect from server trace data */
   status = Server_disconnectTrace(server, traceToken);
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="Example_BIOS_6">Example BIOS 6</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=27" title="Edit section: Example BIOS 6">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In this example, we assume LAD is not used, and as in the previous example, we will turn on function entry and exit tracing, and levels 5, 6, and 7 of Codec Engine modules. See “Trace Mask Values” for details on the different trace level values.
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<pre>   /* Set server trace mask */
   status = Server_setTrace(server, "ti.sdo.ce.%=EX567");
</pre>
<pre>   /* Dump server trace to stdout */
   count = Server_fwriteTrace((Server_Handle)server, "", stdout);
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<h2><span class="mw-headline" id="Getting_Server_CPU_Load">Getting Server CPU Load</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=28" title="Edit section: Getting Server CPU Load">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Applications running on the host can call <code>Server_getCpuLoad()</code> to get an estimate of the CPU load on the remote server. The CPU load is averaged over the benchmark window configured for the ti.sysbios.utils.Load module. Below is an example of <code>Server_getCpuLoad()</code>:
</p><p>&lt;syntaxhighlight lang='c'&gt;
Engine_Handle   engine = NULL;
Server_Handle   server = NULL;
Int             load = 0;
</p><p>/* initialize Codec Engine runtime first */
CERuntime_init();
</p><p>engine = Engine_open(engineName, NULL, NULL);
server = Engine_getServer(engine);
</p><p>load = Server_getCpuLoad(server);
&lt;/syntaxhighlight&gt;
</p><p>Note that <code>Server_getCpuLoad()</code> simply leverages the BIOS Load feature.  In BIOS 5, this was provided via the BIOS Utils product.  The Load feature was subsequently integrated into, and redistributed with, BIOS 6.
</p>
<h3><span class="mw-headline" id="Example_BIOS_5_2">Example BIOS 5</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=29" title="Edit section: Example BIOS 5">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Prior to CE 1.20, users had to explicitly add the following to their server .cfg scripts to enable CPU load gathering:
&lt;syntaxhighlight lang='javascript'&gt;
var Load = xdc.useModule('ti.bios.utils.Load');
&lt;/syntaxhighlight&gt;
In addition, they had to call <code>Load_init()</code> after <code>CERuntime_init()</code> in their <code>main()</code> fxn, as follows:
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<ol><li>include &lt;ti/bios/utils/load/Load.h&gt;</li></ol>
<p>Void main(Int argc, Char *argv[])
{
</p>
<pre>   /* init Codec Engine */
   CERuntime_init();
</pre>
<pre>   Load_init();
   ...
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p><p>In CE 1.20 and later, this is taken care of internally by <code>CERuntime_init()</code>, and neither of these steps (.cfg script nor <code>Load_init()</code>) are required.
</p>
<h3><span class="mw-headline" id="Example_BIOS_6_2">Example BIOS 6</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=30" title="Edit section: Example BIOS 6">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The following code can be added to a BIOS 6 server to enable gathering of CPU load data by the Host application.
</p><p>&lt;syntaxhighlight lang='javascript'&gt;
var Load = xdc.useModule('ti.sysbios.utils.Load');
</p><p>Load.hwiEnabled = false;
Load.swiEnabled = false;
Load.taskEnabled = true;
Load.autoAddTasks = false;
Load.common$.diags_USER4 = Diags.ALWAYS_OFF;
&lt;/syntaxhighlight&gt;
</p>
<h1><span id="What_Happens_to_DSP_Memory_Issues?"></span><span class="mw-headline" id="What_Happens_to_DSP_Memory_Issues.3F">What Happens to DSP Memory Issues?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=31" title="Edit section: What Happens to DSP Memory Issues?">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>The VISA APIs to create and delete algorithms provided by the Codec Engine manage all algorithm resources. This includes the CPU, memory, direct memory access (DMA), and more. The VISA creation and deletion APIs hide most of the details of the codecs' memory and resource management.
</p>
<h2><span class="mw-headline" id="Buffer_Handling_and_Shared_Memory_Maps">Buffer Handling and Shared Memory Maps</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=32" title="Edit section: Buffer Handling and Shared Memory Maps">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>It is the responsibility of the application to handle all I/O and buffering issues.  The VISA APIs use various buffer descriptors (e.g. XDM_BufDesc, XDM_BufDesc1, IVIDEO_BufDesc, etc) to manage data buffers.
</p><p>In shared memory-based systems (e.g. OMAP3, DM644x, OMAP-L13x, etc), you must use memory that both the app and server can access (e.g. <a href="CMEM_Overview.html" title="CMEM Overview">CMEM</a>).  This enables efficient data passing between cores as only pointers are passed and no copies are made.  In addition, these shared memory-based buffers must be physically contiguous and cache-aligned.
</p><p>For example, the DM644x default memory map is designed with the intent to provide generous amount of space for DSP code and data, plenty of private heap for DSP algorithms, and a large space for shared buffers between GPP and DSP.
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">

<caption><i>Table 4–3  DM644x Default Memory Map</i>
</caption>
<tbody><tr>
<th>Address (hex)
</th>
<th>Address (decimal)
</th>
<th>Size
</th>
<th>Segment
</th>
<th>Comments
</th></tr>
<tr>
<td>0x80000000 ..
<p>0x87800000
</p>
</td>
<td>0-120MB
</td>
<td>120MB
</td>
<td>Linux
</td>
<td>booted with MEM=120M
</td></tr>
<tr>
<td>0x87800000 ..
<p>0x88000000
</p>
</td>
<td>120-128MB
</td>
<td>8MB
</td>
<td>CMEM
</td>
<td>shared buffers between GPP and DSP
</td></tr>
<tr>
<td>0x88000000 ..
<p>0x8FA00000
</p>
</td>
<td>128-250MB
</td>
<td>122MB
</td>
<td>DDRALGHEAP *
</td>
<td>DSP segment used exclusively for algorithm heaps
</td></tr>
<tr>
<td>0x8FA00000 ..
<p>0x8FE00000
</p>
</td>
<td>250-254MB
</td>
<td>4MB
</td>
<td>DDR *
</td>
<td>DSP segment for code, stack, and static data
</td></tr>
<tr>
<td>0x8FE00000 ..
<p>0x8FF00000
</p>
</td>
<td>254-255MB
</td>
<td>1MB
</td>
<td>DSPLINKMEM *
</td>
<td>memory for DSPLINK
</td></tr>
<tr>
<td>0x8FF00000 ..
<p>0x8FF00080
</p>
</td>
<td>255MB-255MB
</td>
<td>128B
</td>
<td>CTRLRESET *
</td>
<td>memory for reset vectors
</td></tr>
<tr>
<td>0x8FF00080 ..
<p>0x8FFFFFFF
</p>
</td>
<td>255MB-256MB
</td>
<td>1MB
</td>
<td>-- unnamed --
</td>
<td>
</td></tr></tbody></table>
<p><small>(*) are actual DSP linker segments.</small>
</p>
<h2><span class="mw-headline" id="Memory_Fragmentation">Memory Fragmentation</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=33" title="Edit section: Memory Fragmentation">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>For dual CPU applications, the exception to the rule that the Codec Engine hides DSP memory management issues from the GPP application developer is that buffers passed to the DSP must be contiguous in physical memory and cache-aligned.
</p><p>This differs from buffer handling on the GPP because Linux and similar GPP operating systems handle non-contiguous buffers through a memory management unit (MMU) that holds a table matching virtual addresses to physical addresses.  Many DSPs have no such table.  (Note that the OMAP35x devices <b>do</b> have a DSP-side MMU, but Codec Engine still requires that buffers passed from the GPP to a remote DSP be physically contiguous.)
</p><p>The Codec Engine verifies that these constraints are met in the required platform for data buffers. Algorithm buffers are managed by the Memory_ module, which uses pools of different sizes to ensure that memory is not fragmented.
</p><p>However, the storage space for codec instances created by the Codec Engine must also be contiguous and cache-aligned. The creation and deletion of codec instances is non-deterministic. For example, if your application follows steps like those in the figure below, it may be impossible to recreate a codec instance that was created and deleted earlier:
</p>
<div style="text-align: center;">
<p><a href="File_Using_ce_apis_buffer_creation.html" class="image" title="buffer creation and deletion"><img alt="buffer creation and deletion" src="https://processors.wiki.ti.com/images/c/cf/Using_ce_apis_buffer_creation.PNG" width="382" height="137" /></a><br /><b>Figure 1. Non-Deterministic Buffer Creation and Deletion</b>
</p>
</div>
<p>Since instance creation occurs "in the background" while other codecs are running at higher priorities, you cannot guarantee the time required to create an instance. You can, however, control the order in which instances are created and deleted.
</p><p>If a codec or shared buffer is not physically contiguous, when the caller calls <code>Memory_getBufferPhysicalAddress()</code> with a non-NULL pointer for the Boolean <code>*isContiguous</code> arguments, the Codec Engine sets the ptr data to true or false without printing any message. If the pointer is NULL (which is most likely, since this function is called by the codec stubs, which pass NULL for this ptr), the level 7 trace message is:
</p>
<pre>Memory_getBufferPhysicalAddress&gt; ERROR: user buffer at addr=&lt;hex addr&gt;, size=&lt;size in bytes&gt; is NOT contiguous
This message is printed only if level 7 tracing is enabled, which is the default.
</pre>
<h2><span class="mw-headline" id="Cache_Alignment">Cache Alignment</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=34" title="Edit section: Cache Alignment">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Devices that utilize a cache (for example, the C64+) also require that I/O buffers be cache-aligned. For example, the DSP L2 cache line size on the C64x+ is 128 bytes. Storage space allocated must start at a cache line boundary, and the size must be a multiple of the cache line length.
If these alignment and size constraints are violated, any data object allocated adjacent to the application buffer will share a cache line with a portion of the application buffer. This line may be corrupted as a result of the Cache Controller writing back the shared cache line.
</p>
<h2><span class="mw-headline" id="Cache_Coherence">Cache Coherence</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=35" title="Edit section: Cache Coherence">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>When developing an application for a multiprocessor platform (including those with multiple processing cores, hardware accelerators, and DMA Engines) in which some memory regions are cached, you must perform some memory coherence operations. The Codec Engine framework, when it has enough information, automatically handles some <a href="Cache_Management.html#What_Should_I_know_about_Cache_Coherence.3F" title="Cache Management">cache coherence</a> operations. However, ultimately, the application developer is responsible for ensuring that certain pre-and post-conditions are met for the buffers the application submits and receives from the Codec Engine.
The subsections that follow summarize the responsibilities of the application developer for different processor environments.
</p>
<h3><span id="GPP_+_DSP_Environments"></span><span class="mw-headline" id="GPP_.2B_DSP_Environments">GPP + DSP Environments</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=36" title="Edit section: GPP + DSP Environments">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The following are common issues in the DaVinci environment, though they are present in any multi-core system that utilizes a cache.
Note that the Codec Engine Framework enforces some of these rules in the implementation of the VISA APIs. You should be aware of these rules when accessing shared memory outside the use of the VISA APIs.
</p>
<ul><li>Input Buffers. This is the case when a GPP application captures/generates a buffer and passes it to the DSP.
<ul><li>GPP side. Input buffers must be written-back before each process/control call. (Otherwise, DSP CPU/DMA accesses will access incoherent data in external memory, with no ability to writeback the GPP-side cache.) If a buffer is not cached on the GPP side, a writeback is not required. When a driver fills a GPP-cached input buffer, before passing it to the Codec Engine, the driver should do the following: 1) Start with a cache invalidated buffer. 2) The driver can use DMA or CPU writes to fill the buffer. 3) If CPU is used to fill the buffer, it must be written-back before passing the buffer to Codec Engine.</li>
<li>DSP side. Input buffers must be invalidated before each process/control call. (Otherwise the DSP may read stale data from its cache. This is possible if the same buffer was passed in an earlier call.) Note that the default skeletons for the VISA APIs automatically invalidate input buffers prior to invoking the algorithm's process function.</li></ul></li>
<li>Output Buffers.
<ul><li>GPP side. Output buffers must be invalidated before accessing them on the GPP side following DSP-side processing. (Otherwise the GPP may access stale data resident in its GPP-side cache.) If the buffers are not cache-enabled on the GPP side invalidation is not required.</li>
<li>DSP side. Output buffers must be invalidated before each process/control call. (Otherwise, if DMA is used to fill the buffer, there may be overwrites as cache lines are evicted due to unrelated CPU activity.) Also, output buffers must be written-back after each process/control call. (Otherwise the GPP may read incoherent data from external memory.) Note that the default skeletons for the VISA APIs automatically writeback output buffers following each process/control call.</li>
<li>DMA-Related. If the GPP or DSP uses DMA to access shared buffers, there is more work to ensure coherence. XDAIS provides some DMA rules for frameworks. See <a href="http://www.ti.com/lit/pdf/spru352" class="extiw" title="tidoc:spru352">TMS320 DSP Algorithm Standard Rules and Guidelines (SPRU352)</a> for details.</li></ul></li></ul>
<p>C6000 algorithms must not issue any CPU read/writes to buffers in external memory that are involved in DMA transfers. This also applies to the input buffers passed to the algorithm through its algorithm interface.
Some common cache-related errors are:
</p>
<ul><li>Doing a cache writeback-invalidate for DSP "input" buffers, instead of just an invalidate "before" a process/control call. In this case, if any of the "current" input buffers has been referenced in a "previous" process/control call, then a stale fragment of that buffer may already be resident in the DSP cache. A writeback will corrupt the "current" input buffer with stale data from the cache.</li>
<li>Doing a blind "ALL L2 Cache" writeback-invalidate, instead of a writeback or invalidate on only the algorithm's own input/output buffers. This creates potential problems for other algorithm instances, whose input/output buffers will be affected.</li>
<li>Invalidating all of L2 severely degrades performance for all algorithm instances, due to the resulting cache misses.</li></ul>
<h3><span class="mw-headline" id="Single-Processor_Environments">Single-Processor Environments</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=37" title="Edit section: Single-Processor Environments">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The following are common issues in the DM643x environment, though they are present in any single-CPU system that utilizes cached memory.
</p>
<ul><li>Input Buffers. This is the case when a DSP application captures/generates a buffer and passes it to the Codec Engine. Depending upon how the input buffers have been captured, the buffers must be either invalidated or written-back and invalidated:
<ul><li>If the application (or a driver) modified the contents of the input buffer using CPU read and/or write operations, the buffer must be written-back and invalidated.</li>
<li>If the application (or driver) modified the contents of the input buffer using DMA, then the buffer must not be written-back, but must still be invalidated.</li></ul></li></ul>
<dl><dd>In both cases, the application (or driver) should start filling a cache-invalidated buffer.</dd></dl>
<ul><li>Output Buffers. Output buffers (those filled by Codec Engine) must be invalidated before being submitted to the Codec Engine to be filled. And, when returned from the Codec Engine, the buffers should be written-back to ensure all data is written out to external memory.</li></ul>
<h1><span id="What_Happens_to_DSP_Real-Time_Issues?"></span><span class="mw-headline" id="What_Happens_to_DSP_Real-Time_Issues.3F">What Happens to DSP Real-Time Issues?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=38" title="Edit section: What Happens to DSP Real-Time Issues?">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>It is the responsibility of the GPP application to handle all multi-threading and real-time issues from a GPP perspective. For example, this may involve scheduling higher-frequency, short-duration processing (such as
audio) at a higher priority than long-duration processing (such as video) on Linux-based systems.
The DSP Server used transparently by the Codec Engine for remote algorithms handles multi-threading and reentrancy issues on the DSP. For platforms such as the DM644x that treat the DSP as a black box, threading issues on the DSP are managed by the Codec Server integration.
However, there are still some important considerations.
</p>
<h3><span class="mw-headline" id="Transaction_Latency">Transaction Latency</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=39" title="Edit section: Transaction Latency">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>It is important to consider transaction latency when running DSP algorithms from the GPP. For example, on the DM644x, the round-trip time required to schedule a DSP algorithm from the GPP limits transactions-per-second to approximately 7000. That is, the application can use the Codec Engine to run or control an algorithm up to 7000 times per second.
</p><p>This may seem like plenty of headroom when considering typical frame rates of 30 to 50 per second. However, be aware that applications with a high density of channels may run up against this limit.
</p>
<h3><span class="mw-headline" id="Multi-_vs._Uni-Processor_Performance">Multi- vs. Uni-Processor Performance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=40" title="Edit section: Multi- vs. Uni-Processor Performance">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The VISA APIs wait for the function to return. Thus, your application needs to be multi-threaded if you want other threads to use the processing time while waiting for the DSP to perform its algorithms.
</p><p>A discussion of managing multiple GPP threads in conjunction with the Codec Engine is beyond the scope of this document. See the documentation for your GPP operating system and/or middleware.
</p>
<h3><span class="mw-headline" id="Local_Performance">Local Performance</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=41" title="Edit section: Local Performance">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The Codec Engine is also optimized for local algorithm execution. The execution overhead is the same as that of XDAIS algorithms. The creation times are slightly higher.
</p>
<h1><span id="What_About_Codec_Engine_Debugging?"></span><span class="mw-headline" id="What_About_Codec_Engine_Debugging.3F">What About Codec Engine Debugging?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=42" title="Edit section: What About Codec Engine Debugging?">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<p>Codec Engine modules, both on the application and the server side, provide plenty of trace information that can be activated, to reveal what's happening internally.
</p><p>When any object in your application fails to be created—a codec or an Engine, either locally or on the DSP—follow the instructions in this section to turn on Codec Engine trace in order to do basic debugging. The section titled <a href="#What_About_Software_Trace.3F">What About Software Trace?</a> provides details about Codec Engine tracing, although it is generally needed when debugging real-time, performance issues.
</p>
<h2><span id="Codec_Engine_Debugging_from_the_ARM_on_ARM+DSP_Systems"></span><span class="mw-headline" id="Codec_Engine_Debugging_from_the_ARM_on_ARM.2BDSP_Systems">Codec Engine Debugging from the ARM on ARM+DSP Systems</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=43" title="Edit section: Codec Engine Debugging from the ARM on ARM+DSP Systems">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>See the <a href="CE_DEBUG.html" title="CE DEBUG">CE_DEBUG article</a> for details on easily enabling the detailed trace embedded throughout Codec Engine.
</p>
<h2><span class="mw-headline" id="Codec_Engine_Debugging_on_a_DSP-only_System">Codec Engine Debugging on a DSP-only System</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=44" title="Edit section: Codec Engine Debugging on a DSP-only System">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>On a BIOS-based system, assuming you are debugging your application from Code Composer Studio, you turn tracing on from your C code.  (This is primarily because CCS doesn't support setting environment variables on the target processor, making the <a href="CE_DEBUG.html" title="CE DEBUG">CE_DEBUG</a> technique of enabling trace impossible.)
</p><p>To do so, when you are ready to show Codec Engine trace information — which can be as soon as right after a call to <code>CERuntime_init()</code> — add the following lines to your code (assuming you have done #include &lt;stdio.h&gt; and #include &lt;ti/sdo/ce/trace/gt.h&gt;):
</p><p>&lt;syntaxhighlight lang='c'&gt;
/* print trace using printf() (which sends it to CCS's stdio console window) */
GT_setprintf((GT_PrintFxn)printf);
</p><p>/* for all modules (*), enable trace (+) for warnings (6) and errors (7) */
GT_set("*+67");
&lt;/syntaxhighlight&gt;
</p><p>The <code>GT_set()</code> call configures how much tracing to enable.  To turn on all tracing, use the following line instead:
</p><p>&lt;syntaxhighlight lang='c'&gt;
/* for all modules (*), enable trace (+) for all levels (01234567) */
GT_set("*+01234567");
&lt;/syntaxhighlight&gt;
</p>
<h1><span id="What_About_Software_Trace?"></span><span class="mw-headline" id="What_About_Software_Trace.3F">What About Software Trace?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=45" title="Edit section: What About Software Trace?">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<h2><span class="mw-headline" id="Software_Trace_for_BIOS_5_Based_Versions_of_Codec_Engine">Software Trace for BIOS 5 Based Versions of Codec Engine</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=46" title="Edit section: Software Trace for BIOS 5 Based Versions of Codec Engine">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>A utility module you use to assist with software tracing in Codec Engine applications is the <a href="TraceUtil.html" title="TraceUtil">TraceUtil</a> module. You can use this module for debugging and/or to collect real-time data.
</p><p>Additionally, tools like <a href="SoC_Analyzer.html" title="SoC Analyzer">SoC Analyzer</a> can be developed to help display trace data. TraceUtil can be used to simplify the use of such tools.
</p><p>TraceUtil lets you specify the amount of tracing you want and where you want it collected as follows:
</p>
<ul><li>At design time by setting configuration file attributes</li>
<li>At start time by setting environment variables</li>
<li>At run-time by writing command strings to a named UNIX pipe</li></ul>
<p>TraceUtil manages the three kinds of tracing that Codec Engine modules can produce:
</p>
<ul><li>Tracing on the GPP side. Many Codec Engine and other GPP-side modules drop trace strings describing their state or warning and error messages.</li>
<li>Tracing on the DSP side. DSP-side modules may provide trace information that can be collected by TraceUtil on the GPP-side.</li>
<li>DSP/BIOS logging on the DSP side. DSP/BIOS provides the TRC and LOG modules to collect information about various DSP/BIOS system events such as task switching. You can use the TraceUtil module to enable such DSP/BIOS tracing remotely. Unlike the other kinds of trace, which are ASCII text, the DSP/BIOS log is a binary file.</li></ul>
<p>As a supplement to TraceUtil, GPP-side code can also use printf(), or you can use the GNU Project Debugger (GDB) on GPP-side code.
</p>
<h3><span class="mw-headline" id="Configuring_TraceUtil_at_Design_Time">Configuring TraceUtil at Design Time</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=47" title="Edit section: Configuring TraceUtil at Design Time">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>To enable the TraceUtil module, your must add this line to your GPP application's configuration (.cfg) script. Any location in the script is fine.
</p><p>&lt;syntaxhighlight lang='javascript'&gt;
var TraceUtil = xdc.useModule('ti.sdo.ce.utils.trace.TraceUtil');
&lt;/syntaxhighlight&gt;
</p><p>The default TraceUtil settings cause the GPP application to:
</p>
<ul><li>Print all GPP-side errors and warnings to the standard output.</li>
<li>Collect DSP-side errors and warnings every 200 ms and print them to standard output.</li>
<li>Not enable or capture any DSP/BIOS logging.</li></ul>
<p>Constants are provided to set trace attributes for NO_TRACING, DEFAULT_TRACING, SOCRATES_TRACING, and FULL_TRACING.
</p><p>Instead of using the default, you can add the following line to your .cfg file to print information in the form the SoC Analyzer can use:
</p><p>&lt;syntaxhighlight lang='javascript'&gt;
TraceUtil.attrs = TraceUtil.SOCRATES_TRACING;
&lt;/syntaxhighlight&gt;
</p><p>The set of attributes configured with the SOCRATES_TRACING option enable SoC Analyzer tracing and DSP/BIOS logging. GPP-side trace information is stored in the /tmp/cearmlog.txt file, DSP-side trace information is placed in /tmp/cedsp0log.txt, and DSP/BIOS logging goes to /tmp/bioslog.dat. Polling is initially disabled.
</p><p>With this option, the application begins running with tracing disabled. To turn tracing on, you or your program must write a command to turn tracing on to the trace command pipe. See the section <a href="#Controlling_Trace_at_Run-Time_Through_a_Named_Pipe">Controlling Trace at Run-Time Through a Named Pipe</a> for details.
</p><p>Another option is to add the following line to your .cfg file to enable all types of tracing possible:
</p><p>&lt;syntaxhighlight lang='javascript'&gt;
TraceUtil.attrs = TraceUtil.FULL_TRACING;
&lt;/syntaxhighlight&gt;
</p><p>The output destinations are the same as for SOCRATES_TRACING, but FULL_TRACING enables all levels of trace for both the GPP and DSP.
</p><p>You can further control the details of tracing behavior by setting individual TraceUtil.attrs fields in your .cfg file. For details, see the reference documentation for the ti.sdo.ce.utils.trace.TraceUtil module in the Configuration Reference, which is available at CE_INSTALL_DIR/xdoc/index.html
</p>
<h3><span id="Supporting_TraceUtil_in_Your_Application's_C_Code"></span><span class="mw-headline" id="Supporting_TraceUtil_in_Your_Application.27s_C_Code">Supporting TraceUtil in Your Application's C Code</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=48" title="Edit section: Supporting TraceUtil in Your Application&#039;s C Code">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>To collect the trace information that the DSP produces, you must add these lines of C code to your GPP application:
</p><p>&lt;syntaxhighlight lang='c'&gt;
/* call TraceUtil_start() after CERuntime_init() */
TraceUtil_start(engineName);  /* engineName is a string */
</p><p>...
</p><p>TraceUtil_stop();   /* call at end of your app */
&lt;/syntaxhighlight&gt;
</p><p>This code spawns a thread that collects all available DSP trace messages and dumps them to a file or standard output. (It also collects and stores DSP/BIOS LOG information if you want it to do so.)
</p>
<h3><span id="Configuring_the_DSP_Server_for_DSP/BIOS_Logging"></span><span class="mw-headline" id="Configuring_the_DSP_Server_for_DSP.2FBIOS_Logging">Configuring the DSP Server for DSP/BIOS Logging</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=49" title="Edit section: Configuring the DSP Server for DSP/BIOS Logging">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If you set TraceUtil on the GPP side to use DSP/BIOS logging, you must also have DSP/BIOS logging enabled in your DSP Server image. To do this, add the following line to your DSP Server's configuration script:
</p><p>&lt;syntaxhighlight lang='javascript'&gt;
var LogServer = xdc.useModule('ti.sdo.ce.bioslog.LogServer');
&lt;/syntaxhighlight&gt;
</p><p>If your DSP Server is incapable of DSP/BIOS logging, you will see GPP-side error/warning messages like the following:
</p>
<pre>LogClient_connect&gt; Error: failed to locate server queue, Check if your DSP image has DSP/BIOS logging enabled
LogClient_fwriteLogs&gt; Warning: not connected to the DSP/BIOS log server on the DSP, cannot collect any DSP/BIOS log data.
</pre>
<h3><span class="mw-headline" id="Configuring_the_DSP_Server_To_Redirect_Trace_Output">Configuring the DSP Server To Redirect Trace Output</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=50" title="Edit section: Configuring the DSP Server To Redirect Trace Output">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>When debugging a DSP Server or single-processor DSP application using Code Composer Studio (CCStudio), you can direct trace information to go directly to CCStudio's output window. To do this, modify the main() routine to make the following call before calling CERuntime_init():
</p><p>&lt;syntaxhighlight lang='c'&gt;
GT_setprintf((GT_PrintFxn)printf);
&lt;/syntaxhighlight&gt;
</p><p>This causes each trace call to map to the DSP standard I/O library's printf() function, which sends output to the CCStudio console window.
</p><p>Note that the argument to the GT_setprintf() function can be any function that takes (char *format, …) arguments. So, for example, you could provide your own function that, for example, sends trace information to a serial port.
</p>
<h3><span class="mw-headline" id="Configuring_TraceUtil_at_Application_Start_Time">Configuring TraceUtil at Application Start Time</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=51" title="Edit section: Configuring TraceUtil at Application Start Time">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Before you run your TraceUtil-enabled application, you can set one or more of the following environment variables to override the TraceUtil attributes you specified in your .cfg script:
</p>
<ul><li>CE_TRACE. Mask for the GPP-side tracing. See the section <a href="#Trace_Mask_Values">Trace Mask Values</a> for mask details. For example:</li></ul>
<p><code>    CE_TRACE="*=0567;OM-0"</code>
</p>
<ul><li>CE_TRACEFILE. Specify the output file for GPP trace information. This can be a full path (for example, /tmp/local.txt) or a path relative to the executing application. If the file can't be opened (for example, if this points to a directory that doesn't exist), the trace goes to the standard output. For example:</li></ul>
<p><code>    CE_TRACE="trace/armtrace.txt";</code>
</p>
<ul><li>CE_TRACEFILEFLAGS. Set file creation flags for all files to be opened. Use the standard fopen() flags—"a" means append; "w" means over-write. For example:</li></ul>
<p><code>    CE_TRACEFILEFLAGS="a"</code>
</p>
<ul><li>TRACEUTIL_DSP0TRACEFILE. Specify the output file for DSP trace information. As with CE_TRACEFILE, this can be a full path or a path relative to the executing application. If the file cannot be opened, the trace goes to the standard output.</li>
<li>TRACEUTIL_DSP0BIOSFILE. Specify the output binary file for the DSP/BIOS log. This can be a full path or a path relative to the executing application. If the file cannot be opened, the log information is not collected.</li>
<li>TRACEUTIL_DSP0TRACEMASK. Mask for DSP-side tracing. See the section <a href="#Trace_Mask_Values">Trace Mask Values</a> for mask details. For example:</li></ul>
<p><code>    TRACEUTIL_DSP0TRACEMASK="*+01;ti.bios=01234567"</code>
</p>
<ul><li>TRACEUTIL_REFRESHPERIOD. Specify the number of milliseconds to sleep before the GPP-side collects the next set of DSP-side trace information. Your choice should vary depending on the amount of trace generated and the size of the trace logs. Failure to set this low enough may result in data loss.</li>
<li>TRACEUTIL_CMDPIPE. The name of a UNIX named pipe (for example, "fifo") to which the TraceUtil module should listen for runtime trace commands.</li>
<li>TRACEUTIL_VERBOSE. Set to 1 if you want TraceUtil to print the trace settings (masks and files) it is using and where it got them from. Set to 2 or higher to show more debugging information. In most cases, TRACEUTIL_VERBOSE=1 is recommended.</li></ul>
<p>If you use the bash shell on Linux, it is especially convenient to set environment variables in the same line where you start your application, so they apply to that execution of the application only:
</p><p><code>    CE_TRACE="*+5" CE_TRACEFILE="mylog" TRACEUTIL_VERBOSE=1 ./app.out</code>
</p><p>Note that these environment variables are read only at application startup time. Changing them after the application is running has no effect.
</p>
<hr />
<p><b>Note:</b> The CE_DSP0TRACE environment variable described in previous versions is ignored if you enable the TraceUtil module.
</p>
<hr />
<h3><span class="mw-headline" id="Controlling_Trace_at_Run-Time_Through_a_Named_Pipe">Controlling Trace at Run-Time Through a Named Pipe</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=52" title="Edit section: Controlling Trace at Run-Time Through a Named Pipe">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If the TRACEUTIL_CMDPIPE environment variable is set to a valid name or if the TraceUtil.attrs.cmdPipeFile configuration option is set, the TraceUtil thread listens for any trace commands that appear in the pipe.
</p><p>The SOCRATES_TRACING profile uses the command pipe feature. The pipe is /tmp/cecmdpipe by default, but the name can be overridden by setting the TRACEUTIL_CMDPIPE environment variable.
</p><p>When you start a SoC Analyzer-enabled application, it initially provides no trace other than (potentially) warnings and errors.
</p><p>Ways to override this initial behavior are:
</p>
<ul><li>Define the following environment variables before starting the application. See the section on <a href="#Trace_Mask_Values">Trace Mask Values</a> for mask details.</li></ul>
<pre>CE_TRACE="*+5"
TRACEUTIL_DSP0TRACEMASK="*+5,ti.bios=3"
</pre>
<ul><li>Issue the following command before running the application:</li></ul>
<pre>mkfifo /tmp/cecmdpipe; echo socrates=on &gt; /tmp/cecmdpipe
</pre>
<p>The mkfifo command is necessary only for the first run; TraceUtil creates the pipe if it doesn't exist and doesn't delete it at the end.
</p><p>When a SoC Analyzer-enabled application is running, you can turn tracing on by writing the following string to the /tmp/cecmdpipe file:
</p>
<pre>socrates=on
</pre>
<p>You can turn tracing off by writing the following string to the /tmp/cecmdpipe file:
</p>
<pre>socrates=off
</pre>
<p>The socrates=on and socrates=off pipe commands are aliases for a group of appropriate masks. These aliases are defined in the TraceUtil.xdc file.
</p><p>The best way to write a string to the pipe is to use an open-write-close sequence (as opposed to keeping the pipe file open for writing throughout the session). The [create_pipe]-&gt;open_pipe-&gt;write_text-&gt;close_pipe sequence can be either done from the command line, from a script (as in the example above), or from a C program
</p><p>The following list shows the supported trace pipe commands.
</p>
<ul><li>tracemask={GPP trace mask value} Sets the GPP-side trace mask. For example,</li></ul>
<p><code>   tracemask=*+01234567,OM-1 </code>
</p>
<ul><li>dsp0tracemask={DSP0 trace mask value} Sets the DSP0 trace mask. For example,</li></ul>
<p><code>   dsp0tracemask=*-1,ti.bios-012 </code>
</p>
<ul><li>refreshperiod={number of milliseconds} Sets the refresh period for DSP0 trace and log collection. If 0, there is no collection until a non-zero refreshperiod is specified. For example, refreshperiod=10</li>
<li>resetfiles (no arguments) Resets all open files for GPP trace, DSP0 trace, and DSP0 log (those that are currently in use) by truncating the files to 0 bytes.</li></ul>
<p>Note that only one command per line should be written to the trace pipe. However, as was done for socrates=on, you can define—in the application’s configuration script—command pipe aliases to issue several pipe commands. For example:
</p><p>&lt;syntaxhighlight lang='javascript'&gt;
var TraceUtil =    xdc.useModule('ti.sdo.ce.utils.trace.TraceUtil');
TraceUtil.attrs.cmdAliases = [
</p>
<pre>{
alias: "mycommands_1",
cmds: [
          "resetfiles",
          "tracemask=*+5",
           "dsp0tracemask=*+5,ti.bios+3",
          "refreshperiod=200",
],
},
{
alias: "mycommands_2",
cmds: [
          "tracemask=*-5",
          "refreshperiod=0",
          "dsp0tracemask=*-5,ti.bios-3"
],
},   /* and so on -- no limit on the number of aliases */
</pre>
<p>];
&lt;/syntaxhighlight&gt;
</p>
<h3><span class="mw-headline" id="Trace_Mask_Values">Trace Mask Values</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=53" title="Edit section: Trace Mask Values">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Every VISA module can supply real-time trace output. This output can be enabled and disabled on a per-module basis at run-time. Each module can supply up to 8 levels of trace information. Several levels have universal meaning. For example, 0 corresponds to "entry" tracing (each module entry point displays its name and the arguments passed to it).
</p><p>The NO_TRACING, DEFAULT_TRACING, SOCRATES_TRACING, and FULL_TRACING constants you can use in your application configuration provide easy ways to set commonly desired tracing levels. If you want custom trace levels for various modules, you can do that using the information in this section.
</p><p>You can set trace masks (in a configuration file, environment variable, or command pipe) to a name/value pair or sequence of pairs. The name indicates the module whose tracing should be set, and the value indicates the trace levels enabled for that module.
</p><p>For example, the following setting uses * (asterisk) as a wildcard to enable full Codec Engine tracing. This results in a lot of output, but is often useful in identifying what is going on internally.
</p>
<pre>setenv CE_TRACE "*=01234567"
</pre>
<p>You can also set modules to different trace levels in the same environment variable. To configure more than one module, you can separate masks with a semi-colon. Any module settings after the asterisk name/value pair override the wildcard setting.
</p><p>For example, the following sets all modules to "1567", except "OM" (which you don't want to see), and "CV" (for which you want to see all information):
</p>
<pre>setenv CE_TRACE "*=1567;OM=;CV=01234567"
</pre>
<p>The following table lists the module names you can use in masks. It shows which modules apply to GPP trace (CE_TRACE) and which apply to DSP trace (TRACEUTIL_DSP0TRACEMASK):
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">

<tbody><tr>
<th>Module Abbreviation
</th>
<th>Description
</th>
<th>Valid for GPP
</th>
<th>Valid for DSP
</th></tr>
<tr>
<td>OC
</td>
<td>OSAL Communication. Abstracts messaging APIs across operating systems.
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>OP
</td>
<td>OSAL Process. Abstracts process APIs across operating systems and loads the server image to the DSP.
</td>
<td>Yes
</td>
<td>No
</td></tr>
<tr>
<td>OM
</td>
<td>OSAL Memory. Abstracts memory APIs across operating systems.
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>OG
</td>
<td>OSAL Global. Abstracts generic APIs across operating systems.
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>OT
</td>
<td>OSAL Thread. Abstracts threading APIs across operating systems.
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>CE
</td>
<td>Codec Engine runtime APIs.
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>CS
</td>
<td>Server Runtime APIs.
</td>
<td>Yes
</td>
<td>No
</td></tr>
<tr>
<td>CV
</td>
<td>Codec Engine VISA APIs.
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>CR
</td>
<td>Codec Engine - RMS. Codec Engine’s server daemon.
</td>
<td>No
</td>
<td>Yes
</td></tr>
<tr>
<td>CN
</td>
<td>Codec Engine - Node. Instantiates codecs and communicates through custom skeletons.
</td>
<td>No
</td>
<td>Yes
</td></tr>
<tr>
<td>LC
</td>
<td>Log Client.  Used internally for acquiring BIOS LOG buffers from the DSP
</td>
<td>Yes
</td>
<td>No
</td></tr>
<tr>
<td>LS
</td>
<td>Log Server.  Used internally for acquiring BIOS LOG buffers on the DSP
</td>
<td>No
</td>
<td>Yes
</td></tr>
<tr>
<td>XU
</td>
<td>XdmUtils.  Used internally for managing XDM data structures
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>ti.sdo.ce.osal.AlgMem
</td>
<td>OSAL Algorithm. Used for creating, deleting, and controlling algorithms.
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>ti.sdo.ce.osal.power
</td>
<td>OSAL Power. Used in heterogeneous configurations to power on/off a server. Not supported in all releases.
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>ti.bios *
</td>
<td>Control the DSP/BIOS TRC module.
</td>
<td>No
</td>
<td>Yes
</td></tr>
<tr>
<td>GT_prefix *
</td>
<td>Control what information is included in each trace line prefix.
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>GT_time *
</td>
<td>Control the format of timestamps in trace lines.
</td>
<td>Yes
</td>
<td>Yes
</td></tr></tbody></table>
<p>(*) The ti.bios, GT_prefix, and GT_time modules are special in that they are not affected by module wildcards in a trace mask.
</p><p>You must name them directly to change their flags. For example:
</p>
<pre>setenv CE_TRACE "*=67;GT_prefix=12" setenv TRACEUTIL_DSP0TRACEMASK "*=567;ti.bios=012"
</pre>
<p>For the standard modules, the levels 0 through 7 report the following types of messages:
</p>
<ul><li>7 = fatal errors</li>
<li>6 = warnings</li>
<li>5 = benchmarks</li>
<li>4 through 1 = internal Codec Engine messages</li>
<li>0 = function enter/exit reporting</li></ul>
<p>For the special modules (ti.bios, GT_prefix, and GT_time) the levels have special meanings as follows:
</p>
<table border="1" cellspacing="0" cellpadding="4" rules="all" style="margin:1em 1em 1em 0; border:solid 1px #aaa; border-collapse:collapse;empty-cells:show;">

<tbody><tr>
<th>Level
</th>
<th>ti.bios Module
</th>
<th>GT_prefix Module
</th>
<th>GT_time Module
</th></tr>
<tr>
<td>none
</td>
<td>no DSP/BIOS logging
</td>
<td>no prefix
</td>
<td>microseconds in hex form (0xa0cf80fe)
</td></tr>
<tr>
<td>0
</td>
<td>TRC_LOGCLK
</td>
<td>short module name
</td>
<td>microseconds, in decimal form (4,021,348us)
</td></tr>
<tr>
<td>1
</td>
<td>TRC_LOGPRD
</td>
<td>long module name
</td>
<td>seconds (0.004s)
</td></tr>
<tr>
<td>2
</td>
<td>TRC_LOGSWI
</td>
<td>trace line class (level)
</td>
<td>delta in microseconds, excluding print time (+0,000,259us)
</td></tr>
<tr>
<td>3
</td>
<td>TRC_LOGTSK
</td>
<td>thread ID
</td>
<td>--
</td></tr>
<tr>
<td>4
</td>
<td>TRC_STSHWI
</td>
<td>stack address
</td>
<td>--
</td></tr>
<tr>
<td>5
</td>
<td>TRC_STSPRD with TRC_STSSWI and TRC_STSTSK
</td>
<td>time stamp
</td>
<td>--
</td></tr>
<tr>
<td>6
</td>
<td>TRC_USER0
</td>
<td>--
</td>
<td>--
</td></tr>
<tr>
<td>7
</td>
<td>TRC_USER1
</td>
<td>--
</td>
<td>--
</td></tr></tbody></table>
<p>For GT_prefix, the default levels used are 1, 3, and 5.
</p><p>For GT_time, DSP time stamps are always in cycles, not in microseconds. Setting GT_time currently makes sense only on the GPP.
</p>
<h2><span class="mw-headline" id="Software_Trace_for_BIOS_6_Based_Versions_of_Codec_Engine">Software Trace for BIOS 6 Based Versions of Codec Engine</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=54" title="Edit section: Software Trace for BIOS 6 Based Versions of Codec Engine">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>For BIOS 6 based versions of Codec Engine, GT trace has been replaced by xdc_runtime_Log and xdc_runtime_Diags APIs. Logging is enabled through configuration of the .cfg file and by calling xdc_runtime_Diags_setMask() at run-time. Note that TraceUtil is not supported.
</p>
<h3><span class="mw-headline" id="Log_Configuration">Log Configuration</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=55" title="Edit section: Log Configuration">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Logging can be configured in the application or server .cfg file, by including one of the utility Log setup files in ti/sdo/ce/examples/buildutils. Server .cfg files can include server_log.cfg, which sets up a circular buffer where Log_print() statements will be formatted. An application .cfg file can include common_log.cfg. These files can be included by adding a line to the .cfg file like:
</p><p>&lt;syntaxhighlight lang='javascript'&gt;
// Set up logging
xdc.loadCapsule('ti/sdo/ce/examples/buildutils/common_log.cfg');
&lt;/syntaxhighlight&gt;
</p><p>Alternatively, he common_log.cfg or server_log.cfg file can be copied and pasted into your .cfg file and modified there.
</p><p>Unlike BIOS 6 modules, Codec Engine module logging cannot be enabled in the configuration file. Logging of Codec Engine modules can only be enabled at run-time, with the xdc.runtime function, Diags_setMask().
</p><p><br />
</p>
<h3><span class="mw-headline" id="Trace_Mask_Values_2">Trace Mask Values</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=56" title="Edit section: Trace Mask Values">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Every Codec Engine module can produce real-time trace output that can be enabled and disabled at run-time on a per-module basis. Up to 9 levels of tracing are supported. Here is a description of the trace levels:
</p><p>E – Function entry
X – Funcion exit
1-4 – Informational trace
5 – Benchmarks
6 – Warnings
7 - Errors
</p><p><br />
</p>
<h3><span class="mw-headline" id="Setting_Trace_Masks_at_Run-Time">Setting Trace Masks at Run-Time</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=57" title="Edit section: Setting Trace Masks at Run-Time">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>To set the trace mask of a Codec Engine module you must call Diags_setMask() from run-time code, passing a string containing the module name and trace levels you want to enable. For example, the following code turns on warning and error trace for all Codec Engine modules:
</p><p>&lt;syntaxhighlight lang='c'&gt;
</p>
<ol><li>include &lt;xdc/runtime/Diags.h&gt;</li></ol>
<p>Void main(Int argc, String argv[])
{
</p>
<pre>   /* Enable warnings and errors for all Codec Engine modules */
   Diags_setMask("ti.sdo.ce.%=67");
   ...
</pre>
<p>}
&lt;/syntaxhighlight&gt;
</p><p>Note that the wildcard symbol is ‘%’. If we wanted to add function entry and exit trace to just the Engine module, we would add the following line:
&lt;syntaxhighlight lang='javascript'&gt;
</p>
<pre>   Diags_setMask("ti.sdo.ce.Engine+EX");
</pre>
<p>&lt;/syntaxhighlight&gt;
Note that ‘+’ is used to add trace levels to the current mask. You can use ‘-‘ to remove trace levels from a mask.
</p><p><br />
</p>
<h3><span class="mw-headline" id="Easy_Trace_Enable_for_Linux_Applications">Easy Trace Enable for Linux Applications</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=58" title="Edit section: Easy Trace Enable for Linux Applications">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Once your application has been configured for logging, real-time trace output can then be enabled at run-time either by enabling trace masks in “C” source code, or by setting environment variables (for Linux OS).
</p><p>The simplest way to get trace for a host ARM application, is to set the environment variable, CE_DEBUG. Codec Engine initialization code internally calls Diags_setMask() for various modules and trace levels, depending on the value of CE_DEBUG. When CE_DEBUG is set to 1, warning and error trace will be enabled. Setting CE_DEBUG to 2 turns on most trace, leaving the largely unnecessary trace turned off. When CE_DEBUG is set to 3, all trace is enabled.
</p><p>See <a rel="nofollow" class="external free" href="CE_DEBUG.html">http://processors.wiki.ti.com/index.php/CE_DEBUG</a> for more details on CE_DEBUG usage.
</p><p>Another environment variable that can be set to enable trace, is CE_TRACE. You can set it to the value of the string that you would have passed to Diags_setMask() in run-time code. For example,
&lt;syntaxhighlight lang='c'&gt;
</p>
<pre>   setenv CE_TRACE="ti.sdo.ce.%=67;ti.sdo.ce.Engine+EX"
</pre>
<p>&lt;/syntaxhighlight&gt;
</p>
<h1><span class="mw-headline" id="Additional_Documents_and_Resources">Additional Documents and Resources</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;section=59" title="Edit section: Additional Documents and Resources">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<ul><li><i>Codec Engine Server Integrator User's Guide</i> (<a href="http://www.ti.com/lit/pdf/SPRUED5" class="extiw" title="tidoc:SPRUED5">SPRUED5</a>)</li>
<li><i>Codec Engine Algorithm Creator User's Guide</i> (<a href="http://www.ti.com/lit/pdf/SPRUED6" class="extiw" title="tidoc:SPRUED6">SPRUED6</a>)</li>
<li><i>Codec Engine Application (API) Reference Guide</i> CE_INSTALL_DIR/docs/html/index.html</li>
<li><i>Configuration Reference Guide.</i> CE_INSTALL_DIR/xdoc/index.html</li>
<li><i>Example Build and Run Instructions.</i> CE_INSTALL_DIR/examples/build_instructions.html</li>
<li><a rel="nofollow" class="external text" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/xdais/6_24/exports/xdais_6_24/docs/html/index.html">XDM API Reference.</a></li>
<li><i>XDAIS-DM (Digital Media) User Guide</i> (<a href="http://www.ti.com/lit/pdf/SPRUEC8" class="extiw" title="tidoc:SPRUEC8">SPRUEC8</a>)</li>
<li><i>TMS320 DSP Algorithm Standard Rules and Guidelines</i> (<a href="http://www.ti.com/lit/pdf/SPRU352" class="extiw" title="tidoc:SPRU352">SPRU352</a>)</li>
<li><i>TMS320 DSP Algorithm Standard API Reference</i> (<a href="http://www.ti.com/lit/pdf/SPRU360" class="extiw" title="tidoc:SPRU360">SPRU360</a>)</li>
<li><i>TMS320 DSP Algorithm Standard Developer’s Guide</i> (<a href="http://www.ti.com/lit/pdf/SPRU424" class="extiw" title="tidoc:SPRU424">SPRU424</a>)</li>
<li><i>TMS320 DSP Algorithm Standard Demonstration Application</i> (<a href="http://www.ti.com/lit/pdf/SPRU361" class="extiw" title="tidoc:SPRU361">SPRU361</a>)</li>
<li><a href="Codec_Engine_Overview.html" title="Codec Engine Overview">Codec Engine Overview</a></li></ul>

<!-- 
NewPP limit report
Cached time: 20201130075552
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.168 seconds
Real time usage: 0.170 seconds
Preprocessor visited node count: 271/1000000
Preprocessor generated node count: 335/1000000
Post‐expand include size: 755/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 470/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    2.905      1 -total
 52.04%    1.512      5 Template:Prettytable
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:670-0!canonical and timestamp 20201130075551 and revision id 193327
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Codec Engine Application Developers Guide</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Codec Engine Application Developers Guide</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>Codec Engine Application Developers Guide</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>Codec Engine Application Developers Guide</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>Codec Engine Application Developers Guide</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Codec Engine Application Developers Guide</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Codec Engine Application Developers Guide</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>Codec Engine Application Developers Guide</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>Codec Engine Application Developers Guide</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;oldid=193327">https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;oldid=193327</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Categories</a>: <ul><li><a href="Category_Codec_Engine.html" title="Category:Codec Engine">Codec Engine</a></li><li><a href="Category_DaVinci_Training.html" title="Category:DaVinci Training">DaVinci Training</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=Codec+Engine+Application+Developers+Guide" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="Codec_Engine_Application_Developers_Guide.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Talk:Codec_Engine_Application_Developers_Guide&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="Codec_Engine_Application_Developers_Guide.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/Codec_Engine_Application_Developers_Guide.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/Codec_Engine_Application_Developers_Guide.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;oldid=193327" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=Codec_Engine_Application_Developers_Guide&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 9 February 2015, at 11:05.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.168","walltime":"0.170","ppvisitednodes":{"value":271,"limit":1000000},"ppgeneratednodes":{"value":335,"limit":1000000},"postexpandincludesize":{"value":755,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":470,"limit":5000000},"timingprofile":["100.00%    2.905      1 -total"," 52.04%    1.512      5 Template:Prettytable"]},"cachereport":{"timestamp":"20201130075552","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":231});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/Codec_Engine_Application_Developers_Guide by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 04:31:24 GMT -->
</html>
