<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">

<!-- Mirrored from processors.wiki.ti.com/index.php/Cache_coherency_in_RingIO by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 04:34:16 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8"/>
<title>Cache coherency in RingIO - Texas Instruments Wiki</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Cache_coherency_in_RingIO","wgTitle":"Cache coherency in RingIO","wgCurRevisionId":152895,"wgRevisionId":152895,"wgArticleId":15258,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["SysLink"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Cache_coherency_in_RingIO","wgRelevantArticleId":15258,"wgRequestId":"d1fd4f837128b0e82ff46735","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@19o3a1s",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["site","mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector"/>
<script async="" src="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="https://processors.wiki.ti.com/load.php?debug=false&amp;lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.31.6"/>
<link rel="shortcut icon" href="https://processors.wiki.ti.com/favicon.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="https://processors.wiki.ti.com/opensearch_desc.php" title="Texas Instruments Wiki (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="https://processors.wiki.ti.com/api.php?action=rsd"/>
<link rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Texas Instruments Wiki Atom feed" href="https://processors.wiki.ti.com/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<!--[if lt IE 9]><script src="/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=Vector&amp;sync=1"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-Cache_coherency_in_RingIO rootpage-Cache_coherency_in_RingIO skin-vector action-view">		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div id="siteNotice" class="mw-body-content"><div id="localNotice" lang="en" dir="ltr"><div class="mw-parser-output"><p><br />
<span style="color:#ff0000"><b>NOTICE: The Processors Wiki will End-of-Life on January 15, 2021. It is recommended to download any files or other content you may need that are hosted on processors.wiki.ti.com. The site is now set to read only.</b></span>
</p></div></div></div><div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">Cache coherency in RingIO</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From Texas Instruments Wiki</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><div id="toc" class="toc"><div class="toctitle" lang="en" dir="ltr"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Cache_coherency_in_RingIO"><span class="tocnumber">1</span> <span class="toctext">Cache coherency in RingIO</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Overview"><span class="tocnumber">1.1</span> <span class="toctext">Overview</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Supported_use-cases"><span class="tocnumber">1.2</span> <span class="toctext">Supported use-cases</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#What_does_RingIO_do_internally_to_assist_with_cache_coherency_of_the_data_buffer.3F"><span class="tocnumber">1.3</span> <span class="toctext">What does RingIO do internally to assist with cache coherency of the data buffer?</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Best_practice"><span class="tocnumber">1.4</span> <span class="toctext">Best practice</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Guidelines_when_interacting_with_the_data_buffer_when_data_sizes_cannot_be_a_multiple_of_cache_line_size_.28no_in-place_processing_on_reader_side.29"><span class="tocnumber">1.5</span> <span class="toctext">Guidelines when interacting with the data buffer when data sizes cannot be a multiple of cache line size (no in-place processing on reader side)</span></a>
<ul>
<li class="toclevel-3 tocsection-7"><a href="#Remote_case:_writer_and_reader_on_different_cores_not_sharing_the_same_cache"><span class="tocnumber">1.5.1</span> <span class="toctext">Remote case: writer and reader on different cores not sharing the same cache</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Local_case:_writer_and_reader_on_same_core_.28or_cores_sharing_the_same_cache.29"><span class="tocnumber">1.5.2</span> <span class="toctext">Local case: writer and reader on same core (or cores sharing the same cache)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-9"><a href="#Guidelines_when_there_is_in-place_processing_on_reader_side"><span class="tocnumber">1.6</span> <span class="toctext">Guidelines when there is in-place processing on reader side</span></a>
<ul>
<li class="toclevel-3 tocsection-10"><a href="#Remote_case:_writer_and_reader_on_different_cores_not_sharing_the_same_cache_2"><span class="tocnumber">1.6.1</span> <span class="toctext">Remote case: writer and reader on different cores not sharing the same cache</span></a></li>
<li class="toclevel-3 tocsection-11"><a href="#Local_case:_writer_and_reader_on_same_core_.28or_cores_sharing_the_same_cache.29_2"><span class="tocnumber">1.6.2</span> <span class="toctext">Local case: writer and reader on same core (or cores sharing the same cache)</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-12"><a href="#Cache_coherency_when_foot_buffer_is_used"><span class="tocnumber">1.7</span> <span class="toctext">Cache coherency when foot buffer is used</span></a>
<ul>
<li class="toclevel-3 tocsection-13"><a href="#Both_writer_and_reader_are_local_and_share_the_same_cache"><span class="tocnumber">1.7.1</span> <span class="toctext">Both writer and reader are local and share the same cache</span></a></li>
<li class="toclevel-3 tocsection-14"><a href="#The_writer_and_reader_are_on_different_cores"><span class="tocnumber">1.7.2</span> <span class="toctext">The writer and reader are on different cores</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-15"><a href="#Summary"><span class="tocnumber">1.8</span> <span class="toctext">Summary</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Cache_coherency_in_RingIO">Cache coherency in RingIO</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=1" title="Edit section: Cache coherency in RingIO">edit</a><span class="mw-editsection-bracket">]</span></span></h1>
<h2><span class="mw-headline" id="Overview">Overview</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=2" title="Edit section: Overview">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>RingIO is one of the more complex methods the <a href="Category_SysLink.html" title="Category:SysLink">SysLink software product</a> provides for passing data between processors.  This document describes cache-related rules and guidelines when using RingIO.  <a rel="nofollow" class="external text" href="http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/syslink/latest/docs/html/_ring_i_o_8h.html">For reference, the RingIO API Reference Guide is here.</a>
</p><p>There are three shared buffers owned by any given RingIO instance:
</p>
<ul><li>The <b>control</b> buffer, which contain state information about a RingIO instance</li>
<li>The <b>attribute</b> buffer, which stores the attributes set by the writer</li>
<li>The <b>data</b> buffer, which is the ring buffer that holds the data exchanged between the writer and the reader.</li></ul>
<p>Each of these buffers may reside in a memory region that is cached. Cache coherency of the <b>control</b> buffer is automatically maintained by the module since the buffer is purely used by the module internally. Coherency of the <b>attribute</b> buffer is similarly maintained by the RingIO module since attributes are physically copied into and out of the attribute buffer during write and read operations. Where things get tricky is when dealing with the <b>data</b> buffer, as the user application has direct access to this buffer. Care must be taken to avoid data corruption introduced due to cache usage.
</p><p>Note that our discussion takes aim at the case where the data buffer is in <b>cached</b> memory. If it resides in non-cached memory then cache coherency operations are not necessary. Simply clear the bit 'RingIO_DATABUF_MAINTAINCACHE' in the 'flags' field of the RingIO_openParams structure passed to <code>RingIO_open()</code>, and the user need not worry about this discussion. 
</p><p>In cases where the reader and writer reside on different cores, it is possible that only one client operates on cached memory. In such cases follow the rules in the discussion only for the side where cache is enabled.
</p>
<h2><span class="mw-headline" id="Supported_use-cases">Supported use-cases</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=3" title="Edit section: Supported use-cases">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Here are the rules to follow when using RingIO with the data buffer in cached memory:
</p><p>1. <b>Work using cache-line-multiple sizes.</b> This applies to all <code>RingIO_acquire()</code> and <code>RingIO_release()</code> function calls, and to the size of the data buffer itself. It is by far the *cleanest* use-case, where the reader and writer can maintain cache coherency within their acquired buffers with no side-effects on adjacent data.
</p><p>If #1 is not possible, and arbitrary buffer sizes need to be acquired/released:
</p><p>2. When reader and writer are on the <b>same core</b> (i.e. sharing a common cache), turn the 'RingIO_DATABUF_MAINTAINCACHE' bit off for both clients. The application can then manage the cache by itself, which is simpler when a single core is involved.
</p><p>3. When reader and writer are on <b>different cores</b>, turn the 'RingIO_DATABUF_MAINTAINCACHE' bit on for the clients that accesses the data buffer using the CPU. Ideally, the writer should access the RingIO buffers it acquires using CPU-only or without using the CPU at all, but not both. Otherwise, it would need to ensure <code>RingIO_acquire()</code> and <code>RingIO_release()</code> are called with sizes that is a multiple of cache line size at all times. 
</p><p>4. When <b>in-place processing</b> is performed in the reader, in addition to rule 3, here are some additional rules when reader and writer are on different cores:
</p>
<ul><li>The writer must call <code>RingIO_acquire()</code> and <code>RingIO_release()</code> with cache-aligned sizes at all times.</li>
<li>If the reader accesses acquired RingIO buffers directly using the CPU, it needs to call <code>RingIO_acquire()</code> with multiple-of-cache-line sizes at all times as well.</li></ul>
<p>If both reader and writer are on the same core, you should do at least one of the following beyond rule 2:
</p>
<ul><li>Stick to using strictly CPU-only accesses or non-CPU accesses when accessing the data buffer</li>
<li>Call <code>RingIO_acquire()/RingIO_release()</code> with sizes that are multiple of the cache line size.</li></ul>
<p>5. When using a <b>footbuffer</b>, in addition to rules 2, 3, and 4, the following additional conditions must be satisfied:
</p>
<ul><li>For reader and writer on same core: if either client accesses the data buffer using non-CPU accesses, both reader and writer must call <code>RingIO_acquire()/RingIO_release()</code> with sizes that are a multiple of cache line size, and the application must perform cache writeback and invalidation of the acquired buffer prior to the non-CPU access. Given this may be restrictive, consider leaving the data buffer in non-cached memory instead as an alternative.</li>
<li>For reader and writer on different cores: if cache is enabled on the reader's core, create a data buffer of a size that is multiple of cache line size, and do *not* configure the writer with USE_EXACT_SIZE.</li></ul>
<p>6. Exercise caution when performing cache operations in the application on an acquired buffer when not working with multiple of cache line sizes. They should be avoided whenever possible. If they are absolutely necessary, think through what you are doing as it may impact other acquired buffers in either client sharing the same cache line(s).
</p><p><br />
If you are interested in knowing how these rules came about, continue on with the reading.
</p>
<h2><span id="What_does_RingIO_do_internally_to_assist_with_cache_coherency_of_the_data_buffer?"></span><span class="mw-headline" id="What_does_RingIO_do_internally_to_assist_with_cache_coherency_of_the_data_buffer.3F">What does RingIO do internally to assist with cache coherency of the data buffer?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=4" title="Edit section: What does RingIO do internally to assist with cache coherency of the data buffer?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>When the bit 'RingIO_DATABUF_MAINTAINCACHE' in the 'flags' field of the RingIO_openParams structure passed to <code>RingIO_open()</code> is set, RingIO performs the minimal/basic cache operations to ensure writer and reader can reside on separate cores. Only two functions in the RingIO API perform cache operations on the <b>data</b> buffer: 
</p>
<ul><li><code>RingIO_acquire()</code>, when called by the reader client</li>
<li><code>RingIO_release()</code>, when called by the writer client</li></ul>
<p><code>RingIO_acquire()</code> (when called by the reader) performs cache invalidation on the read portion of the buffer prior to returning it to the application, whereas <code>RingIO_release()</code> (when called by the writer) performs cache writeback and invalidation on the written portion of the buffer to commit the data to shared physical memory.
</p><p>Moreover, it performs supplementary cache coherency operations pertaining to the use of a footbuffer when the latter is used. Refer to the discussion regarding the footbuffer for more details.
</p><p>Any additional cache coherency operations, if required, become the application's responsibility.
</p>
<h2><span class="mw-headline" id="Best_practice">Best practice</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=5" title="Edit section: Best practice">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>To keep things simple, it is best to use data sizes that are multiples of the cache line size in <code>RingIO_acquire()</code> and <code>RingIO_release()</code> calls. For example, if the cache line size is 128 bytes, then <code>RingIO_acquire()</code>/<code>RingIO_release()</code> should be called with sizes that are multiple of 128, such as 256 or 1024. This is because cache operations are performed on entire cache lines, hence when cache invalidation/writeback is done it affects any data that is sharing the same cache line(s) as the region that is being acquired/released. Furthermore, in cases where the <i>application</i> wants to perform cache maintenance on acquired buffers, it becomes more straightforward to perform cache maintenance on a per-buffer basis.
</p><p>If the cache line size differs for the two clients - e.g. it is 128 on the writer's core and 1024 on the reader's core, use the least common multiple for the two sides, which would be 1024 for this example.
</p>
<h2><span id="Guidelines_when_interacting_with_the_data_buffer_when_data_sizes_cannot_be_a_multiple_of_cache_line_size_(no_in-place_processing_on_reader_side)"></span><span class="mw-headline" id="Guidelines_when_interacting_with_the_data_buffer_when_data_sizes_cannot_be_a_multiple_of_cache_line_size_.28no_in-place_processing_on_reader_side.29">Guidelines when interacting with the data buffer when data sizes cannot be a multiple of cache line size (no in-place processing on reader side)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=6" title="Edit section: Guidelines when interacting with the data buffer when data sizes cannot be a multiple of cache line size (no in-place processing on reader side)">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In cases where non-cache-line-multiple sizes are used, the application needs to be careful when calling <code>RingIO_acquire()</code> (from reader) and <code>RingIO_release()</code> (from writer). It is important to make sure the 'RingIO_DATABUF_MAINTAINCACHE' bit is correctly set when opening the writer and/or reader. Let's first examine what happens in the standard case where the reader only reads from the ring buffer without doing any in-place processing that requires writing to it.
</p>
<h3><span class="mw-headline" id="Remote_case:_writer_and_reader_on_different_cores_not_sharing_the_same_cache">Remote case: writer and reader on different cores not sharing the same cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=7" title="Edit section: Remote case: writer and reader on different cores not sharing the same cache">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In the remote case, the writer performs <code>RingIO_release()</code> on one core and the reader performs <code>RingIO_acquire()</code> on another core. Let us consider the most generic case where the writer has acquired a small buffer that is smaller than the cache line size, and that this buffer is somewhere in the middle of the cache line, so there is space that is not part of the buffer both at the beginning and the end of the cache line. 
</p><p><br />
<b>Fig. 1 Example scenario where cache coherency could be problematic</b>
</p><p><a href="File_Fig1_cache_coherency_ringio.html" class="image" title="Fig. 1"><img alt="Fig. 1" src="https://processors.wiki.ti.com/images/5/51/Fig1_cache_coherency_ringio.png" width="771" height="255" /></a>
</p><p>When the buffer is released by the writer, cache writeback is performed on the cache line when the 'RingIO_DATABUF_MAINTAINCACHE' bit is set for the writer client. The content that is outside of the buffer residing on the same cache line is written back as well. The space before/after the buffer is either 1. acquired by the reader 2. acquired by the writer or 3. not acquired by either reader or writer.   
</p><p>1. If space is acquired by reader, it may only read from it (assuming no in-place processing is done. In-place processing on reader side will be discussed later in this chapter.). This data was obviously released previously by the writer, hence it must have been written back and is coherent on the writer side. So no issue here with writing back valid data once more.
</p><p>2. If space is acquired by the writer itself, the cache writeback may corrupt data that the writer has already placed in there (e.g. via DMA). Hence it is the responsibility of the writer to ensure cache coherency here with respect to itself. Ideally, it should access the RingIO buffers it acquires using CPU-only or without using the CPU at all, but not both. Otherwise, it would need to ensure <code>RingIO_acquire()</code> and <code>RingIO_release()</code> are called with sizes that is a multiple of cache line size at all times. And in the event the writer only accesses the data buffer using the DMA, the user should consider putting the data buffer in non-cacheable memory (from writer's side) altogether for best performance.
</p><p>3. If space is not yet acquired by either the reader or writer, it may either contain valid data or be empty. If it is empty, no issue with the writeback. If it contains valid data, since the reader has not yet acquired and used the space, there is no issue to writeback a cache line that is coherent.
</p><p>Now let's examine the case where the <b>reader</b> is acquiring a small buffer in the middle of a cache line. Cache invalidation is automatically performed on the entire cache line. The space is is not owned by the buffer is either 1. acquired by the writer 2. acquired by the reader or 3. not acquired by the either reader or writer.
</p><p>1. If space is acquired by writer, it may be working on it. But there is no issue since the invalidation does not affect the writer side.
</p><p>2. If space is acquired by reader, then the reader may be in the midst of reading valid data from it. Again no issue here except for a minor performance degradation if the reader reads from a cached location that got invalidated indirectly.
</p><p>3. If space is neither yet acquired by the reader nor the writer, then invalidation of the empty/valid space is not an issue.
</p><p>Hence the cache invalidation is not problematic in this case.
</p>
<h3><span id="Local_case:_writer_and_reader_on_same_core_(or_cores_sharing_the_same_cache)"></span><span class="mw-headline" id="Local_case:_writer_and_reader_on_same_core_.28or_cores_sharing_the_same_cache.29">Local case: writer and reader on same core (or cores sharing the same cache)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=8" title="Edit section: Local case: writer and reader on same core (or cores sharing the same cache)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In the local case, the writer performs <code>RingIO_release()</code> on the same core as where the reader performs <code>RingIO_acquire()</code> (or at least both share the same cache). If both writer and reader strictly access the data buffer using the CPU-only or without using the CPU at all, then the 'RingIO_DATABUF_MAINTAINCACHE' bit should be cleared. This is because cache maintenance operations are not necessary in either case.
</p><p>If there is a mixture of accesses, it'd be best to leave the bit cleared as well. The application would then have to manage cache coherency on its own, just like it would normally do when CPU and DMA accesses are performed outside of the context of RingIO. As this cache coherency maintenance can get quite complex and costly (in some cases synchronization between reader and writer may be unavoidable), it is best to avoid this scenario whenever possible, or simplify things by having <code>RingIO_acquire()</code> and <code>RingIO_release()</code> operate on multiple of cache line size at all times, as described in the <a href="Cache_coherency_in_RingIO.html#Best_practice" title="Cache coherency in RingIO">Best practice</a> section.
</p>
<h2><span class="mw-headline" id="Guidelines_when_there_is_in-place_processing_on_reader_side">Guidelines when there is in-place processing on reader side</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=9" title="Edit section: Guidelines when there is in-place processing on reader side">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In general, in-place processing leads to more complex cache coherency issues, hence it should be avoided unless absolutely necessary. When reader does in-place processing and performs write access to acquired buffers, additional requirements are needed to ensure cache coherency on both sides.
</p>
<h3><span class="mw-headline" id="Remote_case:_writer_and_reader_on_different_cores_not_sharing_the_same_cache_2">Remote case: writer and reader on different cores not sharing the same cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=10" title="Edit section: Remote case: writer and reader on different cores not sharing the same cache">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In the remote case, the writer performs RingIO_release on one core and the reader performs RingIO_acquire on another core. Let us consider the extreme case where the writer has acquired a small buffer that is smaller than the cache line size, and that this buffer is somewhere in the middle of the cache line, so there is space that is not part of the buffer both at the beginning and the end of the cache line. When the 'RingIO_DATABUF_MAINTAINCACHE' bit is set for both clients and the buffer is released by the writer, cache writeback is performed on the cache line. The content that is outside of the buffer residing on the same cacheline is written back as well. The space before/after the buffer is either 1. acquired by the reader 2. acquired by the writer or 3. not acquired by either reader or writer.   
</p><p>1. If space is acquired by reader, it may be working on it. When the <code>RingIO_release()</code> call does a cache writeback, it may corrupt the data on the reader side. Hence the writer must call <code>RingIO_release()</code> with cache-aligned sizes at all times to avoid this condition. <code>RingIO_acquire()</code> should also be called with cache-aligned sizes as cache lines may be written back by the system during routine cache eviction.
</p><p>2. If space is acquired by the writer itself, then the reader cannot affect this cache line via in-place processing, since it is effectively owned by the writer. 
</p><p>3. If space is not yet acquired by either the reader or writer, it may either contain valid data or be empty. If it is empty, no issue with the writeback. If it contains valid data, since the reader has not yet acquired and used the space, there shouldn't be any effect introduced by in-place processing in the reader.
</p><p>Now let's examine the case where the reader is acquiring a small buffer in the middle of a cache line. Cache invalidation is automatically performed on the entire cache line. The space is is not owned by the buffer is either 1. acquired by the writer 2. acquired by the reader or 3. not acquired by the either reader or writer.
</p><p>1. If space is acquired by writer, it may be working on it. But the invalidation does not affect the writer since it is not sharing the same cache.
</p><p>2. If space is acquired by reader, then the reader may have written data to it. Then the invalidation might invalidate the cached data! Hence it is the responsibility of the reader to ensure cache coherency here with respect to itself, so that it does not inadvertently invalidate data it is working on when calling RingIO_acquire. If it accesses acquired RingIO buffers directly using the CPU, it would need to write back the data prior to doing a new RingIO_acquire call. Alternatively, it would also be safe if it ensures <code>RingIO_acquire()</code> is called with sizes that is a multiple of cache line size at all times.
</p><p>3. If space is not yet acquired by the reader nor the writer, then invalidation of the empty/valid space is not an issue.
</p><p>After acquiring the space, however, the reader may perform in-place processing and write to the acquired area using the CPU. In this case, the cache becomes dirty and will eventually be written back. During the writeback, if the writer has acquired and written to an area sharing the same cache line as the data being written back, data corruption may result. Hence, long story short: <b>the lesson here is that the reader too has to call RingIO_acquire with multiple-of-cache-line sizes, if it uses the CPU to write to the acquired buffers</b>.
</p>
<h3><span id="Local_case:_writer_and_reader_on_same_core_(or_cores_sharing_the_same_cache)_2"></span><span class="mw-headline" id="Local_case:_writer_and_reader_on_same_core_.28or_cores_sharing_the_same_cache.29_2">Local case: writer and reader on same core (or cores sharing the same cache)</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=11" title="Edit section: Local case: writer and reader on same core (or cores sharing the same cache)">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In the local case, the writer performs RingIO_release on the same core as where the reader performs RingIO_acquire (or at least both share the same cache). 
</p><p>As in the case where there is no in-place processing, the recommendation is to avoid setting the 'RingIO_DATABUF_MAINTAINCACHE' bit when opening the clients. The application would then manage cache coherency on its own, if required. Again keep things simple by sticking to strictly CPU-only access or non-CPU access, and/or by calling <code>RingIO_acquire()/RingIO_release()</code> with sizes that are multiple of the cache line size. In the first case, no cache coherency operations are needed, while in the second case they are certain to be safe.
</p>
<h2><span class="mw-headline" id="Cache_coherency_when_foot_buffer_is_used">Cache coherency when foot buffer is used</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=12" title="Edit section: Cache coherency when foot buffer is used">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>When a RingIO instance is configured to use a foot buffer, RingIO_acquire on the reader side may internally copy data from the top of the data buffer to the footbuffer. When that happens, and the 'RingIO_DATABUF_MAINTAINCACHE' bit for the reader is set, RingIO_acquire() performs the following sequence of operations:
</p>
<ul><li>invalidate the top of the data buffer</li>
<li>if the destination address does not start on a cache line boundary, invalidate the full cache line containing the destination address</li>
<li>perform the copy using the CPU</li>
<li>write the footbuffer contents from cache back to memory and invalidate its cached counterpart.</li></ul>
<p>Let's examine the different scenarios we have covered so far, but with the addition of the footbuffer.
</p>
<h3><span class="mw-headline" id="Both_writer_and_reader_are_local_and_share_the_same_cache">Both writer and reader are local and share the same cache</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=13" title="Edit section: Both writer and reader are local and share the same cache">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In this case, our recommendation was to turn the 'RingIO_DATABUF_MAINTAINCACHE' bit off for both reader and writer. So the cache maintenance will not be done. One important thing to pay attention to here is that the read from the top of the data buffer will cause the content of external memory to be pulled into the cache, and the write to the footbuffer area will go into the cache rather than in external memory. So if the writer and/or reader accesses the data buffer using non-CPU accesses, it would require the application to perform cache writeback and invalidation of the accessed area prior to the data transfer. 
</p><p>However, this cache maintenance leads to other problems. For instance, think of the case when the reader writebacks and invalidates an area in the footbuffer that shares a cache line with an acquired buffer in the writer. The writeback may still result in corruption for the writer's buffer if the latter's content changes between the time the footbuffer is copied and when it is written back by the application. 
</p><p>The solution in this case is to either work with sizes that are a multiple of the cache-line size, or of course to put the data buffer into non-cacheable memory if that is an option.
</p>
<h3><span class="mw-headline" id="The_writer_and_reader_are_on_different_cores">The writer and reader are on different cores</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=14" title="Edit section: The writer and reader are on different cores">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In this case, our recommendation was to turn the 'RingIO_DATABUF_MAINTAINCACHE' bit on for both reader and writer, provided the cache is turned on for both clients. In particular, if the cache is enabled on the reader side, the cache maintenance would be performed during the call to <code>RingIO_acquire()</code> on the reader core. In some cases, the cache operations may affect neighboring cache lines. Unless the user follows certain rules, writing back data from cache to external memory may cause stale data to be flushed out to an area acquired by the writer, or by the reader doing in-place processing with non-CPU accesses. So it is important that the cache writeback occurs on cache line boundary. If reader and writer work with arbitrary sizes, the only way to ensure a safe writeback would be
</p><p>1. The <b>total</b> data buffer size must be a multiple of cache line size;
</p><p>2. The footbuffer cannot be copied while there is an early end condition introduced by specifying 'RingIO_NEED_EXACT_SIZE' on the writer side. 
</p><p>To understand why this is necessary, look at the following figure:
</p><p><br />
<b>Fig.2 The benefit of ensuring data is copied to foot buffer on cache boundary</b>
<a href="File_Fig2_foot_buffer_cache_coherency.html" class="image" title="Fig.2 The benefit of ensuring data is copied to foot buffer on cache boundary"><img alt="Fig.2 The benefit of ensuring data is copied to foot buffer on cache boundary" src="https://processors.wiki.ti.com/images/9/98/Fig2_foot_buffer_cache_coherency.png" width="849" height="530" /></a>
</p><p>By following 1 and 2, we ensure the writeback occurs on a cache line boundary as illustrated in the bottom part of the diagram.
</p><p>We are less concerned regarding the cache invalidation operations, as the reader typically reads from the buffer in normal operation. If in-place processing is done on the reader side, the in-place processing rules discussed previously would need to be followed.
</p>
<h2><span class="mw-headline" id="Summary">Summary</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit&amp;section=15" title="Edit section: Summary">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>So to reiterate, based on our analysis, here are the rules you should follow when cache is enabled for the data buffer (keep in mind that <b>using non-cached memory</b> would lift these restrictions, so that is always an option):
</p><p>1. <b>Work using cache-line-multiple sizes.</b> This applies to all <code>RingIO_acquire()</code> and <code>RingIO_release()</code> function calls, and to the size of the data buffer itself. It is by far the *cleanest* use-case, where the reader and writer can maintain cache coherency within their acquired buffers with no side-effects on adjacent data.
</p><p>If #1 is not possible, and arbitrary buffer sizes need to be acquired/released:
</p><p>2. When reader and writer are on the <b>same core</b> (i.e. sharing a common cache), turn the 'RingIO_DATABUF_MAINTAINCACHE' bit off for both clients. The application can then manage the cache by itself, which is simpler when a single core is involved.
</p><p>3. When reader and writer are on <b>different cores</b>, turn the 'RingIO_DATABUF_MAINTAINCACHE' bit on for the clients that accesses the data buffer using the CPU. Ideally, the writer should access the RingIO buffers it acquires using CPU-only or without using the CPU at all, but not both. Otherwise, it would need to ensure <code>RingIO_acquire()</code> and <code>RingIO_release()</code> are called with sizes that is a multiple of cache line size at all times. 
</p><p>4. When <b>in-place processing</b> is performed in the reader, in addition to rule 3, here are some additional rules when reader and writer are on different cores:
</p>
<ul><li>The writer must call <code>RingIO_acquire()</code> and <code>RingIO_release()</code> with cache-aligned sizes at all times.</li>
<li>If the reader accesses acquired RingIO buffers directly using the CPU, it needs to call <code>RingIO_acquire()</code> with multiple-of-cache-line sizes at all times as well.</li></ul>
<p>If both reader and writer are on the same core, it is recommended to do at least one of the following beyond rule 2:
</p>
<ul><li>Stick to using strictly CPU-only accesses or non-CPU accesses when accessing the data buffer</li>
<li>Call <code>RingIO_acquire()/RingIO_release()</code> with sizes that are multiple of the cache line size.</li></ul>
<p>5. When using a <b>footbuffer</b>, in addition to rules 2, 3, and 4, the following additional conditions must be satisfied:
</p>
<ul><li>For reader and writer on same core: if either client accesses the data buffer using non-CPU accesses, both reader and writer must call <code>RingIO_acquire()/RingIO_release()</code> with sizes that are a multiple of cache line size, and the application must perform cache writeback and invalidation of the acquired buffer prior to the non-CPU access. Given this may be restrictive, consider leaving the data buffer in non-cached memory instead as an alternative.</li>
<li>For reader and writer on different cores: if cache is enabled on the reader's core, create a data buffer of a size that is multiple of cache line size, and do *not* configure the writer with USE_EXACT_SIZE.</li></ul>
<p>6. Exercise caution when performing cache operations in the application on an acquired buffer when not working with multiple of cache line sizes. They should be avoided whenever possible. If they are absolutely necessary, think through what you are doing as it may impact other acquired buffers in either client sharing the same cache line(s).
</p>
<!-- 
NewPP limit report
Cached time: 20201201020831
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.063 seconds
Real time usage: 0.065 seconds
Preprocessor visited node count: 58/1000000
Preprocessor generated node count: 64/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->
</div>
<!-- Saved in parser cache with key procwiki:pcache:idhash:15258-0!canonical and timestamp 20201201020831 and revision id 152895
 -->
<div class='hf-nsfooter' id='hf-nsfooter-'><table style="text-align:center; background:white; width:100%; text-align:left; height: 65px border-top: 1px solid; border-bottom: 1px solid; border-left: 1px solid; border-right: 1px solid; border-width: 1px; border-style: solid;">
<tr>
<td width="305px"><a href="File_E2e.html" class="image"><img alt="E2e.jpg" src="https://processors.wiki.ti.com/images/8/82/E2e.jpg" width="305" height="63" /></a>
</td>
<td>{{
<ol><li>switchcategory:MultiCore=</li></ol>
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Cache coherency in RingIO</b> here.<i></i>
</p>
</td>
<td>Keystone=
<ul><li>For technical support on MultiCore devices, please post your questions in the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/c6000_multi-core_dsps/default.aspx">C6000 MultiCore Forum</a></li>
<li>For questions related to the BIOS MultiCore SDK (MCSDK), please use the <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/embedded/f/355.aspx">BIOS Forum</a></li></ul>
<p>Please post only comments related to the article <b>Cache coherency in RingIO</b> here.<i></i>
</p>
</td>
<td>C2000=<i>For technical support on the C2000 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/tms320c2000_32-bit_real-time_mcus/f/171.aspx">The C2000 Forum</a>. Please post only comments about the article <b>Cache coherency in RingIO</b> here.</i>
</td>
<td>DaVinci=<i>For technical support on DaVincoplease post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/davinci_digital_media_processors/default.aspx">The DaVinci Forum</a>. Please post only comments about the article <b>Cache coherency in RingIO</b> here.</i>
</td>
<td>MSP430=<i>For technical support on MSP430 please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/microcontrollers/msp43016-bit_ultra-low_power_mcus/default.aspx">The MSP430 Forum</a>. Please post only comments about the article <b>Cache coherency in RingIO</b> here.</i>
</td>
<td>OMAP35x=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Cache coherency in RingIO</b> here.</i>
</td>
<td>OMAPL1=<i>For technical support on OMAP please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/dsp/omap_applications_processors/default.aspx">The OMAP Forum</a>. Please post only comments about the article <b>Cache coherency in RingIO</b> here.</i>
</td>
<td>MAVRK=<i>For technical support on MAVRK please post your questions on <a rel="nofollow" class="external text" href="http://e2e.ti.com/support/development_tools/mavrk/default.aspx">The MAVRK Toolbox Forum</a>. Please post only comments about the article <b>Cache coherency in RingIO</b> here.</i>
</td>
<td><i>For technical support please post your questions at <a rel="nofollow" class="external text" href="http://e2e.ti.com/">http://e2e.ti.com</a>. Please post only comments about the article <b>Cache coherency in RingIO</b> here.</i>
<p>}}
</p>
</td></tr></table>
<table style="border-style:solid; border-width:1px; text-align:center; width:100%;">

<tr style="font-size:150%;">
<td rowspan="2"><a href="File_Hyperlink_blue.html" class="image"><img alt="Hyperlink blue.png" src="https://processors.wiki.ti.com/images/9/9f/Hyperlink_blue.png" width="96" height="96" /></a>
</td>
<td><b>Links</b>
</td></tr>
<tr>
<td>
<table style="text-align: left;">
<tr>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/amplifier_and_linear.page">Amplifiers &amp; Linear</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/audio/audio_overview.page">Audio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/rfif.page">Broadband RF/IF &amp; Digital Radio</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/clocksandtimers/clocks_and_timers.page">Clocks &amp; Timers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/dataconverters/data_converter.page">Data Converters</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/mems/mems.page">DLP &amp; MEMS</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/high_reliability.page">High-Reliability</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/interface/interface.page">Interface</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/logic/home_overview.page">Logic</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/powermanagement/power_portal.page">Power Management</a>
</p>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/embedded_processor.page">Processors</a>
</p>
<ul><li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/arm.page">ARM Processors</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/dsp/home.page">Digital Signal Processors (DSP)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/microcontroller/home.page">Microcontrollers (MCU)</a></li>
<li><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/omap-applications-processors/the-omap-experience.page">OMAP Applications Processors</a></li></ul>
</td>
<td style="padding-right: 10px; vertical-align: top;">
<p><a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/switches_and_multiplexers.page">Switches &amp; Multiplexers</a><br/>
<a rel="nofollow" class="external text" href="http://www.ti.com/lsds/ti/analog/temperature_sensor.page">Temperature Sensors &amp; Control ICs</a><br/>
<a rel="nofollow" class="external text" href="http://focus.ti.com/wireless/docs/wirelessoverview.tsp?familyId=2003&amp;sectionId=646&amp;tabId=2735">Wireless Connectivity</a>
</p>
</td></tr></table>
</td></tr></table>
<div id="tiPrivacy"></div>
</div></div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;oldid=152895">https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;oldid=152895</a>"					</div>
				<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="Special_Categories.html" title="Special:Categories">Category</a>: <ul><li><a href="Category_SysLink.html" title="Category:SysLink">SysLink</a></li></ul></div></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="https://processors.wiki.ti.com/index.php?title=Special:UserLogin&amp;returnto=Cache+coherency+in+RingIO" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li><li id="pt-createaccount"><a href="Special_RequestAccount.html" title="You are encouraged to create an account and log in; however, it is not mandatory">Request account</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="Cache_coherency_in_RingIO.html" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="https://processors.wiki.ti.com/index.php?title=Talk:Cache_coherency_in_RingIO&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="Cache_coherency_in_RingIO.html">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=edit" title="This page is protected.&#10;You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="https://processors.wiki.ti.com/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search Texas Instruments Wiki" title="Search Texas Instruments Wiki [f]" accesskey="f" id="searchInput"/><input type="hidden" value="Special:Search" name="title"/><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="Main_Page.html"  title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage"><a href="Main_Page.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li><li id="n-All-pages"><a href="Special_AllPages.html">All pages</a></li><li id="n-All-categories"><a href="Special_Categories.html">All categories</a></li><li id="n-recentchanges"><a href="Special_RecentChanges.html" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="Package_Reflow_Profiles.html" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Toolbox</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="Special_WhatLinksHere/Cache_coherency_in_RingIO.html" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="Special_RecentChangesLinked/Cache_coherency_in_RingIO.html" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="Special_SpecialPages.html" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;oldid=152895" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://processors.wiki.ti.com/index.php?title=Cache_coherency_in_RingIO&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 5 June 2013, at 18:30.</li>
								<li id="footer-info-copyright">Content is available under <a class="external" rel="nofollow" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike</a> unless otherwise noted.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="Project_Privacy_policy.html" title="Project:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="Project_About.html" title="Project:About">About Texas Instruments Wiki</a></li>
								<li id="footer-places-disclaimer"><a href="Project_General_disclaimer.html" title="Project:General disclaimer">Disclaimers</a></li>
								<li id="footer-places-termsofservice"><a href="Project_Terms_of_Service.html" title="Project:Terms of Service">Terms of Use</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-copyrightico">
						<a href="http://creativecommons.org/licenses/by-sa/3.0/"><img src="https://processors.wiki.ti.com/resources/assets/licenses/cc-by-sa.png" alt="Creative Commons Attribution-ShareAlike" width="88" height="31"/></a>					</li>
										<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="https://processors.wiki.ti.com/resources/assets/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /resources/assets/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.063","walltime":"0.065","ppvisitednodes":{"value":58,"limit":1000000},"ppgeneratednodes":{"value":64,"limit":1000000},"postexpandincludesize":{"value":0,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    0.000      1 -total"]},"cachereport":{"timestamp":"20201201020831","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":224});});</script>
	</body>

<!-- Mirrored from processors.wiki.ti.com/index.php/Cache_coherency_in_RingIO by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 01 Dec 2020 04:34:20 GMT -->
</html>
